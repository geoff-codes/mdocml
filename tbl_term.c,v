head	1.43;
access;
symbols
	VERSION_1_13_3:1.40
	VERSION_1_13_2:1.31
	VERSION_1_12_4:1.28
	VERSION_1_13_1:1.27
	VERSION_1_12_3:1.25
	VERSION_1_12_2:1.25
	VERSION_1_12:1.28.0.2
	VERSION_1_12_1:1.21
	VERSION_1_12_0:1.21
	VERSION_1_11_7:1.20
	VERSION_1_11_6:1.20
	VERSION_1_11_5:1.20
	VERSION_1_11_4:1.19
	VERSION_1_11_3:1.19
	VERSION_1_11_2:1.19
	VERSION_1_11_1:1.19
	VERSION_1_10_10:1.19
	VERSION_1_10_9:1.13;
locks; strict;
comment	@ * @;


1.43
date	2015.10.12.00.08.16;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2015.10.06.18.32.20;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2015.03.06.15.48.53;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2015.03.06.11.03.03;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2015.01.31.00.12.41;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2015.01.30.17.32.16;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2015.01.30.04.11.50;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2015.01.30.02.09.04;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2015.01.28.04.19.35;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2015.01.27.05.21.45;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2014.12.24.15.38.55;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2014.10.14.18.18.05;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2014.10.14.02.16.06;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2014.10.13.23.31.46;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.28.23.26.25;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.31.21.37.17;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.27.18.02.49;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.27.17.59.23;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.27.17.54.54;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2011.09.20.23.05.49;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.17.15.43.00;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.25.12.07.30;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2011.01.11.14.12.01;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.10.14.56.06;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.10.14.40.30;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.08.17.16.48;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2011.01.08.17.00.27;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.07.14.59.52;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.07.13.20.58;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.05.15.37.23;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.04.15.02.00;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.04.13.21.45;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.04.13.14.26;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.04.12.06.21;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.03.16.04.41;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.03.15.07.59;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.03.14.57.04;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.03.14.45.59;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.01.03.13.59.21;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.01.02.12.21.07;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.43
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@/*	$Id: tbl_term.c,v 1.42 2015/10/06 18:32:20 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011, 2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "out.h"
#include "term.h"

static	size_t	term_tbl_len(size_t, void *);
static	size_t	term_tbl_strlen(const char *, void *);
static	void	tbl_char(struct termp *, char, size_t);
static	void	tbl_data(struct termp *, const struct tbl_opts *,
			const struct tbl_dat *,
			const struct roffcol *);
static	void	tbl_literal(struct termp *, const struct tbl_dat *,
			const struct roffcol *);
static	void	tbl_number(struct termp *, const struct tbl_opts *,
			const struct tbl_dat *,
			const struct roffcol *);
static	void	tbl_hrule(struct termp *, const struct tbl_span *, int);
static	void	tbl_word(struct termp *, const struct tbl_dat *);


static size_t
term_tbl_strlen(const char *p, void *arg)
{

	return term_strlen((const struct termp *)arg, p);
}

static size_t
term_tbl_len(size_t sz, void *arg)
{

	return term_len((const struct termp *)arg, sz);
}

void
term_tbl(struct termp *tp, const struct tbl_span *sp)
{
	const struct tbl_cell	*cp;
	const struct tbl_dat	*dp;
	static size_t		 offset;
	size_t			 rmargin, maxrmargin, tsz;
	int			 ic, horiz, spans, vert;

	rmargin = tp->rmargin;
	maxrmargin = tp->maxrmargin;

	tp->rmargin = tp->maxrmargin = TERM_MAXMARGIN;

	/* Inhibit printing of spaces: we do padding ourselves. */

	tp->flags |= TERMP_NONOSPACE;
	tp->flags |= TERMP_NOSPACE;

	/*
	 * The first time we're invoked for a given table block,
	 * calculate the table widths and decimal positions.
	 */

	if (tp->tbl.cols == NULL) {
		tp->tbl.len = term_tbl_len;
		tp->tbl.slen = term_tbl_strlen;
		tp->tbl.arg = tp;

		tblcalc(&tp->tbl, sp, rmargin - tp->offset);

		/* Center the table as a whole. */

		offset = tp->offset;
		if (sp->opts->opts & TBL_OPT_CENTRE) {
			tsz = sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX)
			    ? 2 : !!sp->opts->lvert + !!sp->opts->rvert;
			for (ic = 0; ic < sp->opts->cols; ic++)
				tsz += tp->tbl.cols[ic].width + 3;
			tsz -= 3;
			if (offset + tsz > rmargin)
				tsz -= 1;
			tp->offset = (offset + rmargin > tsz) ?
			    (offset + rmargin - tsz) / 2 : 0;
		}

		/* Horizontal frame at the start of boxed tables. */

		if (sp->opts->opts & TBL_OPT_DBOX)
			tbl_hrule(tp, sp, 2);
		if (sp->opts->opts & (TBL_OPT_DBOX | TBL_OPT_BOX))
			tbl_hrule(tp, sp, 1);
	}

	/* Vertical frame at the start of each row. */

	horiz = sp->pos == TBL_SPAN_HORIZ || sp->pos == TBL_SPAN_DHORIZ;

	if (sp->layout->vert ||
	    (sp->prev != NULL && sp->prev->layout->vert) ||
	    sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX))
		term_word(tp, horiz ? "+" : "|");
	else if (sp->opts->lvert)
		tbl_char(tp, horiz ? '-' : ASCII_NBRSP, 1);

	/*
	 * Now print the actual data itself depending on the span type.
	 * Match data cells to column numbers.
	 */

	if (sp->pos == TBL_SPAN_DATA) {
		cp = sp->layout->first;
		dp = sp->first;
		spans = 0;
		for (ic = 0; ic < sp->opts->cols; ic++) {

			/*
			 * Remeber whether we need a vertical bar
			 * after this cell.
			 */

			vert = cp == NULL ? 0 : cp->vert;

			/*
			 * Print the data and advance to the next cell.
			 */

			if (spans == 0) {
				tbl_data(tp, sp->opts, dp, tp->tbl.cols + ic);
				if (dp != NULL) {
					spans = dp->spans;
					dp = dp->next;
				}
			} else
				spans--;
			if (cp != NULL)
				cp = cp->next;

			/*
			 * Separate columns, except in the middle
			 * of spans and after the last cell.
			 */

			if (ic + 1 == sp->opts->cols || spans)
				continue;

			tbl_char(tp, ASCII_NBRSP, 1);
			if (vert > 0)
				tbl_char(tp, '|', vert);
			if (vert < 2)
				tbl_char(tp, ASCII_NBRSP, 2 - vert);
		}
	} else if (horiz)
		tbl_hrule(tp, sp, 0);

	/* Vertical frame at the end of each row. */

	if (sp->layout->last->vert ||
	    (sp->prev != NULL && sp->prev->layout->last->vert) ||
	    (sp->opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX)))
		term_word(tp, horiz ? "+" : " |");
	else if (sp->opts->rvert)
		tbl_char(tp, horiz ? '-' : ASCII_NBRSP, 1);
	term_flushln(tp);

	/*
	 * If we're the last row, clean up after ourselves: clear the
	 * existing table configuration and set it to NULL.
	 */

	if (sp->next == NULL) {
		if (sp->opts->opts & (TBL_OPT_DBOX | TBL_OPT_BOX)) {
			tbl_hrule(tp, sp, 1);
			tp->skipvsp = 1;
		}
		if (sp->opts->opts & TBL_OPT_DBOX) {
			tbl_hrule(tp, sp, 2);
			tp->skipvsp = 2;
		}
		assert(tp->tbl.cols);
		free(tp->tbl.cols);
		tp->tbl.cols = NULL;
		tp->offset = offset;
	}

	tp->flags &= ~TERMP_NONOSPACE;
	tp->rmargin = rmargin;
	tp->maxrmargin = maxrmargin;
}

/*
 * Kinds of horizontal rulers:
 * 0: inside the table (single or double line with crossings)
 * 1: inner frame (single line with crossings and ends)
 * 2: outer frame (single line without crossings with ends)
 */
static void
tbl_hrule(struct termp *tp, const struct tbl_span *sp, int kind)
{
	const struct tbl_cell *c1, *c2;
	int	 vert;
	char	 line, cross;

	line = (kind == 0 && TBL_SPAN_DHORIZ == sp->pos) ? '=' : '-';
	cross = (kind < 2) ? '+' : '-';

	if (kind)
		term_word(tp, "+");
	c1 = sp->layout->first;
	c2 = sp->prev == NULL ? NULL : sp->prev->layout->first;
	if (c2 == c1)
		c2 = NULL;
	for (;;) {
		tbl_char(tp, line, tp->tbl.cols[c1->col].width + 1);
		vert = c1->vert;
		if ((c1 = c1->next) == NULL)
			 break;
		if (c2 != NULL) {
			if (vert < c2->vert)
				vert = c2->vert;
			c2 = c2->next;
		}
		if (vert)
			tbl_char(tp, cross, vert);
		if (vert < 2)
			tbl_char(tp, line, 2 - vert);
	}
	if (kind) {
		term_word(tp, "+");
		term_flushln(tp);
	}
}

static void
tbl_data(struct termp *tp, const struct tbl_opts *opts,
	const struct tbl_dat *dp,
	const struct roffcol *col)
{

	if (dp == NULL) {
		tbl_char(tp, ASCII_NBRSP, col->width);
		return;
	}

	switch (dp->pos) {
	case TBL_DATA_NONE:
		tbl_char(tp, ASCII_NBRSP, col->width);
		return;
	case TBL_DATA_HORIZ:
	case TBL_DATA_NHORIZ:
		tbl_char(tp, '-', col->width);
		return;
	case TBL_DATA_NDHORIZ:
	case TBL_DATA_DHORIZ:
		tbl_char(tp, '=', col->width);
		return;
	default:
		break;
	}

	switch (dp->layout->pos) {
	case TBL_CELL_HORIZ:
		tbl_char(tp, '-', col->width);
		break;
	case TBL_CELL_DHORIZ:
		tbl_char(tp, '=', col->width);
		break;
	case TBL_CELL_LONG:
	case TBL_CELL_CENTRE:
	case TBL_CELL_LEFT:
	case TBL_CELL_RIGHT:
		tbl_literal(tp, dp, col);
		break;
	case TBL_CELL_NUMBER:
		tbl_number(tp, opts, dp, col);
		break;
	case TBL_CELL_DOWN:
		tbl_char(tp, ASCII_NBRSP, col->width);
		break;
	default:
		abort();
	}
}

static void
tbl_char(struct termp *tp, char c, size_t len)
{
	size_t		i, sz;
	char		cp[2];

	cp[0] = c;
	cp[1] = '\0';

	sz = term_strlen(tp, cp);

	for (i = 0; i < len; i += sz)
		term_word(tp, cp);
}

static void
tbl_literal(struct termp *tp, const struct tbl_dat *dp,
		const struct roffcol *col)
{
	size_t		 len, padl, padr, width;
	int		 ic, spans;

	assert(dp->string);
	len = term_strlen(tp, dp->string);
	width = col->width;
	ic = dp->layout->col;
	spans = dp->spans;
	while (spans--)
		width += tp->tbl.cols[++ic].width + 3;

	padr = width > len ? width - len : 0;
	padl = 0;

	switch (dp->layout->pos) {
	case TBL_CELL_LONG:
		padl = term_len(tp, 1);
		padr = padr > padl ? padr - padl : 0;
		break;
	case TBL_CELL_CENTRE:
		if (2 > padr)
			break;
		padl = padr / 2;
		padr -= padl;
		break;
	case TBL_CELL_RIGHT:
		padl = padr;
		padr = 0;
		break;
	default:
		break;
	}

	tbl_char(tp, ASCII_NBRSP, padl);
	tbl_word(tp, dp);
	tbl_char(tp, ASCII_NBRSP, padr);
}

static void
tbl_number(struct termp *tp, const struct tbl_opts *opts,
		const struct tbl_dat *dp,
		const struct roffcol *col)
{
	char		*cp;
	char		 buf[2];
	size_t		 sz, psz, ssz, d, padl;
	int		 i;

	/*
	 * See calc_data_number().  Left-pad by taking the offset of our
	 * and the maximum decimal; right-pad by the remaining amount.
	 */

	assert(dp->string);

	sz = term_strlen(tp, dp->string);

	buf[0] = opts->decimal;
	buf[1] = '\0';

	psz = term_strlen(tp, buf);

	if ((cp = strrchr(dp->string, opts->decimal)) != NULL) {
		for (ssz = 0, i = 0; cp != &dp->string[i]; i++) {
			buf[0] = dp->string[i];
			ssz += term_strlen(tp, buf);
		}
		d = ssz + psz;
	} else
		d = sz + psz;

	if (col->decimal > d && col->width > sz) {
		padl = col->decimal - d;
		if (padl + sz > col->width)
			padl = col->width - sz;
		tbl_char(tp, ASCII_NBRSP, padl);
	} else
		padl = 0;
	tbl_word(tp, dp);
	if (col->width > sz + padl)
		tbl_char(tp, ASCII_NBRSP, col->width - sz - padl);
}

static void
tbl_word(struct termp *tp, const struct tbl_dat *dp)
{
	int		 prev_font;

	prev_font = tp->fonti;
	if (dp->layout->flags & TBL_CELL_BOLD)
		term_fontpush(tp, TERMFONT_BOLD);
	else if (dp->layout->flags & TBL_CELL_ITALIC)
		term_fontpush(tp, TERMFONT_UNDER);

	term_word(tp, dp->string);

	term_fontpopq(tp, prev_font);
}
@


1.42
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.41 2015/09/26 00:54:04 schwarze Exp $ */
a268 1
		/* FALLTHROUGH */
a272 1
		/* FALLTHROUGH */
a287 1
		/* FALLTHROUGH */
a288 1
		/* FALLTHROUGH */
a289 1
		/* FALLTHROUGH */
@


1.41
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.40 2015/03/06 15:48:53 schwarze Exp $ */
d50 1
a50 1
	return(term_strlen((const struct termp *)arg, p));
d57 1
a57 1
	return(term_len((const struct termp *)arg, sz));
@


1.40
log
@Fix vertical spacing at the beginning of tables.
man(7) always prints a blank line, mdoc(7) doesn't.
Problem in mdoc(7) reported by kristaps@@.
mdoc(7) part of the patch tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.39 2015/03/06 11:03:03 schwarze Exp $ */
a305 1
		/* NOTREACHED */
@


1.39
log
@Flush the line preceding a table before clearing the right margin,
such that that line isn't output with unlimited width.
Problem reported and fix OK by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.38 2015/01/31 00:12:41 schwarze Exp $ */
a68 3
	if (tp->tbl.cols == NULL)
		term_flushln(tp);

@


1.38
log
@Use relative offsets instead of absolute pointers for the terminal
font stack.  The latter fail after the stack is grown with realloc().
Fixing an assertion failure found by jsg@@ with afl some time ago
(test case number 51).
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.37 2015/01/30 17:32:16 schwarze Exp $ */
d69 3
a87 2
		term_flushln(tp);

@


1.37
log
@Delete the redundant tbl span flags, just inspect the actual data
where needed, which is less fragile.
This fixes a subtle NULL pointer access to tp->tbl.cols:
Due to a bug in the man(7) parser, the first span of a table can
end up in a .TP head, in which case tblcalc() was never called.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.36 2015/01/30 04:11:50 schwarze Exp $ */
d417 1
a417 1
	const void	*prev_font;
d419 1
a419 1
	prev_font = term_fontq(tp);
@


1.36
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.35 2015/01/30 02:09:04 schwarze Exp $ */
d84 1
a84 1
	if (sp->flags & TBL_SPAN_FIRST) {
d192 1
a192 1
	if (sp->flags & TBL_SPAN_LAST) {
@


1.35
log
@Auditing the tbl(7) code for more NULL pointer accesses, i came out
empty-handed; so this is just KNF and some code simplifications,
no functional change.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.34 2015/01/28 04:19:35 schwarze Exp $ */
a62 1
	const struct tbl_head	*hp;
d67 1
a67 1
	int			 horiz, spans, vert;
d99 2
a100 2
			for (hp = sp->head; hp != NULL; hp = hp->next)
				tsz += tp->tbl.cols[hp->ident].width + 3;
d129 1
a129 2
	 * Spanner spans get a horizontal rule; data spanners have their
	 * data printed by matching data to header.
a132 1
		/* Iterate over template headers. */
d136 1
a136 1
		for (hp = sp->head; hp != NULL; hp = hp->next) {
d150 1
a150 2
				tbl_data(tp, sp->opts, dp,
				    tp->tbl.cols + hp->ident);
d165 1
a165 1
			if (hp->next == NULL || spans)
d171 1
a171 1
			if (vert < 2 && hp->next != NULL)
d235 1
a235 1
		tbl_char(tp, line, tp->tbl.cols[c1->head->ident].width + 1);
d331 2
a332 3
	struct tbl_head		*hp;
	size_t			 width, len, padl, padr;
	int			 spans;
a335 2

	hp = dp->layout->head->next;
d337 4
a340 2
	for (spans = dp->spans; spans--; hp = hp->next)
		width += tp->tbl.cols[hp->ident].width + 3;
@


1.34
log
@implement the tbl(7) "center" layout option
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.33 2015/01/27 05:21:45 schwarze Exp $ */
d265 1
a265 1
	if (NULL == dp) {
a268 1
	assert(dp->layout);
d398 1
a398 2
	if (NULL != (cp = strrchr(dp->string, opts->decimal))) {
		buf[1] = '\0';
@


1.33
log
@Multiple parser and formatter fixes for line drawing in tbl(7).
* Allow mixing vertical line bars with the layout options
of the preceding layout cell.
* Correctly combine box options with layout lines.
* Correctly print vertical lines in data rows, with the right spacing.
* Correctly print cross markers and left and right ends of
horizontal lines even if vertical lines differ above and below.
* Avoid the bogus error message "no table data cells"
when a table data section starts with a horizontal line.
No increase in code size.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.32 2014/12/24 15:38:55 schwarze Exp $ */
d66 2
a68 1
	size_t			 rmargin, maxrmargin;
d94 15
d208 1
a213 1

@


1.32
log
@Prevent unsigned integer underflow when a number is too wide
for a table cell with an "nz" layout specification,
causing essentially infinite output as found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.31 2014/10/14 18:18:05 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
a36 2
static	size_t	tbl_rulewidth(struct termp *, const struct tbl_head *);
static	void	tbl_hframe(struct termp *, const struct tbl_span *, int);
d42 1
a42 2
static	void	tbl_hrule(struct termp *, const struct tbl_span *);
static	void	tbl_vrule(struct termp *, const struct tbl_head *);
d64 1
d66 1
a66 2
	struct roffcol		*col;
	int			 spans;
d84 1
a84 1
	if (TBL_SPAN_FIRST & sp->flags) {
a91 1
	}
d93 1
a93 1
	/* Horizontal frame at the start of boxed tables. */
d95 4
a98 6
	if (TBL_SPAN_FIRST & sp->flags) {
		if (TBL_OPT_DBOX & sp->opts->opts)
			tbl_hframe(tp, sp, 1);
		if (TBL_OPT_DBOX & sp->opts->opts ||
		    TBL_OPT_BOX  & sp->opts->opts)
			tbl_hframe(tp, sp, 0);
d103 8
a110 4
	if ((TBL_OPT_BOX | TBL_OPT_DBOX) & sp->opts->opts ||
	    (sp->head != NULL && sp->head->vert))
		term_word(tp, TBL_SPAN_HORIZ == sp->pos ||
		    TBL_SPAN_DHORIZ == sp->pos ? "+" : "|");
d118 1
a118 7
	switch (sp->pos) {
	case TBL_SPAN_HORIZ:
		/* FALLTHROUGH */
	case TBL_SPAN_DHORIZ:
		tbl_hrule(tp, sp);
		break;
	case TBL_SPAN_DATA:
d120 1
d123 1
a123 1
		for (hp = sp->head; hp; hp = hp->next) {
d126 2
a127 3
			 * If the current data header is invoked during
			 * a spanner ("spans" > 0), don't emit anything
			 * at all.
d130 1
a130 2
			if (--spans >= 0)
				continue;
d132 3
a134 1
			/* Separate columns. */
d136 11
a146 5
			if (NULL != hp->prev)
				tbl_vrule(tp, hp);

			col = &tp->tbl.cols[hp->ident];
			tbl_data(tp, sp->opts, dp, col);
d149 2
a150 2
			 * Go to the next data cell and assign the
			 * number of subsequent spans, if applicable.
d153 8
a160 4
			if (dp) {
				spans = dp->spans;
				dp = dp->next;
			}
d162 2
a163 2
		break;
	}
d167 6
a172 4
	if ((TBL_OPT_BOX | TBL_OPT_DBOX) & sp->opts->opts ||
	    sp->layout->vert)
		term_word(tp, TBL_SPAN_HORIZ == sp->pos ||
		    TBL_SPAN_DHORIZ == sp->pos ? "+" : " |");
d180 3
a182 4
	if (TBL_SPAN_LAST & sp->flags) {
		if (TBL_OPT_DBOX & sp->opts->opts ||
		    TBL_OPT_BOX  & sp->opts->opts) {
			tbl_hframe(tp, sp, 0);
d185 2
a186 2
		if (TBL_OPT_DBOX & sp->opts->opts) {
			tbl_hframe(tp, sp, 1);
d201 4
a204 23
 * Horizontal rules extend across the entire table.
 * Calculate the width by iterating over columns.
 */
static size_t
tbl_rulewidth(struct termp *tp, const struct tbl_head *hp)
{
	size_t		 width;

	width = tp->tbl.cols[hp->ident].width;

	/* Account for leading blanks. */
	if (hp->prev)
		width += 2 - hp->vert;

	/* Account for trailing blank. */
	width++;

	return(width);
}

/*
 * Rules inside the table can be single or double
 * and have crossings with vertical rules marked with pluses.
d207 1
a207 1
tbl_hrule(struct termp *tp, const struct tbl_span *sp)
d209 27
a235 11
	const struct tbl_head *hp;
	char		 c;

	c = '-';
	if (TBL_SPAN_DHORIZ == sp->pos)
		c = '=';

	for (hp = sp->head; hp; hp = hp->next) {
		if (hp->prev && hp->vert)
			tbl_char(tp, '+', hp->vert);
		tbl_char(tp, c, tbl_rulewidth(tp, hp));
d237 3
a239 18
}

/*
 * Rules above and below the table are always single
 * and have an additional plus at the beginning and end.
 * For double frames, this function is called twice,
 * and the outer one does not have crossings.
 */
static void
tbl_hframe(struct termp *tp, const struct tbl_span *sp, int outer)
{
	const struct tbl_head *hp;

	term_word(tp, "+");
	for (hp = sp->head; hp; hp = hp->next) {
		if (hp->prev && hp->vert)
			tbl_char(tp, (outer ? '-' : '+'), hp->vert);
		tbl_char(tp, '-', tbl_rulewidth(tp, hp));
a240 2
	term_word(tp, "+");
	term_flushln(tp);
a301 11
tbl_vrule(struct termp *tp, const struct tbl_head *hp)
{

	tbl_char(tp, ASCII_NBRSP, 1);
	if (0 < hp->vert)
		tbl_char(tp, '|', hp->vert);
	if (2 > hp->vert)
		tbl_char(tp, ASCII_NBRSP, 2 - hp->vert);
}

static void
@


1.31
log
@even if a table has zero columns, do not segfault in the formatter;
bug reported by bentley@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.30 2014/10/14 02:16:06 schwarze Exp $ */
d420 7
a426 3
	padl = col->decimal - d;

	tbl_char(tp, ASCII_NBRSP, padl);
@


1.30
log
@Rudimentary implementation of the e, x, and z table layout modifiers
to equalize, maximize, and ignore the width of columns.
Does not yet take vertical rulers into account,
and does not do line breaks within table cells.
Considerably improves the lftp(1) manual; issue noticed by sthen@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.29 2014/10/13 23:31:46 schwarze Exp $ */
d110 1
a110 1
	    sp->head->vert)
@


1.29
log
@implement font modifiers in table layouts
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.28 2014/08/10 23:54:41 schwarze Exp $ */
d94 1
a94 1
		tblcalc(&tp->tbl, sp);
@


1.28
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.27 2014/04/20 16:46:05 schwarze Exp $ */
d46 1
d382 1
a382 1
	term_word(tp, dp->string);
d423 1
a423 1
	term_word(tp, dp->string);
d428 15
@


1.27
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.26 2014/03/28 23:26:25 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
d19 2
a20 1
#endif
@


1.26
log
@Allow leading and trailing vertical lines,
and format them in the same way as groff.
While here, do not require whitespace before vertical lines
in layout specifications.
Issues found by bentley@@ in mpv(1).
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.25 2013/05/31 21:37:17 schwarze Exp $ */
d35 1
a35 1
			const struct tbl_dat *, 
d39 1
a39 1
static	void	tbl_literal(struct termp *, const struct tbl_dat *, 
d41 2
a42 2
static	void	tbl_number(struct termp *, const struct tbl_opts *, 
			const struct tbl_dat *, 
d69 1
a69 1
	size_t		   	 rmargin, maxrmargin;
d111 1
a111 1
			TBL_SPAN_DHORIZ == sp->pos ? "+" : "|");
d120 1
a120 1
	case (TBL_SPAN_HORIZ):
d122 1
a122 1
	case (TBL_SPAN_DHORIZ):
d125 1
a125 1
	case (TBL_SPAN_DATA):
d131 1
a131 1
			/* 
d148 1
a148 1
			/* 
d166 1
a166 1
			TBL_SPAN_DHORIZ == sp->pos ? "+" : " |");
d260 2
a261 2
		const struct tbl_dat *dp, 
		const struct roffcol *col)
d271 1
a271 1
	case (TBL_DATA_NONE):
d274 1
a274 1
	case (TBL_DATA_HORIZ):
d276 1
a276 1
	case (TBL_DATA_NHORIZ):
d279 1
a279 1
	case (TBL_DATA_NDHORIZ):
d281 1
a281 1
	case (TBL_DATA_DHORIZ):
d287 1
a287 1
	
d289 1
a289 1
	case (TBL_CELL_HORIZ):
d292 1
a292 1
	case (TBL_CELL_DHORIZ):
d295 1
a295 1
	case (TBL_CELL_LONG):
d297 1
a297 1
	case (TBL_CELL_CENTRE):
d299 1
a299 1
	case (TBL_CELL_LEFT):
d301 1
a301 1
	case (TBL_CELL_RIGHT):
d304 1
a304 1
	case (TBL_CELL_NUMBER):
d307 1
a307 1
	case (TBL_CELL_DOWN):
d343 1
a343 1
tbl_literal(struct termp *tp, const struct tbl_dat *dp, 
d362 1
a362 1
	case (TBL_CELL_LONG):
d366 1
a366 1
	case (TBL_CELL_CENTRE):
d372 1
a372 1
	case (TBL_CELL_RIGHT):
@


1.25
log
@The name "struct tbl" was badly misleading for two reasons:
1) This struct almost exclusively contains the table options.
2) Information about the table as a whole is actually in "struct tbl_node".
Besides, "struct tbl" was almost impossible to search for.
So rename it to "struct tbl_opts".  No functional change.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.24 2012/05/27 18:02:49 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d108 2
a109 1
	if (TBL_OPT_BOX & sp->opts->opts || TBL_OPT_DBOX & sp->opts->opts)
d163 2
a164 1
	if (TBL_OPT_BOX & sp->opts->opts || TBL_OPT_DBOX & sp->opts->opts)
@


1.24
log
@Fix the vertical spacing around tbl(7) instances in man(7).

Groff forces the document author to manually request sufficient spacing
after .TE - that is, at least .sp 1v after a table with the "box" option
and at least .sp 2v after a table with the "doublebox" option - or else
it clobbers the box.  I consider that insane, so i'm not imitating groff
in that respect.  Instead, i add at least as much vertical space as groff,
or more where required to avoid clobbering the box.

Consequently, output will be identical for input that looks sane with
groff, and mandoc will make output look better for input that looks bad
with groff.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.23 2012/05/27 17:59:23 schwarze Exp $ */
d34 1
a34 1
static	void	tbl_data(struct termp *, const struct tbl *,
d41 1
a41 1
static	void	tbl_number(struct termp *, const struct tbl *, 
d99 1
a99 1
		if (TBL_OPT_DBOX & sp->tbl->opts)
d101 2
a102 2
		if (TBL_OPT_DBOX & sp->tbl->opts ||
		    TBL_OPT_BOX  & sp->tbl->opts)
d108 1
a108 1
	if (TBL_OPT_BOX & sp->tbl->opts || TBL_OPT_DBOX & sp->tbl->opts)
d145 1
a145 1
			tbl_data(tp, sp->tbl, dp, col);
d162 1
a162 1
	if (TBL_OPT_BOX & sp->tbl->opts || TBL_OPT_DBOX & sp->tbl->opts)
d173 2
a174 2
		if (TBL_OPT_DBOX & sp->tbl->opts ||
		    TBL_OPT_BOX  & sp->tbl->opts) {
d178 1
a178 1
		if (TBL_OPT_DBOX & sp->tbl->opts) {
d257 1
a257 1
tbl_data(struct termp *tp, const struct tbl *tbl,
d303 1
a303 1
		tbl_number(tp, tbl, dp, col);
d384 1
a384 1
tbl_number(struct termp *tp, const struct tbl *tbl,
d402 1
a402 1
	buf[0] = tbl->decimal;
d407 1
a407 1
	if (NULL != (cp = strrchr(dp->string, tbl->decimal))) {
@


1.23
log
@Correct width of horizontal spans; relevant in case of centered or
flush right text, for boxes, and when more columns follow the span.

Issue found by sthen@@ in the net/arp-scan(1) port manual.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.22 2012/05/27 17:54:54 schwarze Exp $ */
d174 1
a174 1
		    TBL_OPT_BOX  & sp->tbl->opts)
d176 3
a178 1
		if (TBL_OPT_DBOX & sp->tbl->opts)
d180 2
@


1.22
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.21 2011/09/20 23:05:49 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d340 3
a342 1
	size_t		 len, padl, padr;
d346 7
a352 1
	padr = col->width > len ? col->width - len : 0;
@


1.21
log
@Major rewrite of the horizontal spacing of tables
to work both with and without frames and rulers.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.20 2011/07/17 15:43:00 kristaps Exp $ */
d129 1
a134 10
			switch (hp->pos) {
			case (TBL_HEAD_VERT):
				/* FALLTHROUGH */
			case (TBL_HEAD_DVERT):
				if (spans <= 0)
					tbl_vrule(tp, hp);
				continue;
			case (TBL_HEAD_DATA):
				break;
			}
d139 1
a139 4
			/*
			 * All cells get a leading blank, except the
			 * first one and those after double rulers.
			 */
d141 2
a142 2
			if (hp->prev && TBL_HEAD_DVERT != hp->prev->pos)
				tbl_char(tp, ASCII_NBRSP, 1);
a146 14
			/* No trailing blanks. */

			if (NULL == hp->next)
				break;

			/*
			 * Add another blank between cells,
			 * or two when there is no vertical ruler.
			 */

			tbl_char(tp, ASCII_NBRSP,
			    TBL_HEAD_VERT  == hp->next->pos ||
			    TBL_HEAD_DVERT == hp->next->pos ? 1 : 2);

d199 8
a206 11
	if (TBL_HEAD_DATA == hp->pos) {
		/* Account for leading blanks. */
		if (hp->prev && TBL_HEAD_DVERT != hp->prev->pos)
			width++;
		/* Account for trailing blanks. */
		width++;
		if (hp->next &&
		    TBL_HEAD_VERT  != hp->next->pos &&
		    TBL_HEAD_DVERT != hp->next->pos)
			width++;
	}
d224 5
a228 4
	for (hp = sp->head; hp; hp = hp->next)
		tbl_char(tp,
		    TBL_HEAD_DATA == hp->pos ? c : '+',
		    tbl_rulewidth(tp, hp));
d243 5
a247 4
	for (hp = sp->head; hp; hp = hp->next)
		tbl_char(tp,
		    outer || TBL_HEAD_DATA == hp->pos ? '-' : '+',
		    tbl_rulewidth(tp, hp));
d314 5
a318 10
	switch (hp->pos) {
	case (TBL_HEAD_VERT):
		term_word(tp, "|");
		break;
	case (TBL_HEAD_DVERT):
		term_word(tp, "||");
		break;
	default:
		break;
	}
@


1.20
log
@Fix copyright email.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.19 2011/01/25 12:07:30 schwarze Exp $ */
d37 2
a38 1
static	void	tbl_hframe(struct termp *, const struct tbl_span *);
a44 1
static	void	tbl_vframe(struct termp *, const struct tbl *);
d98 7
a104 2
	if (TBL_SPAN_FIRST & sp->flags)
		tbl_hframe(tp, sp);
d108 3
a110 1
	tbl_vframe(tp, sp->tbl);
d148 8
d159 14
d186 5
a190 1
	tbl_vframe(tp, sp->tbl);
d199 5
a203 1
		tbl_hframe(tp, sp);
d215 28
a247 7
	size_t		 width;

	/*
	 * An hrule extends across the entire table and is demarked by a
	 * standalone `_' or whatnot in lieu of a table row.  Spanning
	 * headers are marked by a `+', as are table boundaries.
	 */
d253 4
a256 21
	/* FIXME: don't use `+' between data and a spanner! */

	for (hp = sp->head; hp; hp = hp->next) {
		width = tp->tbl.cols[hp->ident].width;
		switch (hp->pos) {
		case (TBL_HEAD_DATA):
			if (hp->next)
				width += 2;
			tbl_char(tp, c, width);
			break;
		case (TBL_HEAD_DVERT):
			tbl_char(tp, '+', width);
			/* FALLTHROUGH */
		case (TBL_HEAD_VERT):
			tbl_char(tp, '+', width);
			break;
		default:
			abort();
			/* NOTREACHED */
		}
	}
d259 6
d266 1
a266 1
tbl_hframe(struct termp *tp, const struct tbl_span *sp)
a268 23
	size_t		 width;

	if ( ! (TBL_OPT_BOX & sp->tbl->opts || 
			TBL_OPT_DBOX & sp->tbl->opts))
		return;

	/* 
	 * Print out the horizontal part of a frame or double frame.  A
	 * double frame has an unbroken `-' outer line the width of the
	 * table, bordered by `+'.  The frame (or inner frame, in the
	 * case of the double frame) is a `-' bordered by `+' and broken
	 * by `+' whenever a span is encountered.
	 */

	if (TBL_OPT_DBOX & sp->tbl->opts) {
		term_word(tp, "+");
		for (hp = sp->head; hp; hp = hp->next) {
			width = tp->tbl.cols[hp->ident].width;
			tbl_char(tp, '-', width);
		}
		term_word(tp, "+");
		term_flushln(tp);
	}
d271 4
a274 11
	for (hp = sp->head; hp; hp = hp->next) {
		width = tp->tbl.cols[hp->ident].width;
		switch (hp->pos) {
		case (TBL_HEAD_DATA):
			tbl_char(tp, '-', width);
			break;
		default:
			tbl_char(tp, '+', width);
			break;
		}
	}
a353 8
tbl_vframe(struct termp *tp, const struct tbl *tbl)
{

	if (TBL_OPT_BOX & tbl->opts || TBL_OPT_DBOX & tbl->opts)
		term_word(tp, "|");
}

static void
d372 1
a372 3
	size_t		 padl, padr, ssz;

	padl = padr = 0;
d375 3
a377 2

	ssz = term_len(tp, 1);
d381 2
a382 2
		padl = ssz;
		padr = col->width - term_strlen(tp, dp->string) - ssz;
d385 1
a385 2
		padr = col->width - term_strlen(tp, dp->string);
		if (3 > padr)
d387 1
a387 1
		padl = (padr - 1) / 2;
d391 2
a392 1
		padl = col->width - term_strlen(tp, dp->string);
a394 1
		padr = col->width - term_strlen(tp, dp->string);
d400 1
a400 1
	tbl_char(tp, ASCII_NBRSP, padr + 2);
a436 3
	sz += term_len(tp, 2);
	d += term_len(tp, 1);

d441 2
a442 1
	tbl_char(tp, ASCII_NBRSP, col->width - sz - padl);
@


1.19
log
@correct horizontal spacing of data cells
correct alignment of centered cells
adjust horizontal rule width to the new spacing
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.18 2011/01/11 14:12:01 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2011 Kristaps Dzonsons <kristaps@@kth.se>
@


1.18
log
@Add support for "^" vertical spanners.  Unlike GNU tbl, raise
error-class messages when data is being ignored by specifying it in "^"
cells (either as-is or in blocks).

Also note again that horizontal spanners aren't really supported...
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.17 2011/01/10 14:56:06 kristaps Exp $ */
d3 2
a4 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
d201 2
d377 5
a381 5
		padl = col->width - term_strlen(tp, dp->string);
		if (padl % 2)
			padr++;
		padl /= 2;
		padr += padl;
d393 1
a393 1
	tbl_char(tp, ASCII_NBRSP, padr);
@


1.17
log
@Make dp->string always consist of a value.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.16 2011/01/10 14:40:30 kristaps Exp $ */
d308 3
@


1.16
log
@First, make extra data cells be thrown away.  This makes "dp->layout"
always hold, which cleans up the table stuff a bit.

Second, set a "spans" value per data cell consisting of the number of
skipped TBL_CELL_SPAN layout cells.

Third, make tbl_term.c understand how to skip over spanned sections when
iterating over the header queue.

What remains is to calculate the widths of spanned cells.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.15 2011/01/08 17:16:48 kristaps Exp $ */
a357 1
	const char	*str;
d361 1
a361 1
	str = dp->string ? dp->string : "";
d368 1
a368 1
		padr = col->width - term_strlen(tp, str) - ssz;
d371 1
a371 1
		padl = col->width - term_strlen(tp, str);
d378 1
a378 1
		padl = col->width - term_strlen(tp, str);
d381 1
a381 1
		padr = col->width - term_strlen(tp, str);
d386 1
a386 1
	term_word(tp, str);
a396 1
	const char	*str;
d405 1
a405 1
	str = dp->string ? dp->string : "";
d407 1
a407 1
	sz = term_strlen(tp, str);
d414 1
a414 1
	if (NULL != (cp = strrchr(str, tbl->decimal))) {
d416 2
a417 2
		for (ssz = 0, i = 0; cp != &str[i]; i++) {
			buf[0] = str[i];
d430 1
a430 1
	term_word(tp, str);
@


1.15
log
@The numerical column type centres on the *last* decimal point.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.14 2011/01/08 17:00:27 kristaps Exp $ */
d67 1
d119 1
d121 5
d130 2
a131 1
				tbl_vrule(tp, hp);
d137 3
d143 7
a149 2
			/* Go to the next data cell. */
			if (dp)
d151 1
a263 1
	enum tbl_cellt	 pos;
d269 1
d289 1
a289 3
	pos = dp && dp->layout ? dp->layout->pos : TBL_CELL_LEFT;

	switch (pos) {
a357 1
	enum tbl_cellt	 pos;
d362 1
a362 2
	pos = dp && dp->layout ? dp->layout->pos : TBL_CELL_LEFT;
	str = dp && dp->string ? dp->string : "";
d366 1
a366 1
	switch (pos) {
d407 1
a407 1
	str = dp && dp->string ? dp->string : "";
@


1.14
log
@Give the "n" cell type knowledge of its spacing.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.13 2011/01/07 14:59:52 kristaps Exp $ */
d403 1
a403 1
	if (NULL != (cp = strchr(str, tbl->decimal))) {
@


1.13
log
@Fixes: T} can be followed by a delimiter then more data.  Make this
work and add documentation for it.

Also make tbl_term() not puke if the number of data cells is less than
the number of layout cells (which happens from time to time).  This
still needs work because we should pad out empty cells so that the
borders all work out.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.12 2011/01/07 13:20:58 kristaps Exp $ */
a29 3
/* FIXME: `n' modifier doesn't always do the right thing. */
/* FIXME: `n' modifier doesn't use the cell-spacing buffer. */

@


1.12
log
@Quiesce lint with some type handling.  Does not change anything.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.11 2011/01/05 15:37:23 kristaps Exp $ */
d275 1
a275 1
	pos = dp->layout ? dp->layout->pos : TBL_CELL_LEFT;
d347 1
d351 3
a353 1
	pos = dp->layout ? dp->layout->pos : TBL_CELL_LEFT;
d359 1
a359 1
		padr = col->width - term_strlen(tp, dp->string) - ssz;
d362 1
a362 1
		padl = col->width - term_strlen(tp, dp->string);
d369 1
a369 1
		padl = col->width - term_strlen(tp, dp->string);
d372 1
a372 1
		padr = col->width - term_strlen(tp, dp->string);
d377 1
a377 1
	term_word(tp, dp->string);
d397 1
a397 3
	str = "";
	if (dp->string)
		str = dp->string;
d422 1
a422 1
	term_word(tp, dp->string);
@


1.11
log
@Stuff tbl_calc() into out.c so that it can be shared by all output modes
(isn't now, but will need to be, used by -T[x]html also).  Necessitated
a lot of churn in getting tbl_calc* code out of tbl_term.c and into
out.c, including renaming some structures and so on.  The abstraction is
in having a pointer to a wrapper function for calculating string widths.
The char devices use term_strlen and term_len; the others will probably
just use strlen().

While at it, remove some superfluous assertions in the tbl code.  This
allows all tbl manuals to clear.

Lastly, set the right-margin to be the maximum margin for each table
span.  This allows big, complicated tbl-pages like terminfo to be
displayed.  They're ugly, but they work.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.10 2011/01/04 15:02:00 kristaps Exp $ */
d35 1
a35 1
static	void	tbl_char(struct termp *, char, int);
d70 1
a70 1
	int		   	 rmargin, maxrmargin;
d168 1
a168 1
	int		 width;
d205 1
a205 1
	int		 width;
d327 1
a327 1
tbl_char(struct termp *tp, char c, int len)
d329 5
a333 2
	int		i, sz;
	const char	cp[2] = {c, '\0'};
d345 1
a345 1
	int		 padl, padr, ssz;
@


1.10
log
@Support `T{' and `T}' data blocks.  When a standalone `T{' is
encountered as a line's last data cell, move into TBL_PART_CDATA mode
whilst leaving the cell's designation as TBL_DATA_NONE.  When new data
arrives that's not a standalone `T}', append it to the cell contends.
Close out and warn appropriately.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.9 2011/01/04 13:21:45 kristaps Exp $ */
d33 30
a62 32
static	inline void	 tbl_char(struct termp *, char, int);
static	void		 tbl_hframe(struct termp *, 
				const struct tbl_span *);
static	void		 tbl_data_number(struct termp *, 
				const struct tbl *, 
				const struct tbl_dat *, 
				const struct termp_tbl *);
static	void		 tbl_data_literal(struct termp *, 
				const struct tbl_dat *, 
				const struct termp_tbl *);
static	void		 tbl_data(struct termp *, const struct tbl *,
				const struct tbl_dat *, 
				const struct termp_tbl *);
static	void		 tbl_spanner(struct termp *, 
				const struct tbl_head *);
static	void		 tbl_hrule(struct termp *, 
				const struct tbl_span *);
static	void		 tbl_vframe(struct termp *, 
				const struct tbl *);
static	void	 	 tbl_calc(struct termp *,
				const struct tbl_span *);
static	void	 	 tbl_calc_data(struct termp *,
				const struct tbl *, 
				const struct tbl_dat *,
				struct termp_tbl *);
static	void	 	 tbl_calc_data_literal(struct termp *,
				const struct tbl_dat *,
				struct termp_tbl *);
static	void	 	 tbl_calc_data_number(struct termp *,
				const struct tbl *, 
				const struct tbl_dat *,
				struct termp_tbl *);
d67 9
a75 2
	const struct tbl_head *hp;
	const struct tbl_dat *dp;
d83 2
a84 4
	 * The first time we're invoked for a given table block, create
	 * the termp_tbl structure.  This contains the column
	 * configuration for the entire table, e.g., table-wide column
	 * width, decimal point, etc.
d88 5
a92 8
		assert(NULL == tp->tbl);
		tp->tbl = calloc
			(sp->tbl->cols, sizeof(struct termp_tbl));
		if (NULL == tp->tbl) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		tbl_calc(tp, sp);
d94 1
a94 2
		/* Flush out any preceding data. */
		term_flushln(tp);
d126 1
a126 1
				tbl_spanner(tp, hp);
d131 3
a133 2
			tbl_data(tp, sp->tbl, dp, 
				&tp->tbl[hp->ident]);
d152 3
a154 3
		assert(tp->tbl);
		free(tp->tbl);
		tp->tbl = NULL;
d158 2
d183 1
a183 1
		width = tp->tbl[hp->ident].width;
d222 1
a222 1
			width = tp->tbl[hp->ident].width;
d231 1
a231 1
		width = tp->tbl[hp->ident].width;
d248 1
a248 1
		const struct termp_tbl *tbp)
d253 1
a253 1
		tbl_char(tp, ASCII_NBRSP, tbp->width);
d259 1
a259 1
		tbl_char(tp, ASCII_NBRSP, tbp->width);
d264 1
a264 1
		tbl_char(tp, '-', tbp->width);
d269 1
a269 1
		tbl_char(tp, '=', tbp->width);
d279 1
a279 1
		tbl_char(tp, '-', tbp->width);
d282 1
a282 1
		tbl_char(tp, '=', tbp->width);
d291 1
a291 1
		tbl_data_literal(tp, dp, tbp);
d294 1
a294 1
		tbl_data_number(tp, tbl, dp, tbp);
d301 1
d303 1
a303 1
tbl_spanner(struct termp *tp, const struct tbl_head *hp)
a320 1
	/* Always just a single vertical line. */
d326 1
a326 1
static inline void
d330 1
a330 4
	char		cp[2];

	cp[0] = c;
	cp[1] = '\0';
d339 2
a340 3
tbl_data_literal(struct termp *tp, 
		const struct tbl_dat *dp, 
		const struct termp_tbl *tblp)
d353 1
a353 1
		padr = tblp->width - term_strlen(tp, dp->string) - ssz;
d356 1
a356 1
		padl = tblp->width - term_strlen(tp, dp->string);
d363 1
a363 1
		padl = tblp->width - term_strlen(tp, dp->string);
d366 1
a366 1
		padr = tblp->width - term_strlen(tp, dp->string);
d376 1
a376 1
tbl_data_number(struct termp *tp, const struct tbl *tbl,
d378 1
a378 1
		const struct termp_tbl *tblp)
d380 5
a384 2
	char		*decp, buf[2];
	int		 d, padl, sz, psz, ssz, i;
d391 3
a393 30
	sz = term_strlen(tp, dp->string);
	psz = term_strlen(tp, ".");

	if (NULL != (decp = strchr(dp->string, tbl->decimal))) {
		buf[1] = '\0';
		for (ssz = i = 0; decp != &dp->string[i]; i++) {
			buf[0] = dp->string[i];
			ssz += term_strlen(tp, buf);
		}
		d = ssz + psz;
	} else
		d = sz + psz;

	assert(d <= tblp->decimal);
	assert(sz - d <= tblp->width - tblp->decimal);

	padl = tblp->decimal - d + term_len(tp, 1);
	assert(tblp->width - sz - padl);

	tbl_char(tp, ASCII_NBRSP, padl);
	term_word(tp, dp->string);
	tbl_char(tp, ASCII_NBRSP, tblp->width - sz - padl);
}

static void
tbl_calc(struct termp *tp, const struct tbl_span *sp)
{
	const struct tbl_dat *dp;
	const struct tbl_head *hp;
	struct termp_tbl *p;
d395 1
a395 1
	/* Calculate width as the max of column cells' widths. */
d397 2
a398 1
	hp = sp->head;
d400 1
a400 3
	for ( ; sp; sp = sp->next) {
		if (TBL_SPAN_DATA != sp->pos)
			continue;
d402 1
a402 80
		for (dp = sp->first; dp; dp = dp->next) {
			if (NULL == dp->layout)
				continue;
			p = &tp->tbl[dp->layout->head->ident];
			tbl_calc_data(tp, sp->tbl, dp, p);
		}
	}

	/* Calculate width as the simple spanner value. */

	for ( ; hp; hp = hp->next) 
		switch (hp->pos) {
		case (TBL_HEAD_VERT):
			tp->tbl[hp->ident].width = term_len(tp, 1);
			break;
		case (TBL_HEAD_DVERT):
			tp->tbl[hp->ident].width = term_len(tp, 2);
			break;
		default:
			break;
		}
}

static void
tbl_calc_data(struct termp *tp, const struct tbl *tbl, 
		const struct tbl_dat *dp, struct termp_tbl *tblp)
{
	int		 sz;

	/* Branch down into data sub-types. */

	switch (dp->layout->pos) {
	case (TBL_CELL_HORIZ):
		/* FALLTHROUGH */
	case (TBL_CELL_DHORIZ):
		sz = term_len(tp, 1);
		if (tblp->width < sz)
			tblp->width = sz;
		break;
	case (TBL_CELL_LONG):
		/* FALLTHROUGH */
	case (TBL_CELL_CENTRE):
		/* FALLTHROUGH */
	case (TBL_CELL_LEFT):
		/* FALLTHROUGH */
	case (TBL_CELL_RIGHT):
		tbl_calc_data_literal(tp, dp, tblp);
		break;
	case (TBL_CELL_NUMBER):
		tbl_calc_data_number(tp, tbl, dp, tblp);
		break;
	default:
		abort();
		/* NOTREACHED */
	}
}

static void
tbl_calc_data_number(struct termp *tp, const struct tbl *tbl, 
		const struct tbl_dat *dp, struct termp_tbl *tblp)
{
	int 		 sz, d, psz, i, ssz;
	char		*cp, buf[2];

	/*
	 * First calculate number width and decimal place (last + 1 for
	 * no-decimal numbers).  If the stored decimal is subsequent
	 * ours, make our size longer by that difference
	 * (right-"shifting"); similarly, if ours is subsequent the
	 * stored, then extend the stored size by the difference.
	 * Finally, re-assign the stored values.
	 */

	/* TODO: use spacing modifier. */

	assert(dp->string);
	sz = term_strlen(tp, dp->string);
	psz = term_strlen(tp, ".");

	if (NULL != (cp = strchr(dp->string, tbl->decimal))) {
d404 2
a405 2
		for (ssz = i = 0; cp != &dp->string[i]; i++) {
			buf[0] = dp->string[i];
d413 1
d415 1
a415 5
	if (tblp->decimal > d) {
		sz += tblp->decimal - d;
		d = tblp->decimal;
	} else
		tblp->width += d - tblp->decimal;
d417 3
a419 4
	if (sz > tblp->width)
		tblp->width = sz;
	if (d > tblp->decimal)
		tblp->decimal = d;
a421 38
static void
tbl_calc_data_literal(struct termp *tp, 
		const struct tbl_dat *dp, 
		struct termp_tbl *tblp)
{
	int		 sz, bufsz, spsz;

	/* 
	 * Calculate our width and use the spacing, with a minimum
	 * spacing dictated by position (centre, e.g,. gets a space on
	 * either side, while right/left get a single adjacent space).
	 */

	assert(dp->string);
	sz = term_strlen(tp, dp->string);

	switch (dp->layout->pos) {
	case (TBL_CELL_LONG):
		/* FALLTHROUGH */
	case (TBL_CELL_CENTRE):
		bufsz = term_len(tp, 2);
		break;
	default:
		bufsz = term_len(tp, 1);
		break;
	}

	spsz = 0;
	if (dp->layout->spacing)
		spsz = term_len(tp, dp->layout->spacing);

	if (spsz)
		bufsz = bufsz > spsz ?  bufsz : spsz;

	sz += bufsz;
	if (tblp->width < sz)
		tblp->width = sz;
}
@


1.9
log
@Have horizontal spanner not clobber pre-set width.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.8 2011/01/04 13:14:26 kristaps Exp $ */
d256 3
d426 1
a426 4
		switch (sp->pos) {
		case (TBL_DATA_HORIZ):
			/* FALLTHROUGH */
		case (TBL_DATA_DHORIZ):
d428 1
a428 3
		default:
			break;
		}
@


1.8
log
@Fix spacing for tables to use term_len().  Also make term.c properly
recode ASCII_HYPHEN and ASCII_NBRSP before passing back for widths.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.7 2011/01/04 12:06:21 kristaps Exp $ */
d458 1
d466 3
a468 1
		tblp->width = term_len(tp, 1);
@


1.7
log
@Fix to make horizontal spanners in the layout be properly printed.
mandoc also now warns (so does tbl(1)) if a horizontal spanner is
specified along with data.

While here, fix up some documentation and uncomment the tbl reference.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.6 2011/01/03 16:04:41 kristaps Exp $ */
a208 3
	tp->flags |= TERMP_NONOSPACE;
	tp->flags |= TERMP_NOSPACE;

d465 1
a465 1
		tblp->width = 1;
d536 1
a536 1
	int		 sz, bufsz;
d551 1
a551 1
		bufsz = 2;
d554 1
a554 1
		bufsz = 1;
d558 1
d560 4
a563 2
		bufsz = bufsz > dp->layout->spacing ? 
			bufsz : dp->layout->spacing;
@


1.6
log
@Switch on the `TS' documentation in roff.7.  As per off-line discussion,
this may be moved to tbl.7, but for the time being, keep it in the
document as it's developed.

Also note that my handling of horizontal rules in layouts needs some
work.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.5 2011/01/03 15:07:59 kristaps Exp $ */
a42 3
static	void		 tbl_data_spanner(struct termp *, 
				const struct tbl_dat *, 
				const struct termp_tbl *);
d261 5
d267 1
a267 1
		tbl_data_spanner(tp, dp, tbp);
d277 2
a278 1
		/* FALLTHROUGH */
d280 1
a280 2
		/* FIXME: THIS IS WRONG. */
		tbl_data_spanner(tp, dp, tbp);
a323 1

a339 20
tbl_data_spanner(struct termp *tp, 
		const struct tbl_dat *dp, 
		const struct termp_tbl *tblp)
{

	switch (dp->pos) {
	case (TBL_DATA_HORIZ):
	case (TBL_DATA_NHORIZ):
		tbl_char(tp, '-', tblp->width);
		break;
	case (TBL_DATA_DHORIZ):
	case (TBL_DATA_NDHORIZ):
		tbl_char(tp, '=', tblp->width);
		break;
	default:
		break;
	}
}

static void
@


1.5
log
@Add in support for number table cells that account for escapes and so
on.  Note also that -Tps and -Tpdf, with these last two commits, produce
more readable output ("less crappy").
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.4 2011/01/03 14:57:04 kristaps Exp $ */
d277 1
@


1.4
log
@Clean up the tbl top-level printing code and document the parts of it.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.3 2011/01/03 14:45:59 kristaps Exp $ */
d400 2
a401 2
	char		*decp;
	int		 d, padl, sz;
d408 2
a409 1
	sz = (int)strlen(dp->string);
d411 9
a419 5
	if (NULL == (decp = strchr(dp->string, tbl->decimal))) {
		d = sz + 1;
	} else {
		d = (int)(decp - dp->string) + 1;
	}
d424 1
a424 1
	padl = tblp->decimal - d + 1;
d510 2
a511 2
	int 		 sz, d;
	char		*cp;
d525 2
a526 1
	sz = (int)strlen(dp->string);
d528 9
a536 4
	if (NULL == (cp = strchr(dp->string, tbl->decimal)))
		d = sz + 1;
	else
		d = (int)(cp - dp->string) + 1;
d538 1
a538 1
	sz += 2;
@


1.3
log
@Start using term_strlen() instead of strlen().  tbl_term.c can now
properly handle embedded escapes when calculating its widths.  NOTE:
this doesn't yet apply to the decimal-point calculation.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.2 2011/01/03 13:59:21 kristaps Exp $ */
d75 12
d96 2
d101 2
d106 1
a106 2
	tp->flags |= TERMP_NONOSPACE;
	tp->flags |= TERMP_NOSPACE;
d110 6
a120 4
		tbl_vframe(tp, sp->tbl);
		term_newln(tp);
		goto end;
	default:
d122 15
a136 1
	}
d138 1
a138 10
	dp = sp->first;
	for (hp = sp->head; hp; hp = hp->next) {
		switch (hp->pos) {
		case (TBL_HEAD_VERT):
			/* FALLTHROUGH */
		case (TBL_HEAD_DVERT):
			tbl_spanner(tp, hp);
			break;
		case (TBL_HEAD_DATA):
			tbl_data(tp, sp->tbl, dp, &tp->tbl[hp->ident]);
a140 4
			break;
		default:
			abort();
			/* NOTREACHED */
d142 1
d148 5
a152 1
end:
@


1.2
log
@Make width calculations occur within tbl_term.c, not tbl.c.  This allows
for front-ends to make decisions about widths, not the back-end.

To pull this off, first make each tbl_head contain a unique index value
(0 <= index < total tbl_head elements) and remove the tbl_calc() routine
from the back-end.

Then, when encountering the first tbl_span in the front-end, dynamically
create an array of configurations (termp_tbl) keyed on each tbl_head's
unique index value.  Construct the decimals and widths at this time,
then continue parsing as before.

The termp_tbl and indexes are required because we pass a const tbl AST
into the front-end.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.1 2011/01/02 12:21:07 kristaps Exp $ */
d55 5
a59 1
static	void	 	 tbl_calc(const struct tbl_span *,
d61 1
a61 1
static	void	 	 tbl_calc_data(const struct tbl *, 
d64 2
a65 3
static	void	 	 tbl_calc_data_literal(const struct tbl_dat *,
				struct termp_tbl *);
static	void	 	 tbl_calc_data_number(const struct tbl *, 
d83 1
a83 1
		tbl_calc(sp, tp->tbl);
d302 1
a302 1
	int		i;
d308 3
a310 1
	for (i = 0; i < len; i++)
d339 1
a339 1
	int		 padl, padr;
d345 1
d349 2
a350 2
		padl = 1;
		padr = tblp->width - (int)strlen(dp->string) - 1;
d353 1
a353 1
		padl = tblp->width - (int)strlen(dp->string);
d360 1
a360 1
		padl = tblp->width - (int)strlen(dp->string);
d363 1
a363 1
		padr = tblp->width - (int)strlen(dp->string);
d377 1
a377 1
	char		*decp, pnt;
a385 1
	pnt = tbl->decimal;
d387 1
a387 1
	if (NULL == (decp = strchr(dp->string, pnt))) {
d405 1
a405 1
tbl_calc(const struct tbl_span *sp, struct termp_tbl *tblp)
d427 2
a428 2
			p = &tblp[dp->layout->head->ident];
			tbl_calc_data(sp->tbl, dp, p);
d437 1
a437 1
			tblp[hp->ident].width = 1;
d440 1
a440 1
			tblp[hp->ident].width = 2;
d448 2
a449 3
tbl_calc_data(const struct tbl *tbl, 
		const struct tbl_dat *dp,
		struct termp_tbl *tblp)
d467 1
a467 1
		tbl_calc_data_literal(dp, tblp);
d470 1
a470 1
		tbl_calc_data_number(tbl, dp, tblp);
d479 1
a479 1
tbl_calc_data_number(const struct tbl *tbl, 
d483 1
a483 1
	char		*cp, pnt;
a497 1
	pnt = tbl->decimal;
d499 1
a499 1
	if (NULL == (cp = strchr(dp->string, pnt)))
d519 3
a521 1
tbl_calc_data_literal(const struct tbl_dat *dp, struct termp_tbl *tblp)
d532 1
a532 1
	sz = (int)strlen(dp->string);
@


1.1
log
@Turn on -Tascii tbl printing.  The output still has some issues---I'm
not sure whether it's in the header calculation or term.c squashing
spaces or whatever, but let's get this in for general testing as soon as
possible.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.13 2009/09/14 09:06:40 kristaps Exp $ */
d38 2
a39 1
				const struct tbl_dat *, int);
d41 2
a42 1
				const struct tbl_dat *, int);
d44 2
a45 1
				const struct tbl_dat *, int);
d47 2
a48 1
				const struct tbl_dat *, int);
d53 12
a64 1
static	void		 tbl_vframe(struct termp *, const struct tbl *);
d72 9
a80 1
	if (TBL_SPAN_FIRST & sp->flags)
d82 1
d99 1
a99 2
		tp->flags &= ~TERMP_NONOSPACE;
		return;
d113 1
a113 1
			tbl_data(tp, sp->tbl, dp, hp->width);
d126 2
a127 1
	if (TBL_SPAN_LAST & sp->flags)
d129 4
d143 1
d158 1
d161 1
a161 1
			tbl_char(tp, c, hp->width);
d164 1
a164 1
			tbl_char(tp, '+', hp->width);
d167 1
a167 1
			tbl_char(tp, '+', hp->width);
d180 1
d199 4
a202 2
		for (hp = sp->head; hp; hp = hp->next)
			tbl_char(tp, '-', hp->width);
d209 1
d212 1
a212 1
			tbl_char(tp, '-', hp->width);
d215 1
a215 1
			tbl_char(tp, '+', hp->width);
d225 2
a226 1
		const struct tbl_dat *dp, int width)
d231 1
a231 1
		tbl_char(tp, ASCII_NBRSP, width);
d239 1
a239 1
		tbl_data_spanner(tp, dp, width);
d251 1
a251 1
		tbl_data_spanner(tp, dp, width);
d260 1
a260 1
		tbl_data_literal(tp, dp, width);
d263 1
a263 1
		tbl_data_number(tp, tbl, dp, width);
d310 3
a312 1
tbl_data_spanner(struct termp *tp, const struct tbl_dat *dp, int width)
d318 1
a318 1
		tbl_char(tp, '-', width);
d322 1
a322 1
		tbl_char(tp, '=', width);
d330 3
a332 1
tbl_data_literal(struct termp *tp, const struct tbl_dat *dp, int width)
d344 1
a344 1
		padr = width - (int)strlen(dp->string) - 1;
d347 1
a347 1
		padl = width - (int)strlen(dp->string);
d354 1
a354 1
		padl = width - (int)strlen(dp->string);
d357 1
a357 1
		padr = width - (int)strlen(dp->string);
d368 2
a369 1
		const struct tbl_dat *dp, int width)
d388 2
a389 3
	assert(d <= dp->layout->head->decimal);
	assert(sz - d <= dp->layout->head->width -
			dp->layout->head->decimal);
d391 2
a392 2
	padl = dp->layout->head->decimal - d + 1;
	assert(width - sz - padl);
d396 151
a546 1
	tbl_char(tp, ASCII_NBRSP, width - sz - padl);
@
