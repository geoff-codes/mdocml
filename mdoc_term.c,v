head	1.330;
access;
symbols
	VERSION_1_13_3:1.313
	VERSION_1_13_2:1.299
	VERSION_1_12_4:1.279
	VERSION_1_13_1:1.275
	VERSION_1_12_3:1.258
	VERSION_1_12_2:1.249
	VERSION_1_12:1.279.0.4
	VERSION_1_12_1:1.238
	VERSION_1_12_0:1.235
	VERSION_1_11_7:1.233
	VERSION_1_11_6:1.233
	VERSION_1_11_5:1.233
	VERSION_1_11_4:1.231
	VERSION_1_11_3:1.230
	VERSION_1_11_2:1.229
	VERSION_1_11_1:1.226
	VERSION_1_10_10:1.220
	VERSION_1_10_9:1.208
	VERSION_1_10_8:1.202
	VERSION_1_10_7:1.196
	VERSION_1_10_6:1.190
	VERSION_1_10_5:1.179
	VERSION_1_10_5_PREPDF:1.177
	VERSION_1_10_4:1.173
	VERSION_1_10_3:1.161
	VERSION_1_10_2:1.156
	VERSION_1_10_1:1.144
	VERSION_1_9_24:1.117
	VERSION_1_9_25:1.122
	VERSION_1_9_23:1.116
	VERSION_1_9_22:1.112
	VERSION_1_9_21:1.112
	VERSION_1_9_20:1.112
	VERSION_1_9_19:1.111
	VERSION_1_9_18:1.111
	VERSION_1_9_17:1.111
	VERSION_1_9_16:1.110
	VERSION_1_9_15:1.110
	VERSION_1_9_15-pre2:1.109
	VERSION_1_9_15-pre1:1.106
	VERSION_1_9_14:1.102
	VERSION_1_9_13:1.100
	VERSION_1_9_12:1.99
	VERSION_1_9_11:1.96
	VERSION_1_9_10:1.96
	VERSION_1_9_9:1.93
	VERSION_1_9_8:1.88
	VERSION_1_9_7:1.87
	VERSION_1_9_6:1.84
	VERSION_1_9_5:1.77
	VERSION_1_9_2:1.68
	VERSION_1_9_1:1.68
	VERSION_1_9_0:1.66
	VERSION_1_8_5:1.63
	VERSION_1_8_4:1.63
	VERSION_1_8_3:1.59
	VERSION_1_8_2:1.49
	VERSION_1_8_1:1.47
	VERSION_1_8_0:1.41
	VERSION_1_7_24:1.24
	VERSION_1_7_23:1.21
	VERSION_1_7_22:1.21
	VERSION_1_7_21:1.20
	VERSION_1_7_20:1.18
	VERSION_1_7_19:1.15
	VERSION_1_7_17:1.12
	VERSION_1_7_16:1.12
	VERSION_1_7_15:1.12
	VERSION_1_7_14:1.11
	VERSION_1_7_13:1.6
	VERSION_1_7_12:1.4
	OPENBSD_CHECKIN:1.4
	VERSION_1_7_10:1.4
	VERSION_1_7_5:1.2;
locks; strict;
comment	@ * @;


1.330
date	2015.10.12.15.29.35;	author schwarze;	state Exp;
branches;
next	1.329;

1.329
date	2015.10.12.00.08.16;	author schwarze;	state Exp;
branches;
next	1.328;

1.328
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.327;

1.327
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.326;

1.326
date	2015.09.21.13.25.00;	author schwarze;	state Exp;
branches;
next	1.325;

1.325
date	2015.09.14.12.57.47;	author schwarze;	state Exp;
branches;
next	1.324;

1.324
date	2015.07.25.14.28.59;	author schwarze;	state Exp;
branches;
next	1.323;

1.323
date	2015.07.25.14.23.08;	author schwarze;	state Exp;
branches;
next	1.322;

1.322
date	2015.07.25.14.18.04;	author schwarze;	state Exp;
branches;
next	1.321;

1.321
date	2015.07.25.14.02.06;	author schwarze;	state Exp;
branches;
next	1.320;

1.320
date	2015.07.17.22.38.29;	author schwarze;	state Exp;
branches;
next	1.319;

1.319
date	2015.04.18.17.53.21;	author schwarze;	state Exp;
branches;
next	1.318;

1.318
date	2015.04.18.16.06.41;	author schwarze;	state Exp;
branches;
next	1.317;

1.317
date	2015.04.04.17.47.18;	author schwarze;	state Exp;
branches;
next	1.316;

1.316
date	2015.04.02.23.48.20;	author schwarze;	state Exp;
branches;
next	1.315;

1.315
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.314;

1.314
date	2015.04.02.21.36.50;	author schwarze;	state Exp;
branches;
next	1.313;

1.313
date	2015.03.06.15.48.52;	author schwarze;	state Exp;
branches;
next	1.312;

1.312
date	2015.03.06.13.09.07;	author schwarze;	state Exp;
branches;
next	1.311;

1.311
date	2015.02.17.20.37.17;	author schwarze;	state Exp;
branches;
next	1.310;

1.310
date	2015.02.12.12.24.33;	author schwarze;	state Exp;
branches;
next	1.309;

1.309
date	2015.02.11.14.15.12;	author schwarze;	state Exp;
branches;
next	1.308;

1.308
date	2015.02.05.01.46.56;	author schwarze;	state Exp;
branches;
next	1.307;

1.307
date	2015.02.05.00.14.13;	author schwarze;	state Exp;
branches;
next	1.306;

1.306
date	2015.02.01.23.10.35;	author schwarze;	state Exp;
branches;
next	1.305;

1.305
date	2015.01.31.00.12.41;	author schwarze;	state Exp;
branches;
next	1.304;

1.304
date	2015.01.30.22.04.44;	author schwarze;	state Exp;
branches;
next	1.303;

1.303
date	2015.01.23.14.21.01;	author schwarze;	state Exp;
branches;
next	1.302;

1.302
date	2014.12.24.23.32.42;	author schwarze;	state Exp;
branches;
next	1.301;

1.301
date	2014.12.23.13.48.57;	author schwarze;	state Exp;
branches;
next	1.300;

1.300
date	2014.12.23.09.31.46;	author schwarze;	state Exp;
branches;
next	1.299;

1.299
date	2014.12.02.10.08.06;	author schwarze;	state Exp;
branches;
next	1.298;

1.298
date	2014.11.30.05.29.00;	author schwarze;	state Exp;
branches;
next	1.297;

1.297
date	2014.11.28.16.54.23;	author schwarze;	state Exp;
branches;
next	1.296;

1.296
date	2014.11.28.16.02.52;	author schwarze;	state Exp;
branches;
next	1.295;

1.295
date	2014.11.27.22.27.56;	author schwarze;	state Exp;
branches;
next	1.294;

1.294
date	2014.11.27.16.20.31;	author schwarze;	state Exp;
branches;
next	1.293;

1.293
date	2014.11.25.20.00.01;	author schwarze;	state Exp;
branches;
next	1.292;

1.292
date	2014.11.21.01.52.53;	author schwarze;	state Exp;
branches;
next	1.291;

1.291
date	2014.11.19.22.00.37;	author schwarze;	state Exp;
branches;
next	1.290;

1.290
date	2014.11.17.06.44.58;	author schwarze;	state Exp;
branches;
next	1.289;

1.289
date	2014.11.10.21.56.43;	author schwarze;	state Exp;
branches;
next	1.288;

1.288
date	2014.10.30.20.10.02;	author schwarze;	state Exp;
branches;
next	1.287;

1.287
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.286;

1.286
date	2014.10.20.15.50.24;	author schwarze;	state Exp;
branches;
next	1.285;

1.285
date	2014.10.20.02.47.09;	author schwarze;	state Exp;
branches;
next	1.284;

1.284
date	2014.10.20.02.33.06;	author schwarze;	state Exp;
branches;
next	1.283;

1.283
date	2014.10.13.22.00.47;	author schwarze;	state Exp;
branches;
next	1.282;

1.282
date	2014.09.17.20.18.58;	author schwarze;	state Exp;
branches;
next	1.281;

1.281
date	2014.09.03.05.22.45;	author schwarze;	state Exp;
branches;
next	1.280;

1.280
date	2014.08.21.12.57.17;	author schwarze;	state Exp;
branches;
next	1.279;

1.279
date	2014.08.17.16.51.55;	author schwarze;	state Exp;
branches;
next	1.278;

1.278
date	2014.08.17.16.44.41;	author schwarze;	state Exp;
branches;
next	1.277;

1.277
date	2014.08.17.08.37.11;	author kristaps;	state Exp;
branches;
next	1.276;

1.276
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.275;

1.275
date	2014.08.06.15.09.05;	author schwarze;	state Exp;
branches;
next	1.274;

1.274
date	2014.07.30.17.06.26;	author schwarze;	state Exp;
branches;
next	1.273;

1.273
date	2014.07.30.00.19.16;	author schwarze;	state Exp;
branches;
next	1.272;

1.272
date	2014.07.29.13.58.18;	author schwarze;	state Exp;
branches;
next	1.271;

1.271
date	2014.07.07.15.03.43;	author schwarze;	state Exp;
branches;
next	1.270;

1.270
date	2014.07.03.23.24.56;	author schwarze;	state Exp;
branches;
next	1.269;

1.269
date	2014.07.02.19.55.10;	author schwarze;	state Exp;
branches;
next	1.268;

1.268
date	2014.07.02.03.48.07;	author schwarze;	state Exp;
branches;
next	1.267;

1.267
date	2014.04.23.16.08.33;	author schwarze;	state Exp;
branches;
next	1.266;

1.266
date	2014.04.20.20.18.12;	author schwarze;	state Exp;
branches;
next	1.265;

1.265
date	2014.04.20.19.40.13;	author schwarze;	state Exp;
branches;
next	1.264;

1.264
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.263;

1.263
date	2014.04.08.07.13.12;	author schwarze;	state Exp;
branches;
next	1.262;

1.262
date	2014.04.08.04.40.47;	author schwarze;	state Exp;
branches;
next	1.261;

1.261
date	2014.03.30.21.28.01;	author schwarze;	state Exp;
branches;
next	1.260;

1.260
date	2014.03.30.19.47.48;	author schwarze;	state Exp;
branches;
next	1.259;

1.259
date	2014.02.16.12.33.39;	author schwarze;	state Exp;
branches;
next	1.258;

1.258
date	2013.12.25.21.24.12;	author schwarze;	state Exp;
branches;
next	1.257;

1.257
date	2013.12.25.15.12.45;	author schwarze;	state Exp;
branches;
next	1.256;

1.256
date	2013.12.25.14.40.34;	author schwarze;	state Exp;
branches;
next	1.255;

1.255
date	2013.12.25.00.39.31;	author schwarze;	state Exp;
branches;
next	1.254;

1.254
date	2013.12.24.23.04.36;	author schwarze;	state Exp;
branches;
next	1.253;

1.253
date	2013.12.24.20.45.27;	author schwarze;	state Exp;
branches;
next	1.252;

1.252
date	2013.12.24.19.11.46;	author schwarze;	state Exp;
branches;
next	1.251;

1.251
date	2013.12.23.02.20.09;	author schwarze;	state Exp;
branches;
next	1.250;

1.250
date	2013.12.22.23.34.13;	author schwarze;	state Exp;
branches;
next	1.249;

1.249
date	2013.06.02.18.16.57;	author schwarze;	state Exp;
branches;
next	1.248;

1.248
date	2013.05.29.16.11.40;	author schwarze;	state Exp;
branches;
next	1.247;

1.247
date	2013.05.29.15.40.22;	author schwarze;	state Exp;
branches;
next	1.246;

1.246
date	2013.05.18.17.47.47;	author schwarze;	state Exp;
branches;
next	1.245;

1.245
date	2012.11.17.00.26.33;	author schwarze;	state Exp;
branches;
next	1.244;

1.244
date	2012.11.16.17.16.55;	author schwarze;	state Exp;
branches;
next	1.243;

1.243
date	2012.07.11.16.57.43;	author schwarze;	state Exp;
branches;
next	1.242;

1.242
date	2012.07.10.14.38.51;	author schwarze;	state Exp;
branches;
next	1.241;

1.241
date	2012.07.09.23.53.36;	author schwarze;	state Exp;
branches;
next	1.240;

1.240
date	2012.07.08.22.49.29;	author schwarze;	state Exp;
branches;
next	1.239;

1.239
date	2012.07.08.16.52.20;	author schwarze;	state Exp;
branches;
next	1.238;

1.238
date	2011.11.13.13.15.14;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2011.11.03.20.36.59;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2011.10.16.12.20.34;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2011.09.20.09.02.23;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2011.09.19.22.36.16;	author schwarze;	state Exp;
branches;
next	1.233;

1.233
date	2011.07.22.10.50.46;	author kristaps;	state Exp;
branches;
next	1.232;

1.232
date	2011.07.21.11.34.53;	author kristaps;	state Exp;
branches;
next	1.231;

1.231
date	2011.06.29.15.38.09;	author kristaps;	state Exp;
branches;
next	1.230;

1.230
date	2011.05.17.14.38.34;	author kristaps;	state Exp;
branches;
next	1.229;

1.229
date	2011.04.30.22.14.42;	author kristaps;	state Exp;
branches;
next	1.228;

1.228
date	2011.04.30.22.14.02;	author kristaps;	state Exp;
branches;
next	1.227;

1.227
date	2011.04.29.22.18.12;	author kristaps;	state Exp;
branches;
next	1.226;

1.226
date	2011.04.04.16.27.03;	author kristaps;	state Exp;
branches;
next	1.225;

1.225
date	2011.04.04.16.21.51;	author kristaps;	state Exp;
branches;
next	1.224;

1.224
date	2011.04.04.16.15.58;	author kristaps;	state Exp;
branches;
next	1.223;

1.223
date	2011.04.04.16.05.36;	author kristaps;	state Exp;
branches;
next	1.222;

1.222
date	2011.03.22.14.05.45;	author kristaps;	state Exp;
branches;
next	1.221;

1.221
date	2011.03.22.10.13.01;	author kristaps;	state Exp;
branches;
next	1.220;

1.220
date	2011.03.07.01.35.51;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2011.02.09.09.52.47;	author kristaps;	state Exp;
branches;
next	1.218;

1.218
date	2011.02.06.23.02.31;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2011.02.06.22.33.38;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2011.02.06.21.44.36;	author kristaps;	state Exp;
branches;
next	1.215;

1.215
date	2011.02.02.21.40.45;	author kristaps;	state Exp;
branches;
next	1.214;

1.214
date	2011.01.25.16.20.24;	author kristaps;	state Exp;
branches;
next	1.213;

1.213
date	2011.01.25.15.46.05;	author kristaps;	state Exp;
branches;
next	1.212;

1.212
date	2011.01.25.15.28.56;	author kristaps;	state Exp;
branches;
next	1.211;

1.211
date	2011.01.25.15.17.18;	author kristaps;	state Exp;
branches;
next	1.210;

1.210
date	2011.01.25.10.37.49;	author kristaps;	state Exp;
branches;
next	1.209;

1.209
date	2011.01.12.10.43.22;	author kristaps;	state Exp;
branches;
next	1.208;

1.208
date	2011.01.06.14.05.12;	author kristaps;	state Exp;
branches;
next	1.207;

1.207
date	2011.01.02.12.21.07;	author kristaps;	state Exp;
branches;
next	1.206;

1.206
date	2011.01.01.12.18.37;	author kristaps;	state Exp;
branches;
next	1.205;

1.205
date	2010.12.25.23.27.50;	author kristaps;	state Exp;
branches;
next	1.204;

1.204
date	2010.12.25.23.25.53;	author kristaps;	state Exp;
branches;
next	1.203;

1.203
date	2010.12.25.13.50.37;	author kristaps;	state Exp;
branches;
next	1.202;

1.202
date	2010.12.24.14.00.40;	author kristaps;	state Exp;
branches;
next	1.201;

1.201
date	2010.12.22.11.15.16;	author kristaps;	state Exp;
branches;
next	1.200;

1.200
date	2010.12.19.12.11.42;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2010.12.16.17.14.48;	author kristaps;	state Exp;
branches;
next	1.198;

1.198
date	2010.12.15.23.44.02;	author kristaps;	state Exp;
branches;
next	1.197;

1.197
date	2010.12.11.14.40.51;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2010.12.05.15.37.30;	author kristaps;	state Exp;
branches;
next	1.195;

1.195
date	2010.11.29.13.02.47;	author kristaps;	state Exp;
branches;
next	1.194;

1.194
date	2010.10.23.23.31.10;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2010.10.10.09.59.48;	author kristaps;	state Exp;
branches;
next	1.192;

1.192
date	2010.10.01.21.51.13;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2010.09.27.23.03.44;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2010.09.27.11.21.39;	author kristaps;	state Exp;
branches;
next	1.189;

1.189
date	2010.09.26.10.00.42;	author kristaps;	state Exp;
branches;
next	1.188;

1.188
date	2010.09.26.09.16.02;	author kristaps;	state Exp;
branches;
next	1.187;

1.187
date	2010.09.25.16.41.33;	author kristaps;	state Exp;
branches;
next	1.186;

1.186
date	2010.09.25.15.51.30;	author kristaps;	state Exp;
branches;
next	1.185;

1.185
date	2010.09.23.20.40.00;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2010.09.04.19.01.52;	author kristaps;	state Exp;
branches;
next	1.183;

1.183
date	2010.08.21.14.04.13;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2010.08.20.22.51.29;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2010.08.09.00.00.37;	author kristaps;	state Exp;
branches;
next	1.180;

1.180
date	2010.08.07.17.11.17;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2010.07.27.08.38.04;	author kristaps;	state Exp;
branches;
next	1.178;

1.178
date	2010.07.26.22.35.59;	author kristaps;	state Exp;
branches;
next	1.177;

1.177
date	2010.07.21.21.55.33;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.19.11.11.54;	author kristaps;	state Exp;
branches;
next	1.175;

1.175
date	2010.07.19.11.06.31;	author kristaps;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.16.00.03.37;	author schwarze;	state Exp;
branches;
next	1.173;

1.173
date	2010.07.07.15.04.54;	author kristaps;	state Exp;
branches;
next	1.172;

1.172
date	2010.07.06.10.54.05;	author kristaps;	state Exp;
branches;
next	1.171;

1.171
date	2010.07.04.22.04.04;	author schwarze;	state Exp;
branches;
next	1.170;

1.170
date	2010.07.04.21.59.30;	author kristaps;	state Exp;
branches;
next	1.169;

1.169
date	2010.07.03.17.17.15;	author kristaps;	state Exp;
branches;
next	1.168;

1.168
date	2010.07.02.15.03.14;	author kristaps;	state Exp;
branches;
next	1.167;

1.167
date	2010.07.02.12.54.33;	author kristaps;	state Exp;
branches;
next	1.166;

1.166
date	2010.07.02.10.53.28;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2010.07.01.22.56.17;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2010.07.01.15.38.56;	author schwarze;	state Exp;
branches;
next	1.163;

1.163
date	2010.07.01.14.34.03;	author kristaps;	state Exp;
branches;
next	1.162;

1.162
date	2010.06.29.19.20.38;	author schwarze;	state Exp;
branches;
next	1.161;

1.161
date	2010.06.27.17.53.27;	author schwarze;	state Exp;
branches;
next	1.160;

1.160
date	2010.06.27.16.18.13;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2010.06.27.01.26.20;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2010.06.26.15.36.37;	author kristaps;	state Exp;
branches;
next	1.157;

1.157
date	2010.06.25.18.53.14;	author kristaps;	state Exp;
branches;
next	1.156;

1.156
date	2010.06.19.20.46.28;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2010.06.13.22.05.43;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2010.06.13.21.41.58;	author kristaps;	state Exp;
branches;
next	1.153;

1.153
date	2010.06.13.21.02.49;	author kristaps;	state Exp;
branches;
next	1.152;

1.152
date	2010.06.12.12.38.01;	author kristaps;	state Exp;
branches;
next	1.151;

1.151
date	2010.06.12.12.21.41;	author kristaps;	state Exp;
branches;
next	1.150;

1.150
date	2010.06.12.12.10.55;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2010.06.12.11.58.22;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2010.06.12.11.21.44;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2010.06.12.10.09.19;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2010.06.10.23.24.37;	author schwarze;	state Exp;
branches;
next	1.145;

1.145
date	2010.06.09.08.07.13;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2010.06.07.20.57.09;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2010.06.07.11.01.15;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2010.06.06.22.08.15;	author schwarze;	state Exp;
branches;
next	1.141;

1.141
date	2010.06.06.10.50.56;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2010.06.04.22.26.13;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2010.06.04.22.16.27;	author kristaps;	state Exp;
branches;
next	1.138;

1.138
date	2010.06.04.21.49.39;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2010.06.04.21.05.39;	author kristaps;	state Exp;
branches;
next	1.136;

1.136
date	2010.06.01.14.51.09;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.31.10.28.04;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.30.22.56.02;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.29.18.58.52;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2010.05.29.18.47.54;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2010.05.26.10.39.35;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2010.05.24.21.51.20;	author schwarze;	state Exp;
branches;
next	1.129;

1.129
date	2010.05.24.21.34.16;	author schwarze;	state Exp;
branches;
next	1.128;

1.128
date	2010.05.24.14.35.59;	author schwarze;	state Exp;
branches;
next	1.127;

1.127
date	2010.05.22.20.41.48;	author joerg;	state Exp;
branches;
next	1.126;

1.126
date	2010.05.17.23.57.06;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2010.05.15.16.24.38;	author kristaps;	state Exp;
branches;
next	1.123;

1.123
date	2010.05.15.16.18.23;	author joerg;	state Exp;
branches;
next	1.122;

1.122
date	2010.05.13.06.22.11;	author kristaps;	state Exp;
branches;
next	1.121;

1.121
date	2010.05.12.16.01.01;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2010.05.10.08.05.17;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2010.05.09.16.38.38;	author kristaps;	state Exp;
branches;
next	1.118;

1.118
date	2010.05.09.16.05.13;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2010.04.08.08.17.55;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2010.04.06.16.27.53;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2010.04.06.11.28.17;	author kristaps;	state Exp;
branches;
next	1.114;

1.114
date	2010.04.06.07.27.42;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2010.04.03.14.25.12;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2010.03.29.19.28.04;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2010.03.23.12.42.22;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2010.01.30.08.42.21;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2010.01.01.18.33.51;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2010.01.01.18.01.40;	author kristaps;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.01.17.14.30;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2010.01.01.14.32.52;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2010.01.01.14.27.59;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2010.01.01.13.35.30;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.01.13.17.59;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2009.11.12.05.50.12;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2009.11.10.11.45.57;	author kristaps;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.31.06.50.25;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2009.10.30.18.53.09;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2009.10.27.08.49.44;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2009.10.27.08.26.12;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.26.04.09.46;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.24.05.52.14;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.22.18.55.32;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.19.15.18.30;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2009.10.18.19.03.37;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2009.10.18.13.34.17;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2009.10.15.01.33.12;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2009.10.13.10.57.25;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2009.10.10.11.05.23;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.07.12.20.20;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.03.19.02.45;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2009.09.26.17.35.49;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2009.09.24.23.54.43;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2009.09.24.15.01.06;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2009.09.24.11.55.28;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2009.09.24.11.05.45;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2009.09.24.09.50.31;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2009.09.24.09.20.02;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2009.09.22.16.10.52;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2009.09.21.14.08.13;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2009.09.21.14.07.07;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2009.09.20.19.25.06;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2009.09.20.17.48.13;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2009.09.20.17.24.57;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2009.09.20.11.05.22;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2009.09.17.13.17.30;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2009.09.16.09.41.24;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2009.09.15.08.16.20;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.20.13.22.48;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.19.14.45.56;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.10.10.09.51;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.29.09.02.41;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.29.08.46.06;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2009.07.25.16.03.03;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2009.07.24.12.52.28;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.24.12.47.35;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.24.11.54.54;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.23.09.40.25;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2009.07.23.08.36.32;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2009.07.21.15.54.18;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2009.07.21.15.39.04;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2009.07.21.15.35.30;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.21.15.03.37;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.07.21.14.28.36;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.07.21.13.45.04;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.21.13.34.13;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.21.12.47.52;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.20.19.30.46;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.20.15.05.34;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.19.08.24.16;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.07.19.08.18.28;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.07.17.12.40.48;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.07.17.10.56.57;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.07.16.13.27.24;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.07.15.08.20.43;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.14.16.03.51;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.14.15.49.44;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.14.15.17.25;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.13.07.23.07;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.12.20.50.08;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.12.20.30.35;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.12.20.24.24;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.12.20.07.04;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.12.19.34.51;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.12.19.28.46;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.12.19.13.12;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.12.17.49.32;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.12.17.45.17;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.12.17.25.07;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.12.16.55.11;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.12.16.52.41;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.12.16.34.16;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.12.08.49.50;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.12.08.45.56;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.07.11.47.17;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.05.19.25.10;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.04.11.07.34;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.04.11.04.46;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.22.13.13.10;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.22.12.38.07;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.22.12.04.05;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.17.18.42.42;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.16.19.45.51;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.15.20.26.47;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.12.09.18.00;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.11.13.13.44;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.11.12.55.30;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.11.12.07.49;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.06.11.07.26.35;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.10.20.18.43;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.12.19.19.57;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.03.13.17.26;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.26.16.23.22;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.26.14.44.41;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.26.14.38.11;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.330
log
@Use "-" rather than "\(hy" for the heads of .Bl -dash and -hyphen lists.
In UTF-8 output, that renders as ASCII HYPHEN-MINUS (U+002D)
rather than HYPHEN (U+2010), which looks better and matches groff.
In ASCII output, it makes no difference.
Suggested by naddy@@.
@
text
@/*	$Id: mdoc_term.c,v 1.329 2015/10/12 00:08:16 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2013 Franco Fichtner <franco@@lastsummer.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "out.h"
#include "term.h"
#include "tag.h"
#include "main.h"

struct	termpair {
	struct termpair	 *ppair;
	int		  count;
};

#define	DECL_ARGS struct termp *p, \
		  struct termpair *pair, \
		  const struct roff_meta *meta, \
		  struct roff_node *n

struct	termact {
	int	(*pre)(DECL_ARGS);
	void	(*post)(DECL_ARGS);
};

static	int	  a2width(const struct termp *, const char *);

static	void	  print_bvspace(struct termp *,
			const struct roff_node *,
			const struct roff_node *);
static	void	  print_mdoc_node(DECL_ARGS);
static	void	  print_mdoc_nodelist(DECL_ARGS);
static	void	  print_mdoc_head(struct termp *, const struct roff_meta *);
static	void	  print_mdoc_foot(struct termp *, const struct roff_meta *);
static	void	  synopsis_pre(struct termp *,
			const struct roff_node *);

static	void	  termp____post(DECL_ARGS);
static	void	  termp__t_post(DECL_ARGS);
static	void	  termp_bd_post(DECL_ARGS);
static	void	  termp_bk_post(DECL_ARGS);
static	void	  termp_bl_post(DECL_ARGS);
static	void	  termp_eo_post(DECL_ARGS);
static	void	  termp_fd_post(DECL_ARGS);
static	void	  termp_fo_post(DECL_ARGS);
static	void	  termp_in_post(DECL_ARGS);
static	void	  termp_it_post(DECL_ARGS);
static	void	  termp_lb_post(DECL_ARGS);
static	void	  termp_nm_post(DECL_ARGS);
static	void	  termp_pf_post(DECL_ARGS);
static	void	  termp_quote_post(DECL_ARGS);
static	void	  termp_sh_post(DECL_ARGS);
static	void	  termp_ss_post(DECL_ARGS);

static	int	  termp__a_pre(DECL_ARGS);
static	int	  termp__t_pre(DECL_ARGS);
static	int	  termp_an_pre(DECL_ARGS);
static	int	  termp_ap_pre(DECL_ARGS);
static	int	  termp_bd_pre(DECL_ARGS);
static	int	  termp_bf_pre(DECL_ARGS);
static	int	  termp_bk_pre(DECL_ARGS);
static	int	  termp_bl_pre(DECL_ARGS);
static	int	  termp_bold_pre(DECL_ARGS);
static	int	  termp_bt_pre(DECL_ARGS);
static	int	  termp_bx_pre(DECL_ARGS);
static	int	  termp_cd_pre(DECL_ARGS);
static	int	  termp_d1_pre(DECL_ARGS);
static	int	  termp_eo_pre(DECL_ARGS);
static	int	  termp_er_pre(DECL_ARGS);
static	int	  termp_ex_pre(DECL_ARGS);
static	int	  termp_fa_pre(DECL_ARGS);
static	int	  termp_fd_pre(DECL_ARGS);
static	int	  termp_fl_pre(DECL_ARGS);
static	int	  termp_fn_pre(DECL_ARGS);
static	int	  termp_fo_pre(DECL_ARGS);
static	int	  termp_ft_pre(DECL_ARGS);
static	int	  termp_in_pre(DECL_ARGS);
static	int	  termp_it_pre(DECL_ARGS);
static	int	  termp_li_pre(DECL_ARGS);
static	int	  termp_ll_pre(DECL_ARGS);
static	int	  termp_lk_pre(DECL_ARGS);
static	int	  termp_nd_pre(DECL_ARGS);
static	int	  termp_nm_pre(DECL_ARGS);
static	int	  termp_ns_pre(DECL_ARGS);
static	int	  termp_quote_pre(DECL_ARGS);
static	int	  termp_rs_pre(DECL_ARGS);
static	int	  termp_rv_pre(DECL_ARGS);
static	int	  termp_sh_pre(DECL_ARGS);
static	int	  termp_skip_pre(DECL_ARGS);
static	int	  termp_sm_pre(DECL_ARGS);
static	int	  termp_sp_pre(DECL_ARGS);
static	int	  termp_ss_pre(DECL_ARGS);
static	int	  termp_tag_pre(DECL_ARGS);
static	int	  termp_under_pre(DECL_ARGS);
static	int	  termp_ud_pre(DECL_ARGS);
static	int	  termp_vt_pre(DECL_ARGS);
static	int	  termp_xr_pre(DECL_ARGS);
static	int	  termp_xx_pre(DECL_ARGS);

static	const struct termact termacts[MDOC_MAX] = {
	{ termp_ap_pre, NULL }, /* Ap */
	{ NULL, NULL }, /* Dd */
	{ NULL, NULL }, /* Dt */
	{ NULL, NULL }, /* Os */
	{ termp_sh_pre, termp_sh_post }, /* Sh */
	{ termp_ss_pre, termp_ss_post }, /* Ss */
	{ termp_sp_pre, NULL }, /* Pp */
	{ termp_d1_pre, termp_bl_post }, /* D1 */
	{ termp_d1_pre, termp_bl_post }, /* Dl */
	{ termp_bd_pre, termp_bd_post }, /* Bd */
	{ NULL, NULL }, /* Ed */
	{ termp_bl_pre, termp_bl_post }, /* Bl */
	{ NULL, NULL }, /* El */
	{ termp_it_pre, termp_it_post }, /* It */
	{ termp_under_pre, NULL }, /* Ad */
	{ termp_an_pre, NULL }, /* An */
	{ termp_under_pre, NULL }, /* Ar */
	{ termp_cd_pre, NULL }, /* Cd */
	{ termp_bold_pre, NULL }, /* Cm */
	{ termp_li_pre, NULL }, /* Dv */
	{ termp_er_pre, NULL }, /* Er */
	{ termp_tag_pre, NULL }, /* Ev */
	{ termp_ex_pre, NULL }, /* Ex */
	{ termp_fa_pre, NULL }, /* Fa */
	{ termp_fd_pre, termp_fd_post }, /* Fd */
	{ termp_fl_pre, NULL }, /* Fl */
	{ termp_fn_pre, NULL }, /* Fn */
	{ termp_ft_pre, NULL }, /* Ft */
	{ termp_bold_pre, NULL }, /* Ic */
	{ termp_in_pre, termp_in_post }, /* In */
	{ termp_li_pre, NULL }, /* Li */
	{ termp_nd_pre, NULL }, /* Nd */
	{ termp_nm_pre, termp_nm_post }, /* Nm */
	{ termp_quote_pre, termp_quote_post }, /* Op */
	{ termp_ft_pre, NULL }, /* Ot */
	{ termp_under_pre, NULL }, /* Pa */
	{ termp_rv_pre, NULL }, /* Rv */
	{ NULL, NULL }, /* St */
	{ termp_under_pre, NULL }, /* Va */
	{ termp_vt_pre, NULL }, /* Vt */
	{ termp_xr_pre, NULL }, /* Xr */
	{ termp__a_pre, termp____post }, /* %A */
	{ termp_under_pre, termp____post }, /* %B */
	{ NULL, termp____post }, /* %D */
	{ termp_under_pre, termp____post }, /* %I */
	{ termp_under_pre, termp____post }, /* %J */
	{ NULL, termp____post }, /* %N */
	{ NULL, termp____post }, /* %O */
	{ NULL, termp____post }, /* %P */
	{ NULL, termp____post }, /* %R */
	{ termp__t_pre, termp__t_post }, /* %T */
	{ NULL, termp____post }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ termp_quote_pre, termp_quote_post }, /* Ao */
	{ termp_quote_pre, termp_quote_post }, /* Aq */
	{ NULL, NULL }, /* At */
	{ NULL, NULL }, /* Bc */
	{ termp_bf_pre, NULL }, /* Bf */
	{ termp_quote_pre, termp_quote_post }, /* Bo */
	{ termp_quote_pre, termp_quote_post }, /* Bq */
	{ termp_xx_pre, NULL }, /* Bsx */
	{ termp_bx_pre, NULL }, /* Bx */
	{ termp_skip_pre, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ termp_quote_pre, termp_quote_post }, /* Do */
	{ termp_quote_pre, termp_quote_post }, /* Dq */
	{ NULL, NULL }, /* Ec */ /* FIXME: no space */
	{ NULL, NULL }, /* Ef */
	{ termp_under_pre, NULL }, /* Em */
	{ termp_eo_pre, termp_eo_post }, /* Eo */
	{ termp_xx_pre, NULL }, /* Fx */
	{ termp_bold_pre, NULL }, /* Ms */
	{ termp_li_pre, NULL }, /* No */
	{ termp_ns_pre, NULL }, /* Ns */
	{ termp_xx_pre, NULL }, /* Nx */
	{ termp_xx_pre, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, termp_pf_post }, /* Pf */
	{ termp_quote_pre, termp_quote_post }, /* Po */
	{ termp_quote_pre, termp_quote_post }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ termp_quote_pre, termp_quote_post }, /* Ql */
	{ termp_quote_pre, termp_quote_post }, /* Qo */
	{ termp_quote_pre, termp_quote_post }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ termp_rs_pre, NULL }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ termp_quote_pre, termp_quote_post }, /* So */
	{ termp_quote_pre, termp_quote_post }, /* Sq */
	{ termp_sm_pre, NULL }, /* Sm */
	{ termp_under_pre, NULL }, /* Sx */
	{ termp_bold_pre, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
	{ termp_xx_pre, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ termp_fo_pre, termp_fo_post }, /* Fo */
	{ NULL, NULL }, /* Fc */
	{ termp_quote_pre, termp_quote_post }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ termp_bk_pre, termp_bk_post }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ termp_bt_pre, NULL }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ termp_under_pre, NULL }, /* Fr */
	{ termp_ud_pre, NULL }, /* Ud */
	{ NULL, termp_lb_post }, /* Lb */
	{ termp_sp_pre, NULL }, /* Lp */
	{ termp_lk_pre, NULL }, /* Lk */
	{ termp_under_pre, NULL }, /* Mt */
	{ termp_quote_pre, termp_quote_post }, /* Brq */
	{ termp_quote_pre, termp_quote_post }, /* Bro */
	{ NULL, NULL }, /* Brc */
	{ NULL, termp____post }, /* %C */
	{ termp_skip_pre, NULL }, /* Es */
	{ termp_quote_pre, termp_quote_post }, /* En */
	{ termp_xx_pre, NULL }, /* Dx */
	{ NULL, termp____post }, /* %Q */
	{ termp_sp_pre, NULL }, /* br */
	{ termp_sp_pre, NULL }, /* sp */
	{ NULL, termp____post }, /* %U */
	{ NULL, NULL }, /* Ta */
	{ termp_ll_pre, NULL }, /* ll */
};

static	int	 fn_prio;

void
terminal_mdoc(void *arg, const struct roff_man *mdoc)
{
	struct roff_node	*n;
	struct termp		*p;

	p = (struct termp *)arg;
	p->overstep = 0;
	p->rmargin = p->maxrmargin = p->defrmargin;
	p->tabwidth = term_len(p, 5);

	n = mdoc->first->child;
	if (p->synopsisonly) {
		while (n != NULL) {
			if (n->tok == MDOC_Sh && n->sec == SEC_SYNOPSIS) {
				if (n->child->next->child != NULL)
					print_mdoc_nodelist(p, NULL,
					    &mdoc->meta,
					    n->child->next->child);
				term_newln(p);
				break;
			}
			n = n->next;
		}
	} else {
		if (p->defindent == 0)
			p->defindent = 5;
		term_begin(p, print_mdoc_head, print_mdoc_foot,
		    &mdoc->meta);
		if (n != NULL) {
			if (n->tok != MDOC_Sh)
				term_vspace(p);
			print_mdoc_nodelist(p, NULL, &mdoc->meta, n);
		}
		term_end(p);
	}
}

static void
print_mdoc_nodelist(DECL_ARGS)
{

	while (n != NULL) {
		print_mdoc_node(p, pair, meta, n);
		n = n->next;
	}
}

static void
print_mdoc_node(DECL_ARGS)
{
	int		 chld;
	struct termpair	 npair;
	size_t		 offset, rmargin;

	chld = 1;
	offset = p->offset;
	rmargin = p->rmargin;
	n->flags &= ~MDOC_ENDED;
	n->prev_font = p->fonti;

	memset(&npair, 0, sizeof(struct termpair));
	npair.ppair = pair;

	/*
	 * Keeps only work until the end of a line.  If a keep was
	 * invoked in a prior line, revert it to PREKEEP.
	 */

	if (p->flags & TERMP_KEEP && n->flags & MDOC_LINE) {
		p->flags &= ~TERMP_KEEP;
		p->flags |= TERMP_PREKEEP;
	}

	/*
	 * After the keep flags have been set up, we may now
	 * produce output.  Note that some pre-handlers do so.
	 */

	switch (n->type) {
	case ROFFT_TEXT:
		if (' ' == *n->string && MDOC_LINE & n->flags)
			term_newln(p);
		if (MDOC_DELIMC & n->flags)
			p->flags |= TERMP_NOSPACE;
		term_word(p, n->string);
		if (MDOC_DELIMO & n->flags)
			p->flags |= TERMP_NOSPACE;
		break;
	case ROFFT_EQN:
		if ( ! (n->flags & MDOC_LINE))
			p->flags |= TERMP_NOSPACE;
		term_eqn(p, n->eqn);
		if (n->next != NULL && ! (n->next->flags & MDOC_LINE))
			p->flags |= TERMP_NOSPACE;
		break;
	case ROFFT_TBL:
		if (p->tbl.cols == NULL)
			term_newln(p);
		term_tbl(p, n->span);
		break;
	default:
		if (termacts[n->tok].pre &&
		    (n->end == ENDBODY_NOT || n->nchild))
			chld = (*termacts[n->tok].pre)
				(p, &npair, meta, n);
		break;
	}

	if (chld && n->child)
		print_mdoc_nodelist(p, &npair, meta, n->child);

	term_fontpopq(p,
	    (ENDBODY_NOT == n->end ? n : n->body)->prev_font);

	switch (n->type) {
	case ROFFT_TEXT:
		break;
	case ROFFT_TBL:
		break;
	case ROFFT_EQN:
		break;
	default:
		if ( ! termacts[n->tok].post || MDOC_ENDED & n->flags)
			break;
		(void)(*termacts[n->tok].post)(p, &npair, meta, n);

		/*
		 * Explicit end tokens not only call the post
		 * handler, but also tell the respective block
		 * that it must not call the post handler again.
		 */
		if (ENDBODY_NOT != n->end)
			n->body->flags |= MDOC_ENDED;

		/*
		 * End of line terminating an implicit block
		 * while an explicit block is still open.
		 * Continue the explicit block without spacing.
		 */
		if (ENDBODY_NOSPACE == n->end)
			p->flags |= TERMP_NOSPACE;
		break;
	}

	if (MDOC_EOS & n->flags)
		p->flags |= TERMP_SENTENCE;

	if (MDOC_ll != n->tok) {
		p->offset = offset;
		p->rmargin = rmargin;
	}
}

static void
print_mdoc_foot(struct termp *p, const struct roff_meta *meta)
{
	size_t sz;

	term_fontrepl(p, TERMFONT_NONE);

	/*
	 * Output the footer in new-groff style, that is, three columns
	 * with the middle being the manual date and flanking columns
	 * being the operating system:
	 *
	 * SYSTEM                  DATE                    SYSTEM
	 */

	term_vspace(p);

	p->offset = 0;
	sz = term_strlen(p, meta->date);
	p->rmargin = p->maxrmargin > sz ?
	    (p->maxrmargin + term_len(p, 1) - sz) / 2 : 0;
	p->trailspace = 1;
	p->flags |= TERMP_NOSPACE | TERMP_NOBREAK;

	term_word(p, meta->os);
	term_flushln(p);

	p->offset = p->rmargin;
	sz = term_strlen(p, meta->os);
	p->rmargin = p->maxrmargin > sz ? p->maxrmargin - sz : 0;
	p->flags |= TERMP_NOSPACE;

	term_word(p, meta->date);
	term_flushln(p);

	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
	p->trailspace = 0;
	p->flags &= ~TERMP_NOBREAK;
	p->flags |= TERMP_NOSPACE;

	term_word(p, meta->os);
	term_flushln(p);

	p->offset = 0;
	p->rmargin = p->maxrmargin;
	p->flags = 0;
}

static void
print_mdoc_head(struct termp *p, const struct roff_meta *meta)
{
	char			*volume, *title;
	size_t			 vollen, titlen;

	/*
	 * The header is strange.  It has three components, which are
	 * really two with the first duplicated.  It goes like this:
	 *
	 * IDENTIFIER              TITLE                   IDENTIFIER
	 *
	 * The IDENTIFIER is NAME(SECTION), which is the command-name
	 * (if given, or "unknown" if not) followed by the manual page
	 * section.  These are given in `Dt'.  The TITLE is a free-form
	 * string depending on the manual volume.  If not specified, it
	 * switches on the manual section.
	 */

	assert(meta->vol);
	if (NULL == meta->arch)
		volume = mandoc_strdup(meta->vol);
	else
		mandoc_asprintf(&volume, "%s (%s)",
		    meta->vol, meta->arch);
	vollen = term_strlen(p, volume);

	if (NULL == meta->msec)
		title = mandoc_strdup(meta->title);
	else
		mandoc_asprintf(&title, "%s(%s)",
		    meta->title, meta->msec);
	titlen = term_strlen(p, title);

	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;
	p->trailspace = 1;
	p->offset = 0;
	p->rmargin = 2 * (titlen+1) + vollen < p->maxrmargin ?
	    (p->maxrmargin - vollen + term_len(p, 1)) / 2 :
	    vollen < p->maxrmargin ?  p->maxrmargin - vollen : 0;

	term_word(p, title);
	term_flushln(p);

	p->flags |= TERMP_NOSPACE;
	p->offset = p->rmargin;
	p->rmargin = p->offset + vollen + titlen < p->maxrmargin ?
	    p->maxrmargin - titlen : p->maxrmargin;

	term_word(p, volume);
	term_flushln(p);

	p->flags &= ~TERMP_NOBREAK;
	p->trailspace = 0;
	if (p->rmargin + titlen <= p->maxrmargin) {
		p->flags |= TERMP_NOSPACE;
		p->offset = p->rmargin;
		p->rmargin = p->maxrmargin;
		term_word(p, title);
		term_flushln(p);
	}

	p->flags &= ~TERMP_NOSPACE;
	p->offset = 0;
	p->rmargin = p->maxrmargin;
	free(title);
	free(volume);
}

static int
a2width(const struct termp *p, const char *v)
{
	struct roffsu	 su;

	if (a2roffsu(v, &su, SCALE_MAX) < 2) {
		SCALE_HS_INIT(&su, term_strlen(p, v));
		su.scale /= term_strlen(p, "0");
	}
	return term_hspan(p, &su) / 24;
}

/*
 * Determine how much space to print out before block elements of `It'
 * (and thus `Bl') and `Bd'.  And then go ahead and print that space,
 * too.
 */
static void
print_bvspace(struct termp *p,
	const struct roff_node *bl,
	const struct roff_node *n)
{
	const struct roff_node	*nn;

	assert(n);

	term_newln(p);

	if (MDOC_Bd == bl->tok && bl->norm->Bd.comp)
		return;
	if (MDOC_Bl == bl->tok && bl->norm->Bl.comp)
		return;

	/* Do not vspace directly after Ss/Sh. */

	nn = n;
	while (nn->prev == NULL) {
		do {
			nn = nn->parent;
			if (nn->type == ROFFT_ROOT)
				return;
		} while (nn->type != ROFFT_BLOCK);
		if (nn->tok == MDOC_Sh || nn->tok == MDOC_Ss)
			return;
		if (nn->tok == MDOC_It &&
		    nn->parent->parent->norm->Bl.type != LIST_item)
			break;
	}

	/* A `-column' does not assert vspace within the list. */

	if (MDOC_Bl == bl->tok && LIST_column == bl->norm->Bl.type)
		if (n->prev && MDOC_It == n->prev->tok)
			return;

	/* A `-diag' without body does not vspace. */

	if (MDOC_Bl == bl->tok && LIST_diag == bl->norm->Bl.type)
		if (n->prev && MDOC_It == n->prev->tok) {
			assert(n->prev->body);
			if (NULL == n->prev->body->child)
				return;
		}

	term_vspace(p);
}


static int
termp_ll_pre(DECL_ARGS)
{

	term_setwidth(p, n->nchild ? n->child->string : NULL);
	return 0;
}

static int
termp_it_pre(DECL_ARGS)
{
	char			buf[24];
	const struct roff_node *bl, *nn;
	size_t			ncols, dcol;
	int			i, offset, width;
	enum mdoc_list		type;

	if (n->type == ROFFT_BLOCK) {
		print_bvspace(p, n->parent->parent, n);
		return 1;
	}

	bl = n->parent->parent->parent;
	type = bl->norm->Bl.type;

	/*
	 * Defaults for specific list types.
	 */

	switch (type) {
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
	case LIST_enum:
		width = term_len(p, 2);
		break;
	case LIST_hang:
		width = term_len(p, 8);
		break;
	case LIST_column:
	case LIST_tag:
		width = term_len(p, 10);
		break;
	default:
		width = 0;
		break;
	}
	offset = 0;

	/*
	 * First calculate width and offset.  This is pretty easy unless
	 * we're a -column list, in which case all prior columns must
	 * be accounted for.
	 */

	if (bl->norm->Bl.offs != NULL) {
		offset = a2width(p, bl->norm->Bl.offs);
		if (offset < 0 && (size_t)(-offset) > p->offset)
			offset = -p->offset;
		else if (offset > SHRT_MAX)
			offset = 0;
	}

	switch (type) {
	case LIST_column:
		if (n->type == ROFFT_HEAD)
			break;

		/*
		 * Imitate groff's column handling:
		 * - For each earlier column, add its width.
		 * - For less than 5 columns, add four more blanks per
		 *   column.
		 * - For exactly 5 columns, add three more blank per
		 *   column.
		 * - For more than 5 columns, add only one column.
		 */
		ncols = bl->norm->Bl.ncols;
		dcol = ncols < 5 ? term_len(p, 4) :
		    ncols == 5 ? term_len(p, 3) : term_len(p, 1);

		/*
		 * Calculate the offset by applying all prior ROFFT_BODY,
		 * so we stop at the ROFFT_HEAD (nn->prev == NULL).
		 */

		for (i = 0, nn = n->prev;
		    nn->prev && i < (int)ncols;
		    nn = nn->prev, i++)
			offset += dcol + a2width(p,
			    bl->norm->Bl.cols[i]);

		/*
		 * When exceeding the declared number of columns, leave
		 * the remaining widths at 0.  This will later be
		 * adjusted to the default width of 10, or, for the last
		 * column, stretched to the right margin.
		 */
		if (i >= (int)ncols)
			break;

		/*
		 * Use the declared column widths, extended as explained
		 * in the preceding paragraph.
		 */
		width = a2width(p, bl->norm->Bl.cols[i]) + dcol;
		break;
	default:
		if (NULL == bl->norm->Bl.width)
			break;

		/*
		 * Note: buffer the width by 2, which is groff's magic
		 * number for buffering single arguments.  See the above
		 * handling for column for how this changes.
		 */
		width = a2width(p, bl->norm->Bl.width) + term_len(p, 2);
		if (width < 0 && (size_t)(-width) > p->offset)
			width = -p->offset;
		else if (width > SHRT_MAX)
			width = 0;
		break;
	}

	/*
	 * Whitespace control.  Inset bodies need an initial space,
	 * while diagonal bodies need two.
	 */

	p->flags |= TERMP_NOSPACE;

	switch (type) {
	case LIST_diag:
		if (n->type == ROFFT_BODY)
			term_word(p, "\\ \\ ");
		break;
	case LIST_inset:
		if (n->type == ROFFT_BODY && n->parent->head->nchild)
			term_word(p, "\\ ");
		break;
	default:
		break;
	}

	p->flags |= TERMP_NOSPACE;

	switch (type) {
	case LIST_diag:
		if (n->type == ROFFT_HEAD)
			term_fontpush(p, TERMFONT_BOLD);
		break;
	default:
		break;
	}

	/*
	 * Pad and break control.  This is the tricky part.  These flags
	 * are documented in term_flushln() in term.c.  Note that we're
	 * going to unset all of these flags in termp_it_post() when we
	 * exit.
	 */

	switch (type) {
	case LIST_enum:
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
		/*
		 * Weird special case.
		 * Some very narrow lists actually hang.
		 */
		if (width <= (int)term_len(p, 2))
			p->flags |= TERMP_HANG;
		if (n->type != ROFFT_HEAD)
			break;
		p->flags |= TERMP_NOBREAK;
		p->trailspace = 1;
		break;
	case LIST_hang:
		if (n->type != ROFFT_HEAD)
			break;

		/*
		 * This is ugly.  If `-hang' is specified and the body
		 * is a `Bl' or `Bd', then we want basically to nullify
		 * the "overstep" effect in term_flushln() and treat
		 * this as a `-ohang' list instead.
		 */
		if (NULL != n->next &&
		    NULL != n->next->child &&
		    (MDOC_Bl == n->next->child->tok ||
		     MDOC_Bd == n->next->child->tok))
			break;

		p->flags |= TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG;
		p->trailspace = 1;
		break;
	case LIST_tag:
		if (n->type != ROFFT_HEAD)
			break;

		p->flags |= TERMP_NOBREAK | TERMP_BRTRSP | TERMP_BRIND;
		p->trailspace = 2;

		if (NULL == n->next || NULL == n->next->child)
			p->flags |= TERMP_DANGLE;
		break;
	case LIST_column:
		if (n->type == ROFFT_HEAD)
			break;

		if (NULL == n->next) {
			p->flags &= ~TERMP_NOBREAK;
			p->trailspace = 0;
		} else {
			p->flags |= TERMP_NOBREAK;
			p->trailspace = 1;
		}

		break;
	case LIST_diag:
		if (n->type != ROFFT_HEAD)
			break;
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
		p->trailspace = 1;
		break;
	default:
		break;
	}

	/*
	 * Margin control.  Set-head-width lists have their right
	 * margins shortened.  The body for these lists has the offset
	 * necessarily lengthened.  Everybody gets the offset.
	 */

	p->offset += offset;

	switch (type) {
	case LIST_hang:
		/*
		 * Same stipulation as above, regarding `-hang'.  We
		 * don't want to recalculate rmargin and offsets when
		 * using `Bd' or `Bl' within `-hang' overstep lists.
		 */
		if (n->type == ROFFT_HEAD &&
		    NULL != n->next &&
		    NULL != n->next->child &&
		    (MDOC_Bl == n->next->child->tok ||
		     MDOC_Bd == n->next->child->tok))
			break;
		/* FALLTHROUGH */
	case LIST_bullet:
	case LIST_dash:
	case LIST_enum:
	case LIST_hyphen:
	case LIST_tag:
		if (n->type == ROFFT_HEAD)
			p->rmargin = p->offset + width;
		else
			p->offset += width;
		break;
	case LIST_column:
		assert(width);
		p->rmargin = p->offset + width;
		/*
		 * XXX - this behaviour is not documented: the
		 * right-most column is filled to the right margin.
		 */
		if (n->type == ROFFT_HEAD)
			break;
		if (NULL == n->next && p->rmargin < p->maxrmargin)
			p->rmargin = p->maxrmargin;
		break;
	default:
		break;
	}

	/*
	 * The dash, hyphen, bullet and enum lists all have a special
	 * HEAD character (temporarily bold, in some cases).
	 */

	if (n->type == ROFFT_HEAD)
		switch (type) {
		case LIST_bullet:
			term_fontpush(p, TERMFONT_BOLD);
			term_word(p, "\\[bu]");
			term_fontpop(p);
			break;
		case LIST_dash:
		case LIST_hyphen:
			term_fontpush(p, TERMFONT_BOLD);
			term_word(p, "-");
			term_fontpop(p);
			break;
		case LIST_enum:
			(pair->ppair->ppair->count)++;
			(void)snprintf(buf, sizeof(buf), "%d.",
			    pair->ppair->ppair->count);
			term_word(p, buf);
			break;
		default:
			break;
		}

	/*
	 * If we're not going to process our children, indicate so here.
	 */

	switch (type) {
	case LIST_bullet:
	case LIST_item:
	case LIST_dash:
	case LIST_hyphen:
	case LIST_enum:
		if (n->type == ROFFT_HEAD)
			return 0;
		break;
	case LIST_column:
		if (n->type == ROFFT_HEAD)
			return 0;
		break;
	default:
		break;
	}

	return 1;
}

static void
termp_it_post(DECL_ARGS)
{
	enum mdoc_list	   type;

	if (n->type == ROFFT_BLOCK)
		return;

	type = n->parent->parent->parent->norm->Bl.type;

	switch (type) {
	case LIST_item:
	case LIST_diag:
	case LIST_inset:
		if (n->type == ROFFT_BODY)
			term_newln(p);
		break;
	case LIST_column:
		if (n->type == ROFFT_BODY)
			term_flushln(p);
		break;
	default:
		term_newln(p);
		break;
	}

	/*
	 * Now that our output is flushed, we can reset our tags.  Since
	 * only `It' sets these flags, we're free to assume that nobody
	 * has munged them in the meanwhile.
	 */

	p->flags &= ~(TERMP_NOBREAK | TERMP_BRTRSP | TERMP_BRIND |
			TERMP_DANGLE | TERMP_HANG);
	p->trailspace = 0;
}

static int
termp_nm_pre(DECL_ARGS)
{
	const char	*cp;

	if (n->type == ROFFT_BLOCK) {
		p->flags |= TERMP_PREKEEP;
		return 1;
	}

	if (n->type == ROFFT_BODY) {
		if (NULL == n->child)
			return 0;
		p->flags |= TERMP_NOSPACE;
		cp = NULL;
		if (n->prev->child != NULL)
		    cp = n->prev->child->string;
		if (cp == NULL)
			cp = meta->name;
		if (cp == NULL)
			p->offset += term_len(p, 6);
		else
			p->offset += term_len(p, 1) + term_strlen(p, cp);
		return 1;
	}

	if (NULL == n->child && NULL == meta->name)
		return 0;

	if (n->type == ROFFT_HEAD)
		synopsis_pre(p, n->parent);

	if (n->type == ROFFT_HEAD &&
	    NULL != n->next && NULL != n->next->child) {
		p->flags |= TERMP_NOSPACE | TERMP_NOBREAK | TERMP_BRIND;
		p->trailspace = 1;
		p->rmargin = p->offset + term_len(p, 1);
		if (NULL == n->child) {
			p->rmargin += term_strlen(p, meta->name);
		} else if (n->child->type == ROFFT_TEXT) {
			p->rmargin += term_strlen(p, n->child->string);
			if (n->child->next)
				p->flags |= TERMP_HANG;
		} else {
			p->rmargin += term_len(p, 5);
			p->flags |= TERMP_HANG;
		}
	}

	term_fontpush(p, TERMFONT_BOLD);
	if (NULL == n->child)
		term_word(p, meta->name);
	return 1;
}

static void
termp_nm_post(DECL_ARGS)
{

	if (n->type == ROFFT_BLOCK) {
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
	} else if (n->type == ROFFT_HEAD &&
	    NULL != n->next && NULL != n->next->child) {
		term_flushln(p);
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG);
		p->trailspace = 0;
	} else if (n->type == ROFFT_BODY && n->child != NULL)
		term_flushln(p);
}

static int
termp_fl_pre(DECL_ARGS)
{

	termp_tag_pre(p, pair, meta, n);
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, "\\-");

	if ( ! (n->nchild == 0 &&
	    (n->next == NULL ||
	     n->next->type == ROFFT_TEXT ||
	     n->next->flags & MDOC_LINE)))
		p->flags |= TERMP_NOSPACE;

	return 1;
}

static int
termp__a_pre(DECL_ARGS)
{

	if (n->prev && MDOC__A == n->prev->tok)
		if (NULL == n->next || MDOC__A != n->next->tok)
			term_word(p, "and");

	return 1;
}

static int
termp_an_pre(DECL_ARGS)
{

	if (n->norm->An.auth == AUTH_split) {
		p->flags &= ~TERMP_NOSPLIT;
		p->flags |= TERMP_SPLIT;
		return 0;
	}
	if (n->norm->An.auth == AUTH_nosplit) {
		p->flags &= ~TERMP_SPLIT;
		p->flags |= TERMP_NOSPLIT;
		return 0;
	}

	if (p->flags & TERMP_SPLIT)
		term_newln(p);

	if (n->sec == SEC_AUTHORS && ! (p->flags & TERMP_NOSPLIT))
		p->flags |= TERMP_SPLIT;

	return 1;
}

static int
termp_ns_pre(DECL_ARGS)
{

	if ( ! (MDOC_LINE & n->flags))
		p->flags |= TERMP_NOSPACE;
	return 1;
}

static int
termp_rs_pre(DECL_ARGS)
{

	if (SEC_SEE_ALSO != n->sec)
		return 1;
	if (n->type == ROFFT_BLOCK && n->prev != NULL)
		term_vspace(p);
	return 1;
}

static int
termp_rv_pre(DECL_ARGS)
{
	int		 nchild;

	term_newln(p);

	nchild = n->nchild;
	if (nchild > 0) {
		term_word(p, "The");

		for (n = n->child; n; n = n->next) {
			term_fontpush(p, TERMFONT_BOLD);
			term_word(p, n->string);
			term_fontpop(p);

			p->flags |= TERMP_NOSPACE;
			term_word(p, "()");

			if (n->next == NULL)
				continue;

			if (nchild > 2) {
				p->flags |= TERMP_NOSPACE;
				term_word(p, ",");
			}
			if (n->next->next == NULL)
				term_word(p, "and");
		}

		if (nchild > 1)
			term_word(p, "functions return");
		else
			term_word(p, "function returns");

		term_word(p, "the value\\~0 if successful;");
	} else
		term_word(p, "Upon successful completion,"
		    " the value\\~0 is returned;");

	term_word(p, "otherwise the value\\~\\-1 is returned"
	    " and the global variable");

	term_fontpush(p, TERMFONT_UNDER);
	term_word(p, "errno");
	term_fontpop(p);

	term_word(p, "is set to indicate the error.");
	p->flags |= TERMP_SENTENCE;

	return 0;
}

static int
termp_ex_pre(DECL_ARGS)
{
	int		 nchild;

	term_newln(p);
	term_word(p, "The");

	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
		term_fontpush(p, TERMFONT_BOLD);
		term_word(p, n->string);
		term_fontpop(p);

		if (nchild > 2 && n->next) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ",");
		}

		if (n->next && NULL == n->next->next)
			term_word(p, "and");
	}

	if (nchild > 1)
		term_word(p, "utilities exit\\~0");
	else
		term_word(p, "utility exits\\~0");

	term_word(p, "on success, and\\~>0 if an error occurs.");

	p->flags |= TERMP_SENTENCE;
	return 0;
}

static int
termp_nd_pre(DECL_ARGS)
{

	if (n->type == ROFFT_BODY)
		term_word(p, "\\(en");
	return 1;
}

static int
termp_bl_pre(DECL_ARGS)
{

	return n->type != ROFFT_HEAD;
}

static void
termp_bl_post(DECL_ARGS)
{

	if (n->type == ROFFT_BLOCK)
		term_newln(p);
}

static int
termp_xr_pre(DECL_ARGS)
{

	if (NULL == (n = n->child))
		return 0;

	assert(n->type == ROFFT_TEXT);
	term_word(p, n->string);

	if (NULL == (n = n->next))
		return 0;

	p->flags |= TERMP_NOSPACE;
	term_word(p, "(");
	p->flags |= TERMP_NOSPACE;

	assert(n->type == ROFFT_TEXT);
	term_word(p, n->string);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");

	return 0;
}

/*
 * This decides how to assert whitespace before any of the SYNOPSIS set
 * of macros (which, as in the case of Ft/Fo and Ft/Fn, may contain
 * macro combos).
 */
static void
synopsis_pre(struct termp *p, const struct roff_node *n)
{
	/*
	 * Obviously, if we're not in a SYNOPSIS or no prior macros
	 * exist, do nothing.
	 */
	if (NULL == n->prev || ! (MDOC_SYNPRETTY & n->flags))
		return;

	/*
	 * If we're the second in a pair of like elements, emit our
	 * newline and return.  UNLESS we're `Fo', `Fn', `Fn', in which
	 * case we soldier on.
	 */
	if (n->prev->tok == n->tok &&
	    MDOC_Ft != n->tok &&
	    MDOC_Fo != n->tok &&
	    MDOC_Fn != n->tok) {
		term_newln(p);
		return;
	}

	/*
	 * If we're one of the SYNOPSIS set and non-like pair-wise after
	 * another (or Fn/Fo, which we've let slip through) then assert
	 * vertical space, else only newline and move on.
	 */
	switch (n->prev->tok) {
	case MDOC_Fd:
	case MDOC_Fn:
	case MDOC_Fo:
	case MDOC_In:
	case MDOC_Vt:
		term_vspace(p);
		break;
	case MDOC_Ft:
		if (MDOC_Fn != n->tok && MDOC_Fo != n->tok) {
			term_vspace(p);
			break;
		}
		/* FALLTHROUGH */
	default:
		term_newln(p);
		break;
	}
}

static int
termp_vt_pre(DECL_ARGS)
{

	if (n->type == ROFFT_ELEM) {
		synopsis_pre(p, n);
		return termp_under_pre(p, pair, meta, n);
	} else if (n->type == ROFFT_BLOCK) {
		synopsis_pre(p, n);
		return 1;
	} else if (n->type == ROFFT_HEAD)
		return 0;

	return termp_under_pre(p, pair, meta, n);
}

static int
termp_bold_pre(DECL_ARGS)
{

	termp_tag_pre(p, pair, meta, n);
	term_fontpush(p, TERMFONT_BOLD);
	return 1;
}

static int
termp_fd_pre(DECL_ARGS)
{

	synopsis_pre(p, n);
	return termp_bold_pre(p, pair, meta, n);
}

static void
termp_fd_post(DECL_ARGS)
{

	term_newln(p);
}

static int
termp_sh_pre(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		/*
		 * Vertical space before sections, except
		 * when the previous section was empty.
		 */
		if (n->prev == NULL ||
		    n->prev->tok != MDOC_Sh ||
		    (n->prev->body != NULL &&
		     n->prev->body->child != NULL))
			term_vspace(p);
		break;
	case ROFFT_HEAD:
		term_fontpush(p, TERMFONT_BOLD);
		break;
	case ROFFT_BODY:
		p->offset = term_len(p, p->defindent);
		switch (n->sec) {
		case SEC_DESCRIPTION:
			fn_prio = 0;
			break;
		case SEC_AUTHORS:
			p->flags &= ~(TERMP_SPLIT|TERMP_NOSPLIT);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
	return 1;
}

static void
termp_sh_post(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_HEAD:
		term_newln(p);
		break;
	case ROFFT_BODY:
		term_newln(p);
		p->offset = 0;
		break;
	default:
		break;
	}
}

static int
termp_bt_pre(DECL_ARGS)
{

	term_word(p, "is currently in beta test.");
	p->flags |= TERMP_SENTENCE;
	return 0;
}

static void
termp_lb_post(DECL_ARGS)
{

	if (SEC_LIBRARY == n->sec && MDOC_LINE & n->flags)
		term_newln(p);
}

static int
termp_ud_pre(DECL_ARGS)
{

	term_word(p, "currently under development.");
	p->flags |= TERMP_SENTENCE;
	return 0;
}

static int
termp_d1_pre(DECL_ARGS)
{

	if (n->type != ROFFT_BLOCK)
		return 1;
	term_newln(p);
	p->offset += term_len(p, p->defindent + 1);
	return 1;
}

static int
termp_ft_pre(DECL_ARGS)
{

	/* NB: MDOC_LINE does not effect this! */
	synopsis_pre(p, n);
	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_fn_pre(DECL_ARGS)
{
	size_t		 rmargin = 0;
	int		 pretty;

	pretty = MDOC_SYNPRETTY & n->flags;

	synopsis_pre(p, n);

	if (NULL == (n = n->child))
		return 0;

	if (pretty) {
		rmargin = p->rmargin;
		p->rmargin = p->offset + term_len(p, 4);
		p->flags |= TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG;
	}

	assert(n->type == ROFFT_TEXT);
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, n->string);
	term_fontpop(p);

	if (n->sec == SEC_DESCRIPTION)
		tag_put(n->string, ++fn_prio, p->line);

	if (pretty) {
		term_flushln(p);
		p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND | TERMP_HANG);
		p->offset = p->rmargin;
		p->rmargin = rmargin;
	}

	p->flags |= TERMP_NOSPACE;
	term_word(p, "(");
	p->flags |= TERMP_NOSPACE;

	for (n = n->next; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
		term_fontpush(p, TERMFONT_UNDER);
		if (pretty)
			p->flags |= TERMP_NBRWORD;
		term_word(p, n->string);
		term_fontpop(p);

		if (n->next) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ",");
		}
	}

	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");

	if (pretty) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, ";");
		term_flushln(p);
	}

	return 0;
}

static int
termp_fa_pre(DECL_ARGS)
{
	const struct roff_node	*nn;

	if (n->parent->tok != MDOC_Fo) {
		term_fontpush(p, TERMFONT_UNDER);
		return 1;
	}

	for (nn = n->child; nn; nn = nn->next) {
		term_fontpush(p, TERMFONT_UNDER);
		p->flags |= TERMP_NBRWORD;
		term_word(p, nn->string);
		term_fontpop(p);

		if (nn->next || (n->next && n->next->tok == MDOC_Fa)) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ",");
		}
	}

	return 0;
}

static int
termp_bd_pre(DECL_ARGS)
{
	size_t			 tabwidth, lm, len, rm, rmax;
	struct roff_node	*nn;
	int			 offset;

	if (n->type == ROFFT_BLOCK) {
		print_bvspace(p, n, n);
		return 1;
	} else if (n->type == ROFFT_HEAD)
		return 0;

	/* Handle the -offset argument. */

	if (n->norm->Bd.offs == NULL ||
	    ! strcmp(n->norm->Bd.offs, "left"))
		/* nothing */;
	else if ( ! strcmp(n->norm->Bd.offs, "indent"))
		p->offset += term_len(p, p->defindent + 1);
	else if ( ! strcmp(n->norm->Bd.offs, "indent-two"))
		p->offset += term_len(p, (p->defindent + 1) * 2);
	else {
		offset = a2width(p, n->norm->Bd.offs);
		if (offset < 0 && (size_t)(-offset) > p->offset)
			p->offset = 0;
		else if (offset < SHRT_MAX)
			p->offset += offset;
	}

	/*
	 * If -ragged or -filled are specified, the block does nothing
	 * but change the indentation.  If -unfilled or -literal are
	 * specified, text is printed exactly as entered in the display:
	 * for macro lines, a newline is appended to the line.  Blank
	 * lines are allowed.
	 */

	if (DISP_literal != n->norm->Bd.type &&
	    DISP_unfilled != n->norm->Bd.type &&
	    DISP_centered != n->norm->Bd.type)
		return 1;

	tabwidth = p->tabwidth;
	if (DISP_literal == n->norm->Bd.type)
		p->tabwidth = term_len(p, 8);

	lm = p->offset;
	rm = p->rmargin;
	rmax = p->maxrmargin;
	p->rmargin = p->maxrmargin = TERM_MAXMARGIN;

	for (nn = n->child; nn; nn = nn->next) {
		if (DISP_centered == n->norm->Bd.type) {
			if (nn->type == ROFFT_TEXT) {
				len = term_strlen(p, nn->string);
				p->offset = len >= rm ? 0 :
				    lm + len >= rm ? rm - len :
				    (lm + rm - len) / 2;
			} else
				p->offset = lm;
		}
		print_mdoc_node(p, pair, meta, nn);
		/*
		 * If the printed node flushes its own line, then we
		 * needn't do it here as well.  This is hacky, but the
		 * notion of selective eoln whitespace is pretty dumb
		 * anyway, so don't sweat it.
		 */
		switch (nn->tok) {
		case MDOC_Sm:
		case MDOC_br:
		case MDOC_sp:
		case MDOC_Bl:
		case MDOC_D1:
		case MDOC_Dl:
		case MDOC_Lp:
		case MDOC_Pp:
			continue;
		default:
			break;
		}
		if (p->flags & TERMP_NONEWLINE ||
		    (nn->next && ! (nn->next->flags & MDOC_LINE)))
			continue;
		term_flushln(p);
		p->flags |= TERMP_NOSPACE;
	}

	p->tabwidth = tabwidth;
	p->rmargin = rm;
	p->maxrmargin = rmax;
	return 0;
}

static void
termp_bd_post(DECL_ARGS)
{
	size_t		 rm, rmax;

	if (n->type != ROFFT_BODY)
		return;

	rm = p->rmargin;
	rmax = p->maxrmargin;

	if (DISP_literal == n->norm->Bd.type ||
	    DISP_unfilled == n->norm->Bd.type)
		p->rmargin = p->maxrmargin = TERM_MAXMARGIN;

	p->flags |= TERMP_NOSPACE;
	term_newln(p);

	p->rmargin = rm;
	p->maxrmargin = rmax;
}

static int
termp_bx_pre(DECL_ARGS)
{

	if (NULL != (n = n->child)) {
		term_word(p, n->string);
		p->flags |= TERMP_NOSPACE;
		term_word(p, "BSD");
	} else {
		term_word(p, "BSD");
		return 0;
	}

	if (NULL != (n = n->next)) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, "-");
		p->flags |= TERMP_NOSPACE;
		term_word(p, n->string);
	}

	return 0;
}

static int
termp_xx_pre(DECL_ARGS)
{
	const char	*pp;
	int		 flags;

	pp = NULL;
	switch (n->tok) {
	case MDOC_Bsx:
		pp = "BSD/OS";
		break;
	case MDOC_Dx:
		pp = "DragonFly";
		break;
	case MDOC_Fx:
		pp = "FreeBSD";
		break;
	case MDOC_Nx:
		pp = "NetBSD";
		break;
	case MDOC_Ox:
		pp = "OpenBSD";
		break;
	case MDOC_Ux:
		pp = "UNIX";
		break;
	default:
		abort();
	}

	term_word(p, pp);
	if (n->child) {
		flags = p->flags;
		p->flags |= TERMP_KEEP;
		term_word(p, n->child->string);
		p->flags = flags;
	}
	return 0;
}

static void
termp_pf_post(DECL_ARGS)
{

	if ( ! (n->next == NULL || n->next->flags & MDOC_LINE))
		p->flags |= TERMP_NOSPACE;
}

static int
termp_ss_pre(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		term_newln(p);
		if (n->prev)
			term_vspace(p);
		break;
	case ROFFT_HEAD:
		term_fontpush(p, TERMFONT_BOLD);
		p->offset = term_len(p, (p->defindent+1)/2);
		break;
	case ROFFT_BODY:
		p->offset = term_len(p, p->defindent);
		break;
	default:
		break;
	}

	return 1;
}

static void
termp_ss_post(DECL_ARGS)
{

	if (n->type == ROFFT_HEAD || n->type == ROFFT_BODY)
		term_newln(p);
}

static int
termp_cd_pre(DECL_ARGS)
{

	synopsis_pre(p, n);
	term_fontpush(p, TERMFONT_BOLD);
	return 1;
}

static int
termp_in_pre(DECL_ARGS)
{

	synopsis_pre(p, n);

	if (MDOC_SYNPRETTY & n->flags && MDOC_LINE & n->flags) {
		term_fontpush(p, TERMFONT_BOLD);
		term_word(p, "#include");
		term_word(p, "<");
	} else {
		term_word(p, "<");
		term_fontpush(p, TERMFONT_UNDER);
	}

	p->flags |= TERMP_NOSPACE;
	return 1;
}

static void
termp_in_post(DECL_ARGS)
{

	if (MDOC_SYNPRETTY & n->flags)
		term_fontpush(p, TERMFONT_BOLD);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ">");

	if (MDOC_SYNPRETTY & n->flags)
		term_fontpop(p);
}

static int
termp_sp_pre(DECL_ARGS)
{
	struct roffsu	 su;
	int		 i, len;

	switch (n->tok) {
	case MDOC_sp:
		if (n->child) {
			if ( ! a2roffsu(n->child->string, &su, SCALE_VS))
				su.scale = 1.0;
			len = term_vspan(p, &su);
		} else
			len = 1;
		break;
	case MDOC_br:
		len = 0;
		break;
	default:
		len = 1;
		fn_prio = 0;
		break;
	}

	if (0 == len)
		term_newln(p);
	else if (len < 0)
		p->skipvsp -= len;
	else
		for (i = 0; i < len; i++)
			term_vspace(p);

	return 0;
}

static int
termp_skip_pre(DECL_ARGS)
{

	return 0;
}

static int
termp_quote_pre(DECL_ARGS)
{

	if (n->type != ROFFT_BODY && n->type != ROFFT_ELEM)
		return 1;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		term_word(p, n->nchild == 1 &&
		    n->child->tok == MDOC_Mt ? "<" : "\\(la");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		term_word(p, "{");
		break;
	case MDOC_Oo:
	case MDOC_Op:
	case MDOC_Bo:
	case MDOC_Bq:
		term_word(p, "[");
		break;
	case MDOC_Do:
	case MDOC_Dq:
		term_word(p, "\\(Lq");
		break;
	case MDOC_En:
		if (NULL == n->norm->Es ||
		    NULL == n->norm->Es->child)
			return 1;
		term_word(p, n->norm->Es->child->string);
		break;
	case MDOC_Po:
	case MDOC_Pq:
		term_word(p, "(");
		break;
	case MDOC__T:
	case MDOC_Qo:
	case MDOC_Qq:
		term_word(p, "\"");
		break;
	case MDOC_Ql:
	case MDOC_So:
	case MDOC_Sq:
		term_word(p, "\\(oq");
		break;
	default:
		abort();
	}

	p->flags |= TERMP_NOSPACE;
	return 1;
}

static void
termp_quote_post(DECL_ARGS)
{

	if (n->type != ROFFT_BODY && n->type != ROFFT_ELEM)
		return;

	p->flags |= TERMP_NOSPACE;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		term_word(p, n->nchild == 1 &&
		    n->child->tok == MDOC_Mt ? ">" : "\\(ra");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		term_word(p, "}");
		break;
	case MDOC_Oo:
	case MDOC_Op:
	case MDOC_Bo:
	case MDOC_Bq:
		term_word(p, "]");
		break;
	case MDOC_Do:
	case MDOC_Dq:
		term_word(p, "\\(Rq");
		break;
	case MDOC_En:
		if (n->norm->Es == NULL ||
		    n->norm->Es->child == NULL ||
		    n->norm->Es->child->next == NULL)
			p->flags &= ~TERMP_NOSPACE;
		else
			term_word(p, n->norm->Es->child->next->string);
		break;
	case MDOC_Po:
	case MDOC_Pq:
		term_word(p, ")");
		break;
	case MDOC__T:
	case MDOC_Qo:
	case MDOC_Qq:
		term_word(p, "\"");
		break;
	case MDOC_Ql:
	case MDOC_So:
	case MDOC_Sq:
		term_word(p, "\\(cq");
		break;
	default:
		abort();
	}
}

static int
termp_eo_pre(DECL_ARGS)
{

	if (n->type != ROFFT_BODY)
		return 1;

	if (n->end == ENDBODY_NOT &&
	    n->parent->head->child == NULL &&
	    n->child != NULL &&
	    n->child->end != ENDBODY_NOT)
		term_word(p, "\\&");
	else if (n->end != ENDBODY_NOT ? n->child != NULL :
	     n->parent->head->child != NULL && (n->child != NULL ||
	     (n->parent->tail != NULL && n->parent->tail->child != NULL)))
		p->flags |= TERMP_NOSPACE;

	return 1;
}

static void
termp_eo_post(DECL_ARGS)
{
	int	 body, tail;

	if (n->type != ROFFT_BODY)
		return;

	if (n->end != ENDBODY_NOT) {
		p->flags &= ~TERMP_NOSPACE;
		return;
	}

	body = n->child != NULL || n->parent->head->child != NULL;
	tail = n->parent->tail != NULL && n->parent->tail->child != NULL;

	if (body && tail)
		p->flags |= TERMP_NOSPACE;
	else if ( ! (body || tail))
		term_word(p, "\\&");
	else if ( ! tail)
		p->flags &= ~TERMP_NOSPACE;
}

static int
termp_fo_pre(DECL_ARGS)
{
	size_t		 rmargin = 0;
	int		 pretty;

	pretty = MDOC_SYNPRETTY & n->flags;

	if (n->type == ROFFT_BLOCK) {
		synopsis_pre(p, n);
		return 1;
	} else if (n->type == ROFFT_BODY) {
		if (pretty) {
			rmargin = p->rmargin;
			p->rmargin = p->offset + term_len(p, 4);
			p->flags |= TERMP_NOBREAK | TERMP_BRIND |
					TERMP_HANG;
		}
		p->flags |= TERMP_NOSPACE;
		term_word(p, "(");
		p->flags |= TERMP_NOSPACE;
		if (pretty) {
			term_flushln(p);
			p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND |
					TERMP_HANG);
			p->offset = p->rmargin;
			p->rmargin = rmargin;
		}
		return 1;
	}

	if (NULL == n->child)
		return 0;

	/* XXX: we drop non-initial arguments as per groff. */

	assert(n->child->string);
	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, n->child->string);
	return 0;
}

static void
termp_fo_post(DECL_ARGS)
{

	if (n->type != ROFFT_BODY)
		return;

	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");

	if (MDOC_SYNPRETTY & n->flags) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, ";");
		term_flushln(p);
	}
}

static int
termp_bf_pre(DECL_ARGS)
{

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type != ROFFT_BODY)
		return 1;

	if (FONT_Em == n->norm->Bf.font)
		term_fontpush(p, TERMFONT_UNDER);
	else if (FONT_Sy == n->norm->Bf.font)
		term_fontpush(p, TERMFONT_BOLD);
	else
		term_fontpush(p, TERMFONT_NONE);

	return 1;
}

static int
termp_sm_pre(DECL_ARGS)
{

	if (NULL == n->child)
		p->flags ^= TERMP_NONOSPACE;
	else if (0 == strcmp("on", n->child->string))
		p->flags &= ~TERMP_NONOSPACE;
	else
		p->flags |= TERMP_NONOSPACE;

	if (p->col && ! (TERMP_NONOSPACE & p->flags))
		p->flags &= ~TERMP_NOSPACE;

	return 0;
}

static int
termp_ap_pre(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, "'");
	p->flags |= TERMP_NOSPACE;
	return 1;
}

static void
termp____post(DECL_ARGS)
{

	/*
	 * Handle lists of authors.  In general, print each followed by
	 * a comma.  Don't print the comma if there are only two
	 * authors.
	 */
	if (MDOC__A == n->tok && n->next && MDOC__A == n->next->tok)
		if (NULL == n->next->next || MDOC__A != n->next->next->tok)
			if (NULL == n->prev || MDOC__A != n->prev->tok)
				return;

	/* TODO: %U. */

	if (NULL == n->parent || MDOC_Rs != n->parent->tok)
		return;

	p->flags |= TERMP_NOSPACE;
	if (NULL == n->next) {
		term_word(p, ".");
		p->flags |= TERMP_SENTENCE;
	} else
		term_word(p, ",");
}

static int
termp_li_pre(DECL_ARGS)
{

	term_fontpush(p, TERMFONT_NONE);
	return 1;
}

static int
termp_lk_pre(DECL_ARGS)
{
	const struct roff_node *link, *descr;

	if (NULL == (link = n->child))
		return 0;

	if (NULL != (descr = link->next)) {
		term_fontpush(p, TERMFONT_UNDER);
		while (NULL != descr) {
			term_word(p, descr->string);
			descr = descr->next;
		}
		p->flags |= TERMP_NOSPACE;
		term_word(p, ":");
		term_fontpop(p);
	}

	term_fontpush(p, TERMFONT_BOLD);
	term_word(p, link->string);
	term_fontpop(p);

	return 0;
}

static int
termp_bk_pre(DECL_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		break;
	case ROFFT_HEAD:
		return 0;
	case ROFFT_BODY:
		if (n->parent->args || 0 == n->prev->nchild)
			p->flags |= TERMP_PREKEEP;
		break;
	default:
		abort();
	}

	return 1;
}

static void
termp_bk_post(DECL_ARGS)
{

	if (n->type == ROFFT_BODY)
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
}

static void
termp__t_post(DECL_ARGS)
{

	/*
	 * If we're in an `Rs' and there's a journal present, then quote
	 * us instead of underlining us (for disambiguation).
	 */
	if (n->parent && MDOC_Rs == n->parent->tok &&
	    n->parent->norm->Rs.quote_T)
		termp_quote_post(p, pair, meta, n);

	termp____post(p, pair, meta, n);
}

static int
termp__t_pre(DECL_ARGS)
{

	/*
	 * If we're in an `Rs' and there's a journal present, then quote
	 * us instead of underlining us (for disambiguation).
	 */
	if (n->parent && MDOC_Rs == n->parent->tok &&
	    n->parent->norm->Rs.quote_T)
		return termp_quote_pre(p, pair, meta, n);

	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_under_pre(DECL_ARGS)
{

	term_fontpush(p, TERMFONT_UNDER);
	return 1;
}

static int
termp_er_pre(DECL_ARGS)
{

	if (n->sec == SEC_ERRORS &&
	    (n->parent->tok == MDOC_It ||
	     (n->parent->tok == MDOC_Bq &&
	      n->parent->parent->parent->tok == MDOC_It)))
		tag_put(n->child->string, 1, p->line);
	return 1;
}

static int
termp_tag_pre(DECL_ARGS)
{

	if (n->child != NULL &&
	    n->child->type == ROFFT_TEXT &&
	    n->prev == NULL &&
	    (n->parent->tok == MDOC_It ||
	     (n->parent->tok == MDOC_Xo &&
	      n->parent->parent->prev == NULL &&
	      n->parent->parent->parent->tok == MDOC_It)))
		tag_put(n->child->string, 1, p->line);
	return 1;
}
@


1.329
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.328 2015/10/06 18:32:19 schwarze Exp $ */
d890 1
a890 1
			term_word(p, "\\(hy");
@


1.328
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.327 2015/09/26 00:54:04 schwarze Exp $ */
a627 1
		/* FALLTHROUGH */
a628 1
		/* FALLTHROUGH */
a629 1
		/* FALLTHROUGH */
a636 1
		/* FALLTHROUGH */
d761 3
a767 6
		/* FALLTHROUGH */
	case LIST_bullet:
		/* FALLTHROUGH */
	case LIST_dash:
		/* FALLTHROUGH */
	case LIST_hyphen:
a849 1
		/* FALLTHROUGH */
a850 1
		/* FALLTHROUGH */
a851 1
		/* FALLTHROUGH */
a852 1
		/* FALLTHROUGH */
a887 1
			/* FALLTHROUGH */
a908 1
		/* FALLTHROUGH */
a909 1
		/* FALLTHROUGH */
a910 1
		/* FALLTHROUGH */
a911 1
		/* FALLTHROUGH */
a938 1
		/* FALLTHROUGH */
a939 1
		/* FALLTHROUGH */
a1277 1
		/* FALLTHROUGH */
a1278 1
		/* FALLTHROUGH */
a1279 1
		/* FALLTHROUGH */
a1280 1
		/* FALLTHROUGH */
a1597 1
			/* FALLTHROUGH */
a1598 1
			/* FALLTHROUGH */
a1599 1
			/* FALLTHROUGH */
a1600 1
			/* FALLTHROUGH */
a1601 1
			/* FALLTHROUGH */
a1602 1
			/* FALLTHROUGH */
a1603 1
			/* FALLTHROUGH */
a1839 1
		/* FALLTHROUGH */
a1844 1
		/* FALLTHROUGH */
a1848 1
		/* FALLTHROUGH */
a1849 1
		/* FALLTHROUGH */
a1850 1
		/* FALLTHROUGH */
a1854 1
		/* FALLTHROUGH */
a1864 1
		/* FALLTHROUGH */
a1868 1
		/* FALLTHROUGH */
a1869 1
		/* FALLTHROUGH */
a1873 1
		/* FALLTHROUGH */
a1874 1
		/* FALLTHROUGH */
a1896 1
		/* FALLTHROUGH */
a1901 1
		/* FALLTHROUGH */
a1905 1
		/* FALLTHROUGH */
a1906 1
		/* FALLTHROUGH */
a1907 1
		/* FALLTHROUGH */
a1911 1
		/* FALLTHROUGH */
a1923 1
		/* FALLTHROUGH */
a1927 1
		/* FALLTHROUGH */
a1928 1
		/* FALLTHROUGH */
a1932 1
		/* FALLTHROUGH */
a1933 1
		/* FALLTHROUGH */
@


1.327
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.326 2015/09/21 13:25:00 schwarze Exp $ */
d538 1
a538 1
	return(term_hspan(p, &su) / 24);
d602 1
a602 1
	return(0);
d616 1
a616 1
		return(1);
d930 1
a930 1
			return(0);
d934 1
a934 1
			return(0);
d940 1
a940 1
	return(1);
d989 1
a989 1
		return(1);
d994 1
a994 1
			return(0);
d1005 1
a1005 1
		return(1);
d1009 1
a1009 1
		return(0);
d1034 1
a1034 1
	return(1);
d1066 1
a1066 1
	return(1);
d1077 1
a1077 1
	return(1);
d1087 1
a1087 1
		return(0);
d1092 1
a1092 1
		return(0);
d1101 1
a1101 1
	return(1);
d1110 1
a1110 1
	return(1);
d1118 1
a1118 1
		return(1);
d1121 1
a1121 1
	return(1);
d1174 1
a1174 1
	return(0);
d1208 1
a1208 1
	return(0);
d1217 1
a1217 1
	return(1);
d1224 1
a1224 1
	return(n->type != ROFFT_HEAD);
d1240 1
a1240 1
		return(0);
d1246 1
a1246 1
		return(0);
d1258 1
a1258 1
	return(0);
d1324 1
a1324 1
		return(termp_under_pre(p, pair, meta, n));
d1327 1
a1327 1
		return(1);
d1329 1
a1329 1
		return(0);
d1331 1
a1331 1
	return(termp_under_pre(p, pair, meta, n));
d1340 1
a1340 1
	return(1);
d1348 1
a1348 1
	return(termp_bold_pre(p, pair, meta, n));
d1393 1
a1393 1
	return(1);
d1419 1
a1419 1
	return(0);
d1436 1
a1436 1
	return(0);
d1444 1
a1444 1
		return(1);
d1447 1
a1447 1
	return(1);
d1457 1
a1457 1
	return(1);
d1471 1
a1471 1
		return(0);
d1521 1
a1521 1
	return(0);
d1531 1
a1531 1
		return(1);
d1546 1
a1546 1
	return(0);
d1558 1
a1558 1
		return(1);
d1560 1
a1560 1
		return(0);
d1590 1
a1590 1
		return(1);
d1648 1
a1648 1
	return(0);
d1683 1
a1683 1
		return(0);
d1693 1
a1693 1
	return(0);
d1733 1
a1733 1
	return(0);
d1765 1
a1765 1
	return(1);
d1782 1
a1782 1
	return(1);
d1801 1
a1801 1
	return(1);
d1850 1
a1850 1
	return(0);
d1857 1
a1857 1
	return(0);
d1865 1
a1865 1
		return(1);
d1896 1
a1896 1
			return(1);
d1923 1
a1923 1
	return(1);
d1998 1
a1998 1
		return(1);
d2010 1
a2010 1
	return(1);
d2047 1
a2047 1
		return(1);
d2065 1
a2065 1
		return(1);
d2069 1
a2069 1
		return(0);
d2076 1
a2076 1
	return(0);
d2101 1
a2101 1
		return(0);
d2103 1
a2103 1
		return(1);
d2112 1
a2112 1
	return(1);
d2129 1
a2129 1
	return(0);
d2139 1
a2139 1
	return(1);
d2174 1
a2174 1
	return(1);
d2183 1
a2183 1
		return(0);
d2200 1
a2200 1
	return(0);
d2211 1
a2211 1
		return(0);
d2220 1
a2220 1
	return(1);
d2256 1
a2256 1
		return(termp_quote_pre(p, pair, meta, n));
d2259 1
a2259 1
	return(1);
d2267 1
a2267 1
	return(1);
d2279 1
a2279 1
	return(1);
d2294 1
a2294 1
	return(1);
@


1.326
log
@Trailing whitespace is significant when determining the width of a tag
in mdoc(7) .Bl -tag and man(7) .TP, but not in man(7) .IP.
Quirk reported by Jan Stary <hans at stare dot cz> on ports@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.325 2015/09/14 12:57:47 schwarze Exp $ */
a1723 1
		/* NOTREACHED */
a1919 1
		/* NOTREACHED */
a1989 1
		/* NOTREACHED */
a2217 1
		/* NOTREACHED */
@


1.325
log
@The .Dv macro actually forces normal font.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.324 2015/07/25 14:28:59 schwarze Exp $ */
d805 1
a805 1
		p->flags |= TERMP_NOBREAK | TERMP_BRIND;
d977 1
a977 1
	p->flags &= ~(TERMP_NOBREAK | TERMP_BRIND |
@


1.324
log
@Simplify and make tag_put() more efficient by integrating tag_get()
into it and by only handling NUL-terminated strings.
Minus 25 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.323 2015/07/25 14:23:08 schwarze Exp $ */
d149 1
a149 1
	{ NULL, NULL }, /* Dv */
@


1.323
log
@implement tagging for .Er
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.322 2015/07/25 14:18:04 schwarze Exp $ */
d1484 2
a1485 4
	if (n->sec == SEC_DESCRIPTION) {
		if ( ! tag_get(n->string, 0, ++fn_prio))
			tag_put(n->string, 0, fn_prio, p->line);
	}
d2281 2
a2282 3
	      n->parent->parent->parent->tok == MDOC_It)) &&
	    ! tag_get(n->child->string, 0, 1))
		tag_put(n->child->string, 0, 1, p->line);
d2296 2
a2297 3
	      n->parent->parent->parent->tok == MDOC_It)) &&
	    ! tag_get(n->child->string, 0, 1))
		tag_put(n->child->string, 0, 1, p->line);
@


1.322
log
@basic tag support for function names; written at YYC
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.321 2015/07/25 14:02:06 schwarze Exp $ */
d98 1
d150 1
a150 1
	{ NULL, NULL }, /* Er */
d2277 13
@


1.321
log
@basic support for tag priorities; written at YYC
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.320 2015/07/17 22:38:29 schwarze Exp $ */
d254 1
d1368 1
a1368 1
		    MDOC_Sh != n->prev->tok ||
d1378 5
a1382 1
		if (SEC_AUTHORS == n->sec)
d1384 4
d1483 5
d1840 1
@


1.320
log
@Initial, still somewhat experimental implementation to leverage
less(1) -T and :t ctags(1)-like functionality to jump to the
definitions of various terms inside manual pages.
To be polished in the tree, so bear with me and report issues.

Technically, if less(1) is used as a pager, information is collected
by the mdoc(7) terminal formatter, first stored using the ohash
library, then ultimately written to a temporary file which is passed
to less via -T.  No change intended for other output formatters or
when running without a pager.

Based on an idea from Kristaps using feedback from many, in particular
phessler@@ nicm@@ millert@@ halex@@ doug@@ kspillner@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.319 2015/04/18 17:53:21 schwarze Exp $ */
d2271 2
a2272 2
	    ! tag_get(n->child->string, 0))
		tag_put(n->child->string, 0, p->line);
@


1.319
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.318 2015/04/18 16:06:41 schwarze Exp $ */
d37 1
d121 1
d150 1
a150 1
	{ NULL, NULL }, /* Ev */
d1054 1
d1336 1
d2259 16
@


1.318
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.317 2015/04/04 17:47:18 schwarze Exp $ */
a255 1
	const struct roff_meta	*meta;
a259 1

d264 1
a264 3
	n = mdoc_node(mdoc)->child;
	meta = mdoc_meta(mdoc);

d270 2
a271 1
					    meta, n->child->next->child);
d280 2
a281 1
		term_begin(p, print_mdoc_head, print_mdoc_foot, meta);
d285 1
a285 1
			print_mdoc_nodelist(p, NULL, meta, n);
@


1.317
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.316 2015/04/02 23:48:20 schwarze Exp $ */
d254 1
a254 1
terminal_mdoc(void *arg, const struct mdoc *mdoc)
@


1.316
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.315 2015/04/02 22:48:17 schwarze Exp $ */
d536 1
a536 1
	return(term_hspan(p, &su));
@


1.315
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.314 2015/04/02 21:36:50 schwarze Exp $ */
d46 1
a46 1
		  const struct mdoc_meta *meta, \
d61 2
a62 2
static	void	  print_mdoc_head(struct termp *, const void *);
static	void	  print_mdoc_foot(struct termp *, const void *);
d256 1
a256 1
	const struct mdoc_meta	*meta;
d410 1
a410 1
print_mdoc_foot(struct termp *p, const void *arg)
a411 1
	const struct mdoc_meta *meta;
a413 2
	meta = (const struct mdoc_meta *)arg;

d459 1
a459 1
print_mdoc_head(struct termp *p, const void *arg)
a460 1
	const struct mdoc_meta	*meta;
a463 2
	meta = (const struct mdoc_meta *)arg;

@


1.314
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.313 2015/03/06 15:48:52 schwarze Exp $ */
d47 1
a47 1
		  struct mdoc_node *n
d57 2
a58 2
			const struct mdoc_node *,
			const struct mdoc_node *);
d64 1
a64 1
			const struct mdoc_node *);
d257 1
a257 1
	struct mdoc_node	*n;
d552 2
a553 2
	const struct mdoc_node *bl,
	const struct mdoc_node *n)
d555 1
a555 1
	const struct mdoc_node	*nn;
d613 1
a613 1
	const struct mdoc_node *bl, *nn;
d1270 1
a1270 1
synopsis_pre(struct termp *p, const struct mdoc_node *n)
d1518 1
a1518 1
	const struct mdoc_node	*nn;
d1544 1
a1544 1
	struct mdoc_node	*nn;
d2173 1
a2173 1
	const struct mdoc_node *link, *descr;
@


1.313
log
@Fix vertical spacing at the beginning of tables.
man(7) always prints a blank line, mdoc(7) doesn't.
Problem in mdoc(7) reported by kristaps@@.
mdoc(7) part of the patch tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.312 2015/03/06 13:09:07 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d31 1
d33 2
a34 1
#include "mandoc_aux.h"
a36 1
#include "mdoc.h"
d335 1
a335 1
	case MDOC_TEXT:
d344 1
a344 1
	case MDOC_EQN:
d351 1
a351 1
	case MDOC_TBL:
d371 1
a371 1
	case MDOC_TEXT:
d373 1
a373 1
	case MDOC_TBL:
d375 1
a375 1
	case MDOC_EQN:
d572 1
a572 1
			if (nn->type == MDOC_ROOT)
d574 1
a574 1
		} while (nn->type != MDOC_BLOCK);
d618 1
a618 1
	if (MDOC_BLOCK == n->type) {
d670 1
a670 1
		if (MDOC_HEAD == n->type)
d687 2
a688 2
		 * Calculate the offset by applying all prior MDOC_BODY,
		 * so we stop at the MDOC_HEAD (NULL == nn->prev).
d738 1
a738 1
		if (MDOC_BODY == n->type)
d742 1
a742 1
		if (MDOC_BODY == n->type && n->parent->head->nchild)
d753 1
a753 1
		if (MDOC_HEAD == n->type)
d781 1
a781 1
		if (MDOC_HEAD != n->type)
d787 1
a787 1
		if (MDOC_HEAD != n->type)
d806 1
a806 1
		if (MDOC_HEAD != n->type)
d816 1
a816 1
		if (MDOC_HEAD == n->type)
d829 1
a829 1
		if (MDOC_HEAD != n->type)
d853 1
a853 1
		if (MDOC_HEAD == n->type &&
d869 1
a869 1
		if (MDOC_HEAD == n->type)
d881 1
a881 1
		if (MDOC_HEAD == n->type)
d895 1
a895 1
	if (MDOC_HEAD == n->type)
d933 1
a933 1
		if (MDOC_HEAD == n->type)
d937 1
a937 1
		if (MDOC_HEAD == n->type)
d952 1
a952 1
	if (MDOC_BLOCK == n->type)
d963 1
a963 1
		if (MDOC_BODY == n->type)
d967 1
a967 1
		if (MDOC_BODY == n->type)
d991 1
a991 1
	if (MDOC_BLOCK == n->type) {
d996 1
a996 1
	if (MDOC_BODY == n->type) {
d1015 1
a1015 1
	if (MDOC_HEAD == n->type)
d1018 1
a1018 1
	if (MDOC_HEAD == n->type &&
d1025 1
a1025 1
		} else if (MDOC_TEXT == n->child->type) {
d1045 1
a1045 1
	if (MDOC_BLOCK == n->type) {
d1047 1
a1047 1
	} else if (MDOC_HEAD == n->type &&
d1052 1
a1052 1
	} else if (MDOC_BODY == n->type && n->child)
d1065 1
a1065 1
	     n->next->type == MDOC_TEXT ||
d1122 1
a1122 1
	if (MDOC_BLOCK == n->type && n->prev)
d1218 1
a1218 1
	if (n->type == MDOC_BODY)
d1227 1
a1227 1
	return(MDOC_HEAD != n->type);
d1234 1
a1234 1
	if (MDOC_BLOCK == n->type)
d1245 1
a1245 1
	assert(MDOC_TEXT == n->type);
d1255 1
a1255 1
	assert(MDOC_TEXT == n->type);
d1325 1
a1325 1
	if (MDOC_ELEM == n->type) {
d1328 1
a1328 1
	} else if (MDOC_BLOCK == n->type) {
d1331 1
a1331 1
	} else if (MDOC_HEAD == n->type)
d1365 1
a1365 1
	case MDOC_BLOCK:
d1376 1
a1376 1
	case MDOC_HEAD:
d1379 1
a1379 1
	case MDOC_BODY:
d1395 1
a1395 1
	case MDOC_HEAD:
d1398 1
a1398 1
	case MDOC_BODY:
d1437 1
a1437 1
	if (MDOC_BLOCK != n->type)
d1473 1
a1473 1
	assert(MDOC_TEXT == n->type);
d1490 1
a1490 1
		assert(MDOC_TEXT == n->type);
d1547 1
a1547 1
	if (MDOC_BLOCK == n->type) {
d1550 1
a1550 1
	} else if (MDOC_HEAD == n->type)
d1594 1
a1594 1
			if (MDOC_TEXT == nn->type) {
d1647 1
a1647 1
	if (MDOC_BODY != n->type)
d1741 1
a1741 1
	case MDOC_BLOCK:
d1746 1
a1746 1
	case MDOC_HEAD:
d1750 1
a1750 1
	case MDOC_BODY:
d1764 1
a1764 1
	if (n->type == MDOC_HEAD || n->type == MDOC_BODY)
d1855 1
a1855 1
	if (MDOC_BODY != n->type && MDOC_ELEM != n->type)
d1922 1
a1922 1
	if (n->type != MDOC_BODY && n->type != MDOC_ELEM)
d1990 1
a1990 1
	if (n->type != MDOC_BODY)
d2011 1
a2011 1
	if (n->type != MDOC_BODY)
d2038 1
a2038 1
	if (MDOC_BLOCK == n->type) {
d2041 1
a2041 1
	} else if (MDOC_BODY == n->type) {
d2076 1
a2076 1
	if (MDOC_BODY != n->type)
d2093 1
a2093 1
	if (MDOC_HEAD == n->type)
d2095 1
a2095 1
	else if (MDOC_BODY != n->type)
d2201 1
a2201 1
	case MDOC_BLOCK:
d2203 1
a2203 1
	case MDOC_HEAD:
d2205 1
a2205 1
	case MDOC_BODY:
d2221 1
a2221 1
	if (MDOC_BODY == n->type)
@


1.312
log
@In mdoc(7), don't mistreat negative .sp arguments as large positive ones.
Instead, use the same logic as for man(7).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.311 2015/02/17 20:37:17 schwarze Exp $ */
d351 2
@


1.311
log
@Render \(lq and \(rq as '"' in -Tascii mode but leave the rendering
of .Do/.Dc, .Dq, .Lb, and .St untouched.
Reduces groff-mandoc differences in OpenBSD base by about 7%.
Reminded of the issue by naddy@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.310 2015/02/12 12:24:33 schwarze Exp $ */
d1811 1
a1811 1
	size_t		 i, len;
d1832 5
a1836 2
	for (i = 0; i < len; i++)
		term_vspace(p);
@


1.310
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.309 2015/02/11 14:15:12 schwarze Exp $ */
d1876 1
a1876 1
		term_word(p, "\\(lq");
d1945 1
a1945 1
		term_word(p, "\\(rq");
@


1.309
log
@do not access a NULL pointer if an .Eo block lacks a tail;
found by jsg@@ with afl, test case #16
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.308 2015/02/05 01:46:56 schwarze Exp $ */
d312 1
d365 1
a365 1
	    (ENDBODY_NOT == n->end ? n : n->pending)->prev_font);
d385 1
a385 1
			n->pending->flags |= MDOC_ENDED;
@


1.308
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.307 2015/02/05 00:14:13 schwarze Exp $ */
d1992 2
a1993 3
	     n->parent->head->child != NULL &&
	     (n->parent->body->child != NULL ||
	      n->parent->tail->child != NULL))
@


1.307
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.306 2015/02/01 23:10:35 schwarze Exp $ */
a1093 3
	if (n->child == NULL)
		return(0);

@


1.306
log
@fix .Eo/.Ec spacing
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.305 2015/01/31 00:12:41 schwarze Exp $ */
d322 3
a324 6
	if (TERMP_KEEP & p->flags) {
		if (n->prev ? (n->prev->lastline != n->line) :
		    (n->parent && n->parent->line != n->line)) {
			p->flags &= ~TERMP_KEEP;
			p->flags |= TERMP_PREKEEP;
		}
@


1.305
log
@Use relative offsets instead of absolute pointers for the terminal
font stack.  The latter fail after the stack is grown with realloc().
Fixing an assertion failure found by jsg@@ with afl some time ago
(test case number 51).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.304 2015/01/30 22:04:44 schwarze Exp $ */
d70 1
d95 1
d195 1
a195 1
	{ termp_quote_pre, termp_quote_post }, /* Eo */
a1888 2
	case MDOC_Eo:
		break;
d1924 1
a1924 3
	if ( ! (n->tok == MDOC_En ||
	    (n->tok == MDOC_Eo && n->end == ENDBODY_SPACE)))
		p->flags |= TERMP_NOSPACE;
d1953 5
a1957 4
		if (NULL != n->norm->Es &&
		    NULL != n->norm->Es->child &&
		    NULL != n->norm->Es->child->next) {
			p->flags |= TERMP_NOSPACE;
a1958 3
		}
		break;
	case MDOC_Eo:
d1986 45
@


1.304
log
@Have pity on the poor stack.
Replace tail recursion by iteration when walking the syntax trees.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.303 2015/01/23 14:21:01 schwarze Exp $ */
d310 1
a310 1
	n->prev_font = term_fontq(p);
@


1.303
log
@Let .Aq/.Ao/.Ac print "<>" instead of the normal "\(la\(ra"
when the only child is .Mt, not when the preceding node is .An,
to improve robustness.  Triggered by a question from Svyatoslav
Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.302 2014/12/24 23:32:42 schwarze Exp $ */
d294 4
a297 3
	print_mdoc_node(p, pair, meta, n);
	if (n->next)
		print_mdoc_nodelist(p, pair, meta, n->next);
@


1.302
log
@Support negative indentations for mdoc(7) displays and lists.
Not exactly recommended for use, rather for groff compatibility.
While here, introduce similar SHRT_MAX limits as in man(7),
fixing a few cases of infinite output found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.301 2014/12/23 13:48:57 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d1858 2
a1859 2
		term_word(p, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  "<" : "\\(la");
d1931 2
a1932 2
		term_word(p, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  ">" : "\\(ra");
@


1.301
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.300 2014/12/23 09:31:46 schwarze Exp $ */
d25 1
d53 1
a53 1
static	size_t	  a2width(const struct termp *, const char *);
d529 1
a529 1
static size_t
d537 1
a537 3
	} else if (su.scale < 0.0)
		su.scale = 0.0;

d608 1
d610 2
a611 3
	char			buf[24];
	int			i;
	size_t			width, offset, ncols, dcol;
d623 28
d656 1
a656 3
	width = offset = 0;

	if (bl->norm->Bl.offs)
d658 5
a716 1
		assert(bl->norm->Bl.width);
d718 4
a721 31
		break;
	}

	/*
	 * List-type can override the width in the case of fixed-head
	 * values (bullet, dash/hyphen, enum).  Tags need a non-zero
	 * offset.
	 */

	switch (type) {
	case LIST_bullet:
		/* FALLTHROUGH */
	case LIST_dash:
		/* FALLTHROUGH */
	case LIST_hyphen:
		/* FALLTHROUGH */
	case LIST_enum:
		if (width < term_len(p, 2))
			width = term_len(p, 2);
		break;
	case LIST_hang:
		if (0 == width)
			width = term_len(p, 8);
		break;
	case LIST_column:
		/* FALLTHROUGH */
	case LIST_tag:
		if (0 == width)
			width = term_len(p, 10);
		break;
	default:
d767 1
a767 1
		 * Very narrow enum lists actually hang.
a768 2
		if (width == term_len(p, 2))
			p->flags |= TERMP_HANG;
d775 2
a864 1
		assert(width);
d1544 1
d1561 7
a1567 2
	else
		p->offset += a2width(p, n->norm->Bd.offs);
@


1.300
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.299 2014/12/02 10:08:06 schwarze Exp $ */
d536 2
a537 1
	}
@


1.299
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.298 2014/11/30 05:29:00 schwarze Exp $ */
a52 1
static	size_t	  a2height(const struct termp *, const char *);
a528 13
a2height(const struct termp *p, const char *v)
{
	struct roffsu	 su;


	assert(v);
	if ( ! a2roffsu(v, &su, SCALE_VS))
		SCALE_VS_INIT(&su, atoi(v));

	return(term_vspan(p, &su));
}

static size_t
d533 1
a533 2
	assert(v);
	if ( ! a2roffsu(v, &su, SCALE_MAX)) {
d1804 1
d1809 6
a1814 1
		len = n->child ? a2height(p, n->child->string) : 1;
@


1.298
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.297 2014/11/28 16:54:23 schwarze Exp $ */
d1635 2
a1636 1
		if (nn->next && nn->next->line == nn->line)
@


1.297
log
@mop up an #ifdef turd deraadt@@ stepped into
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.296 2014/11/28 16:02:52 schwarze Exp $ */
d1737 2
a1738 1
	p->flags |= TERMP_NOSPACE;
@


1.296
log
@Be more careful about meta->name.  For weird input, it can be NULL.
Fixing a NULL access jsg@@ found with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.295 2014/11/27 22:27:56 schwarze Exp $ */
d1230 2
a1231 8
	if (MDOC_BODY != n->type)
		return(1);

#if defined(__OpenBSD__) || defined(__linux__)
	term_word(p, "\\(en");
#else
	term_word(p, "\\(em");
#endif
@


1.295
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.294 2014/11/27 16:20:31 schwarze Exp $ */
d998 1
d1009 9
a1017 6
		p->offset += term_len(p, 1) +
		    (NULL == n->prev->child ?
		     term_strlen(p, meta->name) :
		     MDOC_TEXT == n->prev->child->type ?
		     term_strlen(p, n->prev->child->string) :
		     term_len(p, 5));
@


1.294
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.293 2014/11/25 20:00:01 schwarze Exp $ */
d353 2
a354 1
		if (termacts[n->tok].pre && ENDBODY_NOT == n->end)
d1921 1
a1921 1
	if (MDOC_BODY != n->type && MDOC_ELEM != n->type)
d1924 2
a1925 1
	if (MDOC_En != n->tok)
@


1.293
log
@Do not access a NULL pointer when a section has no body,
which can for example happen for .Sh Xo .Sh without .Xc.
Crash found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.292 2014/11/21 01:52:53 schwarze Exp $ */
a93 1
static	int	  termp_es_pre(DECL_ARGS);
d113 1
d186 1
a186 1
	{ NULL, NULL }, /* Db */
d238 1
a238 1
	{ termp_es_pre, NULL }, /* Es */
d1841 1
a1841 1
termp_es_pre(DECL_ARGS)
@


1.292
log
@We repeatedly observed assertion crashes in the low-level terminal
output handler because the high level terminal formatters could be
tricked into setting the left margin further to the right than the
right margin.  Today, jsg@@ found more of these with afl.

Change the internal interface between both levels, aiming for
simplicity and robustness of the code.  Treat both margins as
*independent* settings:  Now, termp.offset is the requested left
margin, and termp.rmargin is the available space.  Let the lower
level cope with that case of insufficient space.

Obviously, high level code that does centering or flush right
still has to do careful checks, so i did a full audit of margin
settings in the terminal formatters.

Fixes crashes caused by excessively long title or date strings in
the man(7) footer, operating system or date strings in the mdoc(7)
footer, volume strings in the man(7) or mdoc(7) header, and a few
cases related to some non-prologue macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.291 2014/11/19 22:00:37 schwarze Exp $ */
a1376 2
	/* No vspace between consecutive `Sh' calls. */

d1379 9
a1387 4
		if (n->prev && MDOC_Sh == n->prev->tok)
			if (NULL == n->prev->body->child)
				break;
		term_vspace(p);
@


1.291
log
@Let .Ao and .Aq render as "<>" after .An and as "\(la\(ra" elsewhere,
just like groff; minibug noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.290 2014/11/17 06:44:58 schwarze Exp $ */
d408 1
d425 3
a427 2
	p->rmargin = (p->maxrmargin -
	    term_strlen(p, meta->date) + term_len(p, 1)) / 2;
d435 2
a436 1
	p->rmargin = p->maxrmargin - term_strlen(p, meta->os);
d498 1
a498 1
	    p->maxrmargin - vollen;
d879 1
a879 1
		else {
a880 3
			if (p->rmargin < p->offset)
				p->rmargin = p->offset;
		}
a1012 2
		if (p->rmargin < p->offset)
			p->rmargin = p->offset;
@


1.290
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.289 2014/11/10 21:56:43 schwarze Exp $ */
d1857 2
a1858 1
		term_word(p, "<");
d1929 2
a1930 1
		term_word(p, ">");
@


1.289
log
@add required vertical spacing before lists that begin
at the beginning of the first item of an enclosing list
right at the beginning of a new section or subsection;
minibug reported by Steffen Nurpmeso <sdaoden at yandex dot com>
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.288 2014/10/30 20:10:02 schwarze Exp $ */
d196 1
a196 1
	{ NULL, NULL }, /* No */
@


1.288
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.287 2014/10/28 17:36:19 schwarze Exp $ */
d575 8
a582 4
	for (nn = n; nn; nn = nn->parent) {
		if (MDOC_BLOCK != nn->type)
			continue;
		if (MDOC_Ss == nn->tok)
d584 3
a586 5
		if (MDOC_Sh == nn->tok)
			return;
		if (NULL == nn->prev)
			continue;
		break;
@


1.287
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.286 2014/10/20 15:50:24 schwarze Exp $ */
a53 1
static	size_t	  a2offs(const struct termp *, const char *);
a551 21
static size_t
a2offs(const struct termp *p, const char *v)
{
	struct roffsu	 su;

	if ('\0' == *v)
		return(0);
	else if (0 == strcmp(v, "left"))
		return(0);
	else if (0 == strcmp(v, "indent"))
		return(term_len(p, p->defindent + 1));
	else if (0 == strcmp(v, "indent-two"))
		return(term_len(p, (p->defindent + 1) * 2));
	else if ( ! a2roffsu(v, &su, SCALE_MAX)) {
		SCALE_HS_INIT(&su, term_strlen(p, v));
		su.scale /= term_strlen(p, "0");
	}

	return(term_hspan(p, &su));
}

d640 1
a640 1
		offset = a2offs(p, bl->norm->Bl.offs);
d1562 11
a1572 2
	if (n->norm->Bd.offs)
		p->offset += a2offs(p, n->norm->Bd.offs);
@


1.286
log
@correct the spacing after in-line equations
that start at the beginning of an input line
but end before the end of an input line
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.285 2014/10/20 02:47:09 schwarze Exp $ */
a263 3
	if (NULL == p->symtab)
		p->symtab = mchars_alloc();

@


1.285
log
@correct spacing *after* inline equations (much simpler than expected)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.284 2014/10/20 02:33:06 schwarze Exp $ */
d350 1
a350 1
		if ( ! (n->flags & MDOC_LINE))
@


1.284
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.283 2014/10/13 22:00:47 schwarze Exp $ */
d350 2
@


1.283
log
@Properly scale string length measurements for PostScript and PDF output;
this doesn't change anything for ASCII and UTF-8.
Problem reported by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.282 2014/09/17 20:18:58 schwarze Exp $ */
d347 2
@


1.282
log
@simplify handling of .An -[no]split for terminal output:
delete one static function, one flag #define, and 25 lines of code;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.281 2014/09/03 05:22:45 schwarze Exp $ */
d544 1
a544 1
	if ( ! a2roffsu(v, &su, SCALE_MAX))
d546 2
d565 1
a565 1
	else if ( ! a2roffsu(v, &su, SCALE_MAX))
d567 2
@


1.281
log
@Implement the traditional -h option for man(1): show the SYNOPSIS only.
As usual, we get mandoc -h and apropos -h for free.
Try stuff like "apropos -h In=dirent" or "apropos -h Fa=timespec".

Only useful for terminal output, so -Tps, -Tpdf, -Thtml ignore -h for now.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.280 2014/08/21 12:57:17 schwarze Exp $ */
a67 1
static	void	  termp_an_post(DECL_ARGS);
d140 1
a140 1
	{ termp_an_pre, termp_an_post }, /* An */
d1108 10
a1117 2
	if (NULL == n->child)
		return(1);
d1119 2
a1120 8
	/*
	 * If not in the AUTHORS section, `An -split' will cause
	 * newlines to occur before the author name.  If in the AUTHORS
	 * section, by default, the first `An' invocation is nosplit,
	 * then all subsequent ones, regardless of whether interspersed
	 * with other macros/text, are split.  -split, in this case,
	 * will override the condition of the implied first -nosplit.
	 */
d1122 1
a1122 8
	if (n->sec == SEC_AUTHORS) {
		if ( ! (TERMP_ANPREC & p->flags)) {
			if (TERMP_SPLIT & p->flags)
				term_newln(p);
			return(1);
		}
		if (TERMP_NOSPLIT & p->flags)
			return(1);
a1123 2
		return(1);
	}
d1125 2
a1126 2
	if (TERMP_SPLIT & p->flags)
		term_newln(p);
a1130 20
static void
termp_an_post(DECL_ARGS)
{

	if (n->child) {
		if (SEC_AUTHORS == n->sec)
			p->flags |= TERMP_ANPREC;
		return;
	}

	if (AUTH_split == n->norm->An.auth) {
		p->flags &= ~TERMP_NOSPLIT;
		p->flags |= TERMP_SPLIT;
	} else if (AUTH_nosplit == n->norm->An.auth) {
		p->flags &= ~TERMP_SPLIT;
		p->flags |= TERMP_NOSPLIT;
	}

}

@


1.280
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.279 2014/08/17 16:51:55 schwarze Exp $ */
a254 1
	const struct mdoc_node	*n;
d256 1
a260 3
	if (0 == p->defindent)
		p->defindent = 5;

d262 1
a262 1
	p->maxrmargin = p->defrmargin;
d268 1
a268 1
	n = mdoc_node(mdoc);
d271 21
a291 6
	term_begin(p, print_mdoc_head, print_mdoc_foot, meta);

	if (n->child) {
		if (MDOC_Sh != n->child->tok)
			term_vspace(p);
		print_mdoc_nodelist(p, NULL, meta, n->child);
a292 2

	term_end(p);
a475 3
	p->offset = 0;
	p->rmargin = p->maxrmargin;

@


1.279
log
@... and remove the trailing spaces (duh.  i should pay more attention)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.278 2014/08/17 16:44:41 schwarze Exp $ */
d1078 4
a1081 3
	if (n->child)
		p->flags |= TERMP_NOSPACE;
	else if (n->next && n->next->line == n->line)
@


1.278
log
@KNF: fix indentation of previous commit, see style(9):
"Indentation is an 8 character tab.  Second level indents are four spaces."
All the rest of this file already conforms.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.277 2014/08/17 08:37:11 kristaps Exp $ */
d809 1
a809 1
		if (NULL != n->next && 
d866 2
a867 2
		if (MDOC_HEAD == n->type && 
		    NULL != n->next && 
d1033 1
a1033 1
	if (MDOC_HEAD == n->type && 
d1062 1
a1062 1
	} else if (MDOC_HEAD == n->type && 
@


1.277
log
@Protect against accessing "n->next->child" by first checking "n->next".
Noticed in a crash against ".It Nm Fo" with no closing "Fc".
Original patch expanded by schwarze@@ then extended even more.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.276 2014/08/10 23:54:41 schwarze Exp $ */
d810 3
a812 3
			NULL != n->next->child &&
			(MDOC_Bl == n->next->child->tok ||
			 MDOC_Bd == n->next->child->tok))
d867 4
a870 4
			NULL != n->next && 
			NULL != n->next->child &&
			(MDOC_Bl == n->next->child->tok ||
			 MDOC_Bd == n->next->child->tok))
d1034 1
a1034 1
		NULL != n->next && NULL != n->next->child) {
d1063 1
a1063 1
		NULL != n->next && NULL != n->next->child) {
@


1.276
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.275 2014/08/06 15:09:05 schwarze Exp $ */
d809 4
a812 3
		if (n->next->child &&
		    (MDOC_Bl == n->next->child->tok ||
		     MDOC_Bd == n->next->child->tok))
d866 5
a870 3
		if (MDOC_HEAD == n->type && n->next->child &&
		    (MDOC_Bl == n->next->child->tok ||
		     MDOC_Bd == n->next->child->tok))
d1033 2
a1034 1
	if (MDOC_HEAD == n->type && n->next->child) {
d1062 2
a1063 1
	} else if (MDOC_HEAD == n->type && n->next->child) {
@


1.275
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.274 2014/07/30 17:06:26 schwarze Exp $ */
a18 1
#ifdef HAVE_CONFIG_H
a19 1
#endif
@


1.274
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.273 2014/07/30 00:19:16 schwarze Exp $ */
d479 5
a483 1
	mandoc_asprintf(&title, "%s(%s)", meta->title, meta->msec);
@


1.273
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.272 2014/07/29 13:58:18 schwarze Exp $ */
d1773 3
d1787 1
a1787 1
	if (MDOC_HEAD == n->type)
@


1.272
log
@Partial implementation of .Bd -centered.

In groff, .Bd -centered operates in fill mode, which is relatively
hard to implement, while this implementation operates in non-fill
mode so far.  As long as you pay attention that your lines do not
overflow, it works.  To make sure that rendering is the same for
mandoc and groff, it is recommended to insert .br between lines
for now.  This implementation will need improvement later.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.271 2014/07/07 15:03:43 schwarze Exp $ */
a1169 1
	term_word(p, "The");
d1172 2
a1173 4
	for (n = n->child; n; n = n->next) {
		term_fontpush(p, TERMFONT_BOLD);
		term_word(p, n->string);
		term_fontpop(p);
d1175 4
a1178 2
		p->flags |= TERMP_NOSPACE;
		term_word(p, "()");
a1179 1
		if (nchild > 2 && n->next) {
d1181 11
a1191 1
			term_word(p, ",");
d1194 4
a1197 3
		if (n->next && NULL == n->next->next)
			term_word(p, "and");
	}
d1199 4
a1202 4
	if (nchild > 1)
		term_word(p, "functions return");
	else
		term_word(p, "function returns");
d1204 2
a1205 2
	term_word(p, "the value 0 if successful; otherwise the "
	    "value -1 is returned and the global variable");
d1241 1
a1241 1
		term_word(p, "utilities exit");
d1243 1
a1243 1
		term_word(p, "utility exits");
d1245 1
a1245 1
	term_word(p, "0 on success, and >0 if an error occurs.");
@


1.271
log
@no need to skip content before first section header
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.270 2014/07/03 23:24:56 schwarze Exp $ */
d1574 1
a1574 1
	size_t			 tabwidth, rm, rmax;
d1595 2
a1596 1
	    DISP_unfilled != n->norm->Bd.type)
d1603 1
d1609 9
@


1.270
log
@Fix formatting of empty .Bl -inset item heads.
Downgrade empty item heads from ERROR to WARNING.
Show the list type in the error message.
Choose better variable names for nodes in post_it().
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.269 2014/07/02 19:55:10 schwarze Exp $ */
d278 3
a280 1
	if (n->child)
d282 1
@


1.269
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.268 2014/07/02 03:48:07 schwarze Exp $ */
d750 1
a750 1
		if (MDOC_BODY == n->type)
@


1.268
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.267 2014/04/23 16:08:33 schwarze Exp $ */
d2059 3
a2061 4
	assert(n->child && MDOC_TEXT == n->child->type);
	if (0 == strcmp("on", n->child->string)) {
		if (p->col)
			p->flags &= ~TERMP_NOSPACE;
d2063 1
a2063 1
	} else
d2066 3
@


1.267
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.266 2014/04/20 20:18:12 schwarze Exp $ */
d98 1
d162 1
a162 1
	{ NULL, NULL }, /* Ot */
d232 1
a232 1
	{ NULL, NULL }, /* Fr */
d242 2
a243 2
	{ NULL, NULL }, /* Es */ /* TODO */
	{ NULL, NULL }, /* En */ /* TODO */
d1833 7
d1871 6
d1914 2
a1915 1
	p->flags |= TERMP_NOSPACE;
d1942 8
@


1.266
log
@fix unchecked snprintf(3) in page header printing:
the length of the title is unknown, and speed doesn't matter here,
so use asprintf/free rather than a static buffer
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.265 2014/04/20 19:40:13 schwarze Exp $ */
a444 1
	char			 buf[BUFSIZ];
d446 2
a447 2
	char			*title;
	size_t			 buflen, titlen;
d468 6
a473 8
	strlcpy(buf, meta->vol, BUFSIZ);
	buflen = term_strlen(p, buf);

	if (meta->arch) {
		strlcat(buf, " (", BUFSIZ);
		strlcat(buf, meta->arch, BUFSIZ);
		strlcat(buf, ")", BUFSIZ);
	}
d481 3
a483 4
	p->rmargin = 2 * (titlen+1) + buflen < p->maxrmargin ?
	    (p->maxrmargin -
	     term_strlen(p, buf) + term_len(p, 1)) / 2 :
	    p->maxrmargin - buflen;
d490 1
a490 1
	p->rmargin = p->offset + buflen + titlen < p->maxrmargin ?
d493 1
a493 1
	term_word(p, buf);
d510 1
@


1.265
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.264 2014/04/20 16:46:05 schwarze Exp $ */
d33 1
d445 4
a448 3
	char		buf[BUFSIZ], title[BUFSIZ];
	size_t		buflen, titlen;
	const struct mdoc_meta *meta;
d478 1
a478 1
	snprintf(title, BUFSIZ, "%s(%s)", meta->title, meta->msec);
d513 1
@


1.264
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.263 2014/04/08 07:13:12 schwarze Exp $ */
d623 1
a623 1
	char			buf[7];
d919 1
a919 1
			snprintf(buf, sizeof(buf), "%d.",
@


1.263
log
@Add a new term_flushln() flag TERMP_BRIND (if break, then indent)
to control indentation of continuation lines in TERMP_NOBREAK mode.
In the past, this was always on; continue using it
for .Bl, .Nm, .Fn, .Fo, and .HP, but no longer for .IP and .TP.

I looked at this because sthen@@ reported the issue in a manual
of a Perl module from ports, but it affects base, too: This patch
reduces groff-mandoc differences in base by more than 15%.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.262 2014/04/08 04:40:47 schwarze Exp $ */
d45 1
a45 1
	  	  const struct mdoc_meta *meta, \
d60 1
a60 1
static	void  	  print_mdoc_node(DECL_ARGS);
d64 1
a64 1
static	void	  synopsis_pre(struct termp *, 
d131 2
a132 2
	{ termp_ss_pre, termp_ss_post }, /* Ss */ 
	{ termp_sp_pre, NULL }, /* Pp */ 
d140 1
a140 1
	{ termp_under_pre, NULL }, /* Ad */ 
d145 3
a147 3
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
d149 2
a150 2
	{ termp_fa_pre, NULL }, /* Fa */ 
	{ termp_fd_pre, termp_fd_post }, /* Fd */ 
d152 4
a155 4
	{ termp_fn_pre, NULL }, /* Fn */ 
	{ termp_ft_pre, NULL }, /* Ft */ 
	{ termp_bold_pre, NULL }, /* Ic */ 
	{ termp_in_pre, termp_in_post }, /* In */ 
d157 2
a158 2
	{ termp_nd_pre, NULL }, /* Nd */ 
	{ termp_nm_pre, termp_nm_post }, /* Nm */ 
d163 1
a163 1
	{ NULL, NULL }, /* St */ 
d183 1
a183 1
	{ termp_bf_pre, NULL }, /* Bf */ 
d194 1
a194 1
	{ termp_under_pre, NULL }, /* Em */ 
d222 2
a223 2
	{ termp_fo_pre, termp_fo_post }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
d233 7
a239 7
	{ termp_sp_pre, NULL }, /* Lp */ 
	{ termp_lk_pre, NULL }, /* Lk */ 
	{ termp_under_pre, NULL }, /* Mt */ 
	{ termp_quote_pre, termp_quote_post }, /* Brq */ 
	{ termp_quote_pre, termp_quote_post }, /* Bro */ 
	{ NULL, NULL }, /* Brc */ 
	{ NULL, termp____post }, /* %C */ 
d242 2
a243 2
	{ termp_xx_pre, NULL }, /* Dx */ 
	{ NULL, termp____post }, /* %Q */ 
d245 3
a247 3
	{ termp_sp_pre, NULL }, /* sp */ 
	{ NULL, termp____post }, /* %U */ 
	{ NULL, NULL }, /* Ta */ 
a281 1

a290 2

/* ARGSUSED */
d325 1
a325 1
	case (MDOC_TEXT):
d334 1
a334 1
	case (MDOC_EQN):
d337 1
a337 1
	case (MDOC_TBL):
d354 1
a354 1
	case (MDOC_TEXT):
d356 1
a356 1
	case (MDOC_TBL):
d358 1
a358 1
	case (MDOC_EQN):
a391 1

d401 1
a401 1
	/* 
d412 2
a413 2
	p->rmargin = (p->maxrmargin - 
			term_strlen(p, meta->date) + term_len(p, 1)) / 2;
a440 1

a512 1

a525 1

a537 1

a556 1

d563 3
a565 3
print_bvspace(struct termp *p, 
		const struct mdoc_node *bl, 
		const struct mdoc_node *n)
a610 1
/* ARGSUSED */
a618 2

/* ARGSUSED */
d623 3
a625 3
	char		        buf[7];
	int		        i;
	size_t		        width, offset, ncols, dcol;
d636 1
a636 1
	/* 
d648 1
a648 1
	case (LIST_column):
d662 2
a663 4

		/* LINTED */
		dcol = ncols < 5 ? term_len(p, 4) : 
			ncols == 5 ? term_len(p, 3) : term_len(p, 1);
d670 5
a674 5
		for (i = 0, nn = n->prev; 
				nn->prev && i < (int)ncols; 
				nn = nn->prev, i++)
			offset += dcol + a2width
				(p, bl->norm->Bl.cols[i]);
d695 1
a695 1
		/* 
d705 1
a705 1
	/* 
d712 1
a712 1
	case (LIST_bullet):
d714 1
a714 1
	case (LIST_dash):
d716 1
a716 1
	case (LIST_hyphen):
d718 1
a718 1
	case (LIST_enum):
d722 1
a722 1
	case (LIST_hang):
d726 1
a726 1
	case (LIST_column):
d728 1
a728 1
	case (LIST_tag):
d736 1
a736 1
	/* 
d744 1
a744 1
	case (LIST_diag):
d748 2
a749 2
	case (LIST_inset):
		if (MDOC_BODY == n->type) 
d759 1
a759 1
	case (LIST_diag):
d775 1
a775 1
	case (LIST_enum):
d783 1
a783 1
	case (LIST_bullet):
d785 1
a785 1
	case (LIST_dash):
d787 1
a787 1
	case (LIST_hyphen):
d793 1
a793 1
	case (LIST_hang):
d803 3
a805 3
		if (n->next->child && 
				(MDOC_Bl == n->next->child->tok ||
				 MDOC_Bd == n->next->child->tok))
d811 1
a811 1
	case (LIST_tag):
d821 1
a821 1
	case (LIST_column):
d834 1
a834 1
	case (LIST_diag):
d844 1
a844 1
	/* 
d853 1
a853 1
	case (LIST_hang):
d860 2
a861 2
				(MDOC_Bl == n->next->child->tok || 
				 MDOC_Bd == n->next->child->tok))
d864 1
a864 1
	case (LIST_bullet):
d866 1
a866 1
	case (LIST_dash):
d868 1
a868 1
	case (LIST_enum):
d870 1
a870 1
	case (LIST_hyphen):
d872 1
a872 1
	case (LIST_tag):
d882 1
a882 1
	case (LIST_column):
d885 1
a885 1
		/* 
d898 1
a898 1
	/* 
d900 1
a900 1
	 * HEAD character (temporarily bold, in some cases).  
d905 1
a905 1
		case (LIST_bullet):
d910 1
a910 1
		case (LIST_dash):
d912 1
a912 1
		case (LIST_hyphen):
d917 1
a917 1
		case (LIST_enum):
d919 2
a920 2
			snprintf(buf, sizeof(buf), "%d.", 
					pair->ppair->ppair->count);
d927 1
a927 1
	/* 
d932 1
a932 1
	case (LIST_bullet):
d934 1
a934 1
	case (LIST_item):
d936 1
a936 1
	case (LIST_dash):
d938 1
a938 1
	case (LIST_hyphen):
d940 1
a940 1
	case (LIST_enum):
d944 1
a944 1
	case (LIST_column):
a954 2

/* ARGSUSED */
d966 1
a966 1
	case (LIST_item):
d968 1
a968 1
	case (LIST_diag):
d970 1
a970 1
	case (LIST_inset):
d974 1
a974 1
	case (LIST_column):
d983 1
a983 1
	/* 
a993 2

/* ARGSUSED */
a1045 2

/* ARGSUSED */
a1059 2
		
/* ARGSUSED */
a1074 2

/* ARGSUSED */
a1085 2

/* ARGSUSED */
d1101 1
a1101 1
	
a1119 2

/* ARGSUSED */
a1139 2

/* ARGSUSED */
a1148 2

/* ARGSUSED */
a1159 2

/* ARGSUSED */
d1191 2
a1192 2
       	term_word(p, "the value 0 if successful; otherwise the value "
			"-1 is returned and the global variable");
d1198 1
a1198 1
       	term_word(p, "is set to indicate the error.");
a1203 2

/* ARGSUSED */
d1232 1
a1232 1
       	term_word(p, "0 on success, and >0 if an error occurs.");
a1237 2

/* ARGSUSED */
a1252 2

/* ARGSUSED */
a1259 2

/* ARGSUSED */
a1267 1
/* ARGSUSED */
d1278 1
a1278 1
	if (NULL == (n = n->next)) 
d1302 1
a1302 1
	/* 
d1314 4
a1317 4
	if (n->prev->tok == n->tok && 
			MDOC_Ft != n->tok && 
			MDOC_Fo != n->tok && 
			MDOC_Fn != n->tok) {
d1328 1
a1328 1
	case (MDOC_Fd):
d1330 1
a1330 1
	case (MDOC_Fn):
d1332 1
a1332 1
	case (MDOC_Fo):
d1334 1
a1334 1
	case (MDOC_In):
d1336 1
a1336 1
	case (MDOC_Vt):
d1339 1
a1339 1
	case (MDOC_Ft):
a1350 1

a1366 2

/* ARGSUSED */
a1374 2

/* ARGSUSED */
a1382 2

/* ARGSUSED */
a1389 2

/* ARGSUSED */
d1397 1
a1397 1
	case (MDOC_BLOCK):
d1403 1
a1403 1
	case (MDOC_HEAD):
d1406 1
a1406 1
	case (MDOC_BODY):
a1416 2

/* ARGSUSED */
d1422 1
a1422 1
	case (MDOC_HEAD):
d1425 1
a1425 1
	case (MDOC_BODY):
a1433 2

/* ARGSUSED */
a1442 2

/* ARGSUSED */
a1450 2

/* ARGSUSED */
a1459 2

/* ARGSUSED */
a1470 2

/* ARGSUSED */
a1480 2

/* ARGSUSED */
a1541 2

/* ARGSUSED */
a1566 2

/* ARGSUSED */
d1589 3
a1591 3
	
	if (DISP_literal != n->norm->Bd.type && 
			DISP_unfilled != n->norm->Bd.type)
d1611 1
a1611 1
		case (MDOC_Sm):
d1613 1
a1613 1
		case (MDOC_br):
d1615 1
a1615 1
		case (MDOC_sp):
d1617 1
a1617 1
		case (MDOC_Bl):
d1619 1
a1619 1
		case (MDOC_D1):
d1621 1
a1621 1
		case (MDOC_Dl):
d1623 1
a1623 1
		case (MDOC_Lp):
d1625 1
a1625 1
		case (MDOC_Pp):
a1641 2

/* ARGSUSED */
d1647 1
a1647 1
	if (MDOC_BODY != n->type) 
d1653 2
a1654 2
	if (DISP_literal == n->norm->Bd.type || 
			DISP_unfilled == n->norm->Bd.type)
a1663 2

/* ARGSUSED */
a1686 2

/* ARGSUSED */
d1695 1
a1695 1
	case (MDOC_Bsx):
d1698 1
a1698 1
	case (MDOC_Dx):
d1701 1
a1701 1
	case (MDOC_Fx):
d1704 1
a1704 1
	case (MDOC_Nx):
d1707 1
a1707 1
	case (MDOC_Ox):
d1710 1
a1710 1
	case (MDOC_Ux):
a1727 2

/* ARGSUSED */
a1734 2

/* ARGSUSED */
d1740 1
a1740 1
	case (MDOC_BLOCK):
d1745 1
a1745 1
	case (MDOC_HEAD):
a1755 2

/* ARGSUSED */
a1763 2

/* ARGSUSED */
a1772 2

/* ARGSUSED */
a1791 2

/* ARGSUSED */
a1805 2

/* ARGSUSED */
d1812 1
a1812 1
	case (MDOC_sp):
d1815 1
a1815 1
	case (MDOC_br):
a1830 2

/* ARGSUSED */
d1839 1
a1839 1
	case (MDOC_Ao):
d1841 1
a1841 1
	case (MDOC_Aq):
d1844 1
a1844 1
	case (MDOC_Bro):
d1846 1
a1846 1
	case (MDOC_Brq):
d1849 1
a1849 1
	case (MDOC_Oo):
d1851 1
a1851 1
	case (MDOC_Op):
d1853 1
a1853 1
	case (MDOC_Bo):
d1855 1
a1855 1
	case (MDOC_Bq):
d1858 1
a1858 1
	case (MDOC_Do):
d1860 1
a1860 1
	case (MDOC_Dq):
d1863 1
a1863 1
	case (MDOC_Eo):
d1865 1
a1865 1
	case (MDOC_Po):
d1867 1
a1867 1
	case (MDOC_Pq):
d1870 1
a1870 1
	case (MDOC__T):
d1872 1
a1872 1
	case (MDOC_Qo):
d1874 1
a1874 1
	case (MDOC_Qq):
d1877 1
a1877 1
	case (MDOC_Ql):
d1879 1
a1879 1
	case (MDOC_So):
d1881 1
a1881 1
	case (MDOC_Sq):
a1892 2

/* ARGSUSED */
d1903 1
a1903 1
	case (MDOC_Ao):
d1905 1
a1905 1
	case (MDOC_Aq):
d1908 1
a1908 1
	case (MDOC_Bro):
d1910 1
a1910 1
	case (MDOC_Brq):
d1913 1
a1913 1
	case (MDOC_Oo):
d1915 1
a1915 1
	case (MDOC_Op):
d1917 1
a1917 1
	case (MDOC_Bo):
d1919 1
a1919 1
	case (MDOC_Bq):
d1922 1
a1922 1
	case (MDOC_Do):
d1924 1
a1924 1
	case (MDOC_Dq):
d1927 1
a1927 1
	case (MDOC_Eo):
d1929 1
a1929 1
	case (MDOC_Po):
d1931 1
a1931 1
	case (MDOC_Pq):
d1934 1
a1934 1
	case (MDOC__T):
d1936 1
a1936 1
	case (MDOC_Qo):
d1938 1
a1938 1
	case (MDOC_Qq):
d1941 1
a1941 1
	case (MDOC_Ql):
d1943 1
a1943 1
	case (MDOC_So):
d1945 1
a1945 1
	case (MDOC_Sq):
a1953 2

/* ARGSUSED */
a1995 2

/* ARGSUSED */
d2000 1
a2000 1
	if (MDOC_BODY != n->type) 
a2012 2

/* ARGSUSED */
d2022 1
a2022 1
	if (FONT_Em == n->norm->Bf.font) 
d2024 1
a2024 1
	else if (FONT_Sy == n->norm->Bf.font) 
d2026 1
a2026 1
	else 
a2031 2

/* ARGSUSED */
a2046 2

/* ARGSUSED */
a2056 2

/* ARGSUSED */
a2083 2

/* ARGSUSED */
a2091 2

/* ARGSUSED */
a2117 2

/* ARGSUSED */
d2123 1
a2123 1
	case (MDOC_BLOCK):
d2125 1
a2125 1
	case (MDOC_HEAD):
d2127 1
a2127 1
	case (MDOC_BODY):
a2138 2

/* ARGSUSED */
a2146 1
/* ARGSUSED */
d2156 1
a2156 1
			n->parent->norm->Rs.quote_T)
a2161 1
/* ARGSUSED */
d2171 1
a2171 1
			n->parent->norm->Rs.quote_T)
a2177 1
/* ARGSUSED */
@


1.262
log
@If the SYNOPSIS section contains an excessively long .Nm,
adjust the right margin to avoid running into an assertion;
output in that case now agrees with groff, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.261 2014/03/30 21:28:01 schwarze Exp $ */
d822 1
a822 1
		p->flags |= TERMP_NOBREAK | TERMP_HANG;
d829 1
a829 1
		p->flags |= TERMP_NOBREAK;
d851 1
a851 1
		p->flags |= TERMP_NOBREAK;
d1005 2
a1006 3
	p->flags &= ~TERMP_DANGLE;
	p->flags &= ~TERMP_NOBREAK;
	p->flags &= ~TERMP_HANG;
d1043 1
a1043 1
		p->flags |= TERMP_NOSPACE | TERMP_NOBREAK;
d1074 1
a1074 1
		p->flags &= ~(TERMP_NOBREAK | TERMP_HANG);
d1563 1
a1563 1
		p->flags |= TERMP_NOBREAK | TERMP_HANG;
d1573 1
a1573 1
		p->flags &= ~(TERMP_NOBREAK | TERMP_HANG);
d2065 2
a2066 1
			p->flags |= TERMP_NOBREAK | TERMP_HANG;
d2073 2
a2074 1
			p->flags &= ~(TERMP_NOBREAK | TERMP_HANG);
@


1.261
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.260 2014/03/30 19:47:48 schwarze Exp $ */
d1032 2
@


1.260
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.259 2014/02/16 12:33:39 schwarze Exp $ */
d625 1
a625 1
	(*p->setwidth)(p, n->nchild ? a2width(p, n->child->string) : 0);
@


1.259
log
@when indenting, extend the right margin accordingly, when needed;
fixes a crash reported by blambert@@ and a few other, similar ones
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.258 2013/12/25 21:24:12 schwarze Exp $ */
d107 1
d248 1
d389 4
a392 2
	p->offset = offset;
	p->rmargin = rmargin;
d622 10
@


1.258
log
@Oops, .Fa never breaks the output line in the middle of any of its
arguments, not even outside SYNOPSIS mode.  Quite surprising as .Fn
does break the line in the middle of its arguments outside SYNOPSIS
mode, and only doesn't do that in SYNOPSIS mode.  Wonders of groff...
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.257 2013/12/25 15:12:45 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d876 1
a876 1
		else 
d878 3
@


1.257
log
@Garbage collect two local variables each used only one single time.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.256 2013/12/25 14:40:34 schwarze Exp $ */
d1604 1
a1604 2
		if (MDOC_SYNPRETTY & n->flags)
			p->flags |= TERMP_NBRWORD;
@


1.256
log
@In the SYNOPSIS, implement hanging indentation for .Fo
and avoid output line breaks inside .Fa arguments.
This reduces groff-mandoc differences in OpenBSD base by more than 8%.
Patch from Franco Fichtner <franco at lastsummer dot de> (DragonFly).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.255 2013/12/25 00:39:31 schwarze Exp $ */
d1532 1
a1532 1
	size_t		 width, rmargin = 0;
a1542 1
		width = term_len(p, 4);
d1544 1
a1544 1
		p->rmargin = p->offset + width;
d2036 1
a2036 1
	size_t		 width, rmargin = 0;
a2045 1
			width = term_len(p, 4);
d2047 1
a2047 1
			p->rmargin = p->offset + width;
@


1.255
log
@Do not break output lines in .Fn function arguments in SYNOPSIS mode.
Following an idea from Franco Fichtner, but implemented more cleanly.
This reduces groff-mandoc-differences in OpenBSD base by a fantastic 7.5%.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.254 2013/12/24 23:04:36 schwarze Exp $ */
d5 1
d1605 2
d1610 1
a1610 1
		if (nn->next) {
a1615 5
	if (n->child && n->next && n->next->tok == MDOC_Fa) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, ",");
	}

d2037 4
d2046 6
d2055 6
d2062 1
a2062 1
	} 
d2090 1
@


1.254
log
@Delete the unused flag TERMP_IGNDELIM
and the empty callback termp_igndelim_pre().
Sort the remaining termp flags.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.253 2013/12/24 20:45:27 schwarze Exp $ */
d1567 2
@


1.253
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.252 2013/12/24 19:11:46 schwarze Exp $ */
a102 1
static	int	  termp_igndelim_pre(DECL_ARGS);
d196 1
a196 1
	{ termp_igndelim_pre, NULL }, /* No */
d201 1
a201 1
	{ termp_igndelim_pre, termp_pf_post }, /* Pf */
a1789 10
static int
termp_igndelim_pre(DECL_ARGS)
{

	p->flags |= TERMP_IGNDELIM;
	return(1);
}


/* ARGSUSED */
@


1.252
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.251 2013/12/23 02:20:09 schwarze Exp $ */
a309 3
	 *
	 * Also let SYNPRETTY sections behave as if they were wrapped
	 * in a `Bk' block.
d312 1
a312 1
	if (TERMP_KEEP & p->flags || MDOC_SYNPRETTY & n->flags) {
a320 10
	 * Since SYNPRETTY sections aren't "turned off" with `Ek',
	 * we have to intuit whether we should disable formatting.
	 */

	if ( ! (MDOC_SYNPRETTY & n->flags) &&
	    ((n->prev   && MDOC_SYNPRETTY & n->prev->flags) ||
	     (n->parent && MDOC_SYNPRETTY & n->parent->flags)))
		p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);

	/*
d1000 2
a1001 1
	if (MDOC_BLOCK == n->type)
d1003 1
d1052 3
a1054 1
	if (MDOC_HEAD == n->type && n->next->child) {
d2234 1
a2234 1
	if (MDOC_BODY == n->type && ! (MDOC_SYNPRETTY & n->flags))
@


1.251
log
@Implement a long-standing desideratum,
hanging indentation for .Fn in SYNOPSIS mode,
exploiting the new trailspace feature
by deliberately *NOT* using it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.250 2013/12/22 23:34:13 schwarze Exp $ */
d316 1
a316 1
		if (n->prev ? (n->prev->line != n->line) :
@


1.250
log
@Polishing the worms in my favourite can, term_flushln().

The TERMP_TWOSPACE flag i introduced in August 2009 was idiosyncratic
and served only a very narrow purpose.  Replace it by a more intuitive
and more general termp attribute "trailspace", to be used together
with TERMP_NOBREAK, to request a minimum amount of whitespace at
the end of the current column.  Adapt all code to the new interface.

No functional change intended;
code reviews to confirm that are welcome *eg*.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.249 2013/06/02 18:16:57 schwarze Exp $ */
d1541 1
d1551 7
d1563 7
d1592 1
@


1.249
log
@Let .Do .Dq .Ql .So .Sq generate the correct roff(7) character escape
sequences such that output modes like -Tutf8 have a chance to select
nice glyphs.  This doesn't change anything for -Tascii, and, for now,
it doesn't affect -Tps and -Tpdf either.
OK matthew@@ bentley@@; like the idea tedu@@; no opinion jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.248 2013/05/29 16:11:40 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d427 1
d442 1
d494 1
d513 1
d801 4
a804 2
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK;
d807 1
a807 3
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK;
		else
d819 4
a822 3
			p->flags &= ~TERMP_NOBREAK;
		else
			p->flags |= TERMP_HANG;
a824 3
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK | TERMP_TWOSPACE;

d827 4
d838 1
a838 1
		if (NULL == n->next)
d840 2
a841 1
		else
d843 2
d848 4
a851 2
		if (MDOC_HEAD == n->type)
			p->flags |= TERMP_NOBREAK;
a1002 1
	p->flags &= ~TERMP_TWOSPACE;
d1004 1
d1037 1
d1066 1
@


1.248
log
@Simplify condition, avoid duplicate code; no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.247 2013/05/29 15:40:22 schwarze Exp $ */
d1928 1
a1928 1
		term_word(p, "``");
d1949 1
a1949 1
		term_word(p, "`");
d1994 1
a1994 1
		term_word(p, "''");
d2015 1
a2015 1
		term_word(p, "'");
@


1.247
log
@In SYNOPSIS mode, .Ek doesn't end a keep.
Found and fixed on the plane to the OpenBSD t2k13 hackathon in Toronto.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.246 2013/05/18 17:47:47 schwarze Exp $ */
d316 2
a317 1
		if (n->prev && n->prev->line != n->line) {
a319 5
		} else if (NULL == n->prev) {
			if (n->parent && n->parent->line != n->line) {
				p->flags &= ~TERMP_KEEP;
				p->flags |= TERMP_PREKEEP;
			}
@


1.246
log
@Should termp_xx_pre() ever get called for a macro it cannot handle,
use abort(3), just like in the three other comparable cases in this file,
instead of ignoring the problem and causing a null pointer access.
Cosmetical issue reported by Ulrich Spoerlein <uqs@@spoerlein.net>
found by Coverity Scan CID 976115.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.245 2012/11/17 00:26:33 schwarze Exp $ */
d2218 1
a2218 1
	if (MDOC_BODY == n->type)
@


1.245
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.244 2012/11/16 17:16:55 schwarze Exp $ */
d1759 2
a1760 1
		break;
@


1.244
log
@Improve formatting of badly nested font blocks.
The basic idea is to already pop the font at the end marker
instead of allowing it to linger until the final end of the block.

This requires a few preliminaries:
* For each block, save a pointer to the previous font
  to be used in case the block breaks another and gets extended.
* That requires making node information writable during rendering.
* Now fonts may get popped in the wrong order; hence, after the stack
  has already been rewound further by some block that began earlier,
  ignore popping a font that was put on the stack later.
* To be able to exploit all this for font blocks, tie processing
  to their body, not their block, which is more logical anyway.

Triggered by florian@@ reporting vaguely similar issues with list blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.243 2012/07/11 16:57:43 schwarze Exp $ */
d44 1
a44 1
	  	  const struct mdoc_meta *m, \
d254 1
a254 1
	const struct mdoc_meta	*m;
d270 1
a270 1
	m = mdoc_meta(mdoc);
d272 1
a272 1
	term_begin(p, print_mdoc_head, print_mdoc_foot, m);
d275 1
a275 1
		print_mdoc_nodelist(p, NULL, m, n->child);
d285 1
a285 1
	print_mdoc_node(p, pair, m, n);
d287 1
a287 1
		print_mdoc_nodelist(p, pair, m, n->next);
d361 1
a361 1
				(p, &npair, m, n);
d366 1
a366 1
		print_mdoc_nodelist(p, &npair, m, n->child);
d381 1
a381 1
		(void)(*termacts[n->tok].post)(p, &npair, m, n);
d412 1
a412 1
	const struct mdoc_meta *m;
d414 1
a414 1
	m = (const struct mdoc_meta *)arg;
d430 1
a430 1
			term_strlen(p, m->date) + term_len(p, 1)) / 2;
d433 1
a433 1
	term_word(p, m->os);
d437 1
a437 1
	p->rmargin = p->maxrmargin - term_strlen(p, m->os);
d440 1
a440 1
	term_word(p, m->date);
d448 1
a448 1
	term_word(p, m->os);
d462 1
a462 1
	const struct mdoc_meta *m;
d464 1
a464 1
	m = (const struct mdoc_meta *)arg;
d482 2
a483 2
	assert(m->vol);
	strlcpy(buf, m->vol, BUFSIZ);
d486 1
a486 1
	if (m->arch) {
d488 1
a488 1
		strlcat(buf, m->arch, BUFSIZ);
d492 1
a492 1
	snprintf(title, BUFSIZ, "%s(%s)", m->title, m->msec);
d1014 2
a1015 1
		    (NULL == n->prev->child ? term_strlen(p, m->name) :
d1017 1
a1017 1
			term_strlen(p, n->prev->child->string) :
d1022 1
a1022 1
	if (NULL == n->child && NULL == m->name)
d1032 1
a1032 1
			p->rmargin += term_strlen(p, m->name);
d1045 1
a1045 1
		term_word(p, m->name);
d1383 1
a1383 1
		return(termp_under_pre(p, pair, m, n));
d1390 1
a1390 1
	return(termp_under_pre(p, pair, m, n));
d1410 1
a1410 1
	return(termp_bold_pre(p, pair, m, n));
d1642 1
a1642 1
		print_mdoc_node(p, pair, m, nn);
d2232 1
a2232 1
		termp_quote_post(p, pair, m, n);
d2234 1
a2234 1
	termp____post(p, pair, m, n);
d2248 1
a2248 1
		return(termp_quote_pre(p, pair, m, n));
@


1.243
log
@fix position and formatting of %U;
OpenBSD rev. 1.104 and 1.145, respectively
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.242 2012/07/10 14:38:51 schwarze Exp $ */
d45 1
a45 1
		  const struct mdoc_node *n
a295 1
	const void	*font;
d302 1
a302 1
	font = term_fontq(p);
d368 2
a369 1
	term_fontpopq(p, font);
d1609 1
a1609 1
	const struct mdoc_node	*nn;
d2078 1
a2078 1
	else if (MDOC_BLOCK != n->type)
@


1.242
log
@* implement -Tman .Bl -item -inset -diag -ohang -dash -hyphen -enum .It
* fix -Tman .Bl -bullet .It
* adjust the -Tascii .Bl -bullet -dash -hyphen .It
default and minimum width to new groff standards,
it changed from 4n (in groff 1.15) to 2n (in groff 1.21)
* same for -Tascii -enum, it changed from 5n to 2n
* use -hang formatting for -Tascii -enum -width 2n
* for -Tascii -enum, the default is -width 3n
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.241 2012/07/09 23:53:36 schwarze Exp $ */
d245 1
a245 1
	{ termp_under_pre, termp____post }, /* %U */ 
@


1.241
log
@fix -Tascii .Fd line breaking
and implement -Tman .Fd
OpenBSD rev. 1.27 and 1.143, respectively
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.240 2012/07/08 22:49:29 schwarze Exp $ */
d730 1
a730 3
		if (width < term_len(p, 4))
			width = term_len(p, 4);
		break;
d732 2
a733 2
		if (width < term_len(p, 5))
			width = term_len(p, 5);
d788 8
a799 2
	case (LIST_enum):
		/* FALLTHROUGH */
@


1.240
log
@fix .Lk for -Tascii and implement it for -Tman
OpenBSD rev. 1.22 and 1.142, respectively
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.239 2012/07/08 16:52:20 schwarze Exp $ */
d72 1
a72 1
static	void	  termp_d1_post(DECL_ARGS);
d132 2
a133 2
	{ termp_d1_pre, termp_d1_post }, /* D1 */
	{ termp_d1_pre, termp_d1_post }, /* Dl */
d149 1
a149 1
	{ termp_fd_pre, NULL }, /* Fd */ 
d1410 9
a1511 11
static void
termp_d1_post(DECL_ARGS)
{

	if (MDOC_BLOCK != n->type) 
		return;
	term_newln(p);
}


/* ARGSUSED */
@


1.239
log
@implement -Tman .An
also reset -[no]split mode at .Sh AUTHORS in -Tascii
OpenBSD rev. 1.20 and 1.141, respectively
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.238 2011/11/13 13:15:14 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d2162 1
a2162 1
	const struct mdoc_node *nn, *sv;
d2164 2
a2165 1
	term_fontpush(p, TERMFONT_UNDER);
d2167 10
a2176 12
	nn = sv = n->child;

	if (NULL == nn || NULL == nn->next)
		return(1);

	for (nn = nn->next; nn; nn = nn->next) 
		term_word(p, nn->string);

	term_fontpop(p);

	p->flags |= TERMP_NOSPACE;
	term_word(p, ":");
d2179 1
a2179 1
	term_word(p, sv->string);
@


1.238
log
@Make the default left text margin configurable from the command line,
just like the default right margin already is.  This may be useful for
people with expensive screen real estate.  Besides, it helps automated
man(7) to mdoc(7) output comparisons to validate -Tman output.
ok kristaps@@ on an earlier version
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.237 2011/11/03 20:36:59 schwarze Exp $ */
d1428 2
@


1.237
log
@Correct .Eo spacing:
no space between the delimiters and the enclosed text.
The mdoc_html.c part was added by kristaps; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.236 2011/10/16 12:20:34 schwarze Exp $ */
a36 3
#define	INDENT		  5
#define	HALFINDENT	  3

d259 3
d565 1
a565 1
		return(term_len(p, INDENT + 1));
d567 1
a567 1
		return(term_len(p, (INDENT + 1) * 2));
d1427 1
a1427 1
		p->offset = term_len(p, INDENT);
d1495 1
a1495 1
	p->offset += term_len(p, (INDENT + 1));
d1800 1
a1800 1
		p->offset = term_len(p, HALFINDENT);
@


1.236
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.235 2011/09/20 09:02:23 schwarze Exp $ */
d197 1
a197 1
	{ NULL, NULL }, /* Eo */
d1928 2
d1994 2
@


1.235
log
@Sync print_mdoc_head to print_man_head;
this was forgotten after man_term.c rev. 1.25 on March 2, 2010.
The benefit is a sane page header line when .Dt is very long.
Reminded by Thomas Klausner <wiz at NetBSD>, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.234 2011/09/19 22:36:16 schwarze Exp $ */
d587 2
@


1.234
log
@Remove the terminal frontend flag TERMP_NOLPAD.

In columnated contexts (.Bl -column, .Bl -tag, .IP, .TP, .HP etc.), do not
pad after writing a column.  Instead, always pad before writing content.

In itself, this change avoids:
 - writing trailing whitespace in some situations
 - with .fi/.nf in .HP, breaking lines that were already padded

It allows several bugfixes included in this patch:
 - Do not count backspace as a character with positive width.
 - Set up proper indentation when encountering .fi/.nf in .HP.
 - Adjust the .HP indentation width to what groff does.
 - Never unlimit the right margin unless in the final column.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.233 2011/07/22 10:50:46 kristaps Exp $ */
d461 1
a465 3
	p->rmargin = p->maxrmargin;
	p->offset = 0;

d479 3
d484 1
d493 1
d495 1
d497 4
a500 3
	p->rmargin = (p->maxrmargin - 
			term_strlen(p, buf) + term_len(p, 1)) / 2;
	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;
d505 1
d507 2
a508 2
	p->rmargin = p->maxrmargin - term_strlen(p, title);
	p->flags |= TERMP_NOSPACE;
a512 2
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
d514 7
a520 4
	p->flags |= TERMP_NOSPACE;

	term_word(p, title);
	term_flushln(p);
d522 1
a524 1
	p->flags &= ~TERMP_NOSPACE;
@


1.233
log
@Add character output (-Tpdf, -Tps, -Tascii) for equations.  This is the
minimum: unseparated terms.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.232 2011/07/21 11:34:53 kristaps Exp $ */
d438 1
a438 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d446 1
a446 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d502 1
a502 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d510 1
a510 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
a789 2
		else
			p->flags |= TERMP_NOLPAD;
a794 3
			p->flags |= TERMP_NOLPAD;

		if (MDOC_HEAD != n->type)
d805 1
a805 1
				 MDOC_Bd == n->next->child->tok)) {
d807 1
a807 2
			p->flags &= ~TERMP_NOLPAD;
		} else
a812 2
		else
			p->flags |= TERMP_NOLPAD;
a827 4
		assert(n->prev);
		if (MDOC_BODY == n->prev->type) 
			p->flags |= TERMP_NOLPAD;

a983 1
	p->flags &= ~TERMP_NOLPAD;
d999 1
a999 1
		p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d1044 1
a1044 1
	} else if (MDOC_BODY == n->type && n->child) {
a1045 2
		p->flags &= ~TERMP_NOLPAD;
	}
@


1.232
log
@Flip eqn into using parsed nodes.  I've temporarily disabled printing
these in the front-ends except for -Ttree, which will display the parsed
tree.

While here, fix that quoted strings aren't scanned for replacement parts.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.231 2011/06/29 15:38:09 kristaps Exp $ */
d354 1
a354 1
		/*term_word(p, n->eqn->data);*/
@


1.231
log
@First fix how `sp 1' doesn't imply `1v' (it now does) and that 1
followed by non-digits, e.g. `1g', really means `1'.  Next, fix some
spacing issues where `sp' was invoked in -man after sections or
subsections.  Make sure this behaviour is mirrored in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.230 2011/05/17 14:38:34 kristaps Exp $ */
d354 1
a354 1
		term_word(p, n->eqn->data);
@


1.230
log
@Add mode for -Tlocale.  This mode, with this commit, behaves exactly
like -Tascii.  While adding this, inline term_alloc() (was a one-liner),
remove some switches around the terminal encoding for the symbol table
(unnecessary), and split out ascii_alloc() into ascii_init(), which is
also called from locale_init().
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.229 2011/04/30 22:14:42 kristaps Exp $ */
d526 1
d529 1
a529 1
		SCALE_VS_INIT(&su, term_len(p, 1));
@


1.229
log
@Rename mchars_init() -> mchars_alloc() for consistency.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.228 2011/04/30 22:14:02 kristaps Exp $ */
d267 1
a267 8
		switch (p->enc) {
		case (TERMENC_ASCII):
			p->symtab = mchars_alloc();
			break;
		default:
			abort();
			/* NOTREACHED */
		}
@


1.228
log
@Remove enum mcharst, which hasn't been used in quite some time.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.227 2011/04/29 22:18:12 kristaps Exp $ */
d269 1
a269 1
			p->symtab = mchars_init();
@


1.227
log
@Move "chars" interface out of out.h and into mandoc.h.  This doesn't
change any code but for renaming functions and types to be consistent
with other mandoc.h stuff.  The reason for moving into libmandoc is that
the rendering of special characters is part of mandoc itself---not an
external part.  From mandoc(1)'s perspective, this changes nothing, but
for other utilities, it's important to have these part of libmandoc.
Note this isn't documented [yet] in mandoc.3 because there are some
parts I'd like to change around beforehand.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.226 2011/04/04 16:27:03 kristaps Exp $ */
d269 1
a269 1
			p->symtab = mchars_init(MCHARS_ASCII);
@


1.226
log
@Last low-hanging removal of superfluous variable assignments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.225 2011/04/04 16:21:51 kristaps Exp $ */
d269 1
a269 1
			p->symtab = chars_init(CHARS_ASCII);
@


1.225
log
@Clean up superfluous variables in `Xr' handling in -Tascii.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.224 2011/04/04 16:15:58 kristaps Exp $ */
d1539 3
a1541 1
	const struct mdoc_node	*nn;
d1545 4
d1550 1
a1550 1
	term_word(p, n->child->string);
d1557 2
a1558 1
	for (nn = n->child->next; nn; nn = nn->next) {
d1560 1
a1560 1
		term_word(p, nn->string);
d1563 1
a1563 1
		if (nn->next) {
d1572 1
a1572 1
	if (MDOC_SYNPRETTY & n->flags) {
@


1.224
log
@Fully fix the `Rv' and `Ex' handlers for -T[x]html and -Tascii.  This
includes an unreported bug where `Ex' wasn't properly adding a newline.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.223 2011/04/04 16:05:36 kristaps Exp $ */
a1298 1

a1302 1
	const struct mdoc_node *nn;
d1304 1
a1304 1
	if (NULL == n->child)
d1307 2
a1308 2
	assert(MDOC_TEXT == n->child->type);
	nn = n->child;
d1310 1
a1310 2
	term_word(p, nn->string);
	if (NULL == (nn = nn->next)) 
d1312 1
d1316 4
a1319 1
	term_word(p, nn->string);
a1325 1

@


1.223
log
@Clean up -Tascii in the same way as -T[x]html regarding `Rv' arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.222 2011/03/22 14:05:45 kristaps Exp $ */
a1191 1

d1196 1
d1232 1
a1232 1
	const struct mdoc_node	*nn;
d1234 1
d1237 2
a1238 1
	for (nn = n->child; nn; nn = nn->next) {
d1240 1
a1240 1
		term_word(p, nn->string);
d1242 3
a1244 4
		p->flags |= TERMP_NOSPACE;
		if (nn->next && NULL == nn->next->next)
			term_word(p, ", and");
		else if (nn->next)
d1246 4
a1249 2
		else
			p->flags &= ~TERMP_NOSPACE;
d1252 1
a1252 1
	if (n->child && n->child->next)
d1258 1
a1259 1

@


1.222
log
@Move mandoc_isdelim() back into libmdoc.h.  This fixes an unreported
error where (1) -man pages were punctuating delimiters (e.g., `.B a ;')
and where (2) standalone punctuation in -mdoc or -man (e.g., ";" on its
own line) would also be punctuated.  This introduces a small amount of
complexity of mdoc_{html,term}.c must manage their own spacing with
running print_word() or print_text().  The check for delimiting now
happens in mdoc_macro.c's dword().
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.221 2011/03/22 10:13:01 kristaps Exp $ */
d1186 1
a1186 1
	const struct mdoc_node	*nn;
d1191 3
a1193 1
	for (nn = n->child; nn; nn = nn->next) {
d1195 1
a1195 1
		term_word(p, nn->string);
d1198 9
a1206 6
		if (nn->next && NULL == nn->next->next)
			term_word(p, "(), and");
		else if (nn->next)
			term_word(p, "(),");
		else
			term_word(p, "()");
d1209 1
a1209 1
	if (n->child && n->child->next)
@


1.221
log
@Step 4: merge chars.h into out.h.  The functions in this file are
necessary to all [real] front-ends, so stop pretending it's special.
While here, add some documentation to the variable types.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.220 2011/03/07 01:35:51 schwarze Exp $ */
d354 2
d357 2
d1309 1
d1311 1
d1541 1
d1548 2
a1549 1
		if (nn->next)
d1551 1
d1554 1
d1557 2
a1558 1
	if (MDOC_SYNPRETTY & n->flags)
d1560 1
d1582 2
a1583 1
		if (nn->next)
d1585 1
d1588 2
a1589 1
	if (n->child && n->next && n->next->tok == MDOC_Fa)
d1591 1
d2026 1
d2050 1
d2053 2
a2054 1
	if (MDOC_SYNPRETTY & n->flags)
d2056 1
d2130 1
d2167 1
@


1.220
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.219 2011/02/09 09:52:47 kristaps Exp $ */
a34 1
#include "chars.h"
@


1.219
log
@EQN blocks are now printed in all modes.  This is simply a printing of
the concatenated string (in -T[x]html, it gets a SPAN, too).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.218 2011/02/06 23:02:31 schwarze Exp $ */
a415 1
	char		buf[DATESIZ], os[BUFSIZ];
a429 3
	time2a(m->date, buf, DATESIZ);
	strlcpy(os, m->os, BUFSIZ);

d434 1
a434 1
			term_strlen(p, buf) + term_len(p, 1)) / 2;
d437 1
a437 1
	term_word(p, os);
d441 1
a441 1
	p->rmargin = p->maxrmargin - term_strlen(p, os);
d444 1
a444 1
	term_word(p, buf);
d452 1
a452 1
	term_word(p, os);
@


1.218
log
@Fix a regression caused by mdoc_term.c 1.214 / mdoc_html.c 1.148:
Inside .Bk or inside the SYNOPSIS, Unix variant macros cleared
the keep flag.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.217 2011/02/06 22:33:38 schwarze Exp $ */
d358 1
@


1.217
log
@Some pre-handlers produce output, so reorder the code to set up
keep flags before they are called.
Without this bugfix, .Bk was ineffective in some cases.
"looks reasonable" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.216 2011/02/06 21:44:36 kristaps Exp $ */
d1716 1
d1744 1
d1747 1
a1747 1
		p->flags &= ~TERMP_KEEP;
@


1.216
log
@Add initial libmdoc and libman top-most machinery for accepting TBL
directives.  For now this will just ignore them (except for -Ttree,
which just notes that an EQN's been accepted).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.215 2011/02/02 21:40:45 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
a314 18
	
	switch (n->type) {
	case (MDOC_TEXT):
		if (' ' == *n->string && MDOC_LINE & n->flags)
			term_newln(p);
		term_word(p, n->string);
		break;
	case (MDOC_EQN):
		break;
	case (MDOC_TBL):
		term_tbl(p, n->span);
		break;
	default:
		if (termacts[n->tok].pre && ENDBODY_NOT == n->end)
			chld = (*termacts[n->tok].pre)
				(p, &npair, m, n);
		break;
	}
d346 23
d2199 1
a2199 1
	if (n->parent && MDOC_Rs == n->parent->tok && 
@


1.215
log
@If `Ns' is specified on its own line, it should be ignored.  This is
shitty groff behaviour.  Do the same, but raise a warning to this
effect.  This from a TODO noted by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.214 2011/01/25 16:20:24 kristaps Exp $ */
d322 2
d374 2
@


1.214
log
@Arguments to `Bsx' and friends are separated by a non-breaking space.
This removes a TODO raised by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.213 2011/01/25 15:46:05 kristaps Exp $ */
d1154 2
a1155 1
	p->flags |= TERMP_NOSPACE;
@


1.213
log
@Push capitalisation of `Bx' second argument into validator, where it belongs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.212 2011/01/25 15:28:56 kristaps Exp $ */
a1730 1
	assert(pp);
d1732 6
a1737 1
	return(1);
@


1.212
log
@Properly uppercase the first-letter of the `Bx' second argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.211 2011/01/25 15:17:18 kristaps Exp $ */
a1679 1
	char		 buf[3];
a1690 4
		buf[0] = '-';
		buf[1] = toupper((unsigned char)*n->string);
		buf[2] = '\0';

d1692 1
a1692 1
		term_word(p, buf);
d1694 1
a1694 1
		term_word(p, n->string + 1);
@


1.211
log
@Have `Bx' accept two arguments, not just one, and join these arguments
with "xxBSD-yy"
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.210 2011/01/25 10:37:49 kristaps Exp $ */
d1680 1
d1692 4
d1697 1
a1697 1
		term_word(p, "-");
d1699 1
a1699 1
		term_word(p, n->string);
@


1.210
log
@If %B is specified, quote %T.  Noted by schwarze@@ in the TODO.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.209 2011/01/12 10:43:22 kristaps Exp $ */
a75 1
static	void	  termp_bx_post(DECL_ARGS);
d97 1
d190 1
a190 1
	{ NULL, termp_bx_post }, /* Bx */
d1677 2
a1678 2
static void
termp_bx_post(DECL_ARGS)
d1681 12
a1692 1
	if (n->child)
d1694 4
a1697 1
	term_word(p, "BSD");
@


1.209
log
@If the first character of free-form text is whitespace, then a newline
shall precede outputted text (surprise!).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.208 2011/01/06 14:05:12 kristaps Exp $ */
d2172 1
a2172 1
			n->parent->norm->Rs.child_J)
d2188 1
a2188 1
			n->parent->norm->Rs.child_J)
@


1.208
log
@Make -literal displays only have 8-character displays.  From a
low-hanging TODO added by schwarze@@ on 15/08/10.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.207 2011/01/02 12:21:07 kristaps Exp $ */
d318 2
@


1.207
log
@Turn on -Tascii tbl printing.  The output still has some issues---I'm
not sure whether it's in the header calculation or term.c squashing
spaces or whatever, but let's get this in for general testing as soon as
possible.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.206 2011/01/01 12:18:37 kristaps Exp $ */
d1602 3
a1604 1
	p->tabwidth = term_len(p, 8);
@


1.206
log
@Add table processing structures to -mdoc.  This consists of an
external-facing function mdoc_addspan(), then various bits to prohibit
printing and scanning (this requires some if's to be converted into
switch's).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.205 2010/12/25 23:27:50 kristaps Exp $ */
d321 1
@


1.205
log
@As pointed out by schwarze@@, %T/%J renders with a normal double-quote, not
the fancy double-quote.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.204 2010/12/25 23:25:53 kristaps Exp $ */
d315 13
a327 5

	if (MDOC_TEXT == n->type)
		term_word(p, n->string); 
	else if (termacts[n->tok].pre && ENDBODY_NOT == n->end)
		chld = (*termacts[n->tok].pre)(p, &npair, m, n);
d364 8
a371 2
	if (MDOC_TEXT != n->type && termacts[n->tok].post && 
			! (MDOC_ENDED & n->flags)) {
d389 1
@


1.204
log
@Implement schwarze@@'s much more elegant version of my %T/%J fix.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.203 2010/12/25 13:50:37 kristaps Exp $ */
a1857 2
	case (MDOC__T):
		/* FALLTHROUGH */
d1868 2
a1921 2
	case (MDOC__T):
		/* FALLTHROUGH */
d1932 2
@


1.203
log
@Specifying both %T and %J in an `Rs' block causes the title to be quoted
instead of underlined.  This only happens in -Tascii, as -T[x]html both
underlines and italicises.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.202 2010/12/24 14:00:40 kristaps Exp $ */
d2151 2
a2152 2
	if (n->parent && MDOC_Rs == n->parent->tok &&
			n->parent->norm->Rs.titlejournal)
d2168 1
a2168 1
			n->parent->norm->Rs.titlejournal)
@


1.202
log
@As per schwarze@@'s suggestions, roll back the refcount structure in
favour of a simpler shim for normalised data in the node allocation and
free routines.  This removes the need to bump and copy references within
validator handlers, removes a pointer redirect, and also kills the
refcount structure itself.  Data is assumed to "live" either in a
MDOC_BLOCK or MDOC_ELEM and is copied accordingly.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.201 2010/12/22 11:15:16 kristaps Exp $ */
d71 1
d89 1
d179 1
a179 1
	{ termp_under_pre, termp____post }, /* %T */
d1835 1
a1835 1
	if (MDOC_BODY != n->type)
d1858 2
d1897 1
a1897 1
	if (MDOC_BODY != n->type)
d1922 2
d2143 33
@


1.201
log
@Implement reference-counted version of original union mdoc_data.  This
simplifies clean-up and allows for more types without extra hassle.

Also made in-line literal types in -T[x]html use CODE instead of SPAN to
match how literal blocks use PRE.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.200 2010/12/19 12:11:42 schwarze Exp $ */
d559 1
a559 1
	if (MDOC_Bd == bl->tok && bl->norm->d.Bd.comp)
d561 1
a561 1
	if (MDOC_Bl == bl->tok && bl->norm->d.Bl.comp)
d580 1
a580 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->norm->d.Bl.type)
d586 1
a586 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->norm->d.Bl.type)
d613 1
a613 1
	type = bl->norm->d.Bl.type;
d623 2
a624 2
	if (bl->norm->d.Bl.offs)
		offset = a2offs(p, bl->norm->d.Bl.offs);
d640 1
a640 1
		ncols = bl->norm->d.Bl.ncols;
d655 1
a655 1
				(p, bl->norm->d.Bl.cols[i]);
d670 1
a670 1
		width = a2width(p, bl->norm->d.Bl.cols[i]) + dcol;
d673 1
a673 1
		if (NULL == bl->norm->d.Bl.width)
d681 2
a682 2
		assert(bl->norm->d.Bl.width);
		width = a2width(p, bl->norm->d.Bl.width) + term_len(p, 2);
d944 1
a944 1
	type = n->parent->parent->parent->norm->d.Bl.type;
d1118 1
a1118 1
	if (AUTH_split == n->norm->d.An.auth) {
d1121 1
a1121 1
	} else if (AUTH_nosplit == n->norm->d.An.auth) {
d1568 2
a1569 2
	if (n->norm->d.Bd.offs)
		p->offset += a2offs(p, n->norm->d.Bd.offs);
d1579 2
a1580 2
	if (DISP_literal != n->norm->d.Bd.type && 
			DISP_unfilled != n->norm->d.Bd.type)
d1642 2
a1643 2
	if (DISP_literal == n->norm->d.Bd.type || 
			DISP_unfilled == n->norm->d.Bd.type)
d1998 1
a1998 1
	if (FONT_Em == n->norm->d.Bf.font) 
d2000 1
a2000 1
	else if (FONT_Sy == n->norm->d.Bf.font) 
@


1.200
log
@Handle .Bk the same way as groff 1.20.1:
.Bk without arguments defaults to -words.
.Bk with invalid arguments (including -lines) has no effect.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.199 2010/12/16 17:14:48 kristaps Exp $ */
d559 1
a559 1
	if (MDOC_Bd == bl->tok && bl->data.Bd->comp)
d561 1
a561 1
	if (MDOC_Bl == bl->tok && bl->data.Bl->comp)
d580 1
a580 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.Bl->type)
d586 1
a586 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.Bl->type)
d613 1
a613 2
	assert(bl->data.Bl);
	type = bl->data.Bl->type;
d623 2
a624 2
	if (bl->data.Bl->offs)
		offset = a2offs(p, bl->data.Bl->offs);
d640 1
a640 1
		ncols = bl->data.Bl->ncols;
d655 1
a655 1
				(p, bl->data.Bl->cols[i]);
d670 1
a670 1
		width = a2width(p, bl->data.Bl->cols[i]) + dcol;
d673 1
a673 1
		if (NULL == bl->data.Bl->width)
d681 2
a682 2
		assert(bl->data.Bl->width);
		width = a2width(p, bl->data.Bl->width) + term_len(p, 2);
d944 1
a944 1
	type = n->parent->parent->parent->data.Bl->type;
d1118 1
a1118 1
	if (AUTH_split == n->data.An->auth) {
d1121 1
a1121 1
	} else if (AUTH_nosplit == n->data.An->auth) {
d1568 2
a1569 3
	assert(n->data.Bd);
	if (n->data.Bd->offs)
		p->offset += a2offs(p, n->data.Bd->offs);
d1579 2
a1580 2
	if (DISP_literal != n->data.Bd->type && 
			DISP_unfilled != n->data.Bd->type)
d1642 2
a1643 3
	assert(n->data.Bd);
	if (DISP_literal == n->data.Bd->type || 
			DISP_unfilled == n->data.Bd->type)
d1998 1
a1998 3
	assert(n->data.Bf);

	if (FONT_Em == n->data.Bf->font) 
d2000 1
a2000 1
	else if (FONT_Sy == n->data.Bf->font) 
@


1.199
log
@Migrate `An' to use a pointer in its data, like everybody else.  This is
the first step to having a simpler ref-counted system for "data"
associated with a node.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.198 2010/12/15 23:44:02 kristaps Exp $ */
d2120 2
a2121 1
		p->flags |= TERMP_PREKEEP;
@


1.198
log
@Remove `Pp' and `Lp' checks in front-ends to make sure we're not
printing as the first or last child of an `Ss' or `Sh': this is now
ensured within the validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.197 2010/12/11 14:40:51 schwarze Exp $ */
d1119 1
a1119 1
	if (AUTH_split == n->data.An.auth) {
d1122 1
a1122 1
	} else if (AUTH_nosplit == n->data.An.auth) {
@


1.197
log
@Make SYNOPSIS sections and code having .nr nS enabled
behave as if the whole code were wrapped in .Bk/.Ek,
i.e. keeping input lines together on output lines.
This is compatible with new groff behaviour and deviates
from historical groff.
Tweaked version of a patch sent by kristaps@@ on July 16, 2010.
ok kristaps@@ jmc@@ sobrado@@ millert@@
@
text
@d1 1
a1 1
/*	$Id$ */
a1817 5
		assert(n->parent);
		if ((NULL == n->next || NULL == n->prev) &&
				(MDOC_Ss == n->parent->tok ||
				 MDOC_Sh == n->parent->tok))
			return(0);
@


1.196
log
@Merge schwarze@@'s changes allowing nested displays.  Tweak the patch by
making sure output doesn't add a superfluous newline with the nested displays.
Also add a COMPATIBILITY note.

Rename a macro (DATESIZ) to be in line with OpenBSD (DATESIZE).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.195 2010/11/29 13:02:47 kristaps Exp $ */
d322 3
d327 1
a327 1
	if (TERMP_KEEP & p->flags) {
d339 10
@


1.195
log
@Move `Mt', `Ar', and `Li' handling from mdoc_action.c into mdoc_validate.c.

Clarify that `Mt' gets a default `~' (as per groff 1.20) and document it
in mdoc.7.

Made `Lk' be removed in mdoc_macro.c if it has no arguments.  This fixes
segfaults in mdoc_{term,html}.c that nobody's managed to raise yet.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.194 2010/10/23 23:31:10 schwarze Exp $ */
d1595 4
@


1.194
log
@let .Bsx print just "BSD/OS" like in modern groff
from Ulrich Spoerlein <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.193 2010/10/10 09:59:48 kristaps Exp $ */
d2079 1
a2079 1
	if (NULL == nn->next)
@


1.193
log
@`Sm' no longer produces a linebreak when used in `Bd'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.192 2010/10/01 21:51:13 schwarze Exp $ */
d1660 1
a1660 1
		pp = "BSDI BSD/OS";
@


1.192
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id$ */
d1587 2
@


1.191
log
@Merge from OpenBSD right after 1.10.6; now back to full sync.
* mdoc.c: blank lines outside literal mode are more similar to .sp than .Pp
* backslashes do not terminate macros; partial revert of mdoc.c 1.164;
  the intention of that commit is fully achieved in roff.c
* mdoc_term.c: no need to list the same prototype twice
* mdoc_validate.c: drop .Pp before .sp just like .Pp before .Pp
* fix off-by-one found by jsg@@ with parfait, OpenBSD term_ps.c 1.12
ok kristaps@@
@
text
@d105 1
a112 1
static	int	  termp_pf_pre(DECL_ARGS);
d199 1
a199 1
	{ NULL, NULL }, /* No */
d204 1
a204 1
	{ termp_pf_pre, termp_pf_post }, /* Pf */
d1687 1
a1687 1
termp_pf_pre(DECL_ARGS)
a1699 1
	p->flags &= ~TERMP_IGNDELIM;
@


1.190
log
@Suppress whitespace following Pp, Lp, sp, and the other newline-emitting
macros within an unfilled or literal `Bd'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.189 2010/09/26 10:00:42 kristaps Exp $ */
a83 1
static	void	  termp_quote_post(DECL_ARGS);
@


1.189
log
@Linted function arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.188 2010/09/26 09:16:02 kristaps Exp $ */
d1581 20
@


1.188
log
@Big clean-up consolidating all punctuation opening/closing functions into
a single one.  This makes code auditing easier and cuts down on
bytesize.

I also removed some NOSPACE clauses that were handled implicitly by the
punctuation itself, e.g., a NOSPACE prior to printing ')', which in
term.c has its leading whitespace automatically suppressed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.187 2010/09/25 16:41:33 kristaps Exp $ */
d1799 1
d1859 1
@


1.187
log
@A `%T' invoked outside of `Rs' should not produce trailing punctuation.
This from a TODO entry.  Also stripped the superfluous NOSPACE, which is
handled in term_word() or print_text() anyway.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.186 2010/09/25 15:51:30 kristaps Exp $ */
a71 1
static	void	  termp_aq_post(DECL_ARGS);
a74 2
static	void	  termp_bq_post(DECL_ARGS);
static	void	  termp_brq_post(DECL_ARGS);
a76 2
static	void	  termp_dq_post(DECL_ARGS);
static	int	  termp_fd_pre(DECL_ARGS);
a81 1
static	void	  termp_op_post(DECL_ARGS);
d83 2
a84 2
static	void	  termp_pq_post(DECL_ARGS);
static	void	  termp_qq_post(DECL_ARGS);
a85 1
static	void	  termp_sq_post(DECL_ARGS);
a90 1
static	int	  termp_aq_pre(DECL_ARGS);
a95 2
static	int	  termp_bq_pre(DECL_ARGS);
static	int	  termp_brq_pre(DECL_ARGS);
a98 1
static	int	  termp_dq_pre(DECL_ARGS);
d101 1
a112 1
static	int	  termp_op_pre(DECL_ARGS);
d114 1
a114 2
static	int	  termp_pq_pre(DECL_ARGS);
static	int	  termp_qq_pre(DECL_ARGS);
a119 1
static	int	  termp_sq_pre(DECL_ARGS);
d161 1
a161 1
	{ termp_op_pre, termp_op_post }, /* Op */
d181 2
a182 2
	{ termp_aq_pre, termp_aq_post }, /* Ao */
	{ termp_aq_pre, termp_aq_post }, /* Aq */
d186 2
a187 2
	{ termp_bq_pre, termp_bq_post }, /* Bo */
	{ termp_bq_pre, termp_bq_post }, /* Bq */
d192 2
a193 2
	{ termp_dq_pre, termp_dq_post }, /* Do */
	{ termp_dq_pre, termp_dq_post }, /* Dq */
d206 2
a207 2
	{ termp_pq_pre, termp_pq_post }, /* Po */
	{ termp_pq_pre, termp_pq_post }, /* Pq */
d209 3
a211 3
	{ termp_sq_pre, termp_sq_post }, /* Ql */
	{ termp_qq_pre, termp_qq_post }, /* Qo */
	{ termp_qq_pre, termp_qq_post }, /* Qq */
d215 2
a216 2
	{ termp_sq_pre, termp_sq_post }, /* So */
	{ termp_sq_pre, termp_sq_post }, /* Sq */
d226 1
a226 1
	{ termp_op_pre, termp_op_post }, /* Oo */
d238 2
a239 2
	{ termp_brq_pre, termp_brq_post }, /* Brq */ 
	{ termp_brq_pre, termp_brq_post }, /* Bro */ 
a586 27
termp_dq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);

	term_word(p, "\\(lq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_dq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rq");
}


/* ARGSUSED */
static int
a1251 12
static void
termp_op_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type) 
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rB");
}


/* ARGSUSED */
a1267 1
	p->flags |= TERMP_NOSPACE;
a1268 1
	p->flags |= TERMP_NOSPACE;
a1417 17
termp_op_pre(DECL_ARGS)
{

	switch (n->type) {
	case (MDOC_BODY):
		term_word(p, "\\(lB");
		p->flags |= TERMP_NOSPACE;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
a1473 25
termp_aq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\(la");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_aq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(ra");
}


/* ARGSUSED */
static int
a1619 25
static int
termp_qq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\"");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_qq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\"");
}


/* ARGSUSED */
a1667 25
termp_sq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\(oq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_sq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(aq");
}


/* ARGSUSED */
static int
a1798 1
/* ARGSUSED */
d1800 1
a1800 1
termp_brq_pre(DECL_ARGS)
a1804 4
	term_word(p, "\\(lC");
	p->flags |= TERMP_NOSPACE;
	return(1);
}
d1806 46
a1852 20
/* ARGSUSED */
static void
termp_brq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rC");
}


/* ARGSUSED */
static int
termp_bq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\(lB");
a1857 1
/* ARGSUSED */
d1859 1
a1859 1
termp_bq_post(DECL_ARGS)
a1863 4
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rB");
}

a1864 8
/* ARGSUSED */
static int
termp_pq_pre(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	term_word(p, "\\&(");
a1865 2
	return(1);
}
d1867 46
a1912 9

/* ARGSUSED */
static void
termp_pq_post(DECL_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	term_word(p, ")");
a1926 1
		p->flags |= TERMP_NOSPACE;
a1949 1
	p->flags |= TERMP_NOSPACE;
d1952 1
a1952 2
	if (MDOC_SYNPRETTY & n->flags) {
		p->flags |= TERMP_NOSPACE;
a1953 1
	}
d2003 1
a2003 1
	term_word(p, "\\(aq");
a2064 1
	p->flags |= TERMP_NOSPACE;
@


1.186
log
@Add `Rs' vertical-space in -T[x]html "SEE ALSO" section.  Remove
corresponding TODO entry.

Also have the "." after an `Rs' block trigger inter-sentence spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.185 2010/09/23 20:40:00 schwarze Exp $ */
d2133 3
a2135 1
	p->flags |= TERMP_NOSPACE;
@


1.185
log
@When the HEAD of an .Nm block in the SYNOPSIS might be wider
than the column containing it, the TERMP_HANG flag is required,
but avoid the flag when we know that the HEAD is shorter,
because in that case, the flag might ruin the alignment.

Problem originally reported by jmc@@, who also spotted a regression
in an earlier version of this patch.

"feel free to commit" kristaps@@
@
text
@d1 1
a1 1
/*	$Id$ */
d2134 5
a2138 1
	term_word(p, n->next ? "," : ".");
@


1.184
log
@Properly handle -mdoc %A in all outputs.  This has two-author entires
separated by only "and" while two or more are with ", and" for the last
author.

Also remove relevant TODO and add regression tests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.183 2010/08/21 14:04:13 schwarze Exp $ */
d1034 12
a1045 6
		p->flags |= TERMP_NOSPACE | TERMP_NOBREAK | TERMP_HANG;
		p->rmargin = p->offset + term_len(p, 1) +
		    (NULL == n->child ? term_strlen(p, m->name) :
		     MDOC_TEXT == n->child->type ?
			term_strlen(p, n->child->string) :
		     term_len(p, 5));
@


1.183
log
@Backout previous.
As Kristaps found out, i was wrong: .Bl -column phrases do not ignore
spacing rules for trailing punctuation in general.  In particular,
- the rightmost column of a column list is unaffected
- columns terminated by the .Ta macro instead of a tab are unaffected
- columns ending in a blank are unaffected
Spacing rules for trailing punctuation are only ignored when the tab
follows the punctuation immediately, without a blank in between,
because then the combination of punctuation and tab is treated by roff
as a word, and the punctuation is not recognized as isolated.
The reason this doesn't work in mandoc is that in the special case
of .Bl -column (not in general!), mandoc treats tabs as word delimiters.
We either need to solve this differently, or call it a bug in roff.
@
text
@d1 1
a1 1
/*	$Id$ */
d95 1
d182 1
a182 1
	{ NULL, termp____post }, /* %A */
d1083 13
d2115 10
@


1.182
log
@.Bl -column phrases ignore spacing rules for trailing punctuation
and render it just like normal text.
Minimal fix of a formatting bug in operator(7) reported by ray@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.181 2010/08/09 00:00:37 kristaps Exp $ */
a844 2
		p->flags |= TERMP_IGNDELIM;

a1002 7

	/*
	 * TERMP_IGNDELIM is also set by `Pf', but it is safe
	 * to clear it here because `Pf' cannot contain `It'.
	 */

	p->flags &= ~TERMP_IGNDELIM;
a1806 4
	/*
	 * XXX Resetting TERMP_IGNDELIM here is not safe
	 * because `Pf' can be used inside `Bl -column'.
	 */
@


1.181
log
@Correctly print `Lk' arguments in -Tascii.  Issue raised by Aldis Berzoja.
Behaviour ok'd by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.180 2010/08/07 17:11:17 schwarze Exp $ */
d845 2
d1005 7
d1816 4
@


1.180
log
@merge from OpenBSD mdoc_term.c rev. 1.100:
preserve blank lines in .Bd -literal,
both in the middle and at the end of the display
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.179 2010/07/27 08:38:04 kristaps Exp $ */
d2122 1
a2122 1
	const struct mdoc_node *nn;
d2125 2
a2126 1
	nn = n->child;
d2131 3
a2133 1
	term_word(p, nn->string);
d2140 1
a2140 2
	for (nn = nn->next; nn; nn = nn->next) 
		term_word(p, nn->string);
@


1.179
log
@Fix how `Bd -unfilled' and `Bd -literal' break lines.  This unbreaks
displays to work as old groff shows them; however, new groff still does
some fancy shit.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.178 2010/07/26 22:35:59 kristaps Exp $ */
a1655 2
		if (nn->prev && nn->prev->line < nn->line)
			term_newln(p);
d1657 4
@


1.178
log
@`Ad' is supposed to underline.  Found whilst trolling through manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.177 2010/07/21 21:55:33 schwarze Exp $ */
d1624 1
a1624 2
	size_t			 tabwidth;
	size_t			 rm, rmax;
d1656 2
a1657 1
		p->flags |= TERMP_NOSPACE;
a1658 4
		if (NULL == nn->prev ||
		    nn->prev->line < nn->line ||
		    NULL == nn->next)
			term_flushln(p);
@


1.177
log
@In the SYNOPSIS, .Nm at the beginning of an input line starts
an .Nm block, and gets special handling (new line, indentation).
But .Nm in the middle of a line is just a normal in-line element,
so make sure it does NOT get the special handling.
Partly fixes the test(1) SYNOPSIS; indentation after "[" is still
excessive, which is an unrelated and more difficult issue.
Reminded of the problem by jmc@@;
OK kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.176 2010/07/19 11:11:54 kristaps Exp $ */
d154 1
a154 1
	{ NULL, NULL }, /* Ad */ 
@


1.176
log
@Remove some FIXMEs: `Ms' accepts arbitrary text, so it can't/shouldn't
be converted into a symbol.

The `Pp' issue has also been fixed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.175 2010/07/19 11:06:31 kristaps Exp $ */
d1029 2
a1030 1
	synopsis_pre(p, n);
@


1.175
log
@Fix spurrious newline emitted by `Pp' when specified before or after
`Sh'/`Ss'.  Reported by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.174 2010/07/16 00:03:37 schwarze Exp $ */
d211 1
a211 1
	{ termp_bold_pre, NULL }, /* Ms */ /* FIXME: convert to symbol? */
@


1.174
log
@After .Sm on, spacing ought to restart right away, before the next token,
and not with a delay, after the next token.  But be careful not to cause
leading white space at the beginning of a line or column.
In OpenBSD, improves chmod(1), ksh(1), tar(1), ps(1) and probably many more.
ok kristaps@@ and tested by jmc@@ and sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.173 2010/07/07 15:04:54 kristaps Exp $ */
d1908 5
@


1.173
log
@Re-constitution of `ds' symbol processing.  First, push the
roff_getstr() family of functions into roff.c with the "first_string"
directly in struct roff.  Second, pre-process each line for reserved
words in libroff, splicing and re-running a line if it has one (this
allows defined symbols to be macros).  Remove term.c's invocation of the
roff_getstrn() function.  Removed function documentation in roff.3 and
added roff.7 `ds' documentation.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.172 2010/07/06 10:54:05 kristaps Exp $ */
d2069 3
a2071 1
	if (0 == strcmp("on", n->child->string))
d2073 1
a2073 1
	else
@


1.172
log
@Proper `Bk -words' support: only suppress breaks within a line, but
allow end-of-line to break.  This fixes the bad behaviour found when
macros within `Bk' never break.

"Excellent" schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.171 2010/07/04 22:04:04 schwarze Exp $ */
a33 1
#include "regs.h"
@


1.171
log
@Assert my copyright, making it explicit that i'm granting the same license
on those parts of the code and text that i have written as Kristaps is.
"fine with me" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.170 2010/07/04 21:59:30 kristaps Exp $ */
d333 17
@


1.170
log
@Cache column sizes and char pointer into mdoc_bl.  Finally get rid of
the loops here and there to track down the MDOC_Column arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.169 2010/07/03 17:17:15 kristaps Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.169
log
@Allow empty `Fo' to get by without an assertion.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.168 2010/07/02 15:03:14 kristaps Exp $ */
a59 1
static	int	  arg_getattr(int, const struct mdoc_node *);
a528 20
 * Get the index of an argument in a node's argument list or -1 if it
 * does not exist.
 */
static int
arg_getattr(int v, const struct mdoc_node *n)
{
	int		 i;

	if (NULL == n->args)
		return(0);

	for (i = 0; i < (int)n->args->argc; i++) 
		if (n->args->argv[i].arg == v)
			return(i);

	return(-1);
}


/*
d613 1
a613 1
	int		        i, col;
a641 2
		col = arg_getattr(MDOC_Column, bl);

d651 2
a652 1
		ncols = bl->args->argv[col].sz;
d666 1
a666 1
				(p, bl->args->argv[col].value[i]);
d681 1
a681 1
		width = a2width(p, bl->args->argv[col].value[i]) + dcol;
@


1.168
log
@Cached `An' arguments in struct mdoc_an.  Note that this isn't a
pointer like the other data members, as there's no need to copy it around.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.167 2010/07/02 12:54:33 kristaps Exp $ */
d2015 3
a2019 1
	assert(n->child);
@


1.167
log
@Stash `Bf' parameters into struct mdoc_bf.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.166 2010/07/02 10:53:28 kristaps Exp $ */
a59 1
static	int	  arg_hasattr(int, const struct mdoc_node *);
a529 12
 * Return 1 if an argument has a particular argument value or 0 if it
 * does not.  See arg_getattr().
 */
static int
arg_hasattr(int arg, const struct mdoc_node *n)
{

	return(-1 != arg_getattr(arg, n));
}


/*
d1131 1
a1131 1
	if (arg_hasattr(MDOC_Split, n)) {
d1134 1
a1134 1
	} else {
@


1.166
log
@Lint fixes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.165 2010/07/01 22:56:17 kristaps Exp $ */
a2059 1
	const struct mdoc_node	*nn;
d2066 1
a2066 7
	if (NULL == (nn = n->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, n))
			term_fontpush(p, TERMFONT_UNDER);
		else if (arg_hasattr(MDOC_Symbolic, n))
			term_fontpush(p, TERMFONT_BOLD);
		else
			term_fontpush(p, TERMFONT_NONE);
d2068 1
a2068 5
		return(1);
	} 

	assert(MDOC_TEXT == nn->type);
	if (0 == strcmp("Em", nn->string))
d2070 1
a2070 1
	else if (0 == strcmp("Sy", nn->string))
d2072 1
a2072 1
	else
@


1.165
log
@Make struct_bl and struct_bd into pointers.  This removes the need to do
copying on internals after modification.  Even more importantly, if an
ENDBODY token is provided, it would have been impossible for post-change
copying of the data to take place in the BLOCK.  This allows it to
happen by dint of pointers.

Also did some bikeshedding in mdoc_term.c: checking against enum type
and explicitly casting to the "post" function to void.  This is for my
own readability.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.164 2010/07/01 15:38:56 schwarze Exp $ */
d2173 1
a2173 1
		return(1);
d2178 1
a2178 1
		return(1);
d2181 1
d2183 2
@


1.164
log
@Improve .Nm indentation in the SYNOPSIS;
kristaps@@ will do the missing HTML part soon.
"looks nicer" jmc@@
"seems perfect to me" sobrado@@
"slap it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.163 2010/07/01 14:34:03 kristaps Exp $ */
d339 3
a341 4
	if (MDOC_TEXT != n->type &&
	    termacts[n->tok].post &&
	    ! (MDOC_ENDED & n->flags)) {
		(*termacts[n->tok].post)(p, &npair, m, n);
d348 1
a348 1
		if (n->end)
d576 1
a576 1
	if (MDOC_Bd == bl->tok && bl->data.Bd.comp)
d578 1
a578 1
	if (MDOC_Bl == bl->tok && bl->data.Bl.comp)
d597 1
a597 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.Bl.type)
d603 1
a603 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.Bl.type)
d657 2
a658 1
	type = bl->data.Bl.type;
d668 2
a669 2
	if (bl->data.Bl.offs)
		offset = a2offs(p, bl->data.Bl.offs);
d719 1
a719 1
		if (NULL == bl->data.Bl.width)
d727 2
a728 2
		assert(bl->data.Bl.width);
		width = a2width(p, bl->data.Bl.width) + term_len(p, 2);
d990 1
a990 1
	type = n->parent->parent->parent->data.Bl.type;
d1651 3
a1653 2
	if (n->data.Bd.offs)
		p->offset += a2offs(p, n->data.Bd.offs);
d1663 2
a1664 2
	if (DISP_literal != n->data.Bd.type && 
			DISP_unfilled != n->data.Bd.type)
d1701 3
a1703 2
	if (DISP_literal == n->data.Bd.type || 
			DISP_unfilled == n->data.Bd.type)
@


1.163
log
@More reality-checks for the p->end type.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.162 2010/06/29 19:20:38 schwarze Exp $ */
d88 1
d174 1
a174 1
	{ termp_nm_pre, NULL }, /* Nm */ 
d1029 15
d1045 1
a1045 1
		return(1);
d1049 9
d1066 15
@


1.162
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.161 2010/06/27 17:53:27 schwarze Exp $ */
d330 1
a330 1
	else if (termacts[n->tok].pre && !n->end)
@


1.161
log
@minor .Bk fixes:
* do not print invalid arguments verbatim (no groffs prints them, either)
* do not trigger TERMP_PREKEEP twice
* do not die from invlid arguments (groff won't die, either)
* continue to ignore even valid arguments (just like groff)
ok kristaps@@ on the previous version, before removing my last bug ;)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.160 2010/06/27 16:18:13 kristaps Exp $ */
d328 1
a328 4
	if (MDOC_TEXT != n->type) {
		if (termacts[n->tok].pre)
			chld = (*termacts[n->tok].pre)(p, &npair, m, n);
	} else 
d330 2
d338 21
a358 3
	if (MDOC_TEXT != n->type)
		if (termacts[n->tok].post)
			(*termacts[n->tok].post)(p, &npair, m, n);
@


1.160
log
@Following clue-stick applied by schwarze@@, back out const-ness of regset
passed in to libmdoc and libman.

Fix mdoc.3 and man.3 EXAMPLE sections to include regset.

Add MDOC_SYNPRETTY flag cueing front-end to nicely format certain values
as if SEC_SYNOPSIS were the current section.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.159 2010/06/27 01:26:20 schwarze Exp $ */
d2112 11
a2122 2
	p->flags |= TERMP_PREKEEP;
	return(1);
d2131 2
a2132 1
	p->flags &= ~(TERMP_KEEP | TERMP_PREKEEP);
@


1.159
log
@Basic implementation of .Bk/.Ek; from OpenBSD.
OK and one stylistic tweak by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.158 2010/06/26 15:36:37 kristaps Exp $ */
d1281 1
a1281 1
	if (NULL == n->prev || SEC_SYNOPSIS != n->sec)
d1546 1
a1546 1
	if (SEC_SYNOPSIS == n->sec)
d1823 1
a1823 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
d1842 1
a1842 1
	if (SEC_SYNOPSIS == n->sec)
d1848 1
a1848 1
	if (SEC_SYNOPSIS == n->sec)
d1990 1
a1990 1
	if (SEC_SYNOPSIS == n->sec) {
@


1.158
log
@Churn-ish check-in getting mdoc_parseln() and man_parseln() to accept a
const struct regset pointer.  No functionality.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.157 2010/06/25 18:53:14 kristaps Exp $ */
d76 1
d101 1
d241 1
a241 1
	{ NULL, NULL }, /* Bk */
d2109 18
@


1.157
log
@Initial chunks for variable-width fonts.  Pushes all width calculations
in mdoc_term.c and man_term.c down into term.c.  This is still not
implemented in term.c, although stubs for width calculations are in
place.  From now on, offset, rmargin, and other layout variables are
abstract screen widths.  They will resolve to the the familiar values
for -Tascii but -Tps will eventually use points instead of chars.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.156 2010/06/19 20:46:28 kristaps Exp $ */
d33 1
@


1.156
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.155 2010/06/13 22:05:43 kristaps Exp $ */
d55 3
a57 3
static	size_t	  a2width(const char *);
static	size_t	  a2height(const struct mdoc_node *);
static	size_t	  a2offs(const char *);
d274 1
a274 1
	p->tabwidth = 5;
d372 2
a373 1
	p->rmargin = (p->maxrmargin - strlen(buf) + 1) / 2;
d380 1
a380 1
	p->rmargin = p->maxrmargin - strlen(os);
d436 2
a437 1
	p->rmargin = (p->maxrmargin - strlen(buf) + 1) / 2;
d444 1
a444 1
	p->rmargin = p->maxrmargin - strlen(title);
d465 1
a465 1
a2height(const struct mdoc_node *n)
d469 3
a471 4
	assert(MDOC_TEXT == n->type);
	assert(n->string);
	if ( ! a2roffsu(n->string, &su, SCALE_VS))
		SCALE_VS_INIT(&su, strlen(n->string));
d473 1
a473 1
	return(term_vspan(&su));
d478 1
a478 1
a2width(const char *v)
d484 1
a484 1
		SCALE_HS_INIT(&su, strlen(v));
d486 1
a486 1
	return(term_hspan(&su));
d491 1
a491 1
a2offs(const char *v)
d500 1
a500 1
		return(INDENT + 1);
d502 1
a502 1
		return((INDENT + 1) * 2);
d504 1
a504 1
		SCALE_HS_INIT(&su, strlen(v));
d506 1
a506 1
	return(term_hspan(&su));
d648 1
a648 1
		offset = a2offs(bl->data.Bl.offs);
d668 2
a669 1
		dcol = ncols < 5 ? 4 : ncols == 5 ? 3 : 1;
d680 1
a680 1
				(bl->args->argv[col].value[i]);
d695 1
a695 1
		width = a2width(bl->args->argv[col].value[i]) + dcol;
d707 1
a707 1
		width = a2width(bl->data.Bl.width) + 2;
d723 2
a724 2
		if (width < 4)
			width = 4;
d727 2
a728 2
		if (width < 5)
			width = 5;
d732 1
a732 1
			width = 8;
d738 1
a738 1
			width = 10;
d1379 1
a1379 1
		p->offset = INDENT;
d1464 1
a1464 1
	p->offset += (INDENT + 1);
d1592 1
a1592 1
		p->offset += a2offs(n->data.Bd.offs);
d1607 1
a1607 1
	p->tabwidth = 8;
d1782 1
a1782 1
		p->offset = HALFINDENT;
d1858 1
a1858 1
		len = n->child ? a2height(n->child) : 1;
@


1.155
log
@Remove arg_getattrs(), as we only have arg_getattr()-like calls now that
-width is cached.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.154 2010/06/13 21:41:58 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.154
log
@Switch on cached -width usage in front-ends.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.153 2010/06/13 21:02:49 kristaps Exp $ */
a59 2
static	int	  arg_getattrs(const int *, int *, size_t,
			const struct mdoc_node *);
d523 1
a523 1
 * does not exist.  See arg_getattrs().
d528 1
a528 17
	int		 val;

	return(arg_getattrs(&v, &val, 1, n) ? val : -1);
}


/*
 * Walk through the argument list for a node and fill an array "vals"
 * with the positions of the argument structures listed in "keys".
 * Return the number of elements that were written into "vals", which
 * can be zero.
 */
static int
arg_getattrs(const int *keys, int *vals, 
		size_t sz, const struct mdoc_node *n)
{
	int		 i, j, k;
d533 5
a537 7
	for (k = i = 0; i < (int)n->args->argc; i++) 
		for (j = 0; j < (int)sz; j++)
			if (n->args->argv[i].arg == keys[j]) {
				vals[j] = i;
				k++;
			}
	return(k);
d626 1
a626 1
	int		        i, keys[2], vals[2];
a635 10

	/* Get list width, offset, and list type from argument list. */

	keys[0] = MDOC_Width;
	keys[1] = MDOC_Column;

	vals[0] = vals[1] = -1;

	arg_getattrs(keys, vals, 2, bl);

a648 1

d653 3
d665 1
a665 1
		ncols = bl->args->argv[vals[1]].sz;
d678 1
a678 2
				(bl->args->argv[vals[1]].value[i]);

d693 1
a693 2
		width = a2width
			(bl->args->argv[vals[1]].value[i]) + dcol;
@


1.153
log
@Allow -width for lists to be cached in mdoc_bl.  This requires some
trickery because widths may be on-the-fly recalculated.  I don't like
how these are split between mdoc_action.c and mdoc_validate.c, but for
the time being, it'll do.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.152 2010/06/12 12:38:01 kristaps Exp $ */
d55 1
a55 1
static	size_t	  a2width(const struct mdoc_argv *, int);
d479 1
a479 1
a2width(const struct mdoc_argv *arg, int pos)
d483 3
a485 3
	assert(arg->value[pos]);
	if ( ! a2roffsu(arg->value[pos], &su, SCALE_MAX))
		SCALE_HS_INIT(&su, strlen(arg->value[pos]));
d706 1
a706 1
				(&bl->args->argv[vals[1]], i);
d722 2
a723 1
		width = a2width(&bl->args->argv[vals[1]], i) + dcol;
d726 1
a726 1
		if (vals[0] < 0) 
a733 1
		width = a2width(&bl->args->argv[vals[0]], 0) + 2;
d735 1
@


1.152
log
@Cached `Bl -offset' into mdoc_bl.  Removed erroneous "-offset defaults
to 6n if no value is specified" and added regression tests for `Bl'
testing against the empty -offset argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.151 2010/06/12 12:21:41 kristaps Exp $ */
d734 1
@


1.151
log
@Reverted to mdoc_term.c 1.149 (`It' does not inherit `Bl's cache,
obviously, which was causing fallout) and again remove the loop code.
Tested more thoroughly.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.149 2010/06/12 11:58:22 kristaps Exp $ */
d646 1
a646 1
	int		        i, keys[3], vals[3];
d660 1
a660 2
	keys[1] = MDOC_Offset;
	keys[2] = MDOC_Column;
d662 1
a662 1
	vals[0] = vals[1] = vals[2] = -1;
d664 1
a664 1
	arg_getattrs(keys, vals, 3, bl);
d676 3
a678 2
	if (vals[1] >= 0) 
		offset = a2offs(bl->args->argv[vals[1]].value[0]);
d693 1
a693 1
		ncols = bl->args->argv[vals[2]].sz;
d706 1
a706 1
				(&bl->args->argv[vals[2]], i);
d722 1
a722 1
		width = a2width(&bl->args->argv[vals[2]], i) + dcol;
@


1.150
log
@Moved `Bl -compact' into cached data.  This allowed the removal of
scanning the argv list in print_bvspace(), and thus the parent pointer.
@
text
@d64 1
d567 3
a569 1
print_bvspace(struct termp *p, const struct mdoc_node *n)
d575 1
a575 1
	if (MDOC_Bl == n->tok && n->data.Bl.comp)
d577 1
a577 1
	if (MDOC_Bd == n->tok && n->data.Bd.comp)
d596 1
a596 1
	if (MDOC_Bl == n->tok && LIST_column == n->data.Bl.type)
d602 1
a602 1
	if (MDOC_Bl == n->tok && LIST_diag == n->data.Bl.type)
d651 1
a651 1
		print_bvspace(p, n);
d1612 1
a1612 1
		print_bvspace(p, n);
@


1.149
log
@`Bl' is now using a struct instead of a single enum mdoc_list for its
cached values.  You can probably guess where this is going.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.148 2010/06/12 11:21:44 kristaps Exp $ */
a63 1
			const struct mdoc_node *,
d566 1
a566 3
print_bvspace(struct termp *p, 
		const struct mdoc_node *bl, 
		const struct mdoc_node *n)
a569 1
	/* FIXME: MDOC_Bd == bl->tok && bl->data.Bd.comp */
d571 4
a574 1
	if (arg_hasattr(MDOC_Compact, bl))
d593 1
a593 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.Bl.type)
d599 1
a599 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.Bl.type)
d648 1
a648 1
		print_bvspace(p, n->parent->parent, n);
d1609 1
a1609 1
		print_bvspace(p, n, n);
@


1.148
log
@Cache all of `Bd's resolved arguments into mdoc_bd, which is stashed in
the "data" union in mdoc_node.  Allows me to remove some ugly loops in
the front-end and duplicate tests in mdoc_action.c.  Add a regression
test to make sure we're not doing anything bad (more to come).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.147 2010/06/12 10:09:19 kristaps Exp $ */
d573 1
d594 1
a594 1
	if (MDOC_Bl == bl->tok && LIST_column == bl->data.list)
d600 1
a600 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.list)
d665 1
a665 1
	type = bl->data.list;
d993 1
a993 1
	type = n->parent->parent->parent->data.list;
@


1.147
log
@Added enum mdoc_disp (similar to enum mdoc_list).  Display types are now
only calculated once in mdoc_validate.c.

Noted that `Bd -file xxx' is not supported:  it now raises a fatal
warning.  This is noted in mdoc.7.

Empty `Bd' now defaults to LIST_ragged, which is not quite what groff
does, but close enough (gross just throws away the `Bd' and gets upset
when it encounters an `Ed').
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.146 2010/06/10 23:24:37 schwarze Exp $ */
d57 1
a57 1
static	size_t	  a2offs(const struct mdoc_argv *);
d492 1
a492 1
a2offs(const struct mdoc_argv *arg)
d496 1
a496 1
	if ('\0' == arg->value[0][0])
d498 1
a498 1
	else if (0 == strcmp(arg->value[0], "left"))
d500 1
a500 1
	else if (0 == strcmp(arg->value[0], "indent"))
d502 1
a502 1
	else if (0 == strcmp(arg->value[0], "indent-two"))
d504 2
a505 2
	else if ( ! a2roffsu(arg->value[0], &su, SCALE_MAX))
		SCALE_HS_INIT(&su, strlen(arg->value[0]));
d675 1
a675 1
		offset = a2offs(&bl->args->argv[vals[1]]);
a1604 1
	int	         	 i;
d1614 2
a1615 4
	nn = n->parent;

	if (-1 != (i = arg_getattr(MDOC_Offset, nn)))
		p->offset += a2offs(&nn->args->argv[i]);
d1625 2
a1626 2
	if (DISP_literal != n->data.disp && 
			DISP_unfilled != n->data.disp)
d1663 2
a1664 2
	if (DISP_literal == n->data.disp || 
			DISP_unfilled == n->data.disp)
@


1.146
log
@Fix a regression that crept in in man_term.c 1.73 and mdoc_term.c 1.144.
When the title line uses special characters, mandoc will segfault.
Thus, first set up the character tables, then print the header,
as we always did.

Found in OpenBSD /usr/src/usr.sbin/bind/bin/check/named-checkconf.8.

While here, set p->tabwidth in terminal_man() for symmetry
with terminal_mdoc(), as suggested by millert@@ (and already
committed to OpenBSD earlier).   Since 5 is the default, this
is not strictly required, but it is certainly clearer and more
robust.

"looks fine" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.145 2010/06/09 08:07:13 kristaps Exp $ */
a62 1
static	int	  arg_disptype(const struct mdoc_node *);
a490 29
static int
arg_disptype(const struct mdoc_node *n)
{
	int		 i, len;

	assert(MDOC_BLOCK == n->type);

	len = (int)(n->args ? n->args->argc : 0);

	for (i = 0; i < len; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Centred):
			/* FALLTHROUGH */
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	return(-1);
}


d1605 1
a1605 1
	int	         	 i, type;
a1616 3
	type = arg_disptype(nn);
	assert(-1 != type);

d1628 2
a1629 1
	if (MDOC_Literal != type && MDOC_Unfilled != type)
d1646 1
a1647 1

a1657 1
	int		 type;
a1662 3
	type = arg_disptype(n->parent);
	assert(-1 != type);

d1666 2
a1667 1
	if (MDOC_Literal == type || MDOC_Unfilled == type)
@


1.145
log
@Have the standard manpage header and footer print on every page of -Tps
output.  This is more tricky than you may think:  we can't just call the
header function out-of-state (i.e., before a flushln has occured)
because we'd clobber our current state.  Thus, we call at the beginning
and dump the output into an auxiliary buffer.

For the record, I don't think there's any other clean way to do this.
The only other Way That Works is to copy-aside *all* termp state, zero
it, and do the necessary headf/footf.  This is just as complex, as
memory needs to be alloc'd and free'd per margin.

Unfortunately, this prohibits page numbering (the margin is only printed
once), so I'll probably end up re-writing this down the line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.144 2010/06/07 20:57:09 kristaps Exp $ */
a278 3
	term_begin(p, print_mdoc_head, 
			print_mdoc_foot, mdoc_meta(mdoc));

d292 2
@


1.144
log
@First check-in of PostScript output.  This does not change any logic
within term.c, but does add a small shim over putchar() that switches on
the output engine.  Prints, for this initial version, only monospace and
without font decorations.  It's a start.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.143 2010/06/07 11:01:15 kristaps Exp $ */
d68 1
d70 1
a70 2
static	void	  print_mdoc_nodelist(DECL_ARGS);
static	void	  print_foot(struct termp *, const void *);
d279 2
a280 1
	term_begin(p, print_mdoc_head, print_foot, mdoc_meta(mdoc));
a351 1
/* ARGSUSED */
d353 1
a353 1
print_foot(struct termp *p, const void *arg)
a402 1
/* ARGSUSED */
@


1.143
log
@Normalise SYNOPSIS behaviour after I gave up on following groff's
inconsistent behaviour.  In short:

       Some macros are displayed differently in the SYNOPSIS
       section, particularly Nm, Cd, Fd, Fn, Fo, In, Vt, and Ft.
       All of these macros are output on their own line.  If two
       such dissimilar macros are pair-wise invoked (except for Ft
       before Fo or Fn), they are separated by a vertical space,
       unless in the case of Fo, Fn, and Ft, which are always
       separated by vertical space.

Behaviour ok Jason McIntyre, ingo@@.  Fallout will be treated
case-by-case.

I had to clear out some regressions that were testing against groff's
stranger behaviours: these will now break, as we don't care about such
invocations.

Also removed the newline for `Cd' invocation in a non-SYNOPSIS context.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.142 2010/06/06 22:08:15 schwarze Exp $ */
d68 1
a68 1
static	void	  print_mdoc_head(DECL_ARGS);
d70 1
a70 1
static	void	  print_foot(DECL_ARGS);
d279 2
a293 1
	print_mdoc_head(p, NULL, m, n);
d296 2
a297 1
	print_foot(p, NULL, m, n);
d353 1
a353 1
print_foot(DECL_ARGS)
d356 3
d405 1
a405 1
print_mdoc_head(DECL_ARGS)
d408 3
@


1.142
log
@Merge a fix to avoid a regression in OpenBSD:
Restore the blank line before .In in SYNOPSIS
except right after .Sh or right after another .In.

Even though Kristaps says SYNOPSIS blank-line handling
is still very much work in progress and more is probably needed,
this one is useful to keep in sync with OpenBSD.

"fine" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.141 2010/06/06 10:50:56 kristaps Exp $ */
d71 2
d84 1
a84 2
static	void	  termp_fd_post(DECL_ARGS);
static	void	  termp_fn_post(DECL_ARGS);
a95 1
static	void	  termp_vt_post(DECL_ARGS);
d165 1
a165 1
	{ termp_bold_pre, termp_fd_post }, /* Fd */ 
d167 1
a167 1
	{ termp_fn_pre, termp_fn_post }, /* Fn */ 
d180 1
a180 1
	{ termp_vt_pre, termp_vt_post }, /* Vt */
d1058 1
a1058 2
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		term_newln(p);
a1060 1

a1062 1

d1313 58
d1375 2
a1376 1
	if (MDOC_ELEM == n->type)
d1378 4
a1381 1
	else if (MDOC_HEAD == n->type)
a1382 2
	else if (MDOC_BLOCK == n->type)
		return(1);
a1388 14
static void
termp_vt_post(DECL_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return;
	if (n->next && MDOC_Vt == n->next->tok)
		term_newln(p);
	else if (n->next)
		term_vspace(p);
}


/* ARGSUSED */
d1399 2
a1400 2
static void
termp_fd_post(DECL_ARGS)
d1403 2
a1404 1
	term_newln(p);
d1558 1
a1558 3
	if (SEC_SYNOPSIS == n->sec && n->prev)
		term_vspace(p);

d1570 1
a1570 7
	/* NB: MDOC_LINE has no effect on this macro! */
	if (SEC_SYNOPSIS == n->sec) {
		if (n->prev && MDOC_Ft == n->prev->tok)
			term_newln(p);
		else if (n->prev)
			term_vspace(p);
	}
a1597 11
static void
termp_fn_post(DECL_ARGS)
{

	/* NB: MDOC_LINE has no effect on this macro! */
	if (SEC_SYNOPSIS == n->sec)
		term_newln(p);
}


/* ARGSUSED */
d1862 1
a1863 1
	term_newln(p);
d1873 1
a1873 2
	if (SEC_SYNOPSIS == n->sec && n->prev && MDOC_In != n->prev->tok)
		term_vspace(p);
d1894 1
a1894 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
d1900 1
a1900 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
a1901 2
		term_newln(p);
	}
d2012 1
a2012 7
		/* NB: MDOC_LINE has no effect on this macro! */
		if (SEC_SYNOPSIS != n->sec)
			return(1);
		if (n->prev && MDOC_Ft == n->prev->tok)
			term_newln(p);
		else if (n->prev)
			term_vspace(p);
d2036 7
a2042 5
	if (MDOC_BLOCK == n->type) {
		/* NB: MDOC_LINE has no effect on this macro! */
		if (SEC_SYNOPSIS == n->sec)
			term_newln(p);
	} else if (MDOC_BODY == n->type) {
d2044 1
a2044 5
		term_word(p, ")");
		if (SEC_SYNOPSIS == n->sec) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, ";");
		}
@


1.141
log
@Fixed -Tascii and -Thtml rendering of `Ft' and `Fo'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.140 2010/06/04 22:26:13 kristaps Exp $ */
d1848 3
@


1.140
log
@Fix following the first: `Ft' is given special treatment if specified before
`Fn'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.139 2010/06/04 22:16:27 kristaps Exp $ */
a84 1
static	void	  termp_ft_post(DECL_ARGS);
d168 1
a168 1
	{ termp_ft_pre, termp_ft_post }, /* Ft */ 
d1513 3
a1515 3
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		if (n->prev && MDOC_Fo == n->prev->tok)
			term_vspace(p);
a1522 10
static void
termp_ft_post(DECL_ARGS)
{

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		term_newln(p);
}


/* ARGSUSED */
a1984 1
	const struct mdoc_node *nn;
d1986 10
a1995 1
	if (MDOC_BODY == n->type) {
d2000 3
a2002 2
	} else if (MDOC_HEAD != n->type) 
		return(1);
d2004 2
d2007 1
a2007 6
	for (nn = n->child; nn; nn = nn->next) {
		assert(MDOC_TEXT == nn->type);
		term_word(p, nn->string);
	}
	term_fontpop(p);

d2017 12
a2028 7
	if (MDOC_BODY != n->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");
	p->flags |= TERMP_NOSPACE;
	term_word(p, ";");
	term_newln(p);
@


1.139
log
@Fixed `Fn' newline behaviour and added some regression tests to this
extent.

Documented `Fn'.  Please note the COMPATIBILITY note regarding historic
groff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.138 2010/06/04 21:49:39 kristaps Exp $ */
d1541 3
a1543 1
		if (n->prev)
@


1.138
log
@Documented `In' in full.

Fixed `In' to behave properly: it wasn't properly breaking lines,
formatting, or really anything else.  Noted COMPATIBILITY with
OpenBSD's groff, which pukes all over `In'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.137 2010/06/04 21:05:39 kristaps Exp $ */
d1539 6
d1575 3
a1577 2
	if (n->sec == SEC_SYNOPSIS && n->next && MDOC_LINE & n->flags)
		term_vspace(p);
@


1.137
log
@Fixed `Fd' to format in the right way.  Found when confused by what the
hell `Fd' is supposed to do anyway (answer: it's a historical macro and
we shouldn't be doing anything with it anyway).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.136 2010/06/01 14:51:09 kristaps Exp $ */
d1850 2
a1851 2
	term_fontpush(p, TERMFONT_BOLD);
	if (SEC_SYNOPSIS == n->sec)
d1853 5
a1858 1
	term_word(p, "<");
d1869 3
a1871 1
	term_fontpush(p, TERMFONT_BOLD);
a1873 1
	term_fontpop(p);
d1875 4
a1878 12
	if (SEC_SYNOPSIS != n->sec || ! (MDOC_LINE & n->flags))
		return;

	term_newln(p);
	/* 
	 * XXX Not entirely correct.  If `.In foo bar' is specified in
	 * the SYNOPSIS section, then it produces a single break after
	 * the <foo>; mandoc asserts a vertical space.  Since this
	 * construction is rarely used, I think it's fine.
	 */
	if (n->next && MDOC_In != n->next->tok)
		term_vspace(p);
@


1.136
log
@De Morgan's law not being applied properly.  Noted by Ulrich Spoerlein.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.135 2010/05/31 10:28:04 kristaps Exp $ */
a1360 3
	if (n->sec != SEC_SYNOPSIS || ! (MDOC_LINE & n->flags))
		return;

a1361 2
	if (n->next && MDOC_Fd != n->next->tok)
		term_vspace(p);
@


1.135
log
@Remove enum mdocargerr from phrase() (unused).

Add `Ta' macro, which is basically a NULL case everywhere but in
mdoc_macro.c, where it closes out an existing `It' body scope and opens
a new one, then continues parsing as in phrase() (TODO: merge these
two?).

Fix where scope-breaking was silently just dying instead of printing an
error.

Fix where trailing `Ta' or tab weren't creating a new MDOC_BODY context.

We now support arbitrarily complex `It' contents for `Bl -column'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.134 2010/05/30 22:56:02 kristaps Exp $ */
d1875 1
a1875 1
	if (SEC_SYNOPSIS != n->sec && ! (MDOC_LINE & n->flags))
@


1.134
log
@Migrate `Bl -column' phrases to be MDOC_BODY instead of MDOC_HEAD.  This
will make it easy for re-entrant parsing of `Ta' macros to fit in with
standard closure rules.

Added some more regressions for `Bl -column'.  Note that one should
fail, as documented in the TODO file.

Recorded change of AST BNF in mdoc.3.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.133 2010/05/29 18:58:52 kristaps Exp $ */
d263 1
@


1.133
log
@Moved printing of empty word [back] into mdoc_action.c so that it's not
mirrored across front-ends.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.132 2010/05/29 18:47:54 kristaps Exp $ */
d703 1
a703 1
		if (MDOC_BODY == n->type)
d718 5
d724 1
a724 1
				nn && i < (int)ncols; 
d877 12
a888 9
		if (MDOC_HEAD == n->type) {
			assert(n->next);
			if (MDOC_BODY == n->next->type)
				p->flags &= ~TERMP_NOBREAK;
			else
				p->flags |= TERMP_NOBREAK;
			if (n->prev) 
				p->flags |= TERMP_NOLPAD;
		}
d940 3
a942 3
		if (MDOC_HEAD == n->type &&
				MDOC_BODY == n->next->type &&
				p->rmargin < p->maxrmargin)
d996 1
a996 1
		if (MDOC_BODY == n->type)
d1028 1
a1028 1
		if (MDOC_HEAD == n->type)
@


1.132
log
@Commit of patch floated on discuss@@ a few days ago: if an in_line scope
has not been opened and closing punctuation is encountered AND the macro
is marked as accepting no-content (or `Li'), then open an empty scope.

Added regression tests for `Fl' and `Li' testing this behaviour.

Also, squeeze hyph0.in tests into the last characters of each line so
that groff doesn't hyphenate and break the test.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.131 2010/05/26 10:39:35 kristaps Exp $ */
a2100 2
	if (NULL == n->child)
		term_word(p, "");
@


1.131
log
@Documented `Ud'.

Proper EOS handling for `Rv', `Ex', `Ud', and `Bt'.

Both `Bt' and `Ud' now warn about and discard line arguments (reported
by Ulrich Spoerlein).

Collapsed posts_xr into posts_wtext (harmless: they're the same thing).

Added regressions for `Ud' and `Bt'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.130 2010/05/24 21:51:20 schwarze Exp $ */
d2101 2
@


1.130
log
@sync to OpenBSD:
save the visual cursor position in term_flushln()
and use that to avoid multiple blank lines in nested lists while
still putting subsequent empty list tags each on their own line;
"go ahead" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.129 2010/05/24 21:34:16 schwarze Exp $ */
d1195 1
d1228 1
d1430 1
d1451 1
@


1.129
log
@Handle literal tab characters both in literal context (.Bd -literal)
and outside.  In literal context, tab stops are at each eigth column;
outside, they are at each fifth column.

from OpenBSD mdoc_term.c rev. 1.75;
"commit" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.128 2010/05/24 14:35:59 schwarze Exp $ */
d1017 1
a1017 1
			term_flushln(p);
d1024 1
a1024 1
		term_flushln(p);
d1636 3
a1638 5
		if (NULL == nn->next)
			continue;
		if (nn->prev && nn->prev->line < nn->line)
			term_flushln(p);
		else if (NULL == nn->prev)
d1669 1
a1669 1
	term_flushln(p);
@


1.128
log
@fix an obvious typo in print_bvspace():
rev. 1.125 broke vertical spacing in .Bl -column
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.127 2010/05/22 20:41:48 joerg Exp $ */
d277 1
d1597 1
d1627 2
d1643 1
@


1.127
log
@Fix 1.125: Add missing return in termp_nm_pre.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.126 2010/05/17 23:57:06 kristaps Exp $ */
d616 1
a616 1
	if (MDOC_Bl == bl->tok && LIST_diag == bl->data.list)
@


1.126
log
@Increase performance by stashing the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can known whether to
dump list line arguments into the body (`Bl -column' overflowing).

Remove a2list() and arg_listtype() because of this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.125 2010/05/17 22:11:42 kristaps Exp $ */
d1047 1
@


1.125
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.124 2010/05/15 16:24:38 kristaps Exp $ */
a63 1
static	int	  arg_listtype(const struct mdoc_node *);
a513 41
static int
arg_listtype(const struct mdoc_node *n)
{
	int		 i, len;

	assert(MDOC_BLOCK == n->type);

	len = (int)(n->args ? n->args->argc : 0);

	for (i = 0; i < len; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	return(-1);
}


d616 1
a616 1
	if (MDOC_Bl == bl->tok && arg_hasattr(MDOC_Column, bl))
d622 1
a622 1
	if (MDOC_Bl == bl->tok && arg_hasattr(MDOC_Diag, bl)) 
d666 1
a666 1
	int		        i, type, keys[3], vals[3];
d668 1
d687 1
a687 2
	type = arg_listtype(bl);
	assert(-1 != type);
d701 1
a701 1
	case (MDOC_Column):
d759 1
a759 1
	case (MDOC_Bullet):
d761 1
a761 1
	case (MDOC_Dash):
d763 1
a763 1
	case (MDOC_Hyphen):
d767 1
a767 1
	case (MDOC_Enum):
d771 1
a771 1
	case (MDOC_Hang):
d775 1
a775 1
	case (MDOC_Column):
d777 1
a777 1
	case (MDOC_Tag):
d793 1
a793 1
	case (MDOC_Diag):
d797 1
a797 1
	case (MDOC_Inset):
d808 1
a808 1
	case (MDOC_Diag):
d824 1
a824 1
	case (MDOC_Bullet):
d826 1
a826 1
	case (MDOC_Dash):
d828 1
a828 1
	case (MDOC_Enum):
d830 1
a830 1
	case (MDOC_Hyphen):
d836 1
a836 1
	case (MDOC_Hang):
d859 1
a859 1
	case (MDOC_Tag):
d870 1
a870 1
	case (MDOC_Column):
d881 1
a881 1
	case (MDOC_Diag):
d898 1
a898 1
	case (MDOC_Hang):
d909 1
a909 1
	case (MDOC_Bullet):
d911 1
a911 1
	case (MDOC_Dash):
d913 1
a913 1
	case (MDOC_Enum):
d915 1
a915 1
	case (MDOC_Hyphen):
d917 1
a917 1
	case (MDOC_Tag):
d924 1
a924 1
	case (MDOC_Column):
d947 1
a947 1
		case (MDOC_Bullet):
d952 1
a952 1
		case (MDOC_Dash):
d954 1
a954 1
		case (MDOC_Hyphen):
d959 1
a959 1
		case (MDOC_Enum):
d974 1
a974 1
	case (MDOC_Bullet):
d976 1
a976 1
	case (MDOC_Item):
d978 1
a978 1
	case (MDOC_Dash):
d980 1
a980 1
	case (MDOC_Hyphen):
d982 1
a982 1
	case (MDOC_Enum):
d986 1
a986 1
	case (MDOC_Column):
d1002 1
a1002 1
	int		   type;
d1007 1
a1007 2
	type = arg_listtype(n->parent->parent->parent);
	assert(-1 != type);
d1010 1
a1010 1
	case (MDOC_Item):
d1012 1
a1012 1
	case (MDOC_Diag):
d1014 1
a1014 1
	case (MDOC_Inset):
d1018 1
a1018 1
	case (MDOC_Column):
@


1.124
log
@LIBRARY can also occur in section 9.
All manual sections (unknown, 3p, 3f, etc.) correctly handled by -mdoc.
Useful warning printed if unknown manual section.
Checking for manual sections (e.g., LIBRARY) checks only first character, so 3p, 3f, etc. are free.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.123 2010/05/15 16:18:23 joerg Exp $ */
d30 1
d1089 2
d1098 1
d1223 1
a1223 1
	if (n->child->next)
d1262 1
a1262 1
	if (n->child->next)
@


1.123
log
@Make the output width an option for ascii_alloc and use that to compute
the default margin. Hard-code 80 chars/line for now.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.122 2010/05/13 06:22:11 kristaps Exp $ */
d428 1
a428 1
	snprintf(title, BUFSIZ, "%s(%d)", m->title, m->msec);
@


1.122
log
@Fixed bug in -Thtml -mdoc where `Lb' would line-break in LIBRARY section.
Fixed assumption that parse-point == 1 equates to beginning of line (false if whitespace separates macro and control character).
Fixed line-break for non-first-macro in several SYNOPSIS macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.121 2010/05/12 16:01:01 kristaps Exp $ */
d276 1
a276 1
	p->maxrmargin = 78;
@


1.121
log
@Tiny EOS patch.  Back-end cues front-end through flag.  Front-end cues output engine with flag.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.120 2010/05/10 08:05:17 kristaps Exp $ */
d1088 1
a1088 1
	if (SEC_SYNOPSIS == n->sec)
d1387 1
a1387 1
	if (n->sec != SEC_SYNOPSIS)
d1474 1
a1474 1
	if (SEC_LIBRARY == n->sec)
d1543 1
a1543 1
	if (SEC_SYNOPSIS == n->sec)
d1557 1
a1557 1
	if (SEC_SYNOPSIS == n->sec)
d1598 1
a1598 1
	if (n->sec == SEC_SYNOPSIS && n->next)
d1897 1
a1897 1
	if (SEC_SYNOPSIS != n->sec)
@


1.120
log
@-man also now has unbound margins for literal context.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.119 2010/05/09 16:38:38 kristaps Exp $ */
d340 3
@


1.119
log
@Setting maxmargin, too (for completion).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.118 2010/05/09 16:05:13 kristaps Exp $ */
d1662 1
a1662 1
	p->rmargin = p->maxrmargin = 100000; /* FIXME */
d1698 1
a1698 1
		p->rmargin = p->maxrmargin = 100000; /* FIXME */
@


1.118
log
@Allow literal contexts to have unbound line lengths (from Ingo Schwarze's mandoc TODO by way of Jason McIntyre).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.117 2010/04/08 08:17:55 kristaps Exp $ */
d1632 1
a1632 1
	size_t			 sv;
d1660 3
a1662 2
	sv = p->rmargin;
	p->rmargin = 100000; /* FIXME */
d1675 2
a1676 1
	p->rmargin = sv;
d1686 1
a1686 1
	size_t		 sv;
d1694 2
a1695 1
	sv = p->rmargin;
d1698 1
a1698 1
		p->rmargin = 100000; /* FIXME */
d1703 2
a1704 1
	p->rmargin = sv;
@


1.117
log
@Fixed %T: it now correctly underlines, instead of quoting (noted by Jason McIntyre and posted on Ingo Schwarze' mandoc-todo list).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.116 2010/04/06 16:27:53 kristaps Exp $ */
d25 1
d62 1
d483 29
d1160 1
a1160 1
	if (arg_getattr(MDOC_Split, n) > -1) {
d1632 1
d1643 5
a1647 20
	for (type = -1, i = 0; i < (int)nn->args->argc; i++) {
		switch (nn->args->argv[i].arg) {
		case (MDOC_Centred):
			/* FALLTHROUGH */
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			type = nn->args->argv[i].arg;
			break;
		case (MDOC_Offset):
			p->offset += a2offs(&nn->args->argv[i]);
			break;
		default:
			break;
		}
	}
a1656 1
	assert(type > -1);
d1660 3
d1674 1
d1683 2
d1688 9
d1699 2
@


1.116
log
@Allow `Bd' to accept (warn about then ignore) in-line arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.115 2010/04/06 11:28:17 kristaps Exp $ */
a95 1
static	int	  termp__t_pre(DECL_ARGS);
d190 1
a190 1
	{ termp__t_pre, termp____post }, /* %T */
a2081 8
	switch (n->tok) {
	case (MDOC__T):
		term_word(p, "\\(rq");
		p->flags |= TERMP_NOSPACE;
		break;
	default:
		break;
	}
a2130 11


/* ARGSUSED */
static int
termp__t_pre(DECL_ARGS)
{

	term_word(p, "\\(lq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}
@


1.115
log
@Let `Bl' accept arguments on the head line with a warning (these are ignored in the front-end device) (noted by Theo de Raadt).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.114 2010/04/06 07:27:42 kristaps Exp $ */
d1607 2
a1608 2
	} else if (MDOC_BODY != n->type)
		return(1);
@


1.114
log
@`Fl' now correctly suppresses the trailing space if followed by macros on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.113 2010/04/03 14:25:12 kristaps Exp $ */
d102 1
d152 1
a152 1
	{ NULL, termp_bl_post }, /* Bl */
d1254 9
@


1.113
log
@Merged patch by Ingo Schwarze allowing `Xr' to pass through with no arguments (emits warning of course).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.112 2010/03/29 19:28:04 kristaps Exp $ */
a1072 2
	/* A blank `Fl' should incur a subsequent space. */

d1075 2
@


1.112
log
@Integrate Ingo Schwarze's patch for mdoc_iscdelim() (tri-state for opening and closing macro punctuation).
Modify blk_part_exp() to correctly handle leading punctuation before HEAD.
Significantly clean up and document blk_part_exp().
Modify blk_part_imp() for to correctly handle leading punctuation before HEAD.
Significantly clean up and document blk_part_imp().
Integrate Ingo Schwarze's patch for args() (using new mdoc_iscdelim() format).
Documented bad `Ec' handling for later work in mdoc_term.c/mdoc_html.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.111 2010/03/23 12:42:22 kristaps Exp $ */
d1280 4
a1283 1
	assert(n->child && MDOC_TEXT == n->child->type);
@


1.111
log
@Fixed two very subtle bugs in retaining overstep and maxrmargin widths between parse sequences.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.110 2010/01/30 08:42:21 kristaps Exp $ */
d206 1
a206 1
	{ NULL, NULL }, /* Ec */
@


1.110
log
@Fix in handling Vt in SYNOPSIS with trailing punctuation.  Spotted by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.109 2010/01/01 18:33:51 kristaps Exp $ */
d273 3
@


1.109
log
@Fix of subtle, but significant, resetting of tags when in list mode.  Pointed out by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.108 2010/01/01 18:01:40 kristaps Exp $ */
d135 1
d179 1
a179 1
	{ termp_under_pre, termp_vt_post }, /* Vt */
d1294 15
d1314 1
a1314 1
	if (n->sec != SEC_SYNOPSIS)
@


1.108
log
@More in-code documentation and clarity re-arrangements.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.107 2010/01/01 17:14:30 kristaps Exp $ */
a39 1
	int	  	  flag;	
a678 4
	/* Save parent attributes. */

	pair->flag = p->flags;

d820 4
a823 5
	 * Pad and break control.  This is the tricker part.  Lists with
	 * set right-margins for the head get TERMP_NOBREAK because, if
	 * they overrun the margin, they wrap to the new margin.
	 * Correspondingly, the body for these types don't left-pad, as
	 * the head will pad out to to the right.
d964 1
a964 1
			(void)snprintf(buf, sizeof(buf), "%d.", 
d1007 1
a1007 1
	if (MDOC_BODY != n->type && MDOC_HEAD != n->type)
d1031 11
a1041 1
	p->flags = pair->flag;
d2022 1
a2022 1
	if (0 == strcmp("on", n->child->string)) {
d2024 1
a2024 2
		p->flags &= ~TERMP_NOSPACE;
	} else
@


1.107
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.106 2010/01/01 14:32:52 kristaps Exp $ */
d473 1
a473 6
	/*
	 * This is a bit if a magic number on groff's part.  Be careful
	 * in changing it, as the MDOC_Column handler will subtract one
	 * from this for >5 columns (don't go below zero!).
	 */
	return(term_hspan(&su) + 2);
d538 4
d550 4
d563 6
d588 5
d671 1
a671 2
	size_t		        width, offset, ncols;
	int			dcol;
d684 1
a684 1
	/* Get list width and offset. */
d692 1
a692 3
	width = offset = 0;

	(void)arg_getattrs(keys, vals, 3, bl);
d697 8
a707 2
	/* Calculate real width and offset. */

a711 1

d713 7
a719 6
		 * Imitate groff's column handling.
		 * For each earlier column, add its width.
		 * For less than 5 columns, add two more blanks per column.
		 * For exactly 5 columns, add only one more blank per column.
		 * For more than 5 columns, SUBTRACT one column.  We can
		 * do this because a2width() pads exactly 2 spaces.
d722 9
a730 4
		dcol = ncols < 5 ? 2 : ncols == 5 ? 1 : -1;
		for (i=0, nn=n->prev; nn && i < (int)ncols; nn=nn->prev, i++)
			offset += a2width(&bl->args->argv[vals[2]], i) + 
				(size_t)dcol;
d733 4
a736 2
		 * Use the declared column widths,
		 * extended as explained in the preceding paragraph.
d738 2
a739 3
		if (i < (int)ncols)
			width = a2width(&bl->args->argv[vals[2]], i) + 
				(size_t)dcol;
d742 2
a743 4
		 * When exceeding the declared number of columns,
		 * leave the remaining widths at 0.
		 * This will later be adjusted to the default width of 10,
		 * or, for the last column, stretched to the right margin.
d745 1
d748 9
a756 2
		if (vals[0] >= 0) 
			width = a2width(&bl->args->argv[vals[0]], 0);
@


1.106
log
@Correct handling of arbitrary column lengths, which groff handles differently depending on number of visible columns.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.105 2010/01/01 14:27:59 kristaps Exp $ */
d17 4
a70 5
#ifdef __linux__
extern	size_t	  strlcpy(char *, const char *, size_t);
extern	size_t	  strlcat(char *, const char *, size_t);
#endif

@


1.105
log
@Cleaned-up column handling to be char-compatible with groff (thanks Ingo Schwarze).
Fixed assertion in exceeded rmargin by ridiculous columns.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.104 2010/01/01 13:35:30 kristaps Exp $ */
d474 5
a478 1
	/* XXX: pachemu? */
d658 2
a659 1
	size_t		        width, offset, ncols, dcol;
d702 2
a703 1
		 * For more than 5 columns, add no blanks per column.
d706 1
a706 2
		/* LINTED */
		dcol = ncols < 5 ? 2 : ncols == 5 ? 1 : 0;
d708 2
a709 7
			offset += a2width(&bl->args->argv[vals[2]], i) + dcol;

		/*
		 * FIXME: newer groff only wants one space between
		 * columns > 5; however, a2width will have min. two
		 * spaces.  For now, let this slide.
		 */
d716 2
a717 1
			width = a2width(&bl->args->argv[vals[2]], i) + dcol;
@


1.104
log
@Documented `Fl' in mdoc.7.
Backed out stipulation that `Fl ""' is ignored: this is not the case in !OpenBSD groffs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.103 2010/01/01 13:17:59 kristaps Exp $ */
d654 1
a654 1
	size_t		        width, offset;
d682 3
d691 23
a713 8
		/* 
		 * Work around groff's column handling.  The offset is
		 * equal to the sum of all widths leading to the current
		 * column (plus the -offset value).  If this column
		 * exceeds the stated number of columns, the width is
		 * set as 0, else it's the stated column width (later
		 * the 0 will be adjusted to default 10 or, if in the
		 * last column case, set to stretch to the margin).
d715 2
a716 11
		for (i = 0, nn = n->prev; nn && 
				i < (int)bl->args->argv[vals[2]].sz; 
				nn = nn->prev, i++)
			offset += a2width 
				(&bl->args->argv[vals[2]], i);

		/* Whether exceeds maximum column. */
		if (i < (int)bl->args->argv[vals[2]].sz)
			width = a2width(&bl->args->argv[vals[2]], i);
		else
			width = 0;
d718 6
a723 2
		if (vals[1] >= 0) 
			offset += a2offs(&bl->args->argv[vals[1]]);
a727 2
		if (vals[1] >= 0) 
			offset += a2offs(&bl->args->argv[vals[1]]);
d912 2
a913 1
				MDOC_BODY == n->next->type)
@


1.103
log
@`Fl' has each argument be in a separate scope (thanks Ingo Schwarze).
Situation of `Fl [arg]* "" [arg]*' is fixed: empty arguments are ignored.  Note that OpenBSD crashes when this happens.
Situation of `Fl' is fixed wrt trailing whitespace.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.102 2009/11/12 05:50:12 kristaps Exp $ */
a1021 10

	/* A zero-length child shouldn't get a dash. */

	if (n->child) {
		assert(MDOC_TEXT == n->child->type);
		assert(n->child->string);
		if ('\0' == *n->child->string)
			return(0);
	}

@


1.102
log
@Basically re-wrote -Tascii font handling: instead of incrementers for
bold and underline, we use a stack (no cascading, no double-font-mode).
Font modes with \f only affect the current stack point, as documented in
mdoc.7 and man.7.  While -mdoc stacks fonts with embedded macros, -man
replaces them (the stack is always size 1).  This works for all
invocations in supported systems' manual corpora to date.  It doesn't
support groff's insanity with line-scoped \f as documented in mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.101 2009/11/10 11:45:57 kristaps Exp $ */
d1022 10
d1033 6
a1038 1
	p->flags |= TERMP_NOSPACE;
@


1.101
log
@Disable metafonts when printing document footer.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.100 2009/10/31 06:50:25 kristaps Exp $ */
d62 3
a64 3
static	void  	  print_node(DECL_ARGS);
static	void	  print_head(DECL_ARGS);
static	void	  print_body(DECL_ARGS);
d119 1
d171 1
a171 1
	{ NULL, NULL }, /* Li */
d287 1
a287 1
	print_head(p, NULL, m, n);
d289 1
a289 1
		print_body(p, NULL, m, n->child);
d295 1
a295 1
print_body(DECL_ARGS)
d298 1
a298 1
	print_node(p, pair, m, n);
d300 1
a300 1
		print_body(p, pair, m, n->next);
d306 1
a306 1
print_node(DECL_ARGS)
d308 2
a309 1
	int		 chld, bold, under;
d316 1
a316 2
	bold = p->bold;
	under = p->under;
d326 1
d328 1
a328 1
		print_body(p, &npair, m, n->child);
d330 1
a330 8
	/*
	 * XXX - if bold/under were to span scopes, this wouldn't be
	 * possible, but because decoration is always in-scope, we can
	 * get away with this.
	 */

	p->bold = bold;
	p->under = under;
d347 1
a347 2
	/* Disable meta-fonts. */
	p->metafont = 0;
a389 1
/* FIXME: put in utility library. */
d392 1
a392 1
print_head(DECL_ARGS)
d778 1
a778 1
			p->bold++;
d916 1
a916 1
			p->bold++;
d918 1
a918 1
			p->bold--;
d923 1
a923 1
			p->bold++;
d925 1
a925 1
			p->bold--;
d1007 3
a1009 1
	p->bold++;
d1021 1
a1021 1
	p->bold++;
d1119 1
a1119 1
		p->bold++;
d1121 1
a1121 1
		p->bold--;
d1139 1
a1139 1
	p->under++;
d1141 1
a1141 1
	p->under--;
d1158 1
a1158 1
		p->bold++;
d1160 1
a1160 1
		p->bold--;
d1262 1
a1262 1
	p->bold++;
d1296 1
a1296 1
		p->bold++;
d1431 2
a1432 1
	p->under++;
d1453 1
a1453 1
	p->bold++;
d1455 1
a1455 1
	p->bold--;
d1461 1
a1461 1
		p->under++;
d1463 2
a1464 1
		p->under--;
d1495 1
a1495 1
		p->under++;
d1500 1
a1500 1
		p->under++;
d1502 2
a1503 1
		p->under--;
d1565 1
a1565 1
		print_node(p, pair, m, nn);
d1719 1
a1719 1
		p->bold++;
d1745 1
a1745 1
	p->bold++;
d1756 1
a1756 1
	p->bold++;
d1771 1
a1771 1
	p->bold++;
d1774 1
a1774 1
	p->bold--;
d1906 1
a1906 1
	p->bold++;
d1911 1
a1911 1
	p->bold--;
d1945 1
a1945 1
			p->under++;
d1947 3
a1949 1
			p->bold++;
d1956 1
a1956 1
		p->under++;
d1958 3
a1960 1
		p->bold++;
d2016 10
d2030 1
a2030 1
	p->under++;
d2037 1
a2037 1
	p->under--;
d2042 1
a2042 1
	p->bold++;
d2045 1
a2045 1
	p->bold--;
d2056 1
a2056 1
	p->under++;
@


1.100
log
@Patch on DragonFly BSD syntax (thanks Sascha Wildner).
Noted inclusion into DragonFly BSD (thanks Sascha Wildner).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.99 2009/10/30 18:53:09 kristaps Exp $ */
d352 3
@


1.99
log
@More lint fixes.
Removed err.h from inclusions (less main.c--still in progress).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.98 2009/10/27 08:49:44 kristaps Exp $ */
d1637 1
a1637 1
		pp = "DragonFlyBSD";
@


1.98
log
@Removed dynamic allocations of header/footer data.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.97 2009/10/27 08:26:12 kristaps Exp $ */
a20 1
#include <err.h>
@


1.97
log
@bzero() -> memset() (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.96 2009/10/26 04:09:46 kristaps Exp $ */
d351 1
a351 2
	char		 buf[DATESIZ];
	char		*os;
a360 3
	if (NULL == (os = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");

d362 1
a362 2

	(void)strlcpy(os, m->os, p->rmargin);
a390 2

	free(os);
d399 1
a399 1
	char		*buf, *title;
a403 5
	if (NULL == (buf = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");
	if (NULL == (title = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");

d418 1
a418 1
	(void)strlcpy(buf, m->vol, p->rmargin);
d421 3
a423 3
		(void)strlcat(buf, " (", p->rmargin);
		(void)strlcat(buf, m->arch, p->rmargin);
		(void)strlcat(buf, ")", p->rmargin);
d426 1
a426 1
	snprintf(title, p->rmargin, "%s(%d)", m->title, m->msec);
a452 3

	free(title);
	free(buf);
@


1.96
log
@Full `%U' support.
`Lk' display fixed.
Renamed arg2xxxx as a2xxxx for consistency.
Renamed print_foot to print_man_foot for consistency.
Removed default printing of `~' when `Lk' not provided (not sure where I got that from).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.95 2009/10/24 05:52:14 kristaps Exp $ */
d318 1
a318 1
	bzero(&npair, sizeof(struct termpair));
@


1.95
log
@Added `%U' to -mdoc (doesn't render in a nice way yet).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.94 2009/10/22 18:55:32 kristaps Exp $ */
d51 22
d261 1
a261 1
	{ NULL, termp____post }, /* %U */ 
a263 22
#ifdef __linux__
extern	size_t	  strlcpy(char *, const char *, size_t);
extern	size_t	  strlcat(char *, const char *, size_t);
#endif

static	size_t	  arg2width(const struct mdoc_argv *, int);
static	size_t	  arg2height(const struct mdoc_node *);
static	size_t	  arg2offs(const struct mdoc_argv *);

static	int	  arg_hasattr(int, const struct mdoc_node *);
static	int	  arg_getattrs(const int *, int *, size_t,
			const struct mdoc_node *);
static	int	  arg_getattr(int, const struct mdoc_node *);
static	int	  arg_listtype(const struct mdoc_node *);
static	void	  print_bvspace(struct termp *,
			const struct mdoc_node *,
			const struct mdoc_node *);
static	void  	  print_node(DECL_ARGS);
static	void	  print_head(DECL_ARGS);
static	void	  print_body(DECL_ARGS);
static	void	  print_foot(DECL_ARGS);

d472 1
a472 1
arg2height(const struct mdoc_node *n)
d486 1
a486 1
arg2width(const struct mdoc_argv *arg, int pos)
d541 1
a541 1
arg2offs(const struct mdoc_argv *arg)
d720 1
a720 1
			offset += arg2width 
d725 1
a725 1
			width = arg2width(&bl->args->argv[vals[2]], i);
d730 1
a730 1
			offset += arg2offs(&bl->args->argv[vals[1]]);
d734 1
a734 1
			width = arg2width(&bl->args->argv[vals[0]], 0);
d736 1
a736 1
			offset += arg2offs(&bl->args->argv[vals[1]]);
d1559 1
a1559 1
			p->offset += arg2offs(&nn->args->argv[i]);
d1814 1
a1814 1
		len = n->child ? arg2height(n->child) : 1;
d2031 4
a2034 2
	if (NULL == (nn = n->child->next)) {
		p->under++;
a2035 1
	}
a2036 1
	p->under++;
d2038 2
a2041 1
	p->under--;
@


1.94
log
@Fixed maddening mismatch between groff and strftime mismatch of day ("%e").  Noted by Ulrich Sporlein.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.93 2009/10/19 15:18:30 kristaps Exp $ */
d239 1
d2010 2
@


1.93
log
@More fixes to scaling-width multipliers (which, just to make my life difficult, differ not only between -mdoc and -man, but between various invocation, e.g., -offset and -width).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.92 2009/10/18 19:03:37 kristaps Exp $ */
d350 2
a351 2
	struct tm	*tm;
	char		*buf, *os;
a360 2
	if (NULL == (buf = malloc(p->rmargin)))
		err(EXIT_FAILURE, "malloc");
d364 1
a364 4
	tm = localtime(&m->date);

	if (0 == strftime(buf, p->rmargin, "%B %e, %Y", tm))
		err(EXIT_FAILURE, "strftime");
a395 1
	free(buf);
@


1.92
log
@Made sure devices and formats recognise that -man and -mdoc have different syntax for scaling widths: -mdoc assumes no unit means that the value is a string literal while -man instead uses the default vertical/horizontal scale.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.91 2009/10/18 13:34:17 kristaps Exp $ */
d497 1
a497 1
		SCALE_HS_INIT(&su, strlen(arg->value[pos]) + 2);
d499 2
a500 1
	return(term_hspan(&su));
a503 1
/* FIXME: put in utility file for front-ends. */
@


1.91
log
@Arbitrary horizontal and vertical scaling widths now handled by -mdoc -Tascii.
Terminal scaling backend pushed into term.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.90 2009/10/15 01:33:12 kristaps Exp $ */
d26 1
d479 1
a479 1
	int		 r;
d483 2
d486 1
a486 4
	if ((r = a2height(n->string)) < 0)
		return(1);

	return((size_t)r);
d493 1
a493 1
	int		 r;
d496 2
a497 5
	if ('\0' == arg->value[pos][0])
		return(2);

	if ((r = a2width(arg->value[pos])) >= 0)
		return((size_t)r);
d499 1
a499 1
	return(strlen(arg->value[pos]) + 2);
d548 1
a548 1
	int		 r;
d558 2
a559 2
	else if ((r = a2width(arg->value[0])) >= 0)
		return((size_t)r);
d561 1
a561 1
	return(strlen(arg->value[0]));
@


1.90
log
@Added support for `Bd -centered', which appears in newer groffs (not yet implemented in centre-capable front-ends, i.e., -Thtml).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.89 2009/10/13 10:57:25 kristaps Exp $ */
d245 4
a252 2
static	size_t	  arg_offset(const struct mdoc_argv *);
static	size_t	  arg_width(const struct mdoc_argv *, int);
d254 1
a254 1
static	void	  fmt_block_vspace(struct termp *,
a474 1
/* FIXME: put in utility file for front-ends. */
d476 1
a476 1
arg_width(const struct mdoc_argv *arg, int pos)
d478 7
a484 2
	int		 i, len;
	const char	*p;
d486 2
a487 2
	assert(pos < (int)arg->sz && pos >= 0);
	assert(arg->value[pos]);
a488 1
	p = arg->value[pos];
d490 4
a493 2
	if (0 == (len = (int)strlen(p)))
		return(0);
d495 3
a497 3
	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;
d499 2
a500 3
	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return((size_t)atoi(p) + 2);
d502 1
a502 1
	return((size_t)len + 2);
a547 1
/* FIXME: put in utility file for front-ends. */
d549 1
a549 1
arg_offset(const struct mdoc_argv *arg)
d551 1
a551 2
	int		 len, i;
	const char	*p;
d553 3
a555 4
	assert(*arg->value);
	p = *arg->value;

	if (0 == strcmp(p, "left"))
d557 1
a557 1
	if (0 == strcmp(p, "indent"))
d559 1
a559 1
	if (0 == strcmp(p, "indent-two"))
d561 2
d564 1
a564 12
	if (0 == (len = (int)strlen(p)))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return((size_t)atoi(p));

	return((size_t)len);
a603 1
/* ARGSUSED */
d605 1
a605 1
fmt_block_vspace(struct termp *p, 
d685 1
a685 1
		fmt_block_vspace(p, n->parent->parent, n);
d728 1
a728 1
			offset += arg_width 
d733 1
a733 1
			width = arg_width(&bl->args->argv[vals[2]], i);
d738 1
a738 1
			offset += arg_offset(&bl->args->argv[vals[1]]);
d742 1
a742 1
			width = arg_width(&bl->args->argv[vals[0]], 0);
d744 1
a744 1
			offset += arg_offset(&bl->args->argv[vals[1]]);
d1546 1
a1546 1
		fmt_block_vspace(p, n, n);
d1567 1
a1567 1
			p->offset += arg_offset(&nn->args->argv[i]);
d1818 1
a1818 1
	int		 i, len;
d1822 1
a1822 1
		len = n->child ? atoi(n->child->string) : 1;
@


1.89
log
@Moved output definitions into main.h.
Pushed terminal_{mdoc,man} into {mdoc,man}_term.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.88 2009/10/10 11:05:23 kristaps Exp $ */
d1562 2
@


1.88
log
@Fix hang lists in -Tascii -Tmdoc, which seem to have been broken since ~1.8.x.
Noted similarity of HP/TP and -hang/-tag in mandoc.1.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.87 2009/10/07 12:20:20 kristaps Exp $ */
d28 2
d262 1
a262 1
mdoc_run(struct termp *p, const struct mdoc *mdoc)
d266 13
@


1.87
log
@`Bd' literals in -Tascii -mdoc were losing the first line's newline.  Fixed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.86 2009/10/03 19:02:45 kristaps Exp $ */
a28 35
/* FIXME: check HANG lists: they seem to be broken... :
 * .Bl -hang -width Ds
 * .It a
 * b
 * .It Fl f Ns Ar option...
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * .
 * .It a sasd fasd as afsd sfad sfds sadfs sd sfd ssfad asfd
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * Override default compiler behaviour.  See
 * .Sx Compiler Options
 * for details.
 * .El
 *
 */

@


1.86
log
@`Fn' does not print empty ftype span.
-Tascii `node' and `meta' args in DECL_ARGS renamed to `n' and `m' to be more coherent with -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.85 2009/09/26 17:35:49 kristaps Exp $ */
d1612 1
d1618 2
@


1.85
log
@Fixed `Bd' prior vertical space (was ignoring -compact).
Fixed effect of embedding macros in `Bd' (was printing all on each line instead of grouping).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.84 2009/09/24 23:54:43 kristaps Exp $ */
d75 2
a76 2
	  	  const struct mdoc_meta *meta, \
		  const struct mdoc_node *node
d314 3
a316 3
	print_node(p, pair, meta, node);
	if (node->next)
		print_body(p, pair, meta, node->next);
d337 3
a339 4
	if (MDOC_TEXT != node->type) {
		if (termacts[node->tok].pre)
			chld = (*termacts[node->tok].pre)
				(p, &npair, meta, node);
d341 3
a343 4
		term_word(p, node->string);

	if (chld && node->child)
		print_body(p, &npair, meta, node->child);
d354 3
a356 4
	if (MDOC_TEXT != node->type)
		if (termacts[node->tok].post)
			(*termacts[node->tok].post)
				(p, &npair, meta, node);
d383 1
a383 1
	tm = localtime(&meta->date);
d388 1
a388 1
	(void)strlcpy(os, meta->os, p->rmargin);
d451 2
a452 2
	assert(meta->vol);
	(void)strlcpy(buf, meta->vol, p->rmargin);
d454 1
a454 1
	if (meta->arch) {
d456 1
a456 1
		(void)strlcat(buf, meta->arch, p->rmargin);
d460 1
a460 1
	snprintf(title, p->rmargin, "%s(%d)", meta->title, meta->msec);
d634 1
a634 1
		const struct mdoc_node *node)
d636 1
a636 1
	const struct mdoc_node *n;
d644 2
a645 2
	for (n = node; n; n = n->parent) {
		if (MDOC_BLOCK != n->type)
d647 1
a647 1
		if (MDOC_Ss == n->tok)
d649 1
a649 1
		if (MDOC_Sh == n->tok)
d651 1
a651 1
		if (NULL == n->prev)
d659 1
a659 1
		if (node->prev && MDOC_It == node->prev->tok)
d665 3
a667 3
		if (node->prev && MDOC_It == node->prev->tok) {
			assert(node->prev->body);
			if (NULL == node->prev->body->child)
d680 1
a680 1
	if (MDOC_BODY != node->type)
d694 1
a694 1
	if (MDOC_BODY != node->type)
d706 1
a706 1
	const struct mdoc_node *bl, *n;
d711 2
a712 2
	if (MDOC_BLOCK == node->type) {
		fmt_block_vspace(p, node->parent->parent, node);
d716 1
a716 1
	bl = node->parent->parent->parent;
d741 1
a741 1
		if (MDOC_BODY == node->type)
d752 1
a752 1
		for (i = 0, n = node->prev; n && 
d754 1
a754 1
				n = n->prev, i++)
d817 1
a817 1
		if (MDOC_BODY == node->type)
d821 1
a821 1
		if (MDOC_BODY == node->type) 
d832 1
a832 1
		if (MDOC_HEAD == node->type)
d855 1
a855 1
		if (MDOC_HEAD == node->type)
d861 1
a861 1
		if (MDOC_HEAD == node->type)
d866 1
a866 1
		if (MDOC_HEAD != node->type)
d875 3
a877 3
		if (node->next->child && 
				(MDOC_Bl == node->next->child->tok ||
				 MDOC_Bd == node->next->child->tok)) {
d884 1
a884 1
		if (MDOC_HEAD == node->type)
d889 1
a889 1
		if (MDOC_HEAD != node->type)
d891 1
a891 1
		if (NULL == node->next || NULL == node->next->child)
d895 3
a897 3
		if (MDOC_HEAD == node->type) {
			assert(node->next);
			if (MDOC_BODY == node->next->type)
d901 1
a901 1
			if (node->prev) 
d906 1
a906 1
		if (MDOC_HEAD == node->type)
d928 3
a930 3
		if (MDOC_HEAD == node->type && node->next->child &&
				(MDOC_Bl == node->next->child->tok || 
				 MDOC_Bd == node->next->child->tok))
d943 1
a943 1
		if (MDOC_HEAD == node->type)
d955 2
a956 2
		if (MDOC_HEAD == node->type &&
				MDOC_BODY == node->next->type)
d968 1
a968 1
	if (MDOC_HEAD == node->type)
d1006 1
a1006 1
		if (MDOC_HEAD == node->type)
d1010 1
a1010 1
		if (MDOC_BODY == node->type)
d1027 1
a1027 1
	if (MDOC_BODY != node->type && MDOC_HEAD != node->type)
d1030 1
a1030 1
	type = arg_listtype(node->parent->parent->parent);
d1039 1
a1039 1
		if (MDOC_BODY == node->type)
d1043 1
a1043 1
		if (MDOC_HEAD == node->type)
d1060 1
a1060 1
	if (SEC_SYNOPSIS == node->sec)
d1063 2
a1064 2
	if (NULL == node->child)
		term_word(p, meta->name);
d1086 1
a1086 1
	if (NULL == node->child)
d1098 1
a1098 1
	if (node->sec == SEC_AUTHORS) {
d1122 2
a1123 2
	if (node->child) {
		if (SEC_AUTHORS == node->sec)
d1128 1
a1128 1
	if (arg_getattr(MDOC_Split, node) > -1) {
d1154 1
a1154 1
	if (SEC_SEE_ALSO != node->sec)
d1156 1
a1156 1
	if (MDOC_BLOCK == node->type && node->prev)
d1171 1
a1171 3
	nn = node->child;
	assert(nn);
	for ( ; nn; nn = nn->next) {
d1184 1
a1184 1
	if (node->child->next)
d1210 1
a1210 3
	nn = node->child;
	assert(nn);
	for ( ; nn; nn = nn->next) {
d1223 1
a1223 1
	if (node->child->next)
d1239 1
a1239 1
	if (MDOC_BODY != node->type)
d1256 1
a1256 1
	if (MDOC_BLOCK == node->type)
d1266 1
a1266 1
	if (MDOC_BODY != node->type) 
d1277 1
a1277 1
	const struct mdoc_node *n;
d1279 2
a1280 2
	assert(node->child && MDOC_TEXT == node->child->type);
	n = node->child;
d1282 2
a1283 2
	term_word(p, n->string);
	if (NULL == (n = n->next)) 
d1288 1
a1288 1
	term_word(p, n->string);
d1291 1
d1301 1
a1301 1
	if (node->sec != SEC_SYNOPSIS)
d1303 1
a1303 1
	if (node->next && MDOC_Vt == node->next->tok)
d1305 1
a1305 1
	else if (node->next)
d1325 1
a1325 1
	if (node->sec != SEC_SYNOPSIS)
d1329 1
a1329 1
	if (node->next && MDOC_Fd != node->next->tok)
d1341 1
a1341 1
	switch (node->type) {
d1343 2
a1344 2
		if (node->prev && MDOC_Sh == node->prev->tok)
			if (NULL == node->prev->body->child)
d1366 1
a1366 1
	switch (node->type) {
d1385 1
a1385 1
	switch (node->type) {
d1412 1
a1412 1
	if (SEC_LIBRARY == node->sec)
d1423 1
a1423 1
	return(1);
d1432 1
a1432 1
	if (MDOC_BLOCK != node->type)
d1445 1
a1445 1
	if (MDOC_BLOCK != node->type) 
d1456 1
a1456 1
	if (MDOC_BODY != node->type)
d1469 1
a1469 1
	if (MDOC_BODY != node->type)
d1481 2
a1482 2
	if (SEC_SYNOPSIS == node->sec)
		if (node->prev && MDOC_Fo == node->prev->tok)
d1494 1
a1494 1
	if (SEC_SYNOPSIS == node->sec)
d1503 1
a1503 1
	const struct mdoc_node *n;
d1506 1
a1506 1
	term_word(p, node->child->string);
d1512 1
a1512 1
	for (n = node->child->next; n; n = n->next) {
d1514 1
a1514 1
		term_word(p, n->string);
d1516 1
a1516 1
		if (n->next)
d1522 1
a1522 1
	if (SEC_SYNOPSIS == node->sec)
d1534 1
a1534 1
	if (node->sec == SEC_SYNOPSIS && node->next)
d1543 1
a1543 1
	struct mdoc_node *n;
d1545 1
a1545 1
	if (node->parent->tok != MDOC_Fo) {
d1550 1
a1550 1
	for (n = node->child; n; n = n->next) {
d1552 1
a1552 1
		term_word(p, n->string);
d1554 1
a1554 1
		if (n->next)
d1558 1
a1558 1
	if (node->child && node->next && node->next->tok == MDOC_Fa)
d1572 2
a1573 2
	if (MDOC_BLOCK == node->type) {
		fmt_block_vspace(p, node, node);
d1575 1
a1575 1
	} else if (MDOC_BODY != node->type)
d1578 1
a1578 1
	nn = node->parent;
d1611 2
a1612 2
	for (nn = node->child; nn; nn = nn->next) {
		print_node(p, pair, meta, nn);
d1628 1
a1628 1
	if (MDOC_BODY != node->type) 
d1640 1
a1640 1
	if (MDOC_BODY != node->type)
d1653 1
a1653 1
	if (MDOC_BODY != node->type)
d1665 1
a1665 1
	if (node->child)
d1678 1
a1678 1
	switch (node->tok) {
d1712 1
a1712 1
	if (MDOC_BODY != node->type)
d1725 1
a1725 1
	if (MDOC_BODY != node->type)
d1757 1
a1757 1
	switch (node->type) {
d1760 1
a1760 1
		if (node->prev)
d1780 1
a1780 1
	if (MDOC_HEAD == node->type)
d1802 1
a1802 1
	if (SEC_SYNOPSIS == node->sec)
d1821 1
a1821 1
	if (SEC_SYNOPSIS != node->sec)
d1831 1
a1831 1
	if (node->next && MDOC_In != node->next->tok)
d1842 1
a1842 1
	switch (node->tok) {
d1844 1
a1844 1
		len = node->child ? atoi(node->child->string) : 1;
d1868 1
a1868 1
	if (MDOC_BODY != node->type)
d1881 1
a1881 1
	if (MDOC_BODY != node->type)
d1893 1
a1893 1
	if (MDOC_BODY != node->type)
d1906 1
a1906 1
	if (MDOC_BODY != node->type)
d1918 1
a1918 1
	if (MDOC_BODY != node->type)
d1931 1
a1931 1
	if (MDOC_BODY != node->type)
d1941 1
a1941 1
	const struct mdoc_node *n;
d1943 1
a1943 1
	if (MDOC_BODY == node->type) {
d1948 1
a1948 1
	} else if (MDOC_HEAD != node->type) 
d1952 3
a1954 3
	for (n = node->child; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
		term_word(p, n->string);
d1967 1
a1967 1
	if (MDOC_BODY != node->type)
d1981 1
a1981 1
	const struct mdoc_node	*n;
d1983 1
a1983 1
	if (MDOC_HEAD == node->type)
d1985 1
a1985 1
	else if (MDOC_BLOCK != node->type)
d1988 2
a1989 2
	if (NULL == (n = node->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, node))
d1991 1
a1991 1
		else if (arg_hasattr(MDOC_Symbolic, node))
d1997 2
a1998 2
	assert(MDOC_TEXT == n->type);
	if (0 == strcmp("Em", n->string))
d2000 1
a2000 1
	else if (0 == strcmp("Sy", n->string))
d2012 2
a2013 2
	assert(node->child && MDOC_TEXT == node->child->type);
	if (0 == strcmp("on", node->child->string)) {
d2041 1
a2041 1
	switch (node->tok) {
d2049 1
a2049 1
	term_word(p, node->next ? "," : ".");
d2057 1
a2057 4
	const struct mdoc_node *n;

	assert(node->child);
	n = node->child;
d2059 1
a2059 1
	if (NULL == n->next) {
d2065 1
a2065 1
	term_word(p, n->string);
d2071 2
a2072 2
	for (n = n->next; n; n = n->next) 
		term_word(p, n->string);
@


1.84
log
@-Tascii correctly prints `%T' in `Rs' with quotes.
-Thtml behaves like -Tascii for printing.
Printing of `Rs' elements cross-checked with new groff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.83 2009/09/24 15:01:06 kristaps Exp $ */
d642 1
a642 2

	if (MDOC_Bl == bl->tok && arg_hasattr(MDOC_Compact, bl))
a643 1
	assert(node);
d645 1
a645 4
	/*
	 * Search through our prior nodes.  If we follow a `Ss' or `Sh',
	 * then don't vspace.
	 */
d659 1
a659 4
	/* 
	 * XXX - not documented: a `-column' does not ever assert vspace
	 * within the list.
	 */
d665 2
a666 4
	/*
	 * XXX - not documented: a `-diag' without a body does not
	 * assert a vspace prior to the next element. 
	 */
d1093 6
a1098 7
	 * XXX: this is poorly documented.  If not in the AUTHORS
	 * section, `An -split' will cause newlines to occur before the
	 * author name.  If in the AUTHORS section, by default, the
	 * first `An' invocation is nosplit, then all subsequent ones,
	 * regardless of whether interspersed with other macros/text,
	 * are split.  -split, in this case, will override the condition
	 * of the implied first -nosplit.
d1344 3
a1346 4
	/* 
	 * XXX: undocumented: using two `Sh' macros in sequence has no
	 * vspace between calls, only a newline.
	 */
d1575 2
a1576 12
	int	         i, type;

	/*
	 * This is fairly tricky due primarily to crappy documentation.
	 * If -ragged or -filled are specified, the block does nothing
	 * but change the indentation.
	 *
	 * If, on the other hand, -unfilled or -literal are specified,
	 * then the game changes.  Text is printed exactly as entered in
	 * the display: if a macro line, a newline is appended to the
	 * line.  Blank lines are allowed.
	 */
d1584 1
a1584 1
	assert(node->parent->args);
d1586 2
a1587 3
	for (type = -1, i = 0; -1 == type && 
			i < (int)node->parent->args->argc; i++) {
		switch (node->parent->args->argv[i].arg) {
d1595 4
a1598 1
			type = node->parent->args->argv[i].arg;
d1604 8
d1614 1
a1614 11

	i = arg_getattr(MDOC_Offset, node->parent);
	if (-1 != i)
		p->offset += arg_offset(&node->parent->args->argv[i]);

	switch (type) {
	case (MDOC_Literal):
		/* FALLTHROUGH */
	case (MDOC_Unfilled):
		break;
	default:
a1615 1
	}
d1617 5
a1621 4
	for (node = node->child; node; node = node->next) {
		p->flags |= TERMP_NOSPACE;
		print_node(p, pair, meta, node);
		if (node->next)
@


1.83
log
@Added EBADCHILD error (bad child of parent context).
`Rs' post-checks that all children are proper bibliographic elements.
`Rs' correctly re-orders its children as per groff's output (including %C).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.82 2009/09/24 11:55:28 kristaps Exp $ */
d109 1
d193 1
a193 1
	{ NULL, termp____post }, /* %B */
d195 1
a195 1
	{ NULL, termp____post }, /* %I */
d201 1
a201 1
	{ termp_under_pre, termp____post }, /* %T */
d2069 8
d2119 10
@


1.82
log
@Fix in -Tascii where `Lb' causes line-break in any section (should only happen in LIBRARY).
`Fn' first parameter is broken apart into ftype and fname in -Thtml (for correct style application).
Fixed \0 special character.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.81 2009/09/24 11:05:45 kristaps Exp $ */
d263 1
a263 1
	{ NULL, NULL }, /* %C */ 
d267 1
a267 1
	{ NULL, NULL }, /* %Q */ 
d2109 1
@


1.81
log
@Sync'd example style-sheet to be more like OpenBSD's default (KISS).
-Thtml and -Tascii now have equivalent functionality.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.80 2009/09/24 09:50:31 kristaps Exp $ */
a1521 4
	assert(node->child && MDOC_TEXT == node->child->type);

	/* FIXME: can be "type funcname" "type varname"... */

@


1.80
log
@Added Bf, Pf, etc. to -Thtml.
Fixed Rs in -Tascii to behave properly when not in "SEE ALSO" section.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.79 2009/09/24 09:20:02 kristaps Exp $ */
d264 2
a265 2
	{ NULL, NULL }, /* Es */ 
	{ NULL, NULL }, /* En */ 
d1420 1
a1420 1
	return(1);
d1429 2
a1430 1
	term_newln(p);
@


1.79
log
@Many more macros added to -Thtml.
Minor space issues fixed in -Tascii.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.78 2009/09/22 16:10:52 kristaps Exp $ */
d221 1
a221 1
	{ termp_bold_pre, NULL }, /* Ms */
d1167 2
@


1.78
log
@Fix segfault in -Thtml column lists.
Added some more UTF-8 chars.
mandoc_char.7 now has all special characters rendered.
Fixed column layout in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.77 2009/09/21 14:08:13 kristaps Exp $ */
d1845 1
@


1.77
log
@Fix height of hard-breaks in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.76 2009/09/21 14:07:07 kristaps Exp $ */
d765 1
a765 1
				i < (int)bl->args[vals[2]].argv->sz; 
d771 1
a771 1
		if (i < (int)bl->args[vals[2]].argv->sz)
@


1.76
log
@Consolidation of Pp/sp/br/Lp stuff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.75 2009/09/20 19:25:06 kristaps Exp $ */
d1869 1
a1869 1
	switch (node->type) {
@


1.75
log
@Headers and footers in -Thtml.  Various minor additions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.74 2009/09/20 17:48:13 kristaps Exp $ */
a115 1
static	int	  termp_br_pre(DECL_ARGS);
a134 1
static	int	  termp_pp_pre(DECL_ARGS);
d156 1
a156 1
	{ termp_pp_pre, NULL }, /* Pp */ 
d257 1
a257 1
	{ termp_pp_pre, NULL }, /* Lp */ 
d268 1
a268 1
	{ termp_br_pre, NULL }, /* br */
a1163 10
termp_pp_pre(DECL_ARGS)
{

	term_vspace(p);
	return(1);
}


/* ARGSUSED */
static int
d1869 10
a1878 3
	if (NULL == node->child) {
		term_vspace(p);
		return(0);
a1880 1
	len = atoi(node->child->string);
a1891 10
termp_br_pre(DECL_ARGS)
{

	term_newln(p);
	return(1);
}


/* ARGSUSED */
static int
@


1.74
log
@Bl -column in place for -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.73 2009/09/20 17:24:57 kristaps Exp $ */
d427 1
@


1.73
log
@Some extra html tags and near-complete Bl: -tag is hopeless (synonym for -hang, now) and -column is still pending.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.72 2009/09/20 11:05:22 kristaps Exp $ */
d765 1
a765 1
		for (i = 0, n = node->prev; n && n && 
@


1.72
log
@Considerable, wide-ranging improvements to the -Thtml output mode (most especially proper tagging and using `em' instead of `px').
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.71 2009/09/17 13:17:30 kristaps Exp $ */
d523 1
@


1.71
log
@Hang lists in html (the hard one first).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.70 2009/09/16 09:41:24 kristaps Exp $ */
d496 1
a496 1
/* TODO: put into util file. */
d564 1
@


1.70
log
@Made tree/term/out() functions return void.
Put err() functions back into front-ends (no use making it needlessly complex).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.69 2009/09/15 08:16:20 kristaps Exp $ */
d29 35
d496 1
@


1.69
log
@Removed TERMP_BOLD, TERMP_UNDER, TERMP_STYLE in favour of recursive-friendly increments.
Cleaned up confusing behaviour of p->flags.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.68 2009/08/20 13:22:48 kristaps Exp $ */
d116 1
a116 1
static const struct termact termacts[MDOC_MAX] = {
d156 1
a156 1
	{ termp_under_pre, termp_vt_post }, /* Vt */  /* FIXME: type name */
d255 1
a255 2
static	void	  print_head(struct termp *, 
			const struct mdoc_meta *);
d257 1
a257 2
static	void	  print_foot(struct termp *, 
			const struct mdoc_meta *);
d260 2
a261 2
int
mdoc_run(struct termp *p, const struct mdoc *m)
d263 10
a272 11
	/*
	 * Main output function.  When this is called, assume that the
	 * tree is properly formed.
	 */
	print_head(p, mdoc_meta(m));
	assert(mdoc_node(m));
	assert(MDOC_ROOT == mdoc_node(m)->type);
	if (mdoc_node(m)->child)
		print_body(p, NULL, mdoc_meta(m), mdoc_node(m)->child);
	print_foot(p, mdoc_meta(m));
	return(1);
d281 2
a282 3
	if ( ! node->next)
		return;
	print_body(p, pair, meta, node->next);
d286 1
d290 1
a290 1
	int		 dochild, bold, under;
d294 1
a294 1
	dochild = 1;
d300 1
a301 9
	npair.flag = 0;
	npair.count = 0;

	/*
	 * Note on termpair.  This allows a pre function to set a termp
	 * flag that is automatically unset after the body, but before
	 * the post function.  Thus, if a pre uses a termpair flag, it
	 * must be reapplied in the post for use.
	 */
d305 3
a307 3
			if ( ! (*termacts[node->tok].pre)(p, &npair, meta, node))
				dochild = 0;
	} else /* MDOC_TEXT == node->type */
d310 2
a311 1
	/* Children. */
d313 5
a317 2
	if (dochild && node->child)
		print_body(p, &npair, meta, node->child);
a321 2
	/* Post-processing. */

d324 2
a325 1
			(*termacts[node->tok].post)(p, &npair, meta, node);
d332 1
d334 1
a334 1
print_foot(struct termp *p, const struct mdoc_meta *meta)
d348 1
a348 1
		err(1, "malloc");
d350 1
a350 1
		err(1, "malloc");
d355 1
a355 1
		err(1, "strftime");
d392 1
d394 1
a394 1
print_head(struct termp *p, const struct mdoc_meta *meta)
d402 1
a402 1
		err(1, "malloc");
d404 1
a404 1
		err(1, "malloc");
d428 1
a428 2
	(void)snprintf(title, p->rmargin, "%s(%d)", 
			meta->title, meta->msec);
@


1.68
log
@Updated manual structure in mdoc.7.
Synchronised mdoc.template and mdoc.7 manual structure.
`Rv' and `Ex' now accept multiple arguments (-std made standalone, terms as children).
`Rv' and `Ex' format correctly in -Tascii (plurals, commas, etc.).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.67 2009/08/19 14:45:56 kristaps Exp $ */
a31 53
#define	TTYPE_PROG	  0
#define	TTYPE_CMD_FLAG	  1
#define	TTYPE_CMD_ARG	  2
#define	TTYPE_SECTION	  3
#define	TTYPE_FUNC_DECL	  4
#define	TTYPE_VAR_DECL	  5
#define	TTYPE_FUNC_TYPE	  6
#define	TTYPE_FUNC_NAME	  7
#define	TTYPE_FUNC_ARG	  8
#define	TTYPE_LINK	  9
#define	TTYPE_SSECTION	  10
#define	TTYPE_FILE	  11
#define	TTYPE_EMPH	  12
#define	TTYPE_CONFIG	  13
#define	TTYPE_CMD	  14
#define	TTYPE_INCLUDE	  15
#define	TTYPE_SYMB	  16
#define	TTYPE_SYMBOL	  17
#define	TTYPE_DIAG	  18
#define	TTYPE_LINK_ANCHOR 19
#define	TTYPE_LINK_TEXT	  20
#define	TTYPE_REF_JOURNAL 21
#define	TTYPE_REF_TITLE	  22
#define	TTYPE_LIST	  23
#define	TTYPE_NMAX	  24

const	int ttypes[TTYPE_NMAX] = {
	TERMP_BOLD, 		/* TTYPE_PROG */
	TERMP_BOLD,		/* TTYPE_CMD_FLAG */
	TERMP_UNDER, 		/* TTYPE_CMD_ARG */
	TERMP_BOLD, 		/* TTYPE_SECTION */
	TERMP_BOLD,		/* TTYPE_FUNC_DECL */
	TERMP_UNDER,		/* TTYPE_VAR_DECL */
	TERMP_UNDER,		/* TTYPE_FUNC_TYPE */
	TERMP_BOLD, 		/* TTYPE_FUNC_NAME */
	TERMP_UNDER, 		/* TTYPE_FUNC_ARG */
	TERMP_UNDER, 		/* TTYPE_LINK */
	TERMP_BOLD,	 	/* TTYPE_SSECTION */
	TERMP_UNDER,		/* TTYPE_FILE */
	TERMP_UNDER, 		/* TTYPE_EMPH */
	TERMP_BOLD,	 	/* TTYPE_CONFIG */
	TERMP_BOLD,	 	/* TTYPE_CMD */
	TERMP_BOLD,	 	/* TTYPE_INCLUDE */
	TERMP_BOLD,	 	/* TTYPE_SYMB */
	TERMP_BOLD,	 	/* TTYPE_SYMBOL */
	TERMP_BOLD,	 	/* TTYPE_DIAG */
	TERMP_UNDER, 		/* TTYPE_LINK_ANCHOR */
	TERMP_BOLD,	 	/* TTYPE_LINK_TEXT */
	TERMP_UNDER,	 	/* TTYPE_REF_JOURNAL */
	TERMP_UNDER,	 	/* TTYPE_REF_TITLE */
	TERMP_BOLD		/* TTYPE_LIST */
};

a73 2
static	int	  termp__j_pre(DECL_ARGS);
static	int	  termp__t_pre(DECL_ARGS);
a76 1
static	int	  termp_ar_pre(DECL_ARGS);
d79 1
a84 1
static	int	  termp_cm_pre(DECL_ARGS);
a86 1
static	int	  termp_em_pre(DECL_ARGS);
a88 1
static	int	  termp_fd_pre(DECL_ARGS);
a92 1
static	int	  termp_ic_pre(DECL_ARGS);
a95 2
static	int	  termp_ms_pre(DECL_ARGS);
static	int	  termp_mt_pre(DECL_ARGS);
a99 1
static	int	  termp_pa_pre(DECL_ARGS);
d111 1
a111 2
static	int	  termp_sx_pre(DECL_ARGS);
static	int	  termp_sy_pre(DECL_ARGS);
a112 2
static	int	  termp_va_pre(DECL_ARGS);
static	int	  termp_vt_pre(DECL_ARGS);
d133 1
a133 1
	{ termp_ar_pre, NULL }, /* Ar */
d135 1
a135 1
	{ termp_cm_pre, NULL }, /* Cm */
d141 1
a141 1
	{ termp_fd_pre, termp_fd_post }, /* Fd */ 
d145 1
a145 1
	{ termp_ic_pre, NULL }, /* Ic */ 
d152 1
a152 1
	{ termp_pa_pre, NULL }, /* Pa */
d155 2
a156 2
	{ termp_va_pre, NULL }, /* Va */
	{ termp_vt_pre, termp_vt_post }, /* Vt */ 
d162 1
a162 1
	{ termp__j_pre, termp____post }, /* %J */
d167 1
a167 1
	{ termp__t_pre, termp____post }, /* %T */
d185 1
a185 1
	{ termp_em_pre, NULL }, /* Em */ 
d188 1
a188 1
	{ termp_ms_pre, NULL }, /* Ms */
d207 2
a208 2
	{ termp_sx_pre, NULL }, /* Sx */
	{ termp_sy_pre, NULL }, /* Sy */
d226 1
a226 1
	{ termp_mt_pre, NULL }, /* Mt */ 
d293 1
a293 1
	int		 dochild;
d300 2
a322 2
	p->flags |= npair.flag;

d326 2
a327 1
	p->flags &= ~npair.flag;
a811 4
	/*
	 * Style flags.  Diagnostic heads need TTYPE_DIAG.
	 */

d815 1
a815 1
			p->flags |= ttypes[TTYPE_DIAG];
d953 1
a953 1
			p->flags |= TERMP_BOLD;
d955 1
a955 1
			p->flags &= ~TERMP_BOLD;
d960 1
a960 1
			p->flags |= TERMP_BOLD;
d962 1
a962 1
			p->flags &= ~TERMP_BOLD;
d1044 1
a1044 4

	pair->flag |= ttypes[TTYPE_PROG];
	p->flags |= ttypes[TTYPE_PROG];

a1046 1

d1056 1
a1056 2
	pair->flag |= ttypes[TTYPE_CMD_FLAG];
	p->flags |= ttypes[TTYPE_CMD_FLAG];
a1123 10
termp_ar_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_CMD_ARG];
	return(1);
}


/* ARGSUSED */
static int
d1165 1
a1165 1
		p->flags |= ttypes[TTYPE_FUNC_NAME];
d1167 1
a1167 1
		p->flags &= ~ttypes[TTYPE_FUNC_NAME];
d1185 1
a1185 1
	p->flags |= ttypes[TTYPE_VAR_DECL];
d1187 1
a1187 1
	p->flags &= ~ttypes[TTYPE_VAR_DECL];
d1206 1
a1206 1
		p->flags |= ttypes[TTYPE_PROG];
d1208 1
a1208 1
		p->flags &= ~ttypes[TTYPE_PROG];
a1290 11
static int
termp_vt_pre(DECL_ARGS)
{

	/* FIXME: this can be "type name". */
	pair->flag |= ttypes[TTYPE_VAR_DECL];
	return(1);
}


/* ARGSUSED */
d1306 1
a1306 1
termp_fd_pre(DECL_ARGS)
d1309 1
a1309 1
	pair->flag |= ttypes[TTYPE_FUNC_DECL];
d1344 1
a1344 1
		pair->flag |= ttypes[TTYPE_SECTION];
d1478 1
a1478 1
	pair->flag |= ttypes[TTYPE_FUNC_TYPE];
d1503 1
a1503 1
	p->flags |= ttypes[TTYPE_FUNC_NAME];
d1505 1
a1505 1
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
d1511 1
a1511 1
		p->flags |= ttypes[TTYPE_FUNC_ARG];
d1513 1
a1513 1
		p->flags &= ~ttypes[TTYPE_FUNC_ARG];
a1538 10
termp_sx_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_LINK];
	return(1);
}


/* ARGSUSED */
static int
d1544 1
a1544 1
		pair->flag |= ttypes[TTYPE_FUNC_ARG];
d1549 1
a1549 1
		p->flags |= ttypes[TTYPE_FUNC_ARG];
d1551 1
a1551 1
		p->flags &= ~ttypes[TTYPE_FUNC_ARG];
a1564 10
termp_va_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_VAR_DECL];
	return(1);
}


/* ARGSUSED */
static int
a1741 10
termp_pa_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_FILE];
	return(1);
}


/* ARGSUSED */
static int
d1772 1
a1772 1
		pair->flag |= ttypes[TTYPE_SSECTION];
a1794 10
termp_em_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_EMPH];
	return(1);
}


/* ARGSUSED */
static int
d1798 1
a1798 1
	pair->flag |= ttypes[TTYPE_CONFIG];
a1805 20
termp_cm_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_CMD_FLAG];
	return(1);
}


/* ARGSUSED */
static int
termp_ic_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_CMD];
	return(1);
}


/* ARGSUSED */
static int
d1809 1
a1809 3
	pair->flag |= ttypes[TTYPE_INCLUDE];
	p->flags |= ttypes[TTYPE_INCLUDE];

d1824 1
a1824 1
	p->flags |= TERMP_NOSPACE | ttypes[TTYPE_INCLUDE];
d1826 1
a1826 1
	p->flags &= ~ttypes[TTYPE_INCLUDE];
d1962 1
a1962 1
	p->flags |= ttypes[TTYPE_FUNC_NAME];
d1967 1
a1967 1
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
d2001 1
a2001 1
			pair->flag |= ttypes[TTYPE_EMPH];
d2003 1
a2003 1
			pair->flag |= ttypes[TTYPE_SYMB];
d2010 1
a2010 1
		pair->flag |= ttypes[TTYPE_EMPH];
d2012 1
a2012 10
		pair->flag |= ttypes[TTYPE_SYMB];

	return(1);
}


/* ARGSUSED */
static int
termp_sy_pre(DECL_ARGS)
{
a2013 1
	pair->flag |= ttypes[TTYPE_SYMB];
a2019 11
termp_ms_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_SYMBOL];
	return(1);
}



/* ARGSUSED */
static int
a2046 20
static int
termp__j_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_REF_JOURNAL];
	return(1);
}


/* ARGSUSED */
static int
termp__t_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_REF_TITLE];
	return(1);
}


/* ARGSUSED */
d2066 1
a2066 1
		pair->flag |= ttypes[TTYPE_LINK_ANCHOR];
d2070 1
a2070 1
	p->flags |= ttypes[TTYPE_LINK_ANCHOR];
d2074 1
a2074 1
	p->flags &= ~ttypes[TTYPE_LINK_ANCHOR];
d2076 1
a2076 1
	p->flags |= ttypes[TTYPE_LINK_TEXT];
d2079 1
a2080 1
	p->flags &= ~ttypes[TTYPE_LINK_TEXT];
d2087 1
a2087 1
termp_mt_pre(DECL_ARGS)
d2090 1
a2090 1
	pair->flag |= ttypes[TTYPE_LINK_ANCHOR];
a2092 2


@


1.67
log
@More already-fixed FIXMEs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.66 2009/08/10 10:09:51 kristaps Exp $ */
d1240 1
a1240 5
	int		 i;

	i = arg_getattr(MDOC_Std, node);
	assert(-1 != i);
	assert(node->args->argv[i].sz);
d1245 19
a1263 4
	p->flags |= ttypes[TTYPE_FUNC_NAME];
	term_word(p, *node->args->argv[i].value);
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
	p->flags |= TERMP_NOSPACE;
d1265 2
a1266 3
       	term_word(p, "() function returns the value 0 if successful;");
       	term_word(p, "otherwise the value -1 is returned and the");
       	term_word(p, "global variable");
d1274 1
a1274 1
	return(1);
d1282 1
a1282 1
	int		 i;
d1284 1
a1284 3
	i = arg_getattr(MDOC_Std, node);
	assert(-1 != i);
	assert(node->args->argv[i].sz);
d1286 21
a1306 5
	term_word(p, "The");
	p->flags |= ttypes[TTYPE_PROG];
	term_word(p, *node->args->argv[i].value);
	p->flags &= ~ttypes[TTYPE_PROG];
       	term_word(p, "utility exits 0 on success, and >0 if an error occurs.");
d1308 1
a1308 1
	return(1);
@


1.66
log
@Moved indentation size into *term.c files.
Improved handling of libman `IP' macro (still needs work).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.65 2009/07/29 09:02:41 kristaps Exp $ */
a31 2
/* FIXME: macro arguments can be escaped. */

d824 1
a824 1
	 * offset.  FIXME: double-check that correct.
@


1.65
log
@Fixed groff-compat where two `Sh' calls, with the first not having a body, don't assert vspace between calls.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.64 2009/07/29 08:46:06 kristaps Exp $ */
d29 3
@


1.64
log
@Moved CALLABLE check to lookup_raw().
Made PARSABLE check occur prior to lookup().
Non-PARSEABLE macros no longer warn against having macro-like parameters.
Non-CALLABLE macros no longer produce an error, just display their symbols (as in groff) (pointed out by joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.63 2009/07/25 16:03:03 kristaps Exp $ */
d1402 2
a1403 2
	 * FIXME: using two `Sh' macros in sequence has no vspace
	 * between calls, only a newline.
d1406 6
a1412 1
		term_vspace(p);
@


1.63
log
@Patches and results of LLVM static analysis (thanks uqs@@sporlein.net).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.62 2009/07/24 12:52:28 kristaps Exp $ */
d1401 4
a1404 1

@


1.62
log
@Fixed DIAGNOSTIC display (leading double-space only before BODY).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.61 2009/07/24 12:47:35 kristaps Exp $ */
d677 1
@


1.61
log
@Full support for `An -split/-nosplit'.  Compat documented.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.60 2009/07/24 11:54:54 kristaps Exp $ */
d861 2
a862 1
		term_word(p, "\\ \\ ");
@


1.60
log
@`Bd' printing simplified (now that literal text is preserved).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.59 2009/07/23 09:40:25 kristaps Exp $ */
d101 1
d128 1
d196 1
a196 1
	{ NULL, NULL }, /* An */
d1135 59
@


1.59
log
@Ugly fix for `Bl' or `Bd' causing badness when nested in `Bl -hang' lists.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.58 2009/07/23 08:36:32 kristaps Exp $ */
d1585 1
a1585 1
	int	         i, type, ln;
d1604 1
a1604 1
	/* FIXME: display type should be mandated by parser. */
d1606 1
a1606 4
	if (NULL == node->parent->args)
		errx(1, "missing display type");

	for (type = -1, i = 0; 
a1616 1
			i = (int)node->parent->args->argc;
d1622 2
a1623 3

	if (NULL == node->parent->args)
		errx(1, "missing display type");
d1626 1
a1626 3
	if (-1 != i) {
		if (1 != node->parent->args->argv[i].sz)
			errx(1, "expected single value");
a1627 1
	}
a1637 8
	/*
	 * Tricky.  Iterate through all children.  If we're on a
	 * different parse line, append a newline and then the contents.
	 * Ew.
	 */

	ln = node->child ? node->child->line : 0;

d1639 3
a1641 1
		if (ln < node->line) {
a1642 4
			p->flags |= TERMP_NOSPACE;
		}
		ln = node->line;
		print_node(p, pair, meta, node);
d1656 1
@


1.58
log
@Bl -column now accepts columns = (1 + stated columns), which covers all remaining column usage/abuse I can see.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.57 2009/07/21 15:54:18 kristaps Exp $ */
d673 1
a673 1
	if (arg_hasattr(MDOC_Compact, bl))
d698 1
a698 1
	if (arg_hasattr(MDOC_Column, bl))
d706 1
a706 1
	if (arg_hasattr(MDOC_Diag, bl)) 
d911 15
a925 1
		if (MDOC_HEAD == node->type)
d967 11
a985 2
	case (MDOC_Hang):
		/* FALLTHROUGH */
@


1.57
log
@Re-added `Pa' handling -- had removed it, but it's a bug in groff that it doesn't always render.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.56 2009/07/21 15:39:04 kristaps Exp $ */
d785 12
a796 1
		for (i = 0, n = node->prev; n; n = n->prev, i++)
d799 7
a805 2
		assert(i < (int)bl->args->argv[vals[2]].sz);
		width = arg_width(&bl->args->argv[vals[2]], i);
@


1.56
log
@Made `%T' underline instead of quote.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.55 2009/07/21 15:35:30 kristaps Exp $ */
d69 1
a69 1
	0, 			/* TTYPE_FILE */
d158 1
d214 1
a214 1
	{ NULL, NULL }, /* Pa */
d1738 10
@


1.55
log
@Fixed undocumented `-diag' where NULL list item bodies aren't followed by a vspace.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.54 2009/07/21 15:03:37 kristaps Exp $ */
d53 3
a55 2
#define	TTYPE_LIST	  22
#define	TTYPE_NMAX	  23
d80 1
a100 1
static	void	  termp__t_post(DECL_ARGS);
d228 1
a228 1
	{ termp__t_pre, termp__t_post }, /* %T */
d2109 1
a2109 2
	term_word(p, "\"");
	p->flags |= TERMP_NOSPACE;
a2115 11
termp__t_post(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\"");
	termp____post(p, pair, meta, node);
}


/* ARGSUSED */
static void
@


1.54
log
@Fixed `Bl -column' undocumented no-vspace rule to only work within the list.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.53 2009/07/21 14:28:36 kristaps Exp $ */
d692 2
a693 2
	 * XXX - not documented: a `-column' does not ever assert
	 * vertical space within the list.
d700 11
@


1.53
log
@Re-fixed `-diag' (accidentally broke in last checkin).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.52 2009/07/21 13:45:04 kristaps Exp $ */
d311 1
a311 1
static	int	  fmt_block_vspace(struct termp *,
d662 1
a662 1
static int
d672 6
a677 4
		return(1);
	/* XXX - not documented! */
	else if (arg_hasattr(MDOC_Column, bl))
		return(1);
d683 1
a683 1
			break;
d685 1
a685 1
			break;
a687 1
		term_vspace(p);
d691 10
a700 1
	return(1);
d740 4
a743 2
	if (MDOC_BLOCK == node->type)
		return(fmt_block_vspace(p, node->parent->parent, node));
d1546 4
a1549 3
	if (MDOC_BLOCK == node->type)
		return(fmt_block_vspace(p, node, node));
	else if (MDOC_BODY != node->type)
@


1.52
log
@Removed `Pa' underline formatting (no groff does this).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.51 2009/07/21 13:34:13 kristaps Exp $ */
d1017 2
@


1.51
log
@Bringing spacing more in line with groff, patches from schwarze@@openbsd.org.  Pre-testing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.50 2009/07/21 12:47:52 kristaps Exp $ */
d68 1
a68 1
	TERMP_UNDER, 		/* TTYPE_FILE */
a156 1
static	int	  termp_pa_pre(DECL_ARGS);
d212 1
a212 1
	{ termp_pa_pre, NULL }, /* Pa */
a1762 10
termp_pa_pre(DECL_ARGS)
{

	pair->flag |= ttypes[TTYPE_FILE];
	return(1);
}


/* ARGSUSED */
static int
@


1.50
log
@Right-most column now fills to the right margin (undocumented groff behaviour).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.49 2009/07/20 19:30:46 kristaps Exp $ */
d815 2
d818 3
d823 1
a823 3
			p->flags &= ~TERMP_NOSPACE;
		else
			p->flags |= TERMP_NOSPACE;
a825 1
		p->flags |= TERMP_NOSPACE;
d829 2
d876 1
a876 1
			p->flags |= TERMP_NOBREAK;
a1015 3
	case (MDOC_Diag):
		term_word(p, "\\ ");
		/* FALLTHROUGH */
@


1.49
log
@Fixed zero-length width string causing assertion (defaulting to 10 -- this needs work).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.48 2009/07/20 15:05:34 kristaps Exp $ */
a29 1
/* FIXME: support more offset/width tokens. */
d929 7
@


1.48
log
@Undocumented behaviour in groff: `Bl -column' implies `-compact'.
mandoc now allows fewer columns than the -width specifies.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.47 2009/07/19 08:24:16 kristaps Exp $ */
d801 2
d921 1
d928 1
@


1.47
log
@Removed superfluous NOSPACE in bd post.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.46 2009/07/19 08:18:28 kristaps Exp $ */
d675 3
@


1.46
log
@termpair flags unset before post, after body (suggested by schwarze@@openbsd).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.45 2009/07/17 12:40:48 kristaps Exp $ */
a1571 1
	p->flags |= TERMP_LITERAL;
a1593 1

a1594 2
	p->flags &= ~TERMP_LITERAL;
	p->flags |= TERMP_NOSPACE;
@


1.45
log
@`sp' documented: validates & produces correct output.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.44 2009/07/17 10:56:57 kristaps Exp $ */
d367 7
d388 2
a397 1
	p->flags &= ~npair.flag;
d1825 1
a1825 1
	p->flags |= TERMP_NOSPACE;
d1827 1
@


1.44
log
@Added `br' and `sp' macros (requested by joerg@@netbsd.org, jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.43 2009/07/16 13:27:24 kristaps Exp $ */
d167 1
d298 1
a298 1
	{ NULL, NULL }, /* sp */ 
d1837 21
@


1.43
log
@Off-by-one space fixed for `Bl -diag'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.42 2009/07/15 08:20:43 kristaps Exp $ */
d133 1
d296 2
d1836 10
@


1.42
log
@Fix to presentation date (Ulrich Sporlein)
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.41 2009/07/14 16:03:51 kristaps Exp $ */
a799 3
	case (MDOC_Diag):
		term_word(p, "\\ ");
		/* FALLTHROUGH */
d988 1
@


1.41
log
@Using \(en for OpenBSD `Nd' (compromise with jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.40 2009/07/14 15:49:44 kristaps Exp $ */
d410 1
a410 1
	if (0 == strftime(buf, p->rmargin, "%B %d, %Y", tm))
@


1.40
log
@Cleaned up arg_width and arg_column functions.
Added XXn and XXm support to -offset (not documented in mdoc.samples, but used in mdoc.samples!).
Lint warnings fixed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.39 2009/07/14 15:17:25 kristaps Exp $ */
a1142 5
	/* 
	 * XXX: signed off by jmc@@openbsd.org.  This technically
	 * produces a minus sign after the Nd, which is wrong, but is
	 * consistent with the historic OpenBSD tmac file.
	 */
d1144 1
a1144 1
	term_word(p, "\\-");
@


1.39
log
@Removed unnecessary save/restore of style around list prefix.
Added -hang list support.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.38 2009/07/13 07:23:07 kristaps Exp $ */
a519 1
	size_t		 v;
d521 1
d526 3
a528 1
	if (0 == (len = (int)strlen(arg->value[pos])))
d532 1
a532 1
		if ( ! isdigit((u_char)arg->value[pos][i]))
d535 3
a537 6
	if (i == len - 1) {
		if ('n' == arg->value[pos][len - 1] ||
				'm' == arg->value[pos][len - 1]) {
			v = (size_t)atoi(arg->value[pos]);
			return(v + 2);
		}
d539 1
a539 2
	}
	return(strlen(arg->value[pos]) + 2);
d587 2
d591 3
a593 1
	if (0 == strcmp(*arg->value, "left"))
d595 1
a595 1
	if (0 == strcmp(*arg->value, "indent"))
d597 1
a597 1
	if (0 == strcmp(*arg->value, "indent-two"))
d600 10
a609 1
	/* FIXME: needs to support field-widths (10n, etc.). */
d611 1
a611 1
	return(strlen(*arg->value));
@


1.38
log
@Err/warn fix (schwarze@@openbsd.org).
Lots of whitespace churn in getting functions aligned nicely.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.37 2009/07/12 20:50:08 kristaps Exp $ */
d703 1
a703 1
	int		        i, type, keys[3], vals[3], sv;
d772 3
a774 1
		/* FALLTHROUGH */
a791 2
	case (MDOC_Hang):
		/* FALLTHROUGH */
d832 5
a836 1
		/* FALLTHROUGH */
d838 8
a845 1
		/* FALLTHROUGH */
d852 4
a855 7
		if (MDOC_HEAD == node->type && MDOC_Hang == type)
			p->flags |= TERMP_NONOBREAK;

		if (MDOC_HEAD == node->type && MDOC_Tag == type)
			if (NULL == node->next ||
					NULL == node->next->child)
				p->flags |= TERMP_NONOBREAK;
a912 1
	sv = p->flags;
d918 1
d925 1
a936 2
	p->flags = sv; /* Restore saved flags. */

@


1.37
log
@Replacement of `Lb' in mdoc_action.c.
Added warning against bogus `Lb' (like groff does).
Added proper quotes around `Lb' in mdoc_term.c.
Moved mdoc_a2lib -> libmdoc (where it belongs).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.36 2009/07/12 20:30:35 kristaps Exp $ */
d574 2
d582 1
a582 4
	/* FIXME: mandated by parser. */

	errx(1, "list type not supported");
	/* NOTREACHED */
d728 1
d755 1
a755 1
	 * offset.
d771 2
d790 2
d833 2
d840 4
d885 2
d969 1
@


1.36
log
@Moved mdoc_a2st() out of mdoc.h -> libmdoc.h (replacement in mdoc_action.c).
Made bad standards into an error (were a warning).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.35 2009/07/12 20:24:24 kristaps Exp $ */
a149 1
static	int	  termp_lb_pre(DECL_ARGS);
d283 1
a283 1
	{ termp_lb_pre, termp_lb_post }, /* Lb */
a1285 17
static int
termp_lb_pre(DECL_ARGS)
{
	const char	*lb;

	assert(node->child && MDOC_TEXT == node->child->type);
	lb = mdoc_a2lib(node->child->string);
	if (lb) {
		term_word(p, lb);
		return(0);
	}
	term_word(p, "library");
	return(1);
}


/* ARGSUSED */
@


1.35
log
@Moved mdoc_a2att() into libmdoc (replacement happens in mdoc_action.c).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.34 2009/07/12 20:07:04 kristaps Exp $ */
a168 1
static	int	  termp_st_pre(DECL_ARGS);
d215 1
a215 1
	{ termp_st_pre, NULL }, /* St */ 
a1043 12
termp_st_pre(DECL_ARGS)
{
	const char	*cp;

	if (node->child && (cp = mdoc_a2st(node->child->string)))
		term_word(p, cp);
	return(0);
}


/* ARGSUSED */
static int
@


1.34
log
@Removed superfluous FIXMEs in mdoc_term.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.33 2009/07/12 19:34:51 kristaps Exp $ */
a129 1
static	int	  termp_at_pre(DECL_ARGS);
d234 1
a234 1
	{ termp_at_pre, NULL }, /* At */
a1839 18
termp_at_pre(DECL_ARGS)
{
	const char	*att;

	att = NULL;

	if (node->child)
		att = mdoc_a2att(node->child->string);
	if (NULL == att)
		att = "AT&T UNIX";

	term_word(p, att);
	return(0);
}


/* ARGSUSED */
static int
@


1.33
log
@Fixed `Fo' superfluous space before `('. Noted groff compatibility in mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.32 2009/07/12 19:28:46 kristaps Exp $ */
d1073 3
a1075 6
	/* FIXME: mandated by parser. */

	if (-1 == (i = arg_getattr(MDOC_Std, node)))
		errx(1, "expected -std argument");
	if (1 != node->args->argv[i].sz)
		errx(1, "expected -std argument");
d1105 3
a1107 6
	/* FIXME: mandated by parser? */

	if (-1 == (i = arg_getattr(MDOC_Std, node)))
		errx(1, "expected -std argument");
	if (1 != node->args->argv[i].sz)
		errx(1, "expected -std argument");
@


1.32
log
@`Vt' macro behaves [more] properly when in the SYNOPSIS section.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.31 2009/07/12 19:13:12 kristaps Exp $ */
d1944 1
a1950 2
	/* XXX - groff shows only first parameter */

@


1.31
log
@Replaced ugly macro function declarations in mdoc_term with real [sorted] ones.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.30 2009/07/12 17:49:32 kristaps Exp $ */
d1207 5
a1211 1
	if (node->sec == SEC_SYNOPSIS)
@


1.30
log
@Removed rmargin from termpair (right in print_node()).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.29 2009/07/12 17:45:17 kristaps Exp $ */
a82 4
/* 
 * This is used to preserve a style of value across a macro, instead of
 * losing it while the body is processed.
 */
d85 2
a86 2
	int	  	  flag;		/* Cross-body struct termp:flags. */
	int		  count;	/* Enum count. */
d89 4
a92 71
#define	DECL_ARGS \
	struct termp *p, struct termpair *pair, \
	const struct mdoc_meta *meta, \
	const struct mdoc_node *node

#define	DECL_PRE(name) \
static	int	 	  name##_pre(DECL_ARGS)
#define	DECL_POST(name) \
static	void	 	  name##_post(DECL_ARGS)
#define	DECL_PREPOST(name) \
DECL_PRE(name); \
DECL_POST(name);

DECL_PREPOST(termp__t);
DECL_PREPOST(termp_aq);
DECL_PREPOST(termp_bd);
DECL_PREPOST(termp_bq);
DECL_PREPOST(termp_brq);
DECL_PREPOST(termp_d1);
DECL_PREPOST(termp_dq);
DECL_PREPOST(termp_fd);
DECL_PREPOST(termp_fn);
DECL_PREPOST(termp_fo);
DECL_PREPOST(termp_ft);
DECL_PREPOST(termp_in);
DECL_PREPOST(termp_it);
DECL_PREPOST(termp_lb);
DECL_PREPOST(termp_op);
DECL_PREPOST(termp_pf);
DECL_PREPOST(termp_pq);
DECL_PREPOST(termp_qq);
DECL_PREPOST(termp_sh);
DECL_PREPOST(termp_ss);
DECL_PREPOST(termp_sq);
DECL_PREPOST(termp_vt);

DECL_PRE(termp__j);
DECL_PRE(termp_ap);
DECL_PRE(termp_ar);
DECL_PRE(termp_at);
DECL_PRE(termp_bf);
DECL_PRE(termp_bt);
DECL_PRE(termp_cd);
DECL_PRE(termp_cm);
DECL_PRE(termp_em);
DECL_PRE(termp_ex);
DECL_PRE(termp_fa);
DECL_PRE(termp_fl);
DECL_PRE(termp_ic);
DECL_PRE(termp_lk);
DECL_PRE(termp_ms);
DECL_PRE(termp_mt);
DECL_PRE(termp_nd);
DECL_PRE(termp_nm);
DECL_PRE(termp_ns);
DECL_PRE(termp_xx);
DECL_PRE(termp_pa);
DECL_PRE(termp_pp);
DECL_PRE(termp_rs);
DECL_PRE(termp_rv);
DECL_PRE(termp_sm);
DECL_PRE(termp_st);
DECL_PRE(termp_sx);
DECL_PRE(termp_sy);
DECL_PRE(termp_ud);
DECL_PRE(termp_va);
DECL_PRE(termp_xr);

DECL_POST(termp___);
DECL_POST(termp_bl);
DECL_POST(termp_bx);
d99 80
a329 1

@


1.29
log
@Removed offset from termpair (much simpler & cleaner).
Put new offset market in print_node().
Some fixes of forgotten ttypes[TTYPE_XXXX] (just TTYPE).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.28 2009/07/12 17:25:07 kristaps Exp $ */
d89 1
a89 2
	int	  	  flag;		/* Whether being used. */
	size_t	  	  rmargin;	/* Right margin. */
d348 1
a348 3
	size_t		 offset;

	/* Pre-processing. */
d352 1
a354 1
	npair.rmargin = 0;
d379 1
a708 1
	pair->rmargin = p->rmargin;
a970 1
	p->rmargin = pair->rmargin;
d1124 1
@


1.28
log
@Removed ambiguous TERMPAIR_SETFLAG from mdoc_term.c (pairs/flags must be manually set now, and are).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.27 2009/07/12 16:55:11 kristaps Exp $ */
a89 1
	size_t	  	  offset;	/* Left margin. */
d349 1
d354 2
d357 1
a357 1
	npair.offset = npair.rmargin = 0;
a374 2
	p->flags &= ~npair.flag;

d380 3
a710 1
	pair->offset = p->offset;
a973 1
	p->offset = pair->offset;
d1192 1
a1192 1
	pair->flag |= TTYPE_VAR_DECL;
d1212 1
a1212 1
	pair->flag |= TTYPE_FUNC_DECL;
d1224 1
d1341 1
a1341 2
	pair->offset = INDENT + 1;
	p->offset += pair->offset;
a1353 1
	p->offset -= pair->offset;
a1521 2
	pair->offset = p->offset;

a1590 1
	p->offset = pair->offset;
d1740 1
a1740 2
	switch (node->type) {
	case (MDOC_HEAD):
a1741 5
		p->offset = INDENT;
		break;
	default:
		break;
	}
@


1.27
log
@GNU/Linux also uses \- for Nd (ew).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.26 2009/07/12 16:52:41 kristaps Exp $ */
d83 4
a86 2
/* XXX - clean this up. */

a88 2
	int		  type;
#define	TERMPAIR_FLAG	 (1 << 0)
a94 8
#define	TERMPAIR_SETFLAG(termp, p, fl) \
	do { \
		assert(! (TERMPAIR_FLAG & (p)->type)); \
		(termp)->flags |= (fl); \
		(p)->flag = (fl); \
		(p)->type |= TERMPAIR_FLAG; \
	} while ( /* CONSTCOND */ 0)

a354 1
	npair.type = 0;
d368 1
a368 2
	if (TERMPAIR_FLAG & npair.type)
		p->flags |= npair.flag;
d373 1
a373 2
	if (TERMPAIR_FLAG & npair.type)
		p->flags &= ~npair.flag;
d986 3
a988 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_PROG]);
d1001 2
a1002 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_FLAG]);
d1014 1
a1014 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_ARG]);
d1191 1
a1191 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_VAR_DECL]);
d1211 1
a1211 5
	/* 
	 * FIXME: this naming is bad.  This value is used, in general,
	 * for the #include header or other preprocessor statement.
	 */
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_DECL]);
d1237 1
a1237 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SECTION]);
d1390 1
a1390 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_TYPE]);
d1454 1
a1454 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK]);
d1466 1
a1466 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_ARG]);
d1490 1
a1490 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_VAR_DECL]);
d1727 1
a1727 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SSECTION]);
d1759 1
a1759 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FILE]);
d1769 1
a1769 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d1779 1
a1779 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CONFIG]);
d1790 1
a1790 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_FLAG]);
d1800 1
a1800 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD]);
d1810 2
a1811 2
	/* XXX This conforms to new-groff style. */
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_INCLUDE]);
d1984 1
a1984 1
	if (MDOC_HEAD == node->type) {
d1986 1
a1986 1
	} else if (MDOC_BLOCK != node->type)
d1991 1
a1991 1
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d1993 1
a1993 1
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMB]);
d2000 1
a2000 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d2002 1
a2002 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
d2013 1
a2013 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMB]);
d2023 1
a2023 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMBOL]);
d2062 1
a2062 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_REF_JOURNAL]);
d2109 1
a2109 1
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK_ANCHOR]);
d2133 1
a2133 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK_ANCHOR]);
@


1.26
log
@Consolidated Bx/Ox/Nx/etc. into one function.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.25 2009/07/12 16:34:16 kristaps Exp $ */
d911 1
a911 1
			term_word(p, "\\-");
d1140 1
a1140 1
#ifdef __OpenBSD__
@


1.25
log
@`Nd' is now a BFI (was an ELEM).  Noted by joerg@@netbsd.org, behaviour ok jmc@@openbsd.org, etc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.24 2009/07/12 08:49:50 kristaps Exp $ */
a143 1
DECL_PRE(termp_bsx);
a146 1
DECL_PRE(termp_dx);
a150 1
DECL_PRE(termp_fx);
d158 1
a158 2
DECL_PRE(termp_nx);
DECL_PRE(termp_ox);
a167 1
DECL_PRE(termp_ux);
d241 1
a241 1
	{ termp_bsx_pre, NULL }, /* Bsx */
d251 1
a251 1
	{ termp_fx_pre, NULL }, /* Fx */
d255 2
a256 2
	{ termp_nx_pre, NULL }, /* Nx */
	{ termp_ox_pre, NULL }, /* Ox */
d274 1
a274 1
	{ termp_ux_pre, NULL }, /* Ux */
d297 1
a297 1
	{ termp_dx_pre, NULL }, /* Dx */ 
a1457 1

a1635 10
static int
termp_bsx_pre(DECL_ARGS)
{

	term_word(p, "BSDI BSD/OS");
	return(1);
}


/* ARGSUSED */
d1648 1
a1648 1
termp_ox_pre(DECL_ARGS)
d1650 1
d1652 23
a1674 39
	term_word(p, "OpenBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_dx_pre(DECL_ARGS)
{

	term_word(p, "DragonFly");
	return(1);
}


/* ARGSUSED */
static int
termp_ux_pre(DECL_ARGS)
{

	term_word(p, "UNIX");
	return(1);
}


/* ARGSUSED */
static int
termp_fx_pre(DECL_ARGS)
{

	term_word(p, "FreeBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_nx_pre(DECL_ARGS)
{
d1676 2
a1677 1
	term_word(p, "NetBSD");
@


1.24
log
@Noted dissent with \- for OpenBSD.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.23 2009/07/12 08:45:56 kristaps Exp $ */
d1137 3
@


1.23
log
@Added \(hy symbol.
Properly categorised \- as an arithmetic minus sign.
Nd produces \(em instead of old \-.
OpenBSD ifdef'd to use old \- after Nd (ok: jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.22 2009/07/07 11:47:17 kristaps Exp $ */
d1137 5
a1141 1

@


1.22
log
@Made `In' handling work in new-groff style (see mdoc.samples).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.21 2009/07/05 19:25:10 kristaps Exp $ */
d1138 1
d1140 3
@


1.21
log
@Backed out "-width indent" and "-width indent-two", which aren't
supported by any groff mdoc tmac (and erroneously used in many manuals,
hence the confusion).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.20 2009/07/04 11:07:34 kristaps Exp $ */
d1841 1
d1843 4
a1846 1
	term_word(p, "#include");
a1860 1
	term_newln(p);
d1863 8
@


1.20
log
@Fixed -offset indent-two (schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.19 2009/07/04 11:04:46 kristaps Exp $ */
a534 4
	if (0 == strcmp(arg->value[pos], "indent"))
		return(INDENT + 3);
	if (0 == strcmp(arg->value[pos], "indent-two"))
		return(INDENT * 2 + 2);
@


1.19
log
@Fixed -offset left (schwarze@@openbsd.org).
Fixed bogus setting (instead of increment) of offsets.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.18 2009/06/22 13:13:10 kristaps Exp $ */
d611 1
a611 1
		return(INDENT * 2);
@


1.18
log
@Lint fixes.
Version up.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.17 2009/06/22 12:38:07 kristaps Exp $ */
d607 1
a607 1
		return(INDENT - 1);
d764 1
a764 1
			offset = arg_offset(&bl->args->argv[vals[1]]);
@


1.17
log
@Noted .Cd tabs-ok issue (will fix later).
Added single space to -diag lists.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.16 2009/06/22 12:04:05 kristaps Exp $ */
d1312 2
a1313 1
	if ((lb = mdoc_a2lib(node->child->string))) {
@


1.16
log
@Added "Spacing" part of "Punctuation and Spacing" in mandoc.1 manual.
Fixed `Ds' meta-macro default width.
Fixed -width and -offset "indent", "indent-two", and "left" widths.
Fixed -width and -offset literal-word and numeric widths.
Fixed off-by-one errors in whitespace output (schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.15 2009/06/17 18:42:42 kristaps Exp $ */
a778 2
	case (MDOC_Enum):
		/* FALLTHROUGH */
d783 4
d796 2
a797 1
	 * Whitespace control.  Inset bodies need an initial space.
d802 1
@


1.15
log
@Special characters, e.g. \(ae, are now correctly rendered in the current font decoration.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.14 2009/06/16 19:45:51 kristaps Exp $ */
d536 1
a536 1
		return(INDENT);
d538 1
a538 1
		return(INDENT * 2);
d548 2
a549 1
		if ('n' == arg->value[pos][len - 1]) {
d551 1
a551 1
			return(v);
d555 1
a555 1
	return(strlen(arg->value[pos]) + 1);
d607 1
a607 1
		return(0);
d609 1
a609 1
		return(INDENT);
d1344 2
a1345 1
	p->offset += (pair->offset = INDENT);
@


1.14
log
@Removed MDOC___: moved MDOC_Ap to its index (comments not passed into mdoc parser).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.13 2009/06/15 20:26:47 kristaps Exp $ */
d717 1
a717 1
	int		        i, type, keys[3], vals[3];
d901 1
a901 1
	 * HEAD character.  Print it now.
d904 1
d908 1
d914 1
d927 2
@


1.13
log
@Removed superfluous ifdef around strftime (schwarze@@openbsd.org).
Bumped version (this was supposed to be in 1.7.17).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.12 2009/06/12 09:18:00 kristaps Exp $ */
d186 1
a186 1
	{ NULL, NULL }, /* \" */
d293 1
a293 2
	{ termp_ap_pre, NULL }, /* Lb */
	{ termp_pp_pre, NULL }, /* Pp */ 
d338 4
a341 1
	print_body(p, NULL, mdoc_meta(m), mdoc_node(m));
@


1.12
log
@`Lk' is correctly handled as CALLABLE (note groff munges nested output).
`Mt' is now CALLABLE.
Fixed missing validate/action of zero-element, non-called inline elements.
Fixed missing validate/action of nested inline element re-calls.
Fixed bogus column argv index in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.11 2009/06/11 13:13:44 kristaps Exp $ */
a417 3
#ifdef __OpenBSD__
	if (NULL == strftime(buf, p->rmargin, "%B %d, %Y", tm))
#else
a418 1
#endif
@


1.11
log
@Added mdoc.template (from NetBSD -- unlicensed??).
Moved MDOC_TEXT type checks into assertions (should be caught by parser).
Added some FIXME notes in mdoc output (largely that things should be asserted, not caught).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.10 2009/06/11 12:55:30 kristaps Exp $ */
d2122 5
a2128 1
	p->flags &= ~ttypes[TTYPE_LINK_ANCHOR];
d2131 1
d2134 1
a2134 1
	for ( ; n; n = n->next) 
d2136 1
a2137 1

@


1.10
log
@Added "left" -offset tag.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.9 2009/06/11 12:07:49 kristaps Exp $ */
d595 2
d615 1
d1077 2
d1112 2
d1167 3
a1169 2
	if (NULL == (n = node->child))
		errx(1, "expected text line argument");
d1303 1
a1303 2
	if (NULL == node->child)
		errx(1, "expected text line argument");
d1411 1
a1411 2
	if (NULL == node->child)
		errx(1, "expected text line arguments");
d1518 2
d1968 1
a1968 2
		if (MDOC_TEXT != n->type)
			errx(1, "expected text line argument");
d2012 1
a2012 3
	if (MDOC_TEXT != n->type)
		errx(1, "expected text line arguments");

d2048 1
a2048 3
	if (NULL == node->child || MDOC_TEXT != node->child->type)
		errx(1, "expected boolean line argument");

d2119 2
a2120 2
	if (NULL == (n = node->child))
		errx(1, "expected line argument");
d2129 1
a2129 1
	for ( ; n; n = n->next) {
a2130 1
	}
@


1.9
log
@Documented some un-clear parts of main.c.
Fixed footer to be new-groff style (OS DATE OS).
Removed sanity check from mdoc_term (unnecessary).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.8 2009/06/11 07:26:35 kristaps Exp $ */
d89 4
a92 4
	int	  	  flag;
	size_t	  	  offset;
	size_t	  	  rmargin;
	int		  count;
d605 2
d611 2
@


1.8
log
@Fixed email address in manual AUTHOR reference.
Set max right margin to 80 columns (schwarze@@openbsd.org).
Fixed centre-field heading position (schwarze@@openbsd.org).
Also fixed -Tman centre-field.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.7 2009/06/10 20:18:43 kristaps Exp $ */
d308 2
a309 2
extern	size_t		  strlcpy(char *, const char *, size_t);
extern	size_t		  strlcat(char *, const char *, size_t);
a327 1
static	void	  sanity(const struct mdoc_node *);
d333 4
a361 4
	/* Some quick sanity-checking. */

	sanity(node);

d403 8
a426 7
	/*
	 * This is /slightly/ different from regular groff output
	 * because we don't have page numbers.  Print the following:
	 *
	 * OS                                            MDOCDATE
	 */

d429 2
a431 2
	p->rmargin = p->maxrmargin - strlen(buf);
	p->offset = 0;
d436 2
d439 4
d446 1
d448 1
a448 1
	term_word(p, buf);
d451 4
a504 1
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
d507 1
d520 1
a521 1
	p->offset = 0;
a528 113
static void
sanity(const struct mdoc_node *n)
{
	char		*p;

	p = "regular form violated";

	switch (n->type) {
	case (MDOC_TEXT):
		if (n->child) 
			errx(1, p);
		if (NULL == n->parent) 
			errx(1, p);
		if (NULL == n->string)
			errx(1, p);
		switch (n->parent->type) {
		case (MDOC_TEXT):
			/* FALLTHROUGH */
		case (MDOC_ROOT):
			errx(1, p);
			/* NOTREACHED */
		default:
			break;
		}
		break;
	case (MDOC_ELEM):
		if (NULL == n->parent)
			errx(1, p);
		switch (n->parent->type) {
		case (MDOC_TAIL):
			/* FALLTHROUGH */
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		if (n->child) switch (n->child->type) {
		case (MDOC_TEXT):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		break;
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		if (NULL == n->parent)
			errx(1, p);
		if (MDOC_BLOCK != n->parent->type)
			errx(1, p);
		if (n->child) switch (n->child->type) {
		case (MDOC_BLOCK):
			/* FALLTHROUGH */
		case (MDOC_ELEM):
			/* FALLTHROUGH */
		case (MDOC_TEXT):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		break;
	case (MDOC_BLOCK):
		if (NULL == n->parent)
			errx(1, p);
		if (NULL == n->child)
			errx(1, p);
		switch (n->parent->type) {
		case (MDOC_ROOT):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			/* FALLTHROUGH */
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_TAIL):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		switch (n->child->type) {
		case (MDOC_ROOT):
			/* FALLTHROUGH */
		case (MDOC_ELEM):
			errx(1, p);
			/* NOTREACHED */
		default:
			break;
		}
		break;
	case (MDOC_ROOT):
		if (n->parent)
			errx(1, p);
		if (NULL == n->child)
			errx(1, p);
		switch (n->child->type) {
		case (MDOC_BLOCK):
			break;
		default:
			errx(1, p);
			/* NOTREACHED */
		}
		break;
	}
}


@


1.7
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.6 2009/04/12 19:45:26 kristaps Exp $ */
d488 1
a488 1
	p->rmargin = (p->maxrmargin - strlen(buf)) / 2;
@


1.6
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: mdoc_term.c,v 1.5 2009/04/12 19:19:57 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.5
log
@Manual .Dt fields CAPITALISED.
Indent set to 5 chars (nroff compat).
Half-indent set to 3 chars (nroff compat).
Default behaviour is loose-y (ignore macro/char/escape).
Added -fstrict.
Added unknown-character ignoring.
@
text
@d1 1
a1 1
/* $Id: mdoc_term.c,v 1.4 2009/04/03 13:17:26 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.4
log
@Updated manuals.7.
Fixed .Dl display.
@
text
@d1 1
a1 1
/* $Id: mdoc_term.c,v 1.3 2009/03/26 16:23:22 kristaps Exp $ */
d1845 1
a1845 1
		p->offset = INDENT / 2;
@


1.3
log
@All macro-invocations, for consistency, begin with `.' in documentation.
Fixed \\ -> \e in manual documentation.
All preliminary -man macros in place.
@
text
@d1 1
a1 1
/* $Id: mdoc_term.c,v 1.2 2009/03/26 14:44:41 kristaps Exp $ */
d1430 1
a1430 1
	if (MDOC_BODY != node->type)
d1443 1
a1443 1
	if (MDOC_BODY != node->type) 
@


1.2
log
@Fixed after-NLINE-error assertion.
Scanned over all manuals with valgrind.
Version up.
@
text
@d1 1
a1 1
/* $Id: mdoc_term.c,v 1.1 2009/03/26 14:38:11 kristaps Exp $ */
d324 2
a325 2
static	int  	  print_node(DECL_ARGS);
static	int	  print_head(struct termp *, 
d327 2
a328 2
static	int	  print_body(DECL_ARGS);
static	int	  print_foot(struct termp *, 
d337 4
a340 5
	if ( ! print_head(p, mdoc_meta(m)))
		return(0);
	if ( ! print_body(p, NULL, mdoc_meta(m), mdoc_node(m)))
		return(0);
	return(print_foot(p, mdoc_meta(m)));
d344 1
a344 1
static int
d348 1
a348 2
	if ( ! print_node(p, pair, meta, node))
		return(0);
d350 2
a351 2
		return(1);
	return(print_body(p, pair, meta, node->next));
d355 1
a355 1
static int
a396 2

	return(1);
d400 1
a400 1
static int
a447 2

	return(1);
d451 1
a451 1
static int
a516 2

	return(1);
@


1.1
log
@Initial front-end formatting for -man pages.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.69 2009/03/23 09:42:43 kristaps Exp $ */
d309 5
@
