head	1.260;
access;
symbols
	VERSION_1_13_3:1.225
	VERSION_1_13_2:1.205
	VERSION_1_12_4:1.178
	VERSION_1_13_1:1.177
	VERSION_1_12_3:1.167
	VERSION_1_12_2:1.167
	VERSION_1_12:1.178.0.2
	VERSION_1_12_1:1.165
	VERSION_1_12_0:1.165
	VERSION_1_11_7:1.163
	VERSION_1_11_6:1.163
	VERSION_1_11_5:1.163
	VERSION_1_11_4:1.163
	VERSION_1_11_3:1.163
	VERSION_1_11_2:1.161
	VERSION_1_11_1:1.161
	VERSION_1_10_10:1.153
	VERSION_1_10_9:1.135
	VERSION_1_10_8:1.125
	VERSION_1_10_7:1.121
	VERSION_1_10_6:1.107
	VERSION_1_10_5:1.100
	VERSION_1_10_5_PREPDF:1.99
	VERSION_1_10_4:1.98
	VERSION_1_10_3:1.93
	VERSION_1_10_2:1.89
	VERSION_1_10_1:1.85
	VERSION_1_9_24:1.61
	VERSION_1_9_25:1.62
	VERSION_1_9_23:1.60
	VERSION_1_9_22:1.60
	VERSION_1_9_21:1.60
	VERSION_1_9_20:1.60
	VERSION_1_9_19:1.60
	VERSION_1_9_18:1.60
	VERSION_1_9_17:1.60
	VERSION_1_9_16:1.59
	VERSION_1_9_15:1.59
	VERSION_1_9_15-pre2:1.58
	VERSION_1_9_15-pre1:1.57
	VERSION_1_9_14:1.57
	VERSION_1_9_13:1.57
	VERSION_1_9_12:1.54
	VERSION_1_9_11:1.49
	VERSION_1_9_10:1.49
	VERSION_1_9_9:1.46
	VERSION_1_9_8:1.44
	VERSION_1_9_7:1.44
	VERSION_1_9_6:1.44
	VERSION_1_9_5:1.44
	VERSION_1_9_2:1.41
	VERSION_1_9_1:1.41
	VERSION_1_9_0:1.41
	VERSION_1_8_5:1.41
	VERSION_1_8_4:1.39
	VERSION_1_8_3:1.38
	VERSION_1_8_2:1.38
	VERSION_1_8_1:1.38
	VERSION_1_8_0:1.38
	VERSION_1_7_24:1.38
	VERSION_1_7_23:1.38
	VERSION_1_7_22:1.34
	VERSION_1_7_21:1.34
	VERSION_1_7_20:1.31
	VERSION_1_7_19:1.30
	VERSION_1_7_17:1.28
	VERSION_1_7_16:1.27
	VERSION_1_7_15:1.27
	VERSION_1_7_14:1.27
	VERSION_1_7_13:1.25
	VERSION_1_7_12:1.23
	OPENBSD_CHECKIN:1.23
	VERSION_1_7_10:1.23
	VERSION_1_7_5:1.16
	VERSION_1_6_5:1.7
	VERSION_1_6_2:1.4;
locks; strict;
comment	@ * @;


1.260
date	2015.12.15.17.38.45;	author schwarze;	state Exp;
branches;
next	1.259;

1.259
date	2015.11.20.21.59.54;	author schwarze;	state Exp;
branches;
next	1.258;

1.258
date	2015.11.14.23.57.47;	author schwarze;	state Exp;
branches;
next	1.257;

1.257
date	2015.11.07.17.58.55;	author schwarze;	state Exp;
branches;
next	1.256;

1.256
date	2015.11.07.14.22.29;	author schwarze;	state Exp;
branches;
next	1.255;

1.255
date	2015.11.06.17.33.34;	author schwarze;	state Exp;
branches;
next	1.254;

1.254
date	2015.11.06.16.30.33;	author schwarze;	state Exp;
branches;
next	1.253;

1.253
date	2015.10.22.21.54.23;	author schwarze;	state Exp;
branches;
next	1.252;

1.252
date	2015.10.22.21.03.43;	author schwarze;	state Exp;
branches;
next	1.251;

1.251
date	2015.10.20.02.01.31;	author schwarze;	state Exp;
branches;
next	1.250;

1.250
date	2015.10.19.19.51.22;	author schwarze;	state Exp;
branches;
next	1.249;

1.249
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.248;

1.248
date	2015.10.12.00.08.15;	author schwarze;	state Exp;
branches;
next	1.247;

1.247
date	2015.10.11.21.12.54;	author schwarze;	state Exp;
branches;
next	1.246;

1.246
date	2015.10.10.13.21.18;	author schwarze;	state Exp;
branches;
next	1.245;

1.245
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.244;

1.244
date	2015.07.28.18.38.55;	author schwarze;	state Exp;
branches;
next	1.243;

1.243
date	2015.07.21.03.26.21;	author schwarze;	state Exp;
branches;
next	1.242;

1.242
date	2015.07.19.06.05.16;	author schwarze;	state Exp;
branches;
next	1.241;

1.241
date	2015.07.19.00.07.42;	author schwarze;	state Exp;
branches;
next	1.240;

1.240
date	2015.07.18.05.47.32;	author schwarze;	state Exp;
branches;
next	1.239;

1.239
date	2015.07.17.22.38.29;	author schwarze;	state Exp;
branches;
next	1.238;

1.238
date	2015.04.29.11.04.17;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2015.04.20.09.54.48;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2015.04.19.15.10.46;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2015.04.18.16.34.25;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2015.04.18.16.06.40;	author schwarze;	state Exp;
branches;
next	1.233;

1.233
date	2015.04.16.16.36.21;	author schwarze;	state Exp;
branches;
next	1.232;

1.232
date	2015.04.03.08.46.17;	author schwarze;	state Exp;
branches;
next	1.231;

1.231
date	2015.04.02.21.36.49;	author schwarze;	state Exp;
branches;
next	1.230;

1.230
date	2015.03.27.21.33.20;	author schwarze;	state Exp;
branches;
next	1.229;

1.229
date	2015.03.27.17.37.25;	author schwarze;	state Exp;
branches;
next	1.228;

1.228
date	2015.03.27.16.36.31;	author schwarze;	state Exp;
branches;
next	1.227;

1.227
date	2015.03.17.13.35.52;	author schwarze;	state Exp;
branches;
next	1.226;

1.226
date	2015.03.17.07.33.07;	author schwarze;	state Exp;
branches;
next	1.225;

1.225
date	2015.03.10.13.50.03;	author schwarze;	state Exp;
branches;
next	1.224;

1.224
date	2015.03.10.03.02.28;	author schwarze;	state Exp;
branches;
next	1.223;

1.223
date	2015.03.06.09.24.59;	author kristaps;	state Exp;
branches;
next	1.222;

1.222
date	2015.02.27.16.02.10;	author schwarze;	state Exp;
branches;
next	1.221;

1.221
date	2015.02.16.16.23.54;	author schwarze;	state Exp;
branches;
next	1.220;

1.220
date	2015.02.10.08.05.30;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2015.02.07.06.28.08;	author schwarze;	state Exp;
branches;
next	1.218;

1.218
date	2015.02.03.21.16.02;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2015.01.20.21.16.51;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2015.01.16.21.15.05;	author schwarze;	state Exp;
branches;
next	1.215;

1.215
date	2015.01.15.04.26.39;	author schwarze;	state Exp;
branches;
next	1.214;

1.214
date	2015.01.14.21.27.17;	author schwarze;	state Exp;
branches;
next	1.213;

1.213
date	2015.01.13.23.17.52;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2015.01.13.13.22.22;	author schwarze;	state Exp;
branches;
next	1.211;

1.211
date	2015.01.01.13.20.38;	author schwarze;	state Exp;
branches;
next	1.210;

1.210
date	2014.12.31.16.52.39;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2014.12.21.14.49.28;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2014.12.18.21.11.46;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2014.12.17.18.45.35;	author schwarze;	state Exp;
branches;
next	1.206;

1.206
date	2014.12.15.18.05.57;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2014.12.11.19.19.35;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2014.12.09.09.14.33;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2014.12.09.07.29.42;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2014.12.05.21.55.04;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2014.12.02.11.31.51;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2014.11.26.21.40.17;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2014.11.11.19.04.55;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2014.11.11.02.43.41;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2014.11.11.02.10.04;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2014.10.30.17.15.28;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2014.10.25.01.03.52;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2014.10.18.15.57.34;	author schwarze;	state Exp;
branches;
next	1.192;

1.192
date	2014.09.03.23.21.47;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2014.09.03.18.09.14;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2014.09.03.05.22.45;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2014.09.01.22.45.53;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2014.08.30.18.08.10;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2014.08.23.22.26.06;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2014.08.23.00.34.59;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2014.08.22.18.07.15;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2014.08.22.04.52.55;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2014.08.22.03.42.18;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2014.08.21.00.32.15;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2014.08.20.21.04.35;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2014.08.17.03.24.47;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2014.08.16.23.04.25;	author schwarze;	state Exp;
branches;
next	1.178;

1.178
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.177;

1.177
date	2014.06.21.22.24.01;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2014.06.21.16.18.25;	author schwarze;	state Exp;
branches;
next	1.175;

1.175
date	2014.06.20.23.02.31;	author schwarze;	state Exp;
branches;
next	1.174;

1.174
date	2014.06.20.16.11.42;	author schwarze;	state Exp;
branches;
next	1.173;

1.173
date	2014.04.20.16.46.04;	author schwarze;	state Exp;
branches;
next	1.172;

1.172
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.171;

1.171
date	2014.03.19.22.20.43;	author schwarze;	state Exp;
branches;
next	1.170;

1.170
date	2014.03.19.21.51.20;	author schwarze;	state Exp;
branches;
next	1.169;

1.169
date	2014.01.06.00.53.33;	author schwarze;	state Exp;
branches;
next	1.168;

1.168
date	2014.01.05.20.26.36;	author schwarze;	state Exp;
branches;
next	1.167;

1.167
date	2012.11.19.17.22.26;	author schwarze;	state Exp;
branches;
next	1.166;

1.166
date	2012.05.27.17.48.57;	author schwarze;	state Exp;
branches;
next	1.165;

1.165
date	2011.10.06.22.29.12;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2011.09.17.15.00.51;	author schwarze;	state Exp;
branches;
next	1.163;

1.163
date	2011.05.20.15.51.18;	author kristaps;	state Exp;
branches;
next	1.162;

1.162
date	2011.05.17.14.38.34;	author kristaps;	state Exp;
branches;
next	1.161;

1.161
date	2011.03.31.10.53.43;	author kristaps;	state Exp;
branches;
next	1.160;

1.160
date	2011.03.28.21.49.42;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2011.03.23.09.47.13;	author kristaps;	state Exp;
branches;
next	1.158;

1.158
date	2011.03.22.10.35.26;	author kristaps;	state Exp;
branches;
next	1.157;

1.157
date	2011.03.21.12.04.26;	author kristaps;	state Exp;
branches;
next	1.156;

1.156
date	2011.03.20.16.05.21;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2011.03.20.16.02.05;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2011.03.20.11.41.24;	author kristaps;	state Exp;
branches;
next	1.153;

1.153
date	2011.03.17.12.08.01;	author kristaps;	state Exp;
branches;
next	1.152;

1.152
date	2011.03.17.08.49.34;	author kristaps;	state Exp;
branches;
next	1.151;

1.151
date	2011.03.16.15.28.35;	author kristaps;	state Exp;
branches;
next	1.150;

1.150
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2011.03.15.16.15.37;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2011.03.15.13.24.42;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2011.03.07.01.35.51;	author schwarze;	state Exp;
branches;
next	1.146;

1.146
date	2011.02.09.09.33.43;	author kristaps;	state Exp;
branches;
next	1.145;

1.145
date	2011.02.09.09.18.15;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2011.02.09.09.05.52;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2011.02.06.20.36.36;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2011.02.02.21.40.45;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2011.01.25.12.24.27;	author schwarze;	state Exp;
branches;
next	1.140;

1.140
date	2011.01.24.23.41.55;	author schwarze;	state Exp;
branches;
next	1.139;

1.139
date	2011.01.22.13.16.02;	author schwarze;	state Exp;
branches;
next	1.138;

1.138
date	2011.01.12.15.50.42;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2011.01.11.00.11.45;	author schwarze;	state Exp;
branches;
next	1.136;

1.136
date	2011.01.10.14.40.30;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2011.01.04.15.02.00;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2011.01.04.12.06.21;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2011.01.03.23.53.51;	author schwarze;	state Exp;
branches;
next	1.132;

1.132
date	2011.01.03.13.54.02;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2011.01.01.22.27.08;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2011.01.01.16.18.39;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2011.01.01.15.45.18;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2011.01.01.13.37.40;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2010.12.29.14.38.14;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2010.12.29.01.16.57;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2010.12.22.11.38.17;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2010.12.21.01.22.03;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2010.12.15.23.39.40;	author kristaps;	state Exp;
branches;
next	1.122;

1.122
date	2010.12.10.20.58.56;	author schwarze;	state Exp;
branches;
next	1.121;

1.121
date	2010.12.06.16.55.35;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2010.12.06.15.31.19;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.06.11.01.19;	author kristaps;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.05.15.55.01;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.05.15.49.37;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.05.15.37.30;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.02.20.41.46;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.01.17.00.05;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2010.12.01.16.54.25;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.01.16.28.23;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.01.15.09.01;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2010.12.01.10.31.34;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2010.11.29.15.45.15;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2010.10.11.15.46.19;	author kristaps;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.27.09.26.27;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.26.20.22.28;	author schwarze;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.04.20.18.53;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2010.08.20.08.13.43;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.08.14.45.59;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.29.22.00.39;	author joerg;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.25.11.44.31;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.20.14.56.42;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.07.15.04.54;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.04.22.04.04;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.02.12.54.33;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.01.15.38.56;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.30.20.32.15;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.29.14.53.14;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2010.06.27.15.52.41;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.26.15.36.37;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.26.15.22.19;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.19.20.46.27;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.12.11.41.50;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.12.10.09.19;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.08.13.22.37;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.07.20.57.09;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.07.10.52.44;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.06.20.44.53;	author joerg;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.03.13.44.36;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.01.14.54.37;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.31.23.40.25;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.16.22.28.33;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.16.19.08.11;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.16.10.59.36;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.16.00.04.46;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.15.22.28.22;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2010.05.15.21.53.11;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.15.18.43.59;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.15.18.35.14;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.15.16.20.12;	author joerg;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.15.16.18.23;	author joerg;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.15.09.46.31;	author joerg;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.15.05.50.19;	author joerg;	state Exp;
branches;
next	1.66;

1.66
date	2010.05.15.05.11.50;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2010.05.15.04.46.10;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.14.17.59.07;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.14.13.54.15;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.09.21.19.42;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.12.19.27.22;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2010.03.22.20.43.00;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.29.14.39.38;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.01.17.14.27;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2009.11.02.08.29.25;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2009.11.02.08.13.48;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.02.08.08.23;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.31.06.17.19;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.31.06.10.57;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.10.30.05.58.37;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.27.08.26.11;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.26.15.44.51;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.26.08.42.37;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.26.08.18.16;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.26.04.15.42;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.13.10.57.25;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.13.10.21.24;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.21.13.06.13;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.16.22.17.27;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.16.09.41.24;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.07.28.10.15.12;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.27.19.43.02;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.24.14.00.59;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.07.09.52.08;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.07.06.13.08.12;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.06.09.34.29;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.07.06.09.21.24;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.04.11.10.36;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.04.09.01.55;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.27.09.03.03;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.18.10.32.00;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.06.16.20.22.23;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.16.19.13.28;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.15.10.36.01;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.11.12.07.49;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.10.20.18.43;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.04.12.19.19.57;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.03.12.27.18;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.03.11.08.39;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.02.16.42.35;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.02.16.37.40;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.02.16.26.35;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.31.13.50.19;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.03.26.16.23.22;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.25.21.46.24;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.25.21.03.13;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.03.25.15.17.49;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.23.21.20.24;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.23.15.41.09;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.23.15.20.51;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.23.14.22.11;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.22.19.10.48;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.22.19.01.11;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.20.21.58.38;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.20.21.29.29;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.20.19.56.25;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.19.18.30.26;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.19.16.40.49;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.19.16.18.36;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.19.16.17.27;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.260
log
@pledge(2) style:
Make sure to always use the idiom 'if (pledge("'
such that it can easily be searched for.
No functional change.
Requested by deraadt@@ some time ago.
@
text
@/*	$Id: main.c,v 1.259 2015/11/20 21:59:54 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2012, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 * Copyright (c) 2010 Joerg Sonnenberger <joerg@@netbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>
#include <sys/param.h>	/* MACHINE */
#include <sys/wait.h>

#include <assert.h>
#include <ctype.h>
#if HAVE_ERR
#include <err.h>
#endif
#include <errno.h>
#include <fcntl.h>
#include <glob.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "tag.h"
#include "main.h"
#include "manconf.h"
#include "mansearch.h"

#if !defined(__GNUC__) || (__GNUC__ < 2)
# if !defined(lint)
#  define __attribute__(x)
# endif
#endif /* !defined(__GNUC__) || (__GNUC__ < 2) */

enum	outmode {
	OUTMODE_DEF = 0,
	OUTMODE_FLN,
	OUTMODE_LST,
	OUTMODE_ALL,
	OUTMODE_INT,
	OUTMODE_ONE
};

enum	outt {
	OUTT_ASCII = 0,	/* -Tascii */
	OUTT_LOCALE,	/* -Tlocale */
	OUTT_UTF8,	/* -Tutf8 */
	OUTT_TREE,	/* -Ttree */
	OUTT_MAN,	/* -Tman */
	OUTT_HTML,	/* -Thtml */
	OUTT_LINT,	/* -Tlint */
	OUTT_PS,	/* -Tps */
	OUTT_PDF	/* -Tpdf */
};

struct	curparse {
	struct mparse	 *mp;
	enum mandoclevel  wlevel;	/* ignore messages below this */
	int		  wstop;	/* stop after a file with a warning */
	enum outt	  outtype;	/* which output to use */
	void		 *outdata;	/* data for output */
	struct manoutput *outopts;	/* output options */
};

static	int		  fs_lookup(const struct manpaths *,
				size_t ipath, const char *,
				const char *, const char *,
				struct manpage **, size_t *);
static	void		  fs_search(const struct mansearch *,
				const struct manpaths *, int, char**,
				struct manpage **, size_t *);
static	int		  koptions(int *, char *);
#if HAVE_SQLITE3
int			  mandocdb(int, char**);
#endif
static	int		  moptions(int *, char *);
static	void		  mmsg(enum mandocerr, enum mandoclevel,
				const char *, int, int, const char *);
static	void		  parse(struct curparse *, int, const char *);
static	void		  passthrough(const char *, int, int);
static	pid_t		  spawn_pager(struct tag_files *);
static	int		  toptions(struct curparse *, char *);
static	void		  usage(enum argmode) __attribute__((noreturn));
static	int		  woptions(struct curparse *, char *);

static	const int sec_prios[] = {1, 4, 5, 8, 6, 3, 7, 2, 9};
static	char		  help_arg[] = "help";
static	char		 *help_argv[] = {help_arg, NULL};
static	enum mandoclevel  rc;


int
main(int argc, char *argv[])
{
	struct manconf	 conf;
	struct curparse	 curp;
	struct mansearch search;
	struct tag_files *tag_files;
	const char	*progname;
	char		*auxpaths;
	char		*defos;
	unsigned char	*uc;
	struct manpage	*res, *resp;
	char		*conf_file, *defpaths;
	size_t		 isec, i, sz;
	int		 prio, best_prio;
	char		 sec;
	enum mandoclevel rctmp;
	enum outmode	 outmode;
	int		 fd;
	int		 show_usage;
	int		 options;
	int		 use_pager;
	int		 status, signum;
	int		 c;
	pid_t		 pager_pid, tc_pgid, man_pgid, pid;

#if HAVE_PROGNAME
	progname = getprogname();
#else
	if (argc < 1)
		progname = mandoc_strdup("mandoc");
	else if ((progname = strrchr(argv[0], '/')) == NULL)
		progname = argv[0];
	else
		++progname;
	setprogname(progname);
#endif

#if HAVE_SQLITE3
	if (strncmp(progname, "mandocdb", 8) == 0 ||
	    strcmp(progname, BINM_MAKEWHATIS) == 0)
		return mandocdb(argc, argv);
#endif

#if HAVE_PLEDGE
	if (pledge("stdio rpath tmppath tty proc exec flock", NULL) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pledge");
#endif

	/* Search options. */

	memset(&conf, 0, sizeof(conf));
	conf_file = defpaths = NULL;
	auxpaths = NULL;

	memset(&search, 0, sizeof(struct mansearch));
	search.outkey = "Nd";

	if (strcmp(progname, BINM_MAN) == 0)
		search.argmode = ARG_NAME;
	else if (strcmp(progname, BINM_APROPOS) == 0)
		search.argmode = ARG_EXPR;
	else if (strcmp(progname, BINM_WHATIS) == 0)
		search.argmode = ARG_WORD;
	else if (strncmp(progname, "help", 4) == 0)
		search.argmode = ARG_NAME;
	else
		search.argmode = ARG_FILE;

	/* Parser and formatter options. */

	memset(&curp, 0, sizeof(struct curparse));
	curp.outtype = OUTT_LOCALE;
	curp.wlevel  = MANDOCLEVEL_BADARG;
	curp.outopts = &conf.output;
	options = MPARSE_SO | MPARSE_UTF8 | MPARSE_LATIN1;
	defos = NULL;

	use_pager = 1;
	tag_files = NULL;
	show_usage = 0;
	outmode = OUTMODE_DEF;

	while (-1 != (c = getopt(argc, argv,
			"aC:cfhI:iK:klM:m:O:S:s:T:VW:w"))) {
		switch (c) {
		case 'a':
			outmode = OUTMODE_ALL;
			break;
		case 'C':
			conf_file = optarg;
			break;
		case 'c':
			use_pager = 0;
			break;
		case 'f':
			search.argmode = ARG_WORD;
			break;
		case 'h':
			conf.output.synopsisonly = 1;
			use_pager = 0;
			outmode = OUTMODE_ALL;
			break;
		case 'I':
			if (strncmp(optarg, "os=", 3)) {
				warnx("-I %s: Bad argument", optarg);
				return (int)MANDOCLEVEL_BADARG;
			}
			if (defos) {
				warnx("-I %s: Duplicate argument", optarg);
				return (int)MANDOCLEVEL_BADARG;
			}
			defos = mandoc_strdup(optarg + 3);
			break;
		case 'i':
			outmode = OUTMODE_INT;
			break;
		case 'K':
			if ( ! koptions(&options, optarg))
				return (int)MANDOCLEVEL_BADARG;
			break;
		case 'k':
			search.argmode = ARG_EXPR;
			break;
		case 'l':
			search.argmode = ARG_FILE;
			outmode = OUTMODE_ALL;
			break;
		case 'M':
			defpaths = optarg;
			break;
		case 'm':
			auxpaths = optarg;
			break;
		case 'O':
			search.outkey = optarg;
			while (optarg != NULL)
				manconf_output(&conf.output,
				    strsep(&optarg, ","));
			break;
		case 'S':
			search.arch = optarg;
			break;
		case 's':
			search.sec = optarg;
			break;
		case 'T':
			if ( ! toptions(&curp, optarg))
				return (int)MANDOCLEVEL_BADARG;
			break;
		case 'W':
			if ( ! woptions(&curp, optarg))
				return (int)MANDOCLEVEL_BADARG;
			break;
		case 'w':
			outmode = OUTMODE_FLN;
			break;
		default:
			show_usage = 1;
			break;
		}
	}

	if (show_usage)
		usage(search.argmode);

	/* Postprocess options. */

	if (outmode == OUTMODE_DEF) {
		switch (search.argmode) {
		case ARG_FILE:
			outmode = OUTMODE_ALL;
			use_pager = 0;
			break;
		case ARG_NAME:
			outmode = OUTMODE_ONE;
			break;
		default:
			outmode = OUTMODE_LST;
			break;
		}
	}

	if (outmode == OUTMODE_FLN ||
	    outmode == OUTMODE_LST ||
	    !isatty(STDOUT_FILENO))
		use_pager = 0;

#if HAVE_PLEDGE
	if (!use_pager)
		if (pledge("stdio rpath flock", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
#endif

	/* Parse arguments. */

	if (argc > 0) {
		argc -= optind;
		argv += optind;
	}
	resp = NULL;

	/*
	 * Quirks for help(1)
	 * and for a man(1) section argument without -s.
	 */

	if (search.argmode == ARG_NAME) {
		if (*progname == 'h') {
			if (argc == 0) {
				argv = help_argv;
				argc = 1;
			}
		} else if (argc > 1 &&
		    ((uc = (unsigned char *)argv[0]) != NULL) &&
		    ((isdigit(uc[0]) && (uc[1] == '\0' ||
		      (isalpha(uc[1]) && uc[2] == '\0'))) ||
		     (uc[0] == 'n' && uc[1] == '\0'))) {
			search.sec = (char *)uc;
			argv++;
			argc--;
		}
		if (search.arch == NULL)
			search.arch = getenv("MACHINE");
#ifdef MACHINE
		if (search.arch == NULL)
			search.arch = MACHINE;
#endif
	}

	rc = MANDOCLEVEL_OK;

	/* man(1), whatis(1), apropos(1) */

	if (search.argmode != ARG_FILE) {
		if (argc == 0)
			usage(search.argmode);

		if (search.argmode == ARG_NAME &&
		    outmode == OUTMODE_ONE)
			search.firstmatch = 1;

		/* Access the mandoc database. */

		manconf_parse(&conf, conf_file, defpaths, auxpaths);
#if HAVE_SQLITE3
		mansearch_setup(1);
		if ( ! mansearch(&search, &conf.manpath,
		    argc, argv, &res, &sz))
			usage(search.argmode);
#else
		if (search.argmode != ARG_NAME) {
			fputs("mandoc: database support not compiled in\n",
			    stderr);
			return (int)MANDOCLEVEL_BADARG;
		}
		sz = 0;
#endif

		if (sz == 0) {
			if (search.argmode == ARG_NAME)
				fs_search(&search, &conf.manpath,
				    argc, argv, &res, &sz);
			else
				warnx("nothing appropriate");
		}

		if (sz == 0) {
			rc = MANDOCLEVEL_BADARG;
			goto out;
		}

		/*
		 * For standard man(1) and -a output mode,
		 * prepare for copying filename pointers
		 * into the program parameter array.
		 */

		if (outmode == OUTMODE_ONE) {
			argc = 1;
			best_prio = 10;
		} else if (outmode == OUTMODE_ALL)
			argc = (int)sz;

		/* Iterate all matching manuals. */

		resp = res;
		for (i = 0; i < sz; i++) {
			if (outmode == OUTMODE_FLN)
				puts(res[i].file);
			else if (outmode == OUTMODE_LST)
				printf("%s - %s\n", res[i].names,
				    res[i].output == NULL ? "" :
				    res[i].output);
			else if (outmode == OUTMODE_ONE) {
				/* Search for the best section. */
				isec = strcspn(res[i].file, "123456789");
				sec = res[i].file[isec];
				if ('\0' == sec)
					continue;
				prio = sec_prios[sec - '1'];
				if (prio >= best_prio)
					continue;
				best_prio = prio;
				resp = res + i;
			}
		}

		/*
		 * For man(1), -a and -i output mode, fall through
		 * to the main mandoc(1) code iterating files
		 * and running the parsers on each of them.
		 */

		if (outmode == OUTMODE_FLN || outmode == OUTMODE_LST)
			goto out;
	}

	/* mandoc(1) */

#if HAVE_PLEDGE
	if (use_pager) {
		if (pledge("stdio rpath tmppath tty proc exec", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
	} else {
		if (pledge("stdio rpath", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
	}
#endif

	if (search.argmode == ARG_FILE && ! moptions(&options, auxpaths))
		return (int)MANDOCLEVEL_BADARG;

	mchars_alloc();
	curp.mp = mparse_alloc(options, curp.wlevel, mmsg, defos);

	/*
	 * Conditionally start up the lookaside buffer before parsing.
	 */
	if (OUTT_MAN == curp.outtype)
		mparse_keep(curp.mp);

	if (argc < 1) {
		if (use_pager)
			tag_files = tag_init();
		parse(&curp, STDIN_FILENO, "<stdin>");
	}

	while (argc > 0) {
		rctmp = mparse_open(curp.mp, &fd,
		    resp != NULL ? resp->file : *argv);
		if (rc < rctmp)
			rc = rctmp;

		if (fd != -1) {
			if (use_pager) {
				tag_files = tag_init();
				use_pager = 0;
			}

			if (resp == NULL)
				parse(&curp, fd, *argv);
			else if (resp->form & FORM_SRC) {
				/* For .so only; ignore failure. */
				chdir(conf.manpath.paths[resp->ipath]);
				parse(&curp, fd, resp->file);
			} else
				passthrough(resp->file, fd,
				    conf.output.synopsisonly);

			if (argc > 1 && curp.outtype <= OUTT_UTF8)
				ascii_sepline(curp.outdata);
		}

		if (MANDOCLEVEL_OK != rc && curp.wstop)
			break;

		if (resp != NULL)
			resp++;
		else
			argv++;
		if (--argc)
			mparse_reset(curp.mp);
	}

	if (curp.outdata != NULL) {
		switch (curp.outtype) {
		case OUTT_HTML:
			html_free(curp.outdata);
			break;
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_ASCII:
			ascii_free(curp.outdata);
			break;
		case OUTT_PDF:
		case OUTT_PS:
			pspdf_free(curp.outdata);
			break;
		default:
			break;
		}
	}
	mparse_free(curp.mp);
	mchars_free();

out:
	if (search.argmode != ARG_FILE) {
		manconf_free(&conf);
#if HAVE_SQLITE3
		mansearch_free(res, sz);
		mansearch_setup(0);
#endif
	}

	free(defos);

	/*
	 * When using a pager, finish writing both temporary files,
	 * fork it, wait for the user to close it, and clean up.
	 */

	if (tag_files != NULL) {
		fclose(stdout);
		tag_write();
		man_pgid = getpgid(0);
		tag_files->tcpgid = man_pgid == getpid() ?
		    getpgid(getppid()) : man_pgid;
		pager_pid = 0;
		signum = SIGSTOP;
		for (;;) {

			/* Stop here until moved to the foreground. */

			tc_pgid = tcgetpgrp(STDIN_FILENO);
			if (tc_pgid != man_pgid) {
				if (tc_pgid == pager_pid) {
					(void)tcsetpgrp(STDIN_FILENO,
					    man_pgid);
					if (signum == SIGTTIN)
						continue;
				} else
					tag_files->tcpgid = tc_pgid;
				kill(0, signum);
				continue;
			}

			/* Once in the foreground, activate the pager. */

			if (pager_pid) {
				(void)tcsetpgrp(STDIN_FILENO, pager_pid);
				kill(pager_pid, SIGCONT);
			} else
				pager_pid = spawn_pager(tag_files);

			/* Wait for the pager to stop or exit. */

			while ((pid = waitpid(pager_pid, &status,
			    WUNTRACED)) == -1 && errno == EINTR)
				continue;

			if (pid == -1) {
				warn("wait");
				rc = MANDOCLEVEL_SYSERR;
				break;
			}
			if (!WIFSTOPPED(status))
				break;

			signum = WSTOPSIG(status);
		}
		tag_unlink();
	}

	return (int)rc;
}

static void
usage(enum argmode argmode)
{

	switch (argmode) {
	case ARG_FILE:
		fputs("usage: mandoc [-acfhkl] [-I os=name] "
		    "[-K encoding] [-mformat] [-O option]\n"
		    "\t      [-T output] [-W level] [file ...]\n", stderr);
		break;
	case ARG_NAME:
		fputs("usage: man [-acfhklw] [-C file] [-I os=name] "
		    "[-K encoding] [-M path] [-m path]\n"
		    "\t   [-O option=value] [-S subsection] [-s section] "
		    "[-T output] [-W level]\n"
		    "\t   [section] name ...\n", stderr);
		break;
	case ARG_WORD:
		fputs("usage: whatis [-acfhklw] [-C file] "
		    "[-M path] [-m path] [-O outkey] [-S arch]\n"
		    "\t      [-s section] name ...\n", stderr);
		break;
	case ARG_EXPR:
		fputs("usage: apropos [-acfhklw] [-C file] "
		    "[-M path] [-m path] [-O outkey] [-S arch]\n"
		    "\t       [-s section] expression ...\n", stderr);
		break;
	}
	exit((int)MANDOCLEVEL_BADARG);
}

static int
fs_lookup(const struct manpaths *paths, size_t ipath,
	const char *sec, const char *arch, const char *name,
	struct manpage **res, size_t *ressz)
{
	glob_t		 globinfo;
	struct manpage	*page;
	char		*file;
	int		 form, globres;

	form = FORM_SRC;
	mandoc_asprintf(&file, "%s/man%s/%s.%s",
	    paths->paths[ipath], sec, name, sec);
	if (access(file, R_OK) != -1)
		goto found;
	free(file);

	mandoc_asprintf(&file, "%s/cat%s/%s.0",
	    paths->paths[ipath], sec, name);
	if (access(file, R_OK) != -1) {
		form = FORM_CAT;
		goto found;
	}
	free(file);

	if (arch != NULL) {
		mandoc_asprintf(&file, "%s/man%s/%s/%s.%s",
		    paths->paths[ipath], sec, arch, name, sec);
		if (access(file, R_OK) != -1)
			goto found;
		free(file);
	}

	mandoc_asprintf(&file, "%s/man%s/%s.[01-9]*",
	    paths->paths[ipath], sec, name);
	globres = glob(file, 0, NULL, &globinfo);
	if (globres != 0 && globres != GLOB_NOMATCH)
		warn("%s: glob", file);
	free(file);
	if (globres == 0)
		file = mandoc_strdup(*globinfo.gl_pathv);
	globfree(&globinfo);
	if (globres != 0)
		return 0;

found:
#if HAVE_SQLITE3
	warnx("outdated mandoc.db lacks %s(%s) entry, run makewhatis %s",
	    name, sec, paths->paths[ipath]);
#endif
	*res = mandoc_reallocarray(*res, ++*ressz, sizeof(struct manpage));
	page = *res + (*ressz - 1);
	page->file = file;
	page->names = NULL;
	page->output = NULL;
	page->ipath = ipath;
	page->bits = NAME_FILE & NAME_MASK;
	page->sec = (*sec >= '1' && *sec <= '9') ? *sec - '1' + 1 : 10;
	page->form = form;
	return 1;
}

static void
fs_search(const struct mansearch *cfg, const struct manpaths *paths,
	int argc, char **argv, struct manpage **res, size_t *ressz)
{
	const char *const sections[] =
	    {"1", "8", "6", "2", "3", "3p", "5", "7", "4", "9"};
	const size_t nsec = sizeof(sections)/sizeof(sections[0]);

	size_t		 ipath, isec, lastsz;

	assert(cfg->argmode == ARG_NAME);

	*res = NULL;
	*ressz = lastsz = 0;
	while (argc) {
		for (ipath = 0; ipath < paths->sz; ipath++) {
			if (cfg->sec != NULL) {
				if (fs_lookup(paths, ipath, cfg->sec,
				    cfg->arch, *argv, res, ressz) &&
				    cfg->firstmatch)
					return;
			} else for (isec = 0; isec < nsec; isec++)
				if (fs_lookup(paths, ipath, sections[isec],
				    cfg->arch, *argv, res, ressz) &&
				    cfg->firstmatch)
					return;
		}
		if (*ressz == lastsz)
			warnx("No entry for %s in the manual.", *argv);
		lastsz = *ressz;
		argv++;
		argc--;
	}
}

static void
parse(struct curparse *curp, int fd, const char *file)
{
	enum mandoclevel  rctmp;
	struct roff_man	 *man;

	/* Begin by parsing the file itself. */

	assert(file);
	assert(fd >= -1);

	rctmp = mparse_readfd(curp->mp, fd, file);
	if (rc < rctmp)
		rc = rctmp;

	/*
	 * With -Wstop and warnings or errors of at least the requested
	 * level, do not produce output.
	 */

	if (rctmp != MANDOCLEVEL_OK && curp->wstop)
		return;

	/* If unset, allocate output dev now (if applicable). */

	if (curp->outdata == NULL) {
		switch (curp->outtype) {
		case OUTT_HTML:
			curp->outdata = html_alloc(curp->outopts);
			break;
		case OUTT_UTF8:
			curp->outdata = utf8_alloc(curp->outopts);
			break;
		case OUTT_LOCALE:
			curp->outdata = locale_alloc(curp->outopts);
			break;
		case OUTT_ASCII:
			curp->outdata = ascii_alloc(curp->outopts);
			break;
		case OUTT_PDF:
			curp->outdata = pdf_alloc(curp->outopts);
			break;
		case OUTT_PS:
			curp->outdata = ps_alloc(curp->outopts);
			break;
		default:
			break;
		}
	}

	mparse_result(curp->mp, &man, NULL);

	/* Execute the out device, if it exists. */

	if (man == NULL)
		return;
	if (man->macroset == MACROSET_MDOC) {
		mdoc_validate(man);
		switch (curp->outtype) {
		case OUTT_HTML:
			html_mdoc(curp->outdata, man);
			break;
		case OUTT_TREE:
			tree_mdoc(curp->outdata, man);
			break;
		case OUTT_MAN:
			man_mdoc(curp->outdata, man);
			break;
		case OUTT_PDF:
		case OUTT_ASCII:
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_PS:
			terminal_mdoc(curp->outdata, man);
			break;
		default:
			break;
		}
	}
	if (man->macroset == MACROSET_MAN) {
		man_validate(man);
		switch (curp->outtype) {
		case OUTT_HTML:
			html_man(curp->outdata, man);
			break;
		case OUTT_TREE:
			tree_man(curp->outdata, man);
			break;
		case OUTT_MAN:
			man_man(curp->outdata, man);
			break;
		case OUTT_PDF:
		case OUTT_ASCII:
		case OUTT_UTF8:
		case OUTT_LOCALE:
		case OUTT_PS:
			terminal_man(curp->outdata, man);
			break;
		default:
			break;
		}
	}
}

static void
passthrough(const char *file, int fd, int synopsis_only)
{
	const char	 synb[] = "S\bSY\bYN\bNO\bOP\bPS\bSI\bIS\bS";
	const char	 synr[] = "SYNOPSIS";

	FILE		*stream;
	const char	*syscall;
	char		*line, *cp;
	size_t		 linesz;
	int		 print;

	line = NULL;
	linesz = 0;

	if ((stream = fdopen(fd, "r")) == NULL) {
		close(fd);
		syscall = "fdopen";
		goto fail;
	}

	print = 0;
	while (getline(&line, &linesz, stream) != -1) {
		cp = line;
		if (synopsis_only) {
			if (print) {
				if ( ! isspace((unsigned char)*cp))
					goto done;
				while (isspace((unsigned char)*cp))
					cp++;
			} else {
				if (strcmp(cp, synb) == 0 ||
				    strcmp(cp, synr) == 0)
					print = 1;
				continue;
			}
		}
		if (fputs(cp, stdout)) {
			fclose(stream);
			syscall = "fputs";
			goto fail;
		}
	}

	if (ferror(stream)) {
		fclose(stream);
		syscall = "getline";
		goto fail;
	}

done:
	free(line);
	fclose(stream);
	return;

fail:
	free(line);
	warn("%s: SYSERR: %s", file, syscall);
	if (rc < MANDOCLEVEL_SYSERR)
		rc = MANDOCLEVEL_SYSERR;
}

static int
koptions(int *options, char *arg)
{

	if ( ! strcmp(arg, "utf-8")) {
		*options |=  MPARSE_UTF8;
		*options &= ~MPARSE_LATIN1;
	} else if ( ! strcmp(arg, "iso-8859-1")) {
		*options |=  MPARSE_LATIN1;
		*options &= ~MPARSE_UTF8;
	} else if ( ! strcmp(arg, "us-ascii")) {
		*options &= ~(MPARSE_UTF8 | MPARSE_LATIN1);
	} else {
		warnx("-K %s: Bad argument", arg);
		return 0;
	}
	return 1;
}

static int
moptions(int *options, char *arg)
{

	if (arg == NULL)
		/* nothing to do */;
	else if (0 == strcmp(arg, "doc"))
		*options |= MPARSE_MDOC;
	else if (0 == strcmp(arg, "andoc"))
		/* nothing to do */;
	else if (0 == strcmp(arg, "an"))
		*options |= MPARSE_MAN;
	else {
		warnx("-m %s: Bad argument", arg);
		return 0;
	}

	return 1;
}

static int
toptions(struct curparse *curp, char *arg)
{

	if (0 == strcmp(arg, "ascii"))
		curp->outtype = OUTT_ASCII;
	else if (0 == strcmp(arg, "lint")) {
		curp->outtype = OUTT_LINT;
		curp->wlevel  = MANDOCLEVEL_WARNING;
	} else if (0 == strcmp(arg, "tree"))
		curp->outtype = OUTT_TREE;
	else if (0 == strcmp(arg, "man"))
		curp->outtype = OUTT_MAN;
	else if (0 == strcmp(arg, "html"))
		curp->outtype = OUTT_HTML;
	else if (0 == strcmp(arg, "utf8"))
		curp->outtype = OUTT_UTF8;
	else if (0 == strcmp(arg, "locale"))
		curp->outtype = OUTT_LOCALE;
	else if (0 == strcmp(arg, "xhtml"))
		curp->outtype = OUTT_HTML;
	else if (0 == strcmp(arg, "ps"))
		curp->outtype = OUTT_PS;
	else if (0 == strcmp(arg, "pdf"))
		curp->outtype = OUTT_PDF;
	else {
		warnx("-T %s: Bad argument", arg);
		return 0;
	}

	return 1;
}

static int
woptions(struct curparse *curp, char *arg)
{
	char		*v, *o;
	const char	*toks[7];

	toks[0] = "stop";
	toks[1] = "all";
	toks[2] = "warning";
	toks[3] = "error";
	toks[4] = "unsupp";
	toks[5] = "fatal";
	toks[6] = NULL;

	while (*arg) {
		o = arg;
		switch (getsubopt(&arg, UNCONST(toks), &v)) {
		case 0:
			curp->wstop = 1;
			break;
		case 1:
		case 2:
			curp->wlevel = MANDOCLEVEL_WARNING;
			break;
		case 3:
			curp->wlevel = MANDOCLEVEL_ERROR;
			break;
		case 4:
			curp->wlevel = MANDOCLEVEL_UNSUPP;
			break;
		case 5:
			curp->wlevel = MANDOCLEVEL_BADARG;
			break;
		default:
			warnx("-W %s: Bad argument", o);
			return 0;
		}
	}

	return 1;
}

static void
mmsg(enum mandocerr t, enum mandoclevel lvl,
		const char *file, int line, int col, const char *msg)
{
	const char	*mparse_msg;

	fprintf(stderr, "%s: %s:", getprogname(), file);

	if (line)
		fprintf(stderr, "%d:%d:", line, col + 1);

	fprintf(stderr, " %s", mparse_strlevel(lvl));

	if (NULL != (mparse_msg = mparse_strerror(t)))
		fprintf(stderr, ": %s", mparse_msg);

	if (msg)
		fprintf(stderr, ": %s", msg);

	fputc('\n', stderr);
}

static pid_t
spawn_pager(struct tag_files *tag_files)
{
#define MAX_PAGER_ARGS 16
	char		*argv[MAX_PAGER_ARGS];
	const char	*pager;
	char		*cp;
	size_t		 cmdlen;
	int		 argc;
	pid_t		 pager_pid;

	pager = getenv("MANPAGER");
	if (pager == NULL || *pager == '\0')
		pager = getenv("PAGER");
	if (pager == NULL || *pager == '\0')
		pager = "more -s";
	cp = mandoc_strdup(pager);

	/*
	 * Parse the pager command into words.
	 * Intentionally do not do anything fancy here.
	 */

	argc = 0;
	while (argc + 4 < MAX_PAGER_ARGS) {
		argv[argc++] = cp;
		cp = strchr(cp, ' ');
		if (cp == NULL)
			break;
		*cp++ = '\0';
		while (*cp == ' ')
			cp++;
		if (*cp == '\0')
			break;
	}

	/* For more(1) and less(1), use the tag file. */

	if ((cmdlen = strlen(argv[0])) >= 4) {
		cp = argv[0] + cmdlen - 4;
		if (strcmp(cp, "less") == 0 || strcmp(cp, "more") == 0) {
			argv[argc++] = mandoc_strdup("-T");
			argv[argc++] = tag_files->tfn;
		}
	}
	argv[argc++] = tag_files->ofn;
	argv[argc] = NULL;

	switch (pager_pid = fork()) {
	case -1:
		err((int)MANDOCLEVEL_SYSERR, "fork");
	case 0:
		/* Set pgrp in both parent and child to avoid racing exec. */
		(void)setpgid(0, 0);
		break;
	default:
		(void)setpgid(pager_pid, 0);
		(void)tcsetpgrp(STDIN_FILENO, pager_pid);
#if HAVE_PLEDGE
		if (pledge("stdio rpath tmppath tty proc", NULL) == -1)
			err((int)MANDOCLEVEL_SYSERR, "pledge");
#endif
		tag_files->pager_pid = pager_pid;
		return pager_pid;
	}

	/* The child process becomes the pager. */

	if (dup2(tag_files->ofd, STDOUT_FILENO) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pager stdout");
	close(tag_files->ofd);
	close(tag_files->tfd);
	execvp(argv[0], argv);
	err((int)MANDOCLEVEL_SYSERR, "exec %s", argv[0]);
}
@


1.259
log
@Fix multiple issues regarding process group and signal mask handling
found by tb@@ and millert@@; parts of the code, in particular in tag.c,
by millert@@; OK millert@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.258 2015/11/14 23:57:47 schwarze Exp $ */
d302 3
a304 2
	if (!use_pager && pledge("stdio rpath flock", NULL) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pledge");
d434 7
a440 3
	if (pledge(use_pager ? "stdio rpath tmppath tty proc exec" :
	    "stdio rpath", NULL) == -1)
		err((int)MANDOCLEVEL_SYSERR, "pledge");
@


1.258
log
@Fix an issue reported by deraadt@@:  When hitting Ctrl-Backslash (= SIGQUIT)
in the less(1) spawned by man(1), man(1) died uncleanly, leaving behind
its temp files, and killed less(1) uncleanly as well with SIGPIPE,
leaving the terminal in the wrong state.

Fix this by giving less(1) its own process group and handing it
control of the terminal, but in such a way that Ctrl-z (= SIGSTOP)
still works: In that case, let man(1) stop itself, too, and let it
continue the pager when it continues itself.

Joint work with millert@@ who contributed most of the expertise
required, and also most parts of the code.
OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.257 2015/11/07 17:58:55 schwarze Exp $ */
d135 1
a135 1
	int		 status;
d137 1
a137 1
	pid_t		 pager_pid;
d533 5
a537 1
		pager_pid = spawn_pager(tag_files);
d539 31
a569 3
			if (waitpid(pager_pid, &status, WUNTRACED) == -1) {
				if (errno == EINTR)
					continue;
d577 1
a577 10
			(void)tcsetpgrp(STDIN_FILENO, getpgid(0));
			kill(0, WSTOPSIG(status));
	
			/*
			 * I'm now stopped.
			 * When getting SIGCONT, continue here:
			 */

			(void)tcsetpgrp(STDIN_FILENO, pager_pid);
			kill(pager_pid, SIGCONT);
d1072 1
a1072 2
		if (tcsetpgrp(STDIN_FILENO, pager_pid) == -1)
			err((int)MANDOCLEVEL_SYSERR, "tcsetpgrp");
d1077 1
@


1.257
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
Remove the related compatibility code.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.256 2015/11/07 14:22:29 schwarze Exp $ */
d30 1
d135 1
d137 1
d158 1
a158 1
	if (pledge("stdio rpath tmppath proc exec flock", NULL) == -1)
d433 1
a433 1
	if (pledge(use_pager ? "stdio rpath tmppath proc exec" :
d533 23
a555 1
		waitpid(spawn_pager(tag_files), NULL, 0);
d1044 2
d1048 3
d1052 1
a1052 1
		if (pledge("stdio rpath tmppath", NULL) == -1)
@


1.256
log
@Without HAVE_ERR, don't try to include <err.h>, it probably isn't there.
In that case, the required prototypes are in "config.h".
Patch from Peter Bray <pdb_ml at yahoo dot com dot au>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.255 2015/11/06 17:33:34 schwarze Exp $ */
d777 2
a778 3
	char		*line;
	size_t		 len, off;
	ssize_t		 nw;
d781 2
a782 1
	fflush(stdout);
d791 2
a792 1
	while ((line = fgetln(stream, &len)) != NULL) {
d795 1
a795 1
				if ( ! isspace((unsigned char)*line))
d797 2
a798 5
				while (len &&
				    isspace((unsigned char)*line)) {
					line++;
					len--;
				}
d800 2
a801 4
				if ((len == sizeof(synb) &&
				     ! strncmp(line, synb, len - 1)) ||
				    (len == sizeof(synr) &&
				     ! strncmp(line, synr, len - 1)))
d806 5
a810 7
		for (off = 0; off < len; off += nw)
			if ((nw = write(STDOUT_FILENO, line + off,
			    len - off)) == -1 || nw == 0) {
				fclose(stream);
				syscall = "write";
				goto fail;
			}
d815 1
a815 1
		syscall = "fgetln";
d820 1
d825 1
@


1.255
log
@merge pledge(2) support from OpenBSD
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.254 2015/11/06 16:30:33 schwarze Exp $ */
d27 1
d29 1
@


1.254
log
@Use getprogname(3) rather than __progname.
Suggested by Joerg@@ Sonnenberger (NetBSD).
Last year, deraadt@@ confirmed on tech@@ that this "has the potential
to be more portable", and micro-optimizing for speed is not relevant
here.  Also gets rid of one global variable.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.253 2015/10/22 21:54:23 schwarze Exp $ */
d152 5
d296 5
d427 6
d1023 4
@


1.253
log
@move man(7) validation into the dedicated validation phase, too
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.252 2015/10/22 21:03:43 schwarze Exp $ */
a103 2
extern	char		 *__progname;

d117 1
d134 3
a136 1
#if !HAVE_PROGNAME
d138 3
a140 3
		__progname = mandoc_strdup("mandoc");
	else if ((__progname = strrchr(argv[0], '/')) == NULL)
		__progname = argv[0];
d142 2
a143 1
		++__progname;
d147 2
a148 1
	if (strcmp(__progname, BINM_MAKEWHATIS) == 0)
d161 1
a161 1
	if (strcmp(__progname, BINM_MAN) == 0)
d163 1
a163 1
	else if (strcmp(__progname, BINM_APROPOS) == 0)
d165 1
a165 1
	else if (strcmp(__progname, BINM_WHATIS) == 0)
d167 1
a167 1
	else if (strncmp(__progname, "help", 4) == 0)
d305 1
a305 1
		if (*__progname == 'h') {
d597 1
a597 1
	warnx("outdated mandoc.db lacks %s(%s) entry, run makewhatis %s\n",
d937 1
a937 1
	fprintf(stderr, "%s: %s:", __progname, file);
@


1.252
log
@If no output device was allocated because no file wanted to produce output,
refrain from dereferencing a NULL pointer during final deallocation.
Fixing a recent regression reported by czarkoff@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.251 2015/10/20 02:01:31 schwarze Exp $ */
d724 1
@


1.251
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.250 2015/10/19 19:51:22 schwarze Exp $ */
d469 17
a485 15
	switch (curp.outtype) {
	case OUTT_HTML:
		html_free(curp.outdata);
		break;
	case OUTT_UTF8:
	case OUTT_LOCALE:
	case OUTT_ASCII:
		ascii_free(curp.outdata);
		break;
	case OUTT_PDF:
	case OUTT_PS:
		pspdf_free(curp.outdata);
		break;
	default:
		break;
@


1.250
log
@Simplify, no functional change:
Delete the outmdoc, outman, and outfree function pointers.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.249 2015/10/13 22:59:54 schwarze Exp $ */
d699 1
@


1.249
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.248 2015/10/12 00:08:15 schwarze Exp $ */
a61 4
typedef	void		(*out_mdoc)(void *, const struct roff_man *);
typedef	void		(*out_man)(void *, const struct roff_man *);
typedef	void		(*out_free)(void *);

a78 3
	out_mdoc	  outmdoc;	/* mdoc output ptr */
	out_man		  outman;	/* man output ptr */
	out_free	  outfree;	/* free output ptr */
d469 16
a484 2
	if (curp.outfree)
		(*curp.outfree)(curp.outdata);
d667 1
a667 1
	if ( ! (curp->outman && curp->outmdoc)) {
a670 1
			curp->outfree = html_free;
a673 1
			curp->outfree = ascii_free;
a676 1
			curp->outfree = ascii_free;
a679 1
			curp->outfree = ascii_free;
a682 1
			curp->outfree = pspdf_free;
a685 1
			curp->outfree = pspdf_free;
d690 3
d694 27
d723 1
a723 2
			curp->outman = html_man;
			curp->outmdoc = html_mdoc;
d726 1
a726 2
			curp->outman = tree_man;
			curp->outmdoc = tree_mdoc;
d729 1
a729 2
			curp->outmdoc = man_mdoc;
			curp->outman = man_man;
d736 1
a736 2
			curp->outman = terminal_man;
			curp->outmdoc = terminal_mdoc;
a741 11

	mparse_result(curp->mp, &man, NULL);

	/* Execute the out device, if it exists. */

	if (man == NULL)
		return;
	if (curp->outmdoc != NULL && man->macroset == MACROSET_MDOC)
		(*curp->outmdoc)(curp->outdata, man);
	if (curp->outman != NULL && man->macroset == MACROSET_MAN)
		(*curp->outman)(curp->outdata, man);
@


1.248
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.247 2015/10/11 21:12:54 schwarze Exp $ */
a79 1
	struct mchars	 *mchars;	/* character table */
d424 2
a425 3
	curp.mchars = mchars_alloc();
	curp.mp = mparse_alloc(options, curp.wlevel, mmsg,
	    curp.mchars, defos);
d479 1
a479 1
	mchars_free(curp.mchars);
d663 1
a663 2
			curp->outdata = html_alloc(curp->mchars,
			    curp->outopts);
d667 1
a667 2
			curp->outdata = utf8_alloc(curp->mchars,
			    curp->outopts);
d671 1
a671 2
			curp->outdata = locale_alloc(curp->mchars,
			    curp->outopts);
d675 1
a675 2
			curp->outdata = ascii_alloc(curp->mchars,
			    curp->outopts);
d679 1
a679 2
			curp->outdata = pdf_alloc(curp->mchars,
			    curp->outopts);
d683 1
a683 2
			curp->outdata = ps_alloc(curp->mchars,
			    curp->outopts);
@


1.247
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, let's provide compatibility modules
for archaic systems (like commercial Solaris) that still don't have
them.  The compat module has an UCB Copyright (c) 1993...
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.246 2015/10/10 13:21:18 schwarze Exp $ */
a711 1
			/* FALLTHROUGH */
a712 1
			/* FALLTHROUGH */
a713 1
			/* FALLTHROUGH */
a714 1
			/* FALLTHROUGH */
a894 1
			/* FALLTHROUGH */
@


1.246
log
@Decide whether to use_pager as early as possible,
in preparation for pledge(2); no functional change intended.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.245 2015/10/06 18:32:19 schwarze Exp $ */
d27 1
a27 1
#include <errno.h>
d112 2
a116 1
static	const char	 *progname;
d143 1
d145 3
a147 3
		progname = "mandoc";
	else if ((progname = strrchr(argv[0], '/')) == NULL)
		progname = argv[0];
d149 2
a150 1
		++progname;
d153 1
a153 1
	if (strcmp(progname, BINM_MAKEWHATIS) == 0)
d166 1
a166 1
	if (strcmp(progname, BINM_MAN) == 0)
d168 1
a168 1
	else if (strcmp(progname, BINM_APROPOS) == 0)
d170 1
a170 1
	else if (strcmp(progname, BINM_WHATIS) == 0)
d172 1
a172 1
	else if (strncmp(progname, "help", 4) == 0)
d213 1
a213 3
				fprintf(stderr,
				    "%s: -I %s: Bad argument\n",
				    progname, optarg);
d217 1
a217 3
				fprintf(stderr,
				    "%s: -I %s: Duplicate argument\n",
				    progname, optarg);
d310 1
a310 1
		if (*progname == 'h') {
d366 1
a366 3
				fprintf(stderr,
				    "%s: nothing appropriate\n",
				    progname);
d577 1
a577 2
		fprintf(stderr, "%s: %s: glob: %s\n",
		    progname, file, strerror(errno));
d587 2
a588 2
	fprintf(stderr, "%s: outdated mandoc.db lacks %s(%s) entry, run "
	    "makewhatis %s\n", progname, name, sec, paths->paths[ipath]);
d630 1
a630 3
			fprintf(stderr,
			    "%s: No entry for %s in the manual.\n",
			    progname, *argv);
d801 1
a801 2
	fprintf(stderr, "%s: %s: SYSERR: %s: %s",
	    progname, file, syscall, strerror(errno));
d819 1
a819 2
		fprintf(stderr, "%s: -K %s: Bad argument\n",
		    progname, arg);
d838 1
a838 2
		fprintf(stderr, "%s: -m %s: Bad argument\n",
		    progname, arg);
d871 1
a871 2
		fprintf(stderr, "%s: -T %s: Bad argument\n",
		    progname, arg);
d913 1
a913 2
			fprintf(stderr, "%s: -W %s: Bad argument\n",
			    progname, o);
d927 1
a927 1
	fprintf(stderr, "%s: %s:", progname, file);
d993 1
a993 3
		fprintf(stderr, "%s: fork: %s\n",
		    progname, strerror(errno));
		exit((int)MANDOCLEVEL_SYSERR);
d1002 2
a1003 4
	if (dup2(tag_files->ofd, STDOUT_FILENO) == -1) {
		fprintf(stderr, "pager: stdout: %s\n", strerror(errno));
		exit((int)MANDOCLEVEL_SYSERR);
	}
d1007 1
a1007 3
	fprintf(stderr, "%s: exec %s: %s\n",
	    progname, argv[0], strerror(errno));
	exit((int)MANDOCLEVEL_SYSERR);
@


1.245
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.244 2015/07/28 18:38:55 schwarze Exp $ */
d292 5
a427 3
	if (use_pager && ! isatty(STDOUT_FILENO))
		use_pager = 0;

@


1.244
log
@Remove the hack of scrolling forward and backward with +G1G that
many (jmc@@, millert@@, espie@@, deraadt@@) considered revolting.
Instead, when using a pager, since we are using a temporary file
for tags anyway, use another temporary file for the formatted
page(s), as suggested by millert@@ and similar to what the traditional
BSD man(1) did, except that we use only one single temporary output
file rather than one for each formatted manual page, such that
searching (both with / and :t) works across all the displayed files.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.243 2015/07/21 03:26:21 schwarze Exp $ */
d151 1
a151 1
		return(mandocdb(argc, argv));
d213 1
a213 1
				return((int)MANDOCLEVEL_BADARG);
d219 1
a219 1
				return((int)MANDOCLEVEL_BADARG);
d228 1
a228 1
				return((int)MANDOCLEVEL_BADARG);
d257 1
a257 1
				return((int)MANDOCLEVEL_BADARG);
d261 1
a261 1
				return((int)MANDOCLEVEL_BADARG);
d352 1
a352 1
			return((int)MANDOCLEVEL_BADARG);
d421 1
a421 1
		return((int)MANDOCLEVEL_BADARG);
d507 1
a507 1
	return((int)rc);
d585 1
a585 1
		return(0);
d601 1
a601 1
	return(1);
d826 1
a826 1
		return(0);
d828 1
a828 1
	return(1);
d846 1
a846 1
		return(0);
d849 1
a849 1
	return(1);
d880 1
a880 1
		return(0);
d883 1
a883 1
	return(1);
d923 1
a923 1
			return(0);
d927 1
a927 1
	return(1);
d1008 1
a1008 1
		return(pager_pid);
@


1.243
log
@When creation of the temporary tags file fails, call the pager
without the -T option, because otherwise the pager won't even start.
Fixing a bug reported by jca@@.

While here, shorten the code by two lines
and delete one internal interface function.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.242 2015/07/19 06:05:16 schwarze Exp $ */
a97 1
static	void		  handle_sigpipe(int);
d107 1
a107 1
static	pid_t		  spawn_pager(void);
d125 1
d139 1
a140 1
	pid_t		 pager_pid;  /* 0: don't use; 1: not yet spawned. */
d183 2
a184 1
	pager_pid = 1;
d198 1
a198 1
			pager_pid = 0;
d205 1
a205 1
			pager_pid = 0;
d281 1
a281 1
			pager_pid = 0;
d423 2
a424 2
	if (pager_pid == 1 && isatty(STDOUT_FILENO) == 0)
		pager_pid = 0;
d437 2
a438 2
		if (pager_pid == 1)
			pager_pid = spawn_pager();
d449 4
a452 2
			if (pager_pid == 1)
				pager_pid = spawn_pager();
d496 2
a497 3
	 * If a pager is attached, flush the pipe leading to it
	 * and signal end of file such that the user can browse
	 * to the end.  Then wait for the user to close the pager.
d500 1
a500 1
	if (pager_pid != 0 && pager_pid != 1) {
d503 1
a503 1
		waitpid(pager_pid, NULL, 0);
a951 7
static void
handle_sigpipe(int signum)
{

	exit((int)rc);
}

d953 1
a953 1
spawn_pager(void)
a959 1
	int		 fildes[2];
d988 1
a988 1
	/* Read all text right away and use the tag file. */
d990 1
a990 3
	for (;;) {
		if ((cmdlen = strlen(argv[0])) < 4)
			break;
d992 4
a995 8
		if (strcmp(cp, "less") && strcmp(cp, "more"))
			break;
		if ((cp = tag_init()) == NULL)
			break;
		argv[argc++] = mandoc_strdup("+G1G");
		argv[argc++] = mandoc_strdup("-T");
		argv[argc++] = cp;
		break;
d997 1
a999 6
	if (pipe(fildes) == -1) {
		fprintf(stderr, "%s: pipe: %s\n",
		    progname, strerror(errno));
		return(0);
	}

a1007 8
		close(fildes[0]);
		if (dup2(fildes[1], STDOUT_FILENO) == -1) {
			fprintf(stderr, "%s: dup output: %s\n",
			    progname, strerror(errno));
			exit((int)MANDOCLEVEL_SYSERR);
		}
		close(fildes[1]);
		signal(SIGPIPE, handle_sigpipe);
d1013 2
a1014 4
	close(fildes[1]);
	if (dup2(fildes[0], STDIN_FILENO) == -1) {
		fprintf(stderr, "%s: dup input: %s\n",
		    progname, strerror(errno));
d1017 2
a1018 4
	close(fildes[0]);

	/* Hand over to the pager. */

@


1.242
log
@Do not fork and exec gunzip(1), just link with libz instead.
As discussed with deraadt@@, that's cleaner and will help tame(2).
Something like this was also suggested earlier by bapt at FreeBSD.
Minus 50 lines of code, deleting one interface function (mparse_wait),
no functional change intended.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.241 2015/07/19 00:07:42 schwarze Exp $ */
d996 3
a998 1
	if ((cmdlen = strlen(argv[0])) >= 4) {
d1000 8
a1007 7
		if (strcmp(cp, "less") == 0 ||
		    strcmp(cp, "more") == 0) {
			tag_init();
			argv[argc++] = mandoc_strdup("+G1G");
			argv[argc++] = mandoc_strdup("-T");
			argv[argc++] = tag_filename();
		}
@


1.241
log
@If we aren't on a tty, clear the pager flag up front.
Just to clean up code structure, no functional change.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.240 2015/07/18 05:47:32 schwarze Exp $ */
a460 4
			rctmp = mparse_wait(curp.mp);
			if (rc < rctmp)
				rc = rctmp;

@


1.240
log
@Insist that manual page file name extensions must begin with a digit,
lest pkg.conf(5) be shown when pkg(5) is asked for;
issue reported by Michael Reed <m dot reed at mykolab dot com>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.239 2015/07/17 22:38:29 schwarze Exp $ */
d422 3
d436 1
a436 1
		if (pager_pid == 1 && isatty(STDOUT_FILENO))
d448 1
a448 1
			if (pager_pid == 1 && isatty(STDOUT_FILENO))
@


1.239
log
@Initial, still somewhat experimental implementation to leverage
less(1) -T and :t ctags(1)-like functionality to jump to the
definitions of various terms inside manual pages.
To be polished in the tree, so bear with me and report issues.

Technically, if less(1) is used as a pager, information is collected
by the mdoc(7) terminal formatter, first stored using the ohash
library, then ultimately written to a temporary file which is passed
to less via -T.  No change intended for other output formatters or
when running without a pager.

Based on an idea from Kristaps using feedback from many, in particular
phessler@@ nicm@@ millert@@ halex@@ doug@@ kspillner@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.238 2015/04/29 11:04:17 schwarze Exp $ */
d573 1
a573 1
	mandoc_asprintf(&file, "%s/man%s/%s.*",
@


1.238
log
@Improve the error message in case somebody has configured an invalid PAGER.
Suggested by Lorenzo Beretta <lory dot fulgi at infinito dot it>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.237 2015/04/20 09:54:48 schwarze Exp $ */
d42 1
d501 1
d503 1
d965 1
d970 39
a1043 26
	pager = getenv("MANPAGER");
	if (pager == NULL || *pager == '\0')
		pager = getenv("PAGER");
	if (pager == NULL || *pager == '\0')
		pager = "more -s";
	cp = mandoc_strdup(pager);

	/*
	 * Parse the pager command into words.
	 * Intentionally do not do anything fancy here.
	 */

	argc = 0;
	while (argc + 1 < MAX_PAGER_ARGS) {
		argv[argc++] = cp;
		cp = strchr(cp, ' ');
		if (cp == NULL)
			break;
		*cp++ = '\0';
		while (*cp == ' ')
			cp++;
		if (*cp == '\0')
			break;
	}
	argv[argc] = NULL;

@


1.237
log
@Fix previous:  Don't let man(1) warn twice about non-existant names.
Again noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.236 2015/04/19 15:10:46 schwarze Exp $ */
d1030 2
a1031 2
	fprintf(stderr, "%s: exec: %s\n",
	    progname, strerror(errno));
@


1.236
log
@If apropos(1) finds no match, print "nothing appropriate" to stderr
similar to what the old apropos did.
Requested by and OK deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.235 2015/04/18 16:34:25 schwarze Exp $ */
d355 9
a363 3
		if (sz == 0 && search.argmode == ARG_NAME)
			fs_search(&search, &conf.manpath,
			    argc, argv, &res, &sz);
a365 2
			fprintf(stderr, "%s: nothing appropriate\n",
			    progname);
@


1.235
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.234 2015/04/18 16:06:40 schwarze Exp $ */
d360 2
@


1.234
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.233 2015/04/16 16:36:21 schwarze Exp $ */
a634 1
	struct roff_man	 *mdoc;
d722 1
a722 1
	mparse_result(curp->mp, &mdoc, &man, NULL);
d726 5
a730 1
	if (man && curp->outman)
a731 2
	if (mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, mdoc);
@


1.233
log
@shorten "outdated mandoc.db" warning message; requested by deraadt@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.232 2015/04/03 08:46:17 schwarze Exp $ */
d61 2
a62 2
typedef	void		(*out_mdoc)(void *, const struct mdoc *);
typedef	void		(*out_man)(void *, const struct man *);
d635 2
a636 2
	struct mdoc	 *mdoc;
	struct man	 *man;
@


1.232
log
@No need to hardcode /usr/bin/ as the path to more(1); helps portability.
We don't hardcode the paths to gunzip(1) and cmp(1) either.
Discussed with ajacoutot@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.231 2015/04/02 21:36:49 schwarze Exp $ */
d579 2
a580 3
	fprintf(stderr, "%s: outdated mandoc.db lacks %s(%s) entry,\n"
	    "     consider running  # makewhatis %s\n",
	    progname, name, sec, paths->paths[ipath]);
a581 1

@


1.231
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.230 2015/03/27 21:33:20 schwarze Exp $ */
d1000 1
a1000 1
		pager = "/usr/bin/more -s";
@


1.230
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.229 2015/03/27 17:37:25 schwarze Exp $ */
d37 1
d39 1
a39 2
#include "mandoc_aux.h"
#include "main.h"
d42 1
@


1.229
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.228 2015/03/27 16:36:31 schwarze Exp $ */
d86 1
a86 1
	char		  outopts[BUFSIZ]; /* buf of output opts */
d130 1
a130 1
	int		 prio, best_prio, synopsis_only;
d177 1
a182 1
	synopsis_only = 0;
d201 1
a201 2
			(void)strlcat(curp.outopts, "synopsis,", BUFSIZ);
			synopsis_only = 1;
d242 3
a244 2
			(void)strlcat(curp.outopts, optarg, BUFSIZ);
			(void)strlcat(curp.outopts, ",", BUFSIZ);
d447 2
a448 1
				passthrough(resp->file, fd, synopsis_only);
@


1.228
log
@Modernize documentation by inserting blanks between option letters
and option arguments, except for -m because "-m an" and "-m andoc"
look just too weird.  Of course, the traditional form without the
blank will continue to work.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.227 2015/03/17 13:35:52 schwarze Exp $ */
d11 1
a11 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d13 1
a13 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d42 1
a42 1
#include "manpath.h"
d121 1
a123 1
	struct manpaths	 paths;
d154 1
a154 1
	memset(&paths, 0, sizeof(struct manpaths));
d339 1
a339 1
		manpath_parse(&paths, conf_file, defpaths, auxpaths);
d342 2
a343 1
		if( ! mansearch(&search, &paths, argc, argv, &res, &sz))
d355 2
a356 1
			fs_search(&search, &paths, argc, argv, &res, &sz);
d444 1
a444 1
				chdir(paths.paths[resp->ipath]);
d475 1
a475 1
		manpath_free(&paths);
@


1.227
log
@Simplify: Now that rc is global anyway, no need to pass it around
as an argument.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.226 2015/03/17 07:33:07 schwarze Exp $ */
d502 3
a504 3
		fputs("usage: mandoc [-acfhkl] [-Ios=name] "
		    "[-Kencoding] [-mformat] [-Ooption]\n"
		    "\t      [-Toutput] [-Wlevel] [file ...]\n", stderr);
@


1.226
log
@When the user exits the pager before the pager has drained all input
from man(1), man(1) dies from SIGPIPE.  Exiting man(1) is fine in this
case, generating more output would be pointless, but without handling
SIGPIPE, the exit code from man(1) was wrong and csh(1) printed an
ugly message "Broken pipe".  Fix this by handling SIGPIPE explicitly.
Issue noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.225 2015/03/10 13:50:03 schwarze Exp $ */
d104 2
a105 3
static	void		  parse(struct curparse *, int,
				const char *, enum mandoclevel *);
static	enum mandoclevel  passthrough(const char *, int, int);
d425 1
a425 1
		parse(&curp, STDIN_FILENO, "<stdin>", &rc);
d439 1
a439 1
				parse(&curp, fd, *argv, &rc);
d443 3
a445 7
				parse(&curp, fd, resp->file, &rc);
			} else {
				rctmp = passthrough(resp->file, fd,
				    synopsis_only);
				if (rc < rctmp)
					rc = rctmp;
			}
d630 1
a630 2
parse(struct curparse *curp, int fd, const char *file,
	enum mandoclevel *level)
d632 1
a632 1
	enum mandoclevel  rc;
d641 3
a643 1
	rc = mparse_readfd(curp->mp, fd, file);
d650 2
a651 2
	if (MANDOCLEVEL_OK != rc && curp->wstop)
		goto cleanup;
a728 4

cleanup:
	if (*level < rc)
		*level = rc;
d731 1
a731 1
static enum mandoclevel
d789 1
a789 1
	return(MANDOCLEVEL_OK);
d794 2
a795 1
	return(MANDOCLEVEL_SYSERR);
d943 1
a943 1
	exit(rc);
@


1.225
log
@We can keep track of the pager PID without additional complexity.
No functional change for now, but more robust in case anybody should
ever add additional child processes.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.224 2015/03/10 03:02:28 schwarze Exp $ */
d30 1
d96 1
d116 1
d133 1
a133 1
	enum mandoclevel rc, rctmp;
d946 7
d985 1
@


1.224
log
@Fix a regression caused in rev. 1.212, reported by kristaps@@:

When using a pager and the first manual shown is gzip'ed,
the gunzip(1) process ended up as a child of the pager process
such that the man(1) process couldn't wait for it, preventing
proper display of the manual.

Solve this by making the pager a child of the man(1) process
(instead of the other way round), which requires being a bit
more careful about properly closing file descriptors after use
and waiting for the pager before exiting man(1).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.223 2015/03/06 09:24:59 kristaps Exp $ */
d105 1
a105 1
static	void		  spawn_pager(void);
a133 1
	int		 use_pager;
d136 1
d178 1
a178 1
	use_pager = 1;
d193 1
a193 1
			use_pager = 0;
d201 1
a201 1
			use_pager = 0;
d276 1
a276 1
			use_pager = 0;
d421 2
a422 2
		if (use_pager && isatty(STDOUT_FILENO))
			spawn_pager();
d433 2
a434 3
			if (use_pager && isatty(STDOUT_FILENO))
				spawn_pager();
			use_pager = 0;
d485 3
a487 3
	 * Flush the output and signal end of file.
	 * If a pager is attached, it allows browsing to the end.
	 * Otherwise, it does no harm, we are about to exit anyway.
d490 4
a493 8
	fclose(stdout);

	/*
	 * If we spawned a pager, wait for the user to close it.
	 * Otherwise, this call fails with no adverse effect.
	 */

	wait(NULL);
d943 1
a943 1
static void
d952 1
d957 1
a957 1
		return;
d960 1
a960 1
	switch (fork()) {
d975 1
a975 1
		return;
@


1.223
log
@Allow compilation on Mac OS X, which doesn't have MACHINE defined.
While there, specify some casts to satisfy the compiler warnings.

OK schwarze@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.222 2015/02/27 16:02:10 schwarze Exp $ */
d23 1
d485 15
d970 2
d978 1
a979 2
	default:
		break;
d982 1
a982 1
	/* The original process becomes the pager. */
d990 1
@


1.222
log
@When man(1) and apropos(1) look for a file man1/foo.1 but it's unavailable,
fall back to glob(man1/foo.*), which is more like what old man(1) did.
Do this both for file names from the database and for fs_lookup().
This is relevant because some ports install files like man1/xset.1x.
Regression reported by patrick keshishian <pkeshish at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.221 2015/02/16 16:23:54 schwarze Exp $ */
d306 1
a306 1
		    ((uc = argv[0]) != NULL) &&
d310 1
a310 1
			search.sec = uc;
d316 1
d319 1
@


1.221
log
@Delete the -V option.  It serves no purpose but keeps confusing people.

Keeping track of the versions of installed software is the job of
the package manager, not of the individual binaries.  If individual
binaries include version numbers, that tends to goad people into
writing broken configuration tests that inspect version numbers
instead of properly testing for features.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.220 2015/02/10 08:05:30 schwarze Exp $ */
d28 1
d521 1
d524 1
a524 1
	int		 form;
d526 1
d529 1
a529 2
	if (access(file, R_OK) != -1) {
		form = FORM_SRC;
a530 1
	}
d544 1
a544 2
		if (access(file, R_OK) != -1) {
			form = FORM_SRC;
a545 1
		}
d548 13
a560 1
	return(0);
@


1.220
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.219 2015/02/07 06:28:08 schwarze Exp $ */
a105 1
static	void		  version(void) __attribute__((noreturn));
a258 3
		case 'V':
			version();
			/* NOTREACHED */
a484 8
version(void)
{

	printf("mandoc %s\n", VERSION);
	exit((int)MANDOCLEVEL_OK);
}

static void
d490 1
a490 1
		fputs("usage: mandoc [-acfhklV] [-Ios=name] "
d495 1
a495 1
		fputs("usage: man [-acfhklVw] [-C file] [-I os=name] "
d502 1
a502 1
		fputs("usage: whatis [-acfhklVw] [-C file] "
d507 1
a507 1
		fputs("usage: apropos [-acfhklVw] [-C file] "
@


1.219
log
@be more careful about argc == 0
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.218 2015/02/03 21:16:02 schwarze Exp $ */
d569 1
a569 1
	
@


1.218
log
@Enable the integrated man(1) even when database support is disabled,
using the file system lookup fallback code, also reducing the number
of preprocessor conditional directives.
Hopefully, it will make some small Linux distros happy.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.217 2015/01/20 21:16:51 schwarze Exp $ */
d137 3
a139 2
	progname = strrchr(argv[0], '/');
	if (progname == NULL)
d291 4
a294 2
	argc -= optind;
	argv += optind;
d420 1
a420 1
	if (argc == 0) {
d426 1
a426 1
	while (argc) {
@


1.217
log
@Split the -Werror message level into -Werror (broken manual, probably
using mandoc is better than using groff) and -Wunsupp (manual using
unsupported low-level roff(7) feature, probably using groff is better
than using mandoc).  Once this feature is complete, it is intended
to help porting, making the decision whether to USE_GROFF easier.

As a first step, distinguish four classes of roff(7) requests:
1. Supported (currently 24 requests)
2. Currently ignored because unimportant (120)  ->  no message
3. Ignored for good because insecure (14)  ->  -Werror
4. Currently unsupported (68)  ->  these trigger the new -Wunsupp messages
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.216 2015/01/16 21:15:05 schwarze Exp $ */
a85 1
#if HAVE_SQLITE3
a92 1
#endif
a101 1
#if HAVE_SQLITE3
a102 1
#endif
a123 1
#if HAVE_SQLITE3
a128 1
#endif
a150 1
#if HAVE_SQLITE3
a151 1
#endif
a177 1
#if HAVE_SQLITE3
a178 1
#endif
a187 1
#if HAVE_SQLITE3
a188 1
#endif
a197 1
#if HAVE_SQLITE3
a198 1
#endif
a231 1
#if HAVE_SQLITE3
a232 1
#endif
a291 1
#if HAVE_SQLITE3
a292 1
#endif
a324 1
#if HAVE_SQLITE3
d335 1
d339 8
a399 5
#else
		fputs("mandoc: database support not compiled in\n",
		    stderr);
		return((int)MANDOCLEVEL_BADARG);
#endif
d425 1
a425 4
#if HAVE_SQLITE3
		    resp != NULL ? resp->file :
#endif
		    *argv);
a433 1
#if HAVE_SQLITE3
a434 1
#endif
a435 1
#if HAVE_SQLITE3
a445 1
#endif
a457 1
#if HAVE_SQLITE3
a460 1
#endif
a470 1
#if HAVE_SQLITE3
d474 1
d477 1
a478 1
#endif
a523 1
#if HAVE_SQLITE3
d561 1
d565 1
a614 1
#endif
a720 1
#if HAVE_SQLITE3
a785 1
#endif
@


1.216
log
@Let man(1) show manuals for the current architecture by default,
and support the MACHINE environment variable as documented in man(1).
Missing feature reported by pascal@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.215 2015/01/15 04:26:39 schwarze Exp $ */
d892 1
a892 1
	const char	*toks[6];
d898 3
a900 2
	toks[4] = "fatal";
	toks[5] = NULL;
d917 3
@


1.215
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.214 2015/01/14 21:27:17 schwarze Exp $ */
d22 1
d332 4
@


1.214
log
@if earlier files set a non-zero exit status,
do not allow later files to reset it to zero
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.213 2015/01/13 23:17:52 schwarze Exp $ */
d179 1
a179 1
	curp.wlevel  = MANDOCLEVEL_FATAL;
a649 5
	/* Stop immediately if the parse has failed. */

	if (MANDOCLEVEL_FATAL <= rc)
		goto cleanup;

d911 1
a911 1
			curp->wlevel = MANDOCLEVEL_FATAL;
@


1.213
log
@Be developer-friendly, 'cause OpenBSD devs like to:
cd /usr/src/share/man/man4; vi newdev.4 Makefile; make install; man newdev

When a manual is missing from an outdated database, let man(1)
show it anyway, using a KISS file system lookup as a fallback.
Requested by deraadt@@.

87 new lines of code doesn't seem too much bloat to me.

Of course, keeping your mandoc.db(5) files up to date with makewhatis(8)
or weekly(8) is still required for apropos(1) to find your new pages.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.212 2015/01/13 13:22:22 schwarze Exp $ */
d134 1
a134 1
	enum mandoclevel rc;
d434 1
a434 1
		rc = mparse_open(curp.mp, &fd,
d439 2
d456 2
a457 2
			} else
				rc = passthrough(resp->file, fd,
d459 3
d464 3
a466 2
			if (mparse_wait(curp.mp) != MANDOCLEVEL_OK)
				rc = MANDOCLEVEL_SYSERR;
@


1.212
log
@do not spawn a pager when there is no output; issue pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.211 2015/01/01 13:20:38 schwarze Exp $ */
d85 9
d352 3
a354 1
		resp = res;
a356 3
			if (search.argmode == ARG_NAME)
				fprintf(stderr, "%s: No entry for %s "
				    "in the manual.\n", progname, argv[0]);
d375 1
d537 92
@


1.211
log
@If man(1) only has one single argument, always interpret it as a name,
never as a section.  Who would have thought that people call their
manual pages 7z(1), 9c(1), 9p(1), and 9p(3)...
Patch from Sebastien Marie <semarie dash openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.210 2014/12/31 16:52:39 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2014 Ingo Schwarze <schwarze@@openbsd.org>
a407 3
	if (use_pager && isatty(STDOUT_FILENO))
		spawn_pager();

d418 3
a420 1
	if (argc == 0)
d422 1
d425 15
a440 4
		if (resp != NULL) {
			rc = mparse_open(curp.mp, &fd, resp->file);
			if (fd == -1)
				/* nothing */;
a447 2
			resp++;
		} else
d449 6
a454 4
		{
			rc = mparse_open(curp.mp, &fd, *argv++);
			if (fd != -1)
				parse(&curp, fd, argv[-1], &rc);
a456 3
		if (mparse_wait(curp.mp) != MANDOCLEVEL_OK)
			rc = MANDOCLEVEL_SYSERR;

d460 8
a467 2
		if (--argc && curp.outtype <= OUTT_UTF8)
			ascii_sepline(curp.outdata);
d633 1
a633 4
 cleanup:

	mparse_reset(curp->mp);

@


1.210
log
@When showing more than one formatted manual page, insert horizontal lines
between pages.  Suggested by Theo Buehler <theo at math dot ethz dot ch>.
Even in UTF-8 output mode, do not use fancy line drawing characters such
that you can easily use /^--- to skip to the next manual in your pager.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.209 2014/12/21 14:49:28 schwarze Exp $ */
d313 2
a314 1
		} else if (((uc = argv[0]) != NULL) &&
@


1.209
log
@Use -m for macro set selection in mandoc(1) mode only, not in man(1)
and apropos(1) mode.  While here, put a space character between
options and option arguments in error messages.
Both reported by Alessandro DE LAURENZIS <just22 dot adl at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.208 2014/12/18 21:11:46 schwarze Exp $ */
d450 3
a452 1
		argc--;
d640 2
@


1.208
log
@update usage() and the list of non-standard (i.e. non-posix) options;
from jmc@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.207 2014/12/17 18:45:35 schwarze Exp $ */
d209 1
a209 1
				    "%s: -I%s: Bad argument\n",
d215 1
a215 1
				    "%s: -I%s: Duplicate argument\n",
d404 1
a404 1
	if ( ! moptions(&options, auxpaths))
d703 1
a703 1
		fprintf(stderr, "%s: -K%s: Bad argument\n",
d723 1
a723 1
		fprintf(stderr, "%s: -m%s: Bad argument\n",
d757 1
a757 1
		fprintf(stderr, "%s: -T%s: Bad argument\n",
d796 1
a796 1
			fprintf(stderr, "%s: -W%s: Bad argument\n",
@


1.207
log
@Be a bit more lenient in what to accept for section names given
as the first man(1) command line argument without -s:
Accept digits like "1", "2"; digit+letter like "3p", "1X"; and "n".
Issue reported by Svyatoslav Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.206 2014/12/15 18:05:57 schwarze Exp $ */
d491 4
a494 2
		fputs("usage: man [-acfhklVw] [-C file] "
		    "[-M path] [-m path] [-S arch] [-s section]\n"
@


1.206
log
@Let "man n open" do the same as "man -s n open" again, that is,
show the open(n) Tcl manual, as documented in man(1).  Issue reported
by Svyatoslav Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.205 2014/12/11 19:19:35 schwarze Exp $ */
d117 1
d313 5
a317 5
		} else if (argv[0] != NULL && (
		    (isdigit((unsigned char)argv[0][0]) &&
		     (argv[0][1] == '\0' || !strcmp(argv[0], "3p"))) ||
		    (argv[0][0] == 'n' && argv[0][1] == '\0'))) {
			search.sec = argv[0];
@


1.205
log
@Guard some come needed for database support only by #if HAVE_SQLITE3.
Compiler warnings about unused code reported by wiz@@NetBSD.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.204 2014/12/09 09:14:33 schwarze Exp $ */
d312 4
a315 3
		} else if (argv[0] != NULL &&
		    isdigit((unsigned char)argv[0][0]) &&
		    (argv[0][1] == '\0' || !strcmp(argv[0], "3p"))) {
@


1.204
log
@Support choosing alternative binary and manual names from configure.local,
to help downstream distributions avoid naming conflicts.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.203 2014/12/09 07:29:42 schwarze Exp $ */
d94 1
d96 1
d115 1
a115 1
	char		*conf_file, *defpaths, *auxpaths;
d119 1
d121 1
a121 1
	int		 prio, best_prio;
a128 1
	int		 synopsis_only;
d146 4
a149 1
	conf_file = defpaths = auxpaths = NULL;
d175 1
d177 1
d187 1
d189 1
d199 1
d201 1
d235 1
d237 1
d620 1
d684 1
@


1.203
log
@Integrate the makewhatis binary into the mandoc binary
just like we do it on OpenBSD.  Smaller and neater.
While here, let ./configure set INSTALL_TARGETS.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.202 2014/12/05 21:55:04 schwarze Exp $ */
d137 1
a137 2
	if (0 == strncmp(progname, "mandocdb", 8) ||
	    0 == strncmp(progname, "makewhatis", 10))
d149 1
a149 1
	if (strcmp(progname, "man") == 0)
d151 1
a151 1
	else if (strncmp(progname, "apropos", 7) == 0)
d153 1
a153 1
	else if (strncmp(progname, "whatis", 6) == 0)
@


1.202
log
@implement help(1)
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.201 2014/12/02 11:31:51 schwarze Exp $ */
d86 3
d136 6
@


1.201
log
@Switch the default output mode from -Tascii to -Tlocale.
This doesn't change anything unless LC_CTYPE is set,
but it helps when running with LC_TYPE=something.UTF-8.

OK tedu@@  and earlier positive feedback from:
bentley@@ deraadt@@ naddy@@ stsp@@  uqs@@freebsd wiz@@netbsd
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.200 2014/11/26 21:40:17 schwarze Exp $ */
d99 2
d147 2
d280 4
a283 1
	/* Quirk for a man(1) section argument without -s. */
d285 13
a297 7
	if (search.argmode == ARG_NAME &&
	    argv[0] != NULL &&
	    isdigit((unsigned char)argv[0][0]) &&
	    (argv[0][1] == '\0' || !strcmp(argv[0], "3p"))) {
		search.sec = argv[0];
		argv++;
		argc--;
@


1.200
log
@Simplify the mparse_open()/mparse_wait() interface.
Don't bother the user with the PID of the child process,
store it inside the opaque mparse handle.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.199 2014/11/11 19:04:55 schwarze Exp $ */
d151 1
a151 1
	curp.outtype = OUTT_ASCII;
@


1.199
log
@In man(1) mode without -a, stop searching after the first manual tree
that contained at least one match in order to not prefer mdoc(1) from
ports over mdoc(7).  As a bonus, this results in a speedup.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.198 2014/11/11 02:43:41 schwarze Exp $ */
a117 1
	pid_t		 child_pid;
d390 1
a390 2
			rc = mparse_open(curp.mp, &fd, resp->file,
			    &child_pid);
d404 1
a404 2
			rc = mparse_open(curp.mp, &fd, *argv++,
			    &child_pid);
d409 1
a409 2
		if (child_pid &&
		    mparse_wait(curp.mp, child_pid) != MANDOCLEVEL_OK)
@


1.198
log
@Let -h imply -c (that is, not use the pager).
Usually, -h output is short, so the pager is just a nuisance.
Also, traditional man(1) does not use a pager for -h.
Triggered by a remark of deraadt@@ on ICB.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.197 2014/11/11 02:10:04 schwarze Exp $ */
d297 4
@


1.197
log
@implement -h (synopsis only) for preformatted (cat) pages;
requested by tedu@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.196 2014/10/30 17:15:28 schwarze Exp $ */
d180 1
@


1.196
log
@add -K to usage() and wrap nicely; from jmc@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.195 2014/10/28 17:36:19 schwarze Exp $ */
d91 1
a91 1
static	enum mandoclevel  passthrough(const char *, int);
d122 1
d159 1
d179 1
d395 2
a396 1
				rc = passthrough(resp->file, fd);
d586 1
a586 1
passthrough(const char *file, int fd)
d588 4
a591 1
	char		 buf[BUFSIZ];
d593 35
a627 7
	ssize_t		 nr, nw, off;

	while ((nr = read(fd, buf, BUFSIZ)) != -1 && nr != 0)
		for (off = 0; off < nr; off += nw)
			if ((nw = write(STDOUT_FILENO, buf + off,
			    (size_t)(nr - off))) == -1 || nw == 0) {
				close(fd);
d631 1
d633 5
a637 1
	close(fd);
d639 3
a641 2
	if (nr == 0)
		return(MANDOCLEVEL_OK);
a642 1
	syscall = "read";
@


1.195
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.194 2014/10/25 01:03:52 schwarze Exp $ */
d446 2
a447 2
		    "[-mformat] [-Ooption] [-Toutput] [-Wlevel]\n"
		    "\t      [file ...]\n", stderr);
@


1.194
log
@integrate preconv(1) into mandoc(1);
enhances functionality and reduces code and docs by more than 300 lines
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.193 2014/10/18 15:57:34 schwarze Exp $ */
a66 1
	OUTT_XHTML,	/* -Txhtml */
d74 1
d367 3
a369 1
	curp.mp = mparse_alloc(options, curp.wlevel, mmsg, defos);
d414 2
a415 2
	if (curp.mp)
		mparse_free(curp.mp);
a499 4
		case OUTT_XHTML:
			curp->outdata = xhtml_alloc(curp->outopts);
			curp->outfree = html_free;
			break;
d501 2
a502 1
			curp->outdata = html_alloc(curp->outopts);
d506 2
a507 1
			curp->outdata = utf8_alloc(curp->outopts);
d511 2
a512 1
			curp->outdata = locale_alloc(curp->outopts);
d516 2
a517 1
			curp->outdata = ascii_alloc(curp->outopts);
d521 2
a522 1
			curp->outdata = pdf_alloc(curp->outopts);
d526 2
a527 1
			curp->outdata = ps_alloc(curp->outopts);
a535 2
			/* FALLTHROUGH */
		case OUTT_XHTML:
d670 1
a670 1
		curp->outtype = OUTT_XHTML;
@


1.193
log
@plug file descriptor leaks on read or write failure;
hinted at by Steffen Nurpmeso <sdaoden at yandex dot com>.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.192 2014/09/03 23:21:47 schwarze Exp $ */
d85 1
d153 1
a153 1
	options = MPARSE_SO;
d160 2
a161 1
	while (-1 != (c = getopt(argc, argv, "aC:cfhI:iklM:m:O:S:s:T:VW:w"))) {
d197 4
d608 20
@


1.192
log
@Add *.gz support to apropos(1) -a, man(1), and even mandoc(1).
Implemented by moving the zip code from makewhatis(8) to the parser lib.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.191 2014/09/03 18:09:14 schwarze Exp $ */
d584 1
d589 3
a591 2
        if (nr == 0) {
		close(fd);
a592 1
        }
@


1.191
log
@If a manual page is installed gzip(1)ed, let makewhatis(8) take
note in mandoc.db(5), such that man(1) -w and apropos(1) -w can
report the correct filename.
This is a prerequisite for letting apropos -a and man support
gzip'ed manuals in the future, which doesn't work yet.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.190 2014/09/03 05:22:45 schwarze Exp $ */
d90 1
a90 1
static	enum mandoclevel  passthrough(const char *);
d117 2
d375 5
a379 1
			if (resp->form & FORM_SRC) {
d382 1
a382 1
				parse(&curp, -1, resp->file, &rc);
d384 1
a384 1
				rc = passthrough(resp->file);
d388 11
a398 1
			parse(&curp, -1, *argv++, &rc);
d574 1
a574 1
passthrough(const char *file)
a578 7
	int		 fd;

	fd = open(file, O_RDONLY);
	if (fd == -1) {
		syscall = "open";
		goto fail;
	}
@


1.190
log
@Implement the traditional -h option for man(1): show the SYNOPSIS only.
As usual, we get mandoc -h and apropos -h for free.
Try stuff like "apropos -h In=dirent" or "apropos -h Fa=timespec".

Only useful for terminal output, so -Tps, -Tpdf, -Thtml ignore -h for now.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.189 2014/09/01 22:45:53 schwarze Exp $ */
d373 1
a373 1
			if (resp->form) {
@


1.189
log
@In man(1) mode, change to the right directory before starting the parser,
just like traditional man(1) does, such that .so links have a chance to
work.  After this point, we don't need the current directory for anything
else before exit, so we don't need to worry about getting back and we can
safely ignore failure.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.188 2014/08/30 18:08:10 schwarze Exp $ */
d157 1
a157 1
	while (-1 != (c = getopt(argc, argv, "aC:cfI:iklM:m:O:S:s:T:VW:w"))) {
d171 4
d421 1
a421 1
		fputs("usage: mandoc [-acfklV] [-Ios=name] "
d431 1
a431 1
		fputs("usage: whatis [-acfklVw] [-C file] "
d436 1
a436 1
		fputs("usage: apropos [-acfklVw] [-C file] "
@


1.188
log
@Introduce a man(1) -l option as an alias for mandoc -a.
Basically, this does the same as man -l in Linux man-db.
The point is that now all functionality of the combined tool
is reachable from the man(1) command name:
apropos = man -k, whatis = man -f, mandoc = man -cl.

Originally suggested by Carsten dot Kunze at arcor dot de,
current maintainer of the Heirloom Documentation Tools.

While here, add various missing information to the usage()
and to the manuals.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.187 2014/08/23 22:26:06 schwarze Exp $ */
a286 1
		manpath_free(&paths);
d369 3
a371 1
			if (resp->form)
d373 1
a373 1
			else
d392 1
@


1.187
log
@without search results, skip the processing loops and the parser
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.186 2014/08/23 00:34:59 schwarze Exp $ */
d157 1
a157 1
	while (-1 != (c = getopt(argc, argv, "aC:cfI:ikM:m:O:S:s:T:VW:w"))) {
d192 4
d415 2
a416 2
		fputs("usage: mandoc [-V] [-Ios=name] [-mformat]"
		    " [-Ooption] [-Toutput] [-Wlevel]\n"
d420 1
a420 1
		fputs("usage: man [-acfhkVw] [-C file] "
d425 3
a427 2
		fputs("usage: whatis [-V] [-C file] [-M path] [-m path] "
		    "[-S arch] [-s section] name ...\n", stderr);
d430 2
a431 2
		fputs("usage: apropos [-V] [-C file] [-M path] [-m path] "
		    "[-O outkey] [-S arch]\n"
@


1.186
log
@Let man(1) display preformatted manuals by simply reading them
from the file and copying them to the standard output.
This works even for mixed formats: "man -a groff mandoc" displays
groff(1) [formatted], mandoc(1) [unformatted], groff(7) [formatted],
and mandoc(7) [unformatted] in that order.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.185 2014/08/22 18:07:15 schwarze Exp $ */
d286 8
@


1.185
log
@implement man(1) quirk: section argument without -s
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.184 2014/08/22 04:52:55 schwarze Exp $ */
d26 1
d90 1
d110 1
a110 2
	struct manpage	*res;
	char		**auxargv;
d254 1
a254 1
	auxargv = NULL;
d284 1
a293 2
			argv[0] = res[0].file;
			argv[1] = NULL;
d295 1
a295 1
		} else if (outmode == OUTMODE_ALL) {
a296 4
			argv = auxargv = mandoc_reallocarray(
			    NULL, sz + 1, sizeof(char *));
			argv[argc] = NULL;
		}
d307 1
a307 3
			else if (outmode == OUTMODE_ALL)
				argv[i] = res[i].file;
			else {
d317 1
a317 1
				argv[0] = res[i].file;
d352 1
a352 1
	if (NULL == *argv)
d355 11
a365 2
	while (*argv) {
		parse(&curp, -1, *argv, &rc);
d368 1
a368 1
		++argv;
a380 1
		free(auxargv);
d538 34
@


1.184
log
@implement MANPAGER and PAGER
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.183 2014/08/22 03:42:18 schwarze Exp $ */
d24 1
d231 2
d248 2
d256 11
@


1.183
log
@mandoc -a, man, apropos -a, whatis -a now paginate by default
but provide an option -c to not paginate;
taking inspiration from manpage.c, hence adding (c) 2012 kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.182 2014/08/21 00:32:15 schwarze Exp $ */
d640 6
a645 1
	int	 fildes[2];
d667 9
a675 9
		close(fildes[1]);
		if (dup2(fildes[0], STDIN_FILENO) == -1) {
			fprintf(stderr, "%s: dup input: %s\n",
			    progname, strerror(errno));
		} else {
			execlp("more", "more", "-s", NULL);
			fprintf(stderr, "%s: exec: %s\n",
			    progname, strerror(errno));
		}
d678 33
@


1.182
log
@Implement classic man(1) output mode showing only one manual even
if there is more than one match, using traditional section priorities,
and implement man(1) -a (show all) output mode, not just for man(1),
but also for apropos(1) and whatis(1).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.181 2014/08/20 21:04:35 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d24 1
d88 1
d116 1
d151 1
d154 2
a155 1
	while (-1 != (c = getopt(argc, argv, "aC:fI:ikM:m:O:S:s:T:VW:w"))) {
d163 3
d234 1
d331 3
d636 38
@


1.181
log
@Parse the new -a, -i, and -w options.
Implement -w (list manual page filenames).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.180 2014/08/17 03:24:47 schwarze Exp $ */
d92 1
d106 4
a109 1
	size_t		 i, sz;
d238 5
d250 3
d258 21
d282 1
a282 1
			else
d286 14
d301 9
a309 3
		mansearch_free(res, sz);
		mansearch_setup(0);
		return((int)MANDOCLEVEL_OK);
a329 2
	rc = MANDOCLEVEL_OK;

d344 10
@


1.180
log
@Fully integrate apropos(1) into mandoc(1).
Switch the argmode on the progname, including man(1).
Provide -f and -k options to switch the argmode.
Store the argmode inside struct search, generalizing the flags.
Derive the deftype from the argmode when needed instead of storing it.
Store the outkey inside struct search instead of passing it alone.
While here, get rid of the trailing blanks in Makefile.depend.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.179 2014/08/16 23:04:25 schwarze Exp $ */
d44 9
d108 1
d145 2
a146 1
	while (-1 != (c = getopt(argc, argv, "C:fI:kM:m:O:S:s:T:VW:"))) {
d148 3
d172 3
d203 3
d218 14
d246 8
a253 3
		for (i = 0; i < sz; i++)
			printf("%s - %s\n", res[i].names,
			    res[i].output == NULL ? "" : res[i].output);
@


1.179
log
@When BUILD_DB is active, link apropos(1) into the mandoc binary.
This is the first step on the way to a man(1) implementation.
The new ./configure is flexible enough to make this step quite easy.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.178 2014/08/10 23:54:41 schwarze Exp $ */
d35 2
a72 4
#if HAVE_SQLITE3
int			  apropos(int, char**);
#endif

d79 1
a79 1
static	void		  usage(void) __attribute__((noreturn));
a88 1
	int		 c;
d90 10
d101 1
a101 2
	enum mandoclevel rc;
	char		*defos;
d109 18
a126 5
#if HAVE_SQLITE3
	if (0 == strncmp(progname, "apropos", 7) ||
	    0 == strncmp(progname, "whatis", 6))
		return(apropos(argc, argv));
#endif
a128 2

	options = MPARSE_SO;
d131 1
d134 2
a135 1
	while (-1 != (c = getopt(argc, argv, "I:m:O:T:VW:")))
d137 6
d158 6
d165 1
a165 2
			if ( ! moptions(&options, optarg))
				return((int)MANDOCLEVEL_BADARG);
d168 1
d172 6
d190 2
a191 2
			usage();
			/* NOTREACHED */
d193 36
a237 3
	argc -= optind;
	argv += optind;

d263 1
a263 1
	printf("%s %s\n", progname, VERSION);
d268 1
a268 1
usage(void)
d271 21
a291 10
	fprintf(stderr, "usage: %s "
			"[-V] "
			"[-Ios=name] "
			"[-mformat] "
			"[-Ooption] "
			"[-Toutput] "
			"[-Wlevel]\n"
			"\t      [file ...]\n",
			progname);

d412 3
a414 1
	if (0 == strcmp(arg, "doc"))
@


1.178
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.177 2014/06/21 22:24:01 schwarze Exp $ */
d71 4
d103 6
@


1.177
log
@Reduce the verbosity of error messages caused by open(2) failures.
Suggested by and ok jmc@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.176 2014/06/21 16:18:25 schwarze Exp $ */
a18 1
#ifdef HAVE_CONFIG_H
d20 2
a21 1
#endif
@


1.176
log
@Prefix messages about bad command line options and arguments
with "mandoc: " or "makewhatis: ", respectively,
similar to what we already do for other messages.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.175 2014/06/20 23:02:31 schwarze Exp $ */
d414 1
d421 4
a424 2
	fprintf(stderr, " %s: %s", mparse_strlevel(lvl),
	    mparse_strerror(t));
@


1.175
log
@As suggested by jmc@@, only include line and column numbers into messages
when they are meaningful, to avoid confusing stuff like this:
$ mandoc /dev/null
mandoc: /dev/null:0:1: FATAL: not a manual
Instead, just say:
mandoc: /dev/null: FATAL: not a manual

Another example this applies to is documents having a prologue,
but lacking a body.  Do not throw a FATAL error for these; instead,
issue a WARNING and show the empty document, in the man(7) case with
the same amount of blank lines as groff does.  Also downgrade mdoc(7)
documents having content before the first .Sh from FATAL to WARNING.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.174 2014/06/20 16:11:42 schwarze Exp $ */
d111 2
a112 1
				    "-I%s: Bad argument\n", optarg);
d117 2
a118 2
				    "-I%s: Duplicate argument\n",
				    optarg);
d328 2
a329 1
		fprintf(stderr, "%s: Bad argument\n", arg);
d362 2
a363 1
		fprintf(stderr, "%s: Bad argument\n", arg);
d401 2
a402 1
			fprintf(stderr, "-W%s: Bad argument\n", o);
@


1.174
log
@Prefix error messages from mandoc(1) with "mandoc: "
just like almost all other utility programs do.
Suggested by nick@@ who wondered where messages came from
when calling mandoc(1) from inside a Perl script.
ok jmc@@ nick@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.173 2014/04/20 16:46:04 schwarze Exp $ */
d411 7
a417 3
	fprintf(stderr, "%s: %s:%d:%d: %s: %s", progname,
	    file, line, col + 1,
	    mparse_strlevel(lvl), mparse_strerror(t));
@


1.173
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.172 2014/03/23 11:25:26 schwarze Exp $ */
d411 2
a412 1
	fprintf(stderr, "%s:%d:%d: %s: %s", file, line, col + 1,
@


1.172
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.171 2014/03/19 22:20:43 schwarze Exp $ */
d63 1
a63 1
	enum outt	  outtype; 	/* which output to use */
d65 1
a65 1
	out_man	  	  outman;	/* man output ptr */
d74 1
a74 1
static	void		  parse(struct curparse *, int, 
d83 1
a105 1
	/* LINTED */
d108 1
a108 1
		case ('I'):
d110 2
a111 2
				fprintf(stderr, "-I%s: Bad argument\n",
						optarg);
d115 3
a117 2
				fprintf(stderr, "-I%s: Duplicate argument\n",
						optarg);
d122 1
a122 1
		case ('m'):
d126 1
a126 1
		case ('O'):
d130 1
a130 1
		case ('T'):
d134 1
a134 1
		case ('W'):
d138 1
a138 1
		case ('V'):
d197 1
a197 1
			"\t      [file ...]\n", 
d204 2
a205 2
parse(struct curparse *curp, int fd, 
		const char *file, enum mandoclevel *level)
d235 1
a235 1
		case (OUTT_XHTML):
d239 1
a239 1
		case (OUTT_HTML):
d243 1
a243 1
		case (OUTT_UTF8):
d247 1
a247 1
		case (OUTT_LOCALE):
d251 1
a251 1
		case (OUTT_ASCII):
d255 1
a255 1
		case (OUTT_PDF):
d259 1
a259 1
		case (OUTT_PS):
d268 1
a268 1
		case (OUTT_HTML):
d270 1
a270 1
		case (OUTT_XHTML):
d274 1
a274 1
		case (OUTT_TREE):
d278 1
a278 1
		case (OUTT_MAN):
d282 1
a282 1
		case (OUTT_PDF):
d284 1
a284 1
		case (OUTT_ASCII):
d286 1
a286 1
		case (OUTT_UTF8):
d288 1
a288 1
		case (OUTT_LOCALE):
d290 1
a290 1
		case (OUTT_PS):
d371 1
a371 1
	const char	*toks[6]; 
d383 1
a383 1
		case (0):
d386 1
a386 1
		case (1):
d388 1
a388 1
		case (2):
d391 1
a391 1
		case (3):
d394 1
a394 1
		case (4):
d407 1
a407 1
mmsg(enum mandocerr t, enum mandoclevel lvl, 
d411 2
a412 4
	fprintf(stderr, "%s:%d:%d: %s: %s", 
			file, line, col + 1, 
			mparse_strlevel(lvl),
			mparse_strerror(t));
@


1.171
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.170 2014/03/19 21:51:20 schwarze Exp $ */
d31 1
@


1.170
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.169 2014/01/06 00:53:33 schwarze Exp $ */
d297 1
a297 1
	mparse_result(curp->mp, &mdoc, &man);
@


1.169
log
@Joerg Sonnenberger contributed copyrightable amounts of text to
some files.  To make it clear that he also put his contributions
under the ISC license, with his explicit permission, add his
Copyright notice to the relevant files.  No code change.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.168 2014/01/05 20:26:36 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d70 1
a70 1
static	int		  moptions(enum mparset *, char *);
d87 1
a87 1
	enum mparset	 type;
d99 1
a99 1
	type = MPARSE_AUTO;
d121 1
a121 1
			if ( ! moptions(&type, optarg))
d144 1
a144 1
	curp.mp = mparse_alloc(type, curp.wlevel, mmsg, defos, 0);
d315 1
a315 1
moptions(enum mparset *tflags, char *arg)
d319 1
a319 1
		*tflags = MPARSE_MDOC;
d321 1
a321 1
		*tflags = MPARSE_AUTO;
d323 1
a323 1
		*tflags = MPARSE_MAN;
@


1.168
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute of
struct mparse and mparse_alloc() and fix some errors in mandoc(3).

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.167 2012/11/19 17:22:26 schwarze Exp $ */
d5 1
@


1.167
log
@sync usage(), and tidy up the output a little; from jmc@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.84 2012/11/19 08:46:24 jmc Exp $ */
d143 1
a143 1
	curp.mp = mparse_alloc(type, curp.wlevel, mmsg, &curp, defos);
@


1.166
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.165 2011/10/06 22:29:12 kristaps Exp $ */
d189 1
a189 1
			"[-foption] "
d193 2
a194 2
			"[-Wlevel] "
			"[file...]\n", 
@


1.165
log
@If -Tman is specified and input is -man, echo the preprocessed (`so'
replaced by file) input.  This replaces earlier behaviour of doing
nothing, which I found unexpected (mandoc should always output).

This requires a buffer in read.c that saves the input lines before being
parsed, with a special hook if `so' is invoked.  This buffer is just
flushed to output if -mman is the input.

While mucking around doing this, I also alpha-ordered the mandoc.h
functions.

Ok schwarze@@, with no screaming when the polished patch was published.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.164 2011/09/17 15:00:51 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d88 1
d101 1
d104 1
a104 1
	while (-1 != (c = getopt(argc, argv, "m:O:T:VW:")))
d106 13
d143 1
a143 1
	curp.mp = mparse_alloc(type, curp.wlevel, mmsg, &curp);
d170 1
@


1.164
log
@Initial, incomplete support for -Tman
to convert mdoc(7) documents to the man(7) language.
This is work in progress and will be developed in tree.
It does already handle the cat(1) manual,
but will hardly handle all your fancy manuals yet.
go ahead  kristaps@@ jmc@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.163 2011/05/20 15:51:18 kristaps Exp $ */
d130 6
d261 1
@


1.163
log
@Turn on -Tutf8 in the frontend.  Here we go!
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.162 2011/05/17 14:38:34 kristaps Exp $ */
d49 1
d253 3
d319 2
@


1.162
log
@Add mode for -Tlocale.  This mode, with this commit, behaves exactly
like -Tascii.  While adding this, inline term_alloc() (was a one-liner),
remove some switches around the terminal encoding for the symbol table
(unnecessary), and split out ascii_alloc() into ascii_init(), which is
also called from locale_init().
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.161 2011/03/31 10:53:43 kristaps Exp $ */
d47 1
d217 4
d256 2
d317 2
@


1.161
log
@Make -Werr be -Wlevel, keeping it in sync with mandoc.1.  Noted by
Alexander Schrijver---thanks!
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.160 2011/03/28 21:49:42 kristaps Exp $ */
d46 1
d210 1
d214 5
a241 1
			curp->outfree = html_free;
d251 2
d310 2
@


1.160
log
@Put mandocerrs and mandoclevels arrays into libmandoc with accessors
mparse_strerror() and mparse_strlevel().
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.159 2011/03/23 09:47:13 kristaps Exp $ */
d168 1
a168 1
			"[-Werr] "
@


1.159
log
@Make (e.g.) `SM' before `B' be only a warning.  In reality, this refers
to ELINE macros ("next-line", but not unbreakable like the next-line
paragraph macros) followed by other macros.  This addresses a report by
Christian Weisgerber, posted in the TODO by schwarze@@, and aired on
discuss@@ (22/03/2011) for whether a fix is warranted.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.158 2011/03/22 10:35:26 kristaps Exp $ */
a65 118
static	const char * const	mandoclevels[MANDOCLEVEL_MAX] = {
	"SUCCESS",
	"RESERVED",
	"WARNING",
	"ERROR",
	"FATAL",
	"BADARG",
	"SYSERR"
};

static	const char * const	mandocerrs[MANDOCERR_MAX] = {
	"ok",

	"generic warning",

	/* related to the prologue */
	"no title in document",
	"document title should be all caps",
	"unknown manual section",
	"date missing, using today's date",
	"cannot parse date, using it verbatim",
	"prologue macros out of order",
	"duplicate prologue macro",
	"macro not allowed in prologue",
	"macro not allowed in body",

	/* related to document structure */
	".so is fragile, better use ln(1)",
	"NAME section must come first",
	"bad NAME section contents",
	"manual name not yet set",
	"sections out of conventional order",
	"duplicate section name",
	"section not in conventional manual section",

	/* related to macros and nesting */
	"skipping obsolete macro",
	"skipping paragraph macro",
	"skipping no-space macro",
	"blocks badly nested",
	"child violates parent syntax",
	"nested displays are not portable",
	"already in literal mode",
	"line scope broken",

	/* related to missing macro arguments */
	"skipping empty macro",
	"argument count wrong",
	"missing display type",
	"list type must come first",
	"tag lists require a width argument",
	"missing font type",
	"skipping end of block that is not open",

	/* related to bad macro arguments */
	"skipping argument",
	"duplicate argument",
	"duplicate display type",
	"duplicate list type",
	"unknown AT&T UNIX version",
	"bad Boolean value",
	"unknown font",
	"unknown standard specifier",
	"bad width argument",

	/* related to plain text */
	"blank line in non-literal context",
	"tab in non-literal context",
	"end of line whitespace",
	"bad comment style",
	"unknown escape sequence",
	"unterminated quoted string",
	
	"generic error",

	/* related to tables */
	"bad table syntax",
	"bad table option",
	"bad table layout",
	"no table layout cells specified",
	"no table data cells specified",
	"ignore data in cell",
	"data block still open",
	"ignoring extra data cells",

	"input stack limit exceeded, infinite loop?",
	"skipping bad character",
	"escaped character not allowed in a name",
	"skipping text before the first section header",
	"skipping unknown macro",
	"NOT IMPLEMENTED, please use groff: skipping request",
	"argument count wrong",
	"skipping end of block that is not open",
	"missing end of block",
	"scope open on exit",
	"uname(3) system call failed",
	"macro requires line argument(s)",
	"macro requires body argument(s)",
	"macro requires argument(s)",
	"missing list type",
	"line argument(s) will be lost",
	"body argument(s) will be lost",

	"generic fatal error",

	"not a manual",
	"column syntax is inconsistent",
	"NOT IMPLEMENTED: .Bd -file",
	"line scope broken, syntax violated",
	"argument count wrong, violates syntax",
	"child violates parent syntax",
	"argument count wrong, violates syntax",
	"NOT IMPLEMENTED: .so with absolute path or \"..\"",
	"no document body",
	"no document prologue",
	"static buffer exhausted",
};

d362 2
a363 1
			mandoclevels[lvl], mandocerrs[t]);
@


1.158
log
@Add a FATAL error for when no manual type was assigned (you can repeat
this for yourself by having a file consisting only of comments).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.157 2011/03/21 12:04:26 kristaps Exp $ */
d109 1
a156 1
	"line scope broken",
@


1.157
log
@main.c doesn't need roff.h anymore.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.156 2011/03/20 16:05:21 kristaps Exp $ */
d171 1
@


1.156
log
@Let read.c worry about the currently-open file instead of having this
information duplicated in main.c.  For the time being, remove evt_close
and evt_open, as the only known mparse interface (main.c) doesn't need
them.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.155 2011/03/20 16:02:05 kristaps Exp $ */
a32 1
#include "roff.h"
@


1.155
log
@Consolidate messages.  Have all parse-time messages (in libmdoc,
libroff, etc., etc.) route into mandoc_msg() and mandoc_vmsg(), for the
time being in libmandoc.h.  This requires struct mparse to be passed
into the allocation routines instead of mandocmsg and a void pointer.
Then, move some of the functionality of the old mmsg() into read.c's
mparse_mmsg() (check against wlevel and setting of file_status) and use
main.c's mmsg() as simply a printing tool.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.154 2011/03/20 11:41:24 kristaps Exp $ */
a56 1
	const char	 *file;		/* current file-name */
a183 2
static	void		  evt_close(void *, const char *);
static	int		  evt_open(void *, const char *);
d243 1
a243 1
	curp.mp = mparse_alloc(type, evt_open, evt_close, curp.wlevel, mmsg, &curp);
a292 17
static int
evt_open(void *arg, const char *file)
{

	evt_close(arg, file);
	return(1);
}

static void
evt_close(void *arg, const char *file)
{
	struct curparse	*p;

	p = (struct curparse *)arg;
	p->file = file;
}

@


1.154
log
@Split the document parsing sequence out of main.c and into read.c,
putting the interface into mandoc.h.  This effectively makes the
function of main.c be command-line handling, invoking the parser, and
sending its output to the output handler.  The sequence of parsing
(pfile(), pdesc(), etc.) has changed very little but for clean-up of
some state variables (curp->fd, etc.).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.153 2011/03/17 12:08:01 kristaps Exp $ */
a77 10
static	const enum mandocerr	mandoclimits[MANDOCLEVEL_MAX] = {
	MANDOCERR_OK,
	MANDOCERR_WARNING,
	MANDOCERR_WARNING,
	MANDOCERR_ERROR,
	MANDOCERR_FATAL,
	MANDOCERR_MAX,
	MANDOCERR_MAX
};

d188 2
a189 2
static	void		  mmsg(enum mandocerr, void *, 
				int, int, const char *);
d246 1
a246 1
	curp.mp = mparse_alloc(type, evt_open, evt_close, mmsg, &curp);
d494 2
a495 1
mmsg(enum mandocerr t, void *arg, int ln, int col, const char *msg)
a496 2
	struct curparse *cp;
	enum mandoclevel level;
d498 3
a500 11
	level = MANDOCLEVEL_FATAL;
	while (t < mandoclimits[level])
		/* LINTED */
		level--;

	cp = (struct curparse *)arg;
	if (level < cp->wlevel)
		return;

	fprintf(stderr, "%s:%d:%d: %s: %s", cp->file, ln, col + 1, 
			mandoclevels[level], mandocerrs[t]);
a505 2

	mparse_setstatus(cp->mp, level);
@


1.153
log
@mandocmsg finally has no return value.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.152 2011/03/17 08:49:34 kristaps Exp $ */
a21 3
#include <sys/mman.h>
#include <sys/stat.h>

a22 2
#include <ctype.h>
#include <fcntl.h>
a34 8
#ifndef MAP_FILE
#define	MAP_FILE	0
#endif

#define	REPARSE_LIMIT	1000

/* FIXME: Intel's compiler?  LLVM?  pcc?  */

a44 11
struct	buf {
	char	 	 *buf;
	size_t		  sz;
};

enum	intt {
	INTT_AUTO,
	INTT_MDOC,
	INTT_MAN
};

d46 7
a52 7
	OUTT_ASCII = 0,
	OUTT_TREE,
	OUTT_HTML,
	OUTT_XHTML,
	OUTT_LINT,
	OUTT_PS,
	OUTT_PDF
d56 1
a56 1
	enum mandoclevel  exit_status;	/* status of all file parses */
a57 3
	enum mandoclevel  file_status;	/* error status of current parse */
	int		  fd;		/* current file-descriptor */
	int		  line;		/* line number in the file */
a59 8
	enum intt	  inttype;	/* which parser to use */
	struct man	 *pman;		/* persistent man parser */
	struct mdoc	 *pmdoc;	/* persistent mdoc parser */
	struct man	 *man;		/* man parser */
	struct mdoc	 *mdoc;		/* mdoc parser */
	struct roff	 *roff;		/* roff parser (!NULL) */
	struct regset	  regs;		/* roff registers */
	int		  reparse_count; /* finite interpolation stack */
d195 3
a197 6
static	void		  parsebuf(struct curparse *, struct buf, int);
static	void		  pdesc(struct curparse *);
static	void		  fdesc(struct curparse *);
static	void		  ffile(const char *, struct curparse *);
static	int		  pfile(const char *, struct curparse *);
static	int		  moptions(enum intt *, char *);
d200 2
a201 1
static	void		  pset(const char *, int, struct curparse *);
d214 2
d225 1
a225 1
	curp.inttype = INTT_AUTO;
a227 1
	curp.exit_status = MANDOCLEVEL_OK;
d233 1
a233 1
			if ( ! moptions(&curp.inttype, optarg))
d256 2
d261 1
a261 3
	if (NULL == *argv) {
		curp.file = "<stdin>";
		curp.fd = STDIN_FILENO;
d263 2
a264 2
		fdesc(&curp);
	}
d267 2
a268 2
		ffile(*argv, &curp);
		if (MANDOCLEVEL_OK != curp.exit_status && curp.wstop)
d275 2
a276 6
	if (curp.pmdoc)
		mdoc_free(curp.pmdoc);
	if (curp.pman)
		man_free(curp.pman);
	if (curp.roff)
		roff_free(curp.roff);
d278 1
a278 1
	return((int)curp.exit_status);
a280 1

d285 1
a285 1
	(void)printf("%s %s\n", progname, VERSION);
a288 1

d293 1
a293 1
	(void)fprintf(stderr, "usage: %s "
a305 25
static void
ffile(const char *file, struct curparse *curp)
{

	/*
	 * Called once per input file.  Get the file ready for reading,
	 * pass it through to the parser-driver, then close it out.
	 * XXX: don't do anything special as this is only called for
	 * files; stdin goes directly to fdesc().
	 */

	curp->file = file;

	if (-1 == (curp->fd = open(curp->file, O_RDONLY, 0))) {
		perror(curp->file);
		curp->exit_status = MANDOCLEVEL_SYSERR;
		return;
	}

	fdesc(curp);

	if (-1 == close(curp->fd))
		perror(curp->file);
}

d307 1
a307 1
pfile(const char *file, struct curparse *curp)
a308 2
	const char	*savefile;
	int		 fd, savefd;
d310 2
a311 21
	if (-1 == (fd = open(file, O_RDONLY, 0))) {
		perror(file);
		curp->file_status = MANDOCLEVEL_SYSERR;
		return(0);
	}

	savefile = curp->file;
	savefd = curp->fd;

	curp->file = file;
	curp->fd = fd;

	pdesc(curp);

	curp->file = savefile;
	curp->fd = savefd;

	if (-1 == close(fd))
		perror(file);

	return(MANDOCLEVEL_FATAL > curp->file_status ? 1 : 0);
a313 1

d315 1
a315 1
resize_buf(struct buf *buf, size_t initial)
d317 1
d319 2
a320 2
	buf->sz = buf->sz > initial/2 ? 2 * buf->sz : initial;
	buf->buf = mandoc_realloc(buf->buf, buf->sz);
a322 70

static int
read_whole_file(struct curparse *curp, struct buf *fb, int *with_mmap)
{
	struct stat	 st;
	size_t		 off;
	ssize_t		 ssz;

	if (-1 == fstat(curp->fd, &st)) {
		perror(curp->file);
		return(0);
	}

	/*
	 * If we're a regular file, try just reading in the whole entry
	 * via mmap().  This is faster than reading it into blocks, and
	 * since each file is only a few bytes to begin with, I'm not
	 * concerned that this is going to tank any machines.
	 */

	if (S_ISREG(st.st_mode)) {
		if (st.st_size >= (1U << 31)) {
			fprintf(stderr, "%s: input too large\n", 
					curp->file);
			return(0);
		}
		*with_mmap = 1;
		fb->sz = (size_t)st.st_size;
		fb->buf = mmap(NULL, fb->sz, PROT_READ, 
				MAP_FILE|MAP_SHARED, curp->fd, 0);
		if (fb->buf != MAP_FAILED)
			return(1);
	}

	/*
	 * If this isn't a regular file (like, say, stdin), then we must
	 * go the old way and just read things in bit by bit.
	 */

	*with_mmap = 0;
	off = 0;
	fb->sz = 0;
	fb->buf = NULL;
	for (;;) {
		if (off == fb->sz) {
			if (fb->sz == (1U << 31)) {
				fprintf(stderr, "%s: input too large\n", 
						curp->file);
				break;
			}
			resize_buf(fb, 65536);
		}
		ssz = read(curp->fd, fb->buf + (int)off, fb->sz - off);
		if (ssz == 0) {
			fb->sz = off;
			return(1);
		}
		if (ssz == -1) {
			perror(curp->file);
			break;
		}
		off += (size_t)ssz;
	}

	free(fb->buf);
	fb->buf = NULL;
	return(0);
}


d324 2
a325 1
fdesc(struct curparse *curp)
d327 3
d331 1
a331 11
	/*
	 * Called once per file with an opened file descriptor.  All
	 * pre-file-parse operations (whether stdin or a file) should go
	 * here.
	 *
	 * This calls down into the nested parser, which drills down and
	 * fully parses a file and all its dependences (i.e., `so').  It
	 * then runs the cleanup validators and pushes to output.
	 */

	/* Zero the parse type. */
d333 2
a334 3
	curp->mdoc = NULL;
	curp->man = NULL;
	curp->file_status = MANDOCLEVEL_OK;
d336 1
a336 1
	/* Make sure the mandotory roff parser is initialised. */
d338 1
a338 8
	if (NULL == curp->roff) {
		curp->roff = roff_alloc(&curp->regs, curp, mmsg);
		assert(curp->roff);
	}

	/* Fully parse the file. */

	pdesc(curp);
d340 1
a340 1
	if (MANDOCLEVEL_FATAL <= curp->file_status)
a342 23
	/* NOTE a parser may not have been assigned, yet. */

	if ( ! (curp->man || curp->mdoc)) {
		fprintf(stderr, "%s: Not a manual\n", curp->file);
		curp->file_status = MANDOCLEVEL_FATAL;
		goto cleanup;
	}

	/* Clean up the parse routine ASTs. */

	if (curp->mdoc && ! mdoc_endparse(curp->mdoc)) {
		assert(MANDOCLEVEL_FATAL <= curp->file_status);
		goto cleanup;
	}

	if (curp->man && ! man_endparse(curp->man)) {
		assert(MANDOCLEVEL_FATAL <= curp->file_status);
		goto cleanup;
	}

	assert(curp->roff);
	roff_endparse(curp->roff);

d344 2
a345 2
	 * With -Wstop and warnings or errors of at least
	 * the requested level, do not produce output.
d348 1
a348 1
	if (MANDOCLEVEL_OK != curp->file_status && curp->wstop)
d402 2
d406 4
a409 4
	if (curp->man && curp->outman)
		(*curp->outman)(curp->outdata, curp->man);
	if (curp->mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, curp->mdoc);
d413 1
a413 41
	memset(&curp->regs, 0, sizeof(struct regset));

	/* Reset the current-parse compilers. */

	if (curp->mdoc)
		mdoc_reset(curp->mdoc);
	if (curp->man)
		man_reset(curp->man);

	assert(curp->roff);
	roff_reset(curp->roff);

	if (curp->exit_status < curp->file_status)
		curp->exit_status = curp->file_status;

	return;
}

static void
pdesc(struct curparse *curp)
{
	struct buf	 blk;
	int		 with_mmap;

	/*
	 * Run for each opened file; may be called more than once for
	 * each full parse sequence if the opened file is nested (i.e.,
	 * from `so').  Simply sucks in the whole file and moves into
	 * the parse phase for the file.
	 */

	if ( ! read_whole_file(curp, &blk, &with_mmap)) {
		curp->file_status = MANDOCLEVEL_SYSERR;
		return;
	}

	/* Line number is per-file. */

	curp->line = 1;

	parsebuf(curp, blk, 1);
d415 2
a416 304
	if (with_mmap)
		munmap(blk.buf, blk.sz);
	else
		free(blk.buf);
}

/*
 * Main parse routine for an opened file.  This is called for each
 * opened file and simply loops around the full input file, possibly
 * nesting (i.e., with `so').
 */
static void
parsebuf(struct curparse *curp, struct buf blk, int start)
{
	const struct tbl_span	*span;
	struct buf	 ln;
	enum rofferr	 rr;
	int		 i, of, rc;
	int		 pos; /* byte number in the ln buffer */
	int		 lnn; /* line number in the real file */
	unsigned char	 c;

	memset(&ln, 0, sizeof(struct buf));

	lnn = curp->line; 
	pos = 0; 

	for (i = 0; i < (int)blk.sz; ) {
		if (0 == pos && '\0' == blk.buf[i])
			break;

		if (start) {
			curp->line = lnn;
			curp->reparse_count = 0;
		}

		while (i < (int)blk.sz && (start || '\0' != blk.buf[i])) {

			/*
			 * When finding an unescaped newline character,
			 * leave the character loop to process the line.
			 * Skip a preceding carriage return, if any.
			 */

			if ('\r' == blk.buf[i] && i + 1 < (int)blk.sz &&
			    '\n' == blk.buf[i + 1])
				++i;
			if ('\n' == blk.buf[i]) {
				++i;
				++lnn;
				break;
			}

			/* 
			 * Warn about bogus characters.  If you're using
			 * non-ASCII encoding, you're screwing your
			 * readers.  Since I'd rather this not happen,
			 * I'll be helpful and drop these characters so
			 * we don't display gibberish.  Note to manual
			 * writers: use special characters.
			 */

			c = (unsigned char) blk.buf[i];

			if ( ! (isascii(c) && 
					(isgraph(c) || isblank(c)))) {
				mmsg(MANDOCERR_BADCHAR, curp, 
				    curp->line, pos, "ignoring byte");
				i++;
				continue;
			}

			/* Trailing backslash = a plain char. */

			if ('\\' != blk.buf[i] || i + 1 == (int)blk.sz) {
				if (pos >= (int)ln.sz)
					resize_buf(&ln, 256);
				ln.buf[pos++] = blk.buf[i++];
				continue;
			}

			/*
			 * Found escape and at least one other character.
			 * When it's a newline character, skip it.
			 * When there is a carriage return in between,
			 * skip that one as well.
			 */

			if ('\r' == blk.buf[i + 1] && i + 2 < (int)blk.sz &&
			    '\n' == blk.buf[i + 2])
				++i;
			if ('\n' == blk.buf[i + 1]) {
				i += 2;
				++lnn;
				continue;
			}

			if ('"' == blk.buf[i + 1]) {
				i += 2;
				/* Comment, skip to end of line */
				for (; i < (int)blk.sz; ++i) {
					if ('\n' == blk.buf[i]) {
						++i;
						++lnn;
						break;
					}
				}

				/* Backout trailing whitespaces */
				for (; pos > 0; --pos) {
					if (ln.buf[pos - 1] != ' ')
						break;
					if (pos > 2 && ln.buf[pos - 2] == '\\')
						break;
				}
				break;
			}

			/* Some other escape sequence, copy & cont. */

			if (pos + 1 >= (int)ln.sz)
				resize_buf(&ln, 256);

			ln.buf[pos++] = blk.buf[i++];
			ln.buf[pos++] = blk.buf[i++];
		}

 		if (pos >= (int)ln.sz)
			resize_buf(&ln, 256);

		ln.buf[pos] = '\0';

		/*
		 * A significant amount of complexity is contained by
		 * the roff preprocessor.  It's line-oriented but can be
		 * expressed on one line, so we need at times to
		 * readjust our starting point and re-run it.  The roff
		 * preprocessor can also readjust the buffers with new
		 * data, so we pass them in wholesale.
		 */

		of = 0;

rerun:
		rr = roff_parseln
			(curp->roff, curp->line, 
			 &ln.buf, &ln.sz, of, &of);

		switch (rr) {
		case (ROFF_REPARSE):
			if (REPARSE_LIMIT >= ++curp->reparse_count)
				parsebuf(curp, ln, 0);
			else
				mmsg(MANDOCERR_ROFFLOOP, curp, 
				    curp->line, pos, NULL);
			pos = 0;
			continue;
		case (ROFF_APPEND):
			pos = (int)strlen(ln.buf);
			continue;
		case (ROFF_RERUN):
			goto rerun;
		case (ROFF_IGN):
			pos = 0;
			continue;
		case (ROFF_ERR):
			assert(MANDOCLEVEL_FATAL <= curp->file_status);
			break;
		case (ROFF_SO):
			if (pfile(ln.buf + of, curp)) {
				pos = 0;
				continue;
			} else
				break;
		default:
			break;
		}

		/*
		 * If we encounter errors in the recursive parsebuf()
		 * call, make sure we don't continue parsing.
		 */

		if (MANDOCLEVEL_FATAL <= curp->file_status)
			break;

		/*
		 * If input parsers have not been allocated, do so now.
		 * We keep these instanced betwen parsers, but set them
		 * locally per parse routine since we can use different
		 * parsers with each one.
		 */

		if ( ! (curp->man || curp->mdoc))
			pset(ln.buf + of, pos - of, curp);

		/* 
		 * Lastly, push down into the parsers themselves.  One
		 * of these will have already been set in the pset()
		 * routine.
		 * If libroff returns ROFF_TBL, then add it to the
		 * currently open parse.  Since we only get here if
		 * there does exist data (see tbl_data.c), we're
		 * guaranteed that something's been allocated.
		 * Do the same for ROFF_EQN.
		 */

		rc = -1;

		if (ROFF_TBL == rr)
			while (NULL != (span = roff_span(curp->roff))) {
				rc = curp->man ?
					man_addspan(curp->man, span) :
					mdoc_addspan(curp->mdoc, span);
				if (0 == rc)
					break;
			}
		else if (ROFF_EQN == rr)
			rc = curp->mdoc ? 
				mdoc_addeqn(curp->mdoc, 
					roff_eqn(curp->roff)) :
				man_addeqn(curp->man,
					roff_eqn(curp->roff));
		else if (curp->man || curp->mdoc)
			rc = curp->man ?
				man_parseln(curp->man, 
					curp->line, ln.buf, of) :
				mdoc_parseln(curp->mdoc, 
					curp->line, ln.buf, of);

		if (0 == rc) {
			assert(MANDOCLEVEL_FATAL <= curp->file_status);
			break;
		}

		/* Temporary buffers typically are not full. */

		if (0 == start && '\0' == blk.buf[i])
			break;

		/* Start the next input line. */

		pos = 0;
	}

	free(ln.buf);
}

static void
pset(const char *buf, int pos, struct curparse *curp)
{
	int		 i;

	/*
	 * Try to intuit which kind of manual parser should be used.  If
	 * passed in by command-line (-man, -mdoc), then use that
	 * explicitly.  If passed as -mandoc, then try to guess from the
	 * line: either skip dot-lines, use -mdoc when finding `.Dt', or
	 * default to -man, which is more lenient.
	 *
	 * Separate out pmdoc/pman from mdoc/man: the first persists
	 * through all parsers, while the latter is used per-parse.
	 */

	if ('.' == buf[0] || '\'' == buf[0]) {
		for (i = 1; buf[i]; i++)
			if (' ' != buf[i] && '\t' != buf[i])
				break;
		if ('\0' == buf[i])
			return;
	}

	switch (curp->inttype) {
	case (INTT_MDOC):
		if (NULL == curp->pmdoc) 
			curp->pmdoc = mdoc_alloc
				(&curp->regs, curp, mmsg);
		assert(curp->pmdoc);
		curp->mdoc = curp->pmdoc;
		return;
	case (INTT_MAN):
		if (NULL == curp->pman) 
			curp->pman = man_alloc
				(&curp->regs, curp, mmsg);
		assert(curp->pman);
		curp->man = curp->pman;
		return;
	default:
		break;
	}

	if (pos >= 3 && 0 == memcmp(buf, ".Dd", 3))  {
		if (NULL == curp->pmdoc) 
			curp->pmdoc = mdoc_alloc
				(&curp->regs, curp, mmsg);
		assert(curp->pmdoc);
		curp->mdoc = curp->pmdoc;
		return;
	} 

	if (NULL == curp->pman) 
		curp->pman = man_alloc(&curp->regs, curp, mmsg);
	assert(curp->pman);
	curp->man = curp->pman;
d420 1
a420 1
moptions(enum intt *tflags, char *arg)
d424 1
a424 1
		*tflags = INTT_MDOC;
d426 1
a426 1
		*tflags = INTT_AUTO;
d428 1
a428 1
		*tflags = INTT_MAN;
d446 1
a446 2
	}
	else if (0 == strcmp(arg, "tree"))
d518 3
a520 2
	fprintf(stderr, "%s:%d:%d: %s: %s",
	    cp->file, ln, col + 1, mandoclevels[level], mandocerrs[t]);
d523 1
d526 1
a526 2
	if (cp->file_status < level)
		cp->file_status = level;
@


1.152
log
@Move mandoc_{realloc,malloc,calloc} out of libmandoc.h and into mandoc.h
so that everybody can use them.  This follows the convention of
libXXXX.h being internal to a library and XXXX.h being the external
interface.  Not only does this allow the removal of lots of redundant
NULL-checking code, it also sets the tone for adding new mandoc-global
routines.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.151 2011/03/16 15:28:35 kristaps Exp $ */
d236 1
a236 1
static	int		  mmsg(enum mandocerr, void *, 
d1039 1
a1039 1
static int
d1052 1
a1052 1
		return(1);
a1061 2
	
	return(level < MANDOCLEVEL_FATAL);
@


1.151
log
@Push exit_status into struct curparse alongside file_status.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.150 2011/03/15 16:23:51 kristaps Exp $ */
d408 1
a408 5
	buf->buf = realloc(buf->buf, buf->sz);
	if (NULL == buf->buf) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.150
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.149 2011/03/15 16:15:37 kristaps Exp $ */
d80 1
a244 1
static	enum mandoclevel  exit_status = MANDOCLEVEL_OK;
d263 1
d304 1
a304 1
		if (MANDOCLEVEL_OK != exit_status && curp.wstop)
d318 1
a318 1
	return((int)exit_status);
d363 1
a363 1
		exit_status = MANDOCLEVEL_SYSERR;
d622 2
a623 2
	if (exit_status < curp->file_status)
		exit_status = curp->file_status;
@


1.149
log
@Remove duplicate UNCONST definition.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.148 2011/03/15 13:24:42 kristaps Exp $ */
d809 1
a809 1
			pos = strlen(ln.buf);
@


1.148
log
@Clean-up: make file_status global be local to curparse.  "I agree with
the direction of this particular patch", schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.147 2011/03/07 01:35:51 schwarze Exp $ */
a44 1
#define	UNCONST(a)	((void *)(uintptr_t)(const void *)(a))
@


1.147
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.146 2011/02/09 09:33:43 kristaps Exp $ */
d81 6
a86 5
	const char	 *file;		/* Current parse. */
	int		  fd;		/* Current parse. */
	int		  line;		/* Line number in the file. */
	enum mandoclevel  wlevel;	/* Ignore messages below this. */
	int		  wstop;	/* Stop after a file with a warning. */
a244 1
static	enum mandoclevel  file_status = MANDOCLEVEL_OK;
d381 1
a381 1
		file_status = MANDOCLEVEL_SYSERR;
d399 1
a399 1
	return(MANDOCLEVEL_FATAL > file_status ? 1 : 0);
d503 1
a503 1
	file_status = MANDOCLEVEL_OK;
d516 1
a516 1
	if (MANDOCLEVEL_FATAL <= file_status)
d523 1
a523 1
		file_status = MANDOCLEVEL_FATAL;
d530 1
a530 1
		assert(MANDOCLEVEL_FATAL <= file_status);
d535 1
a535 1
		assert(MANDOCLEVEL_FATAL <= file_status);
d547 1
a547 1
	if (MANDOCLEVEL_OK != file_status && curp->wstop)
d622 2
a623 2
	if (exit_status < file_status)
		exit_status = file_status;
d642 1
a642 1
		file_status = MANDOCLEVEL_SYSERR;
d658 5
a673 6
	/*
	 * Main parse routine for an opened file.  This is called for
	 * each opened file and simply loops around the full input file,
	 * possibly nesting (i.e., with `so').
	 */

d818 1
a818 1
			assert(MANDOCLEVEL_FATAL <= file_status);
d835 1
a835 1
		if (MANDOCLEVEL_FATAL <= file_status)
d883 1
a883 1
			assert(MANDOCLEVEL_FATAL <= file_status);
d1064 2
a1065 2
	if (file_status < level)
		file_status = level;
@


1.146
log
@Consolidate "rc" value in main.c around addspan, addeqn, and parseln.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.145 2011/02/09 09:18:15 kristaps Exp $ */
d131 2
a132 1
	"cannot parse date argument",
@


1.145
log
@Allow -man to process EQN as well.  Also fix a segfault in missing case
statements in the post-handler for EQN in -mdoc and -man.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.144 2011/02/09 09:05:52 kristaps Exp $ */
d856 1
d859 3
a861 2
		if (ROFF_TBL == rr) {
			assert(curp->man || curp->mdoc);
d863 2
a864 3
				if (curp->man)
					man_addspan(curp->man, span);
				else
d866 2
d869 1
a869 3
		} else if (ROFF_EQN == rr) {
			assert(curp->man || curp->mdoc);
			assert(roff_eqn(curp->roff));
d875 1
a875 1
		} else if (curp->man || curp->mdoc) {
d882 3
a884 4
			if ( ! rc) {
				assert(MANDOCLEVEL_FATAL <= file_status);
				break;
			}
@


1.144
log
@Allow EQN data to be pushed down into libmdoc via mdoc_addeqn().  Only
the adding itself is implemented; equation data is not yet shown.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.143 2011/02/06 20:36:36 kristaps Exp $ */
d869 5
a873 2
			if (curp->mdoc)
				mdoc_addeqn(curp->mdoc, roff_eqn(curp->roff));
@


1.143
log
@Add initial EQN support to mandoc.  This parses, then throws away, data
between EQ and EN roff blocks.  EQN is different from TBL in that data
after .EQ is unilaterally considered an equation until an .EN.  Thus,
there's no need to jump through hoops in having table spans and so on.
This is ONLY the parse code framework in libroff.  EQN is not yet passed
into the backends.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.142 2011/02/02 21:40:45 kristaps Exp $ */
d868 3
@


1.142
log
@If `Ns' is specified on its own line, it should be ignored.  This is
shitty groff behaviour.  Do the same, but raise a warning to this
effect.  This from a TODO noted by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.141 2011/01/25 12:24:27 schwarze Exp $ */
d866 2
@


1.141
log
@Since tbl_data() can now produce multiple spans, let parsebuf()
generate man(7) or mdoc(7) nodes for all these spans,
not only for the last one.
Restores the horizontal lines in the cpu(4/hppa) tables.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.140 2011/01/24 23:41:55 schwarze Exp $ */
d149 1
@


1.140
log
@Skip carriage return before newline, if any.
As pointed out by Joerg Sonnenberger, this is useful
because we use mmap(3) and look for '\n' by hand.
"check it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.139 2011/01/22 13:16:02 schwarze Exp $ */
d659 1
d859 6
a864 5
			if (curp->man)
				man_addspan(curp->man, roff_span(curp->roff));
			else
				mdoc_addspan(curp->mdoc, roff_span(curp->roff));

@


1.139
log
@When finding the roff .it request (line trap),
make it clear that you cannot use mandoc to format that page (yet).
Triggered by a report from brad@@, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.138 2011/01/12 15:50:42 kristaps Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d687 10
d731 6
a736 1
			/* Found escape & at least one other char. */
d738 3
a742 1
				/* Escaped newlines are skipped over */
@


1.138
log
@Make out-of-context `fi' invocations not cause an error, but just a
warning.  From a TODO by schwarze@@, originally noted by Brad Smith.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.137 2011/01/11 00:11:45 schwarze Exp $ */
d199 1
a199 1
	"NOT IMPLEMENTED: skipping request",
@


1.137
log
@Refactoring in preparation for .rm support:
Unify parsing of names given as roff request arguments into a new
function roff_getname(), which is rather different from the parsing
function for normal arguments, mandoc_getarg(), because names cannot
be quoted and cannot contain whitespace or escaped characters.
The new function now throws an ERROR when finding escaped characters
in a name.
"I'm fine with this." kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.136 2011/01/10 14:40:30 kristaps Exp $ */
d161 1
@


1.136
log
@First, make extra data cells be thrown away.  This makes "dp->layout"
always hold, which cleans up the table stuff a bit.

Second, set a "spans" value per data cell consisting of the number of
skipped TBL_CELL_SPAN layout cells.

Third, make tbl_term.c understand how to skip over spanned sections when
iterating over the header queue.

What remains is to calculate the widths of spanned cells.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.135 2011/01/04 15:02:00 kristaps Exp $ */
d195 1
@


1.135
log
@Support `T{' and `T}' data blocks.  When a standalone `T{' is
encountered as a line's last data cell, move into TBL_PART_CDATA mode
whilst leaving the cell's designation as TBL_DATA_NONE.  When new data
arrives that's not a standalone `T}', append it to the cell contends.
Close out and warn appropriately.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.134 2011/01/04 12:06:21 kristaps Exp $ */
a180 3
	/* related to tables */
	"extra data cells",

d191 1
@


1.134
log
@Fix to make horizontal spanners in the layout be properly printed.
mandoc also now warns (so does tbl(1)) if a horizontal spanner is
specified along with data.

While here, fix up some documentation and uncomment the tbl reference.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.133 2011/01/03 23:53:51 schwarze Exp $ */
d193 1
@


1.133
log
@Partial cleanup of argument count validation in mdoc(7):

* Do not segfault on empty .Db, .Rs, .Sm, and .St.
* Let check_count() really throw the requested level, not always ERROR.
* Downgrade most bad argument counts from ERROR to WARNING.
* And some related internal cleanup.

Looks fine to kristaps@@.

Note that the macros using eerr_ge1() still need to be checked at a later
time; but as all the others are done, let's use what we already have.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.132 2011/01/03 13:54:02 kristaps Exp $ */
d192 2
@


1.132
log
@Make sure we don't continue recursively parsing once we've exited with
failure (this had caused some segfaults with the new assert() call in
MAN_HALT and MDOC_HALT).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.131 2011/01/01 22:27:08 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d156 1
@


1.131
log
@Add a warning if a data cell has no layout.  Also make -Ttree show this
with a little star next to the entry (yeah, this is mostly for testing).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.130 2011/01/01 16:18:39 kristaps Exp $ */
d808 8
@


1.130
log
@More checks for proper table exit.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.129 2011/01/01 15:45:18 kristaps Exp $ */
d179 3
d185 1
@


1.129
log
@Add documentation bits for libroff's new roff_span().

Add bits to remember tbl's invocation point.

Add ERROR class message if no data's in the table.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.128 2011/01/01 13:37:40 kristaps Exp $ */
d530 1
a530 4
	if ( ! roff_endparse(curp->roff)) {
		assert(MANDOCLEVEL_FATAL <= file_status);
		goto cleanup;
	}
@


1.128
log
@Switch on tbl rows being added to the parse stream.  Here we go!
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.127 2010/12/29 14:38:14 kristaps Exp $ */
d186 1
@


1.127
log
@Merge, with considerable changes, tbl.bsd.lv's layout-handling code.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.126 2010/12/29 01:16:57 kristaps Exp $ */
d801 1
a801 1
		case (ROFF_CONT):
d819 4
d825 8
a832 1
		if (curp->man || curp->mdoc) {
@


1.126
log
@Significant update to options handling, which now departs almost
completely with the BSD.lv code due to performance issues and flat-out
errors.

Performance issues: functions called per character.  Ugly.

Flat-out errors: disallowing "reserved" tokens as arguments to those
options accepting arguments.

Also added are two mandoc.h error codes for general tbl syntax errors
and for bad options.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.125 2010/12/22 11:38:17 kristaps Exp $ */
d184 2
@


1.125
log
@Revert IGNPAR to a warning after clue-stick applied by schwarze@@:
although technically-speaking a lost macro is an error (e.g.,
MANDOCERR_MACRO), casting out some extra whitespace (note, IGNPAR only
happens in conditions where whitespace already exists!) is hardly an
error matter.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.124 2010/12/21 01:22:03 schwarze Exp $ */
d182 2
@


1.124
log
@Sane behaviour for the growing of very small buffers:
Always grow at least to the minimum requested size.
Before this, a buffer of 1 byte was grown to 2 bytes,
which was too small and sometimes caused segfaults.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.123 2010/12/15 23:39:40 kristaps Exp $ */
d148 1
a185 1
	"skipping paragraph macro",
@


1.123
log
@Add a "last child" member of struct mdoc_node.

Remove `Pp' or `Lp' if it is the FIRST or LAST child of an `Sh' or `Sh' body.

Make "skipping paragraph" be an error, not a warning, as information (an
invoked macro) is ignored.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.122 2010/12/10 20:58:56 schwarze Exp $ */
d392 1
a392 1
	buf->sz = buf->sz ? 2 * buf->sz : initial;
@


1.122
log
@Abort endless loops during roff macro and string expansion.
For now, use the simplest conceivable approach, like groff does:
Just a fixed, ugly input stack limit.
"check it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.121 2010/12/06 16:55:35 kristaps Exp $ */
a147 1
	"skipping paragraph macro",
d185 1
@


1.121
log
@Bring schwarze@@'s mandoc.h and main.c errors and warnings entirely in sync,
except for the tbl one which will be the focus of later study.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.120 2010/12/06 15:31:19 kristaps Exp $ */
d44 1
d93 1
d182 1
d671 1
a671 1
		if (start)
d673 2
d773 5
a777 1
			parsebuf(curp, ln, 0);
@


1.120
log
@Add support for `ft' macro found in groff(7).  Based on a patch by
schwarze@@, but without the -T[x]html handling, which structurally does
not work.  Also add man.7 documentation (not in original patch).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.119 2010/12/06 11:01:19 kristaps Exp $ */
d125 11
d137 3
a139 1
	"text should be uppercase",
d141 1
a141 11
	"section name repeats",
	"out of order prologue",
	"repeated prologue entry",
	"list type must come first",
	"tab in non-literal context",
	"bad escape sequence",
	"unterminated quoted string",
	"argument requires the width argument",
	"bad date argument",
	"bad width argument",
	"unknown manual section",
d143 4
a146 1
	"end of line whitespace",
d148 3
d152 6
a157 1
	"generic error",
d159 6
a164 1
	"NAME section must come first",
d167 7
a173 17
	"child violates parent syntax",
	"displays may not be nested",
	"bad AT&T symbol",
	"bad standard",
	"list type repeated",
	"display type repeated",
	"argument repeated",
	"ignoring argument",
	"manual name not yet set",
	"obsolete macro ignored",
	"empty macro ignored",
	"macro not allowed in body",
	"macro not allowed in prologue",
	"bad character",
	"bad NAME section contents",
	"no blank lines",
	"no text in this context",
d175 8
a182 1
	"unknown macro will be lost",
d186 2
a187 2
	"request scope close w/none open",
	"scope already open",
a192 1
	"no title in document",
a193 2
	"missing display type",
	"missing font type",
a195 1
	"paragraph macro ignored",
d200 1
a200 4
	"unsupported display type",
	"blocks badly nested",
	"no such block is open",
	"missing end of block",
@


1.119
log
@Merge schwarze@@'s relaxation of scope-breaking rules: allow implicit
ending of scopes and drop stray scope-endings.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.118 2010/12/05 15:55:01 kristaps Exp $ */
d147 1
@


1.118
log
@Remove long-standing FIXME regarding the consolidation of WIDTHARG and
NOARGV warnings.  From patch by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.117 2010/12/05 15:49:37 kristaps Exp $ */
d190 1
@


1.117
log
@Merge schwarze@@'s patch to allow uname() to fail without causing an exit.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.116 2010/12/05 15:37:30 kristaps Exp $ */
a135 1
	"superfluous width argument",
@


1.116
log
@Merge schwarze@@'s changes allowing nested displays.  Tweak the patch by
making sure output doesn't add a superfluous newline with the nested displays.
Also add a COMPATIBILITY note.

Rename a macro (DATESIZ) to be in line with OpenBSD (DATESIZE).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.115 2010/12/02 20:41:46 schwarze Exp $ */
d173 1
a197 1
	"utsname system call failed",
@


1.115
log
@Track the parser status both per file (file_status), such that
we can for example skip rendering on FATAL parsing errors,
and globally (exit_status), such that we know what to return.
Without this, following files produced no rendered output
once a single file suffered from a FATAL error.
Bug reported by kristaps@@, fix by me.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.114 2010/12/01 17:00:05 kristaps Exp $ */
d149 1
a186 1
	"displays may not be nested",
@


1.114
log
@Fix enum/int mixing.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.113 2010/12/01 16:54:25 kristaps Exp $ */
d216 1
d353 1
a353 1
		exit_status = MANDOCLEVEL_SYSERR;
d371 1
a371 1
	return(MANDOCLEVEL_FATAL > exit_status ? 1 : 0);
d475 1
d488 1
a488 1
	if (MANDOCLEVEL_FATAL <= exit_status)
d495 1
a495 1
		exit_status = MANDOCLEVEL_FATAL;
d502 1
a502 1
		assert(MANDOCLEVEL_FATAL <= exit_status);
d507 1
a507 1
		assert(MANDOCLEVEL_FATAL <= exit_status);
d513 1
a513 1
		assert(MANDOCLEVEL_FATAL <= exit_status);
d522 1
a522 1
	if (MANDOCLEVEL_OK != exit_status && curp->wstop)
d597 3
d617 1
a617 1
		exit_status = MANDOCLEVEL_SYSERR;
d770 1
a770 1
			assert(MANDOCLEVEL_FATAL <= exit_status);
d806 1
a806 1
				assert(MANDOCLEVEL_FATAL <= exit_status);
d988 2
a989 2
	if (exit_status < level)
		exit_status = level;
@


1.113
log
@Merge OpenBSD's `so' handling (plus some documentation).  Great work to
schwarze@@ and joerg@@ for his comments!
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.112 2010/12/01 16:28:23 kristaps Exp $ */
d632 1
d747 1
a747 1
		rc = roff_parseln
d751 1
a751 1
		switch (rc) {
@


1.112
log
@Fix a subtle error in the new main.c where the parse type (mdoc/man) was
being inherited during the parse sequence, making pset() meaningless.
Make sure that the mdoc/man curp pointer is set for each parse from a
persistent object.

This flushes out an obscure error where `man' pages called with `mdoc'
will parse and segfault due to a missing title.  Never happened earlier
because `mdoc' pages were guaranteed to have a prologue.  Fix this
later.

Also document the new main.c functions.  Please make sure these sort of
things are documented!  Throw in some whitespace to make things a bit
more readable.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.111 2010/12/01 15:09:01 kristaps Exp $ */
d125 1
d194 1
@


1.111
log
@Merge restructuring of main.c code.  This provided by schwarze@@ and inspected
carefully by joerg@@.  Merge roff.h header for compilation's sake (this is not
yet implemented in roff.c.).

THIS IS A BUGGY CHECK-IN.  The manual type is erroneously kept between runs
of the compiler.  This is a known bug.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.110 2010/12/01 10:31:34 kristaps Exp $ */
d86 2
d207 1
a207 2
static	void		  pset(const char *, int, struct curparse *,
				struct man **, struct mdoc **);
d280 4
a283 4
	if (curp.mdoc)
		mdoc_free(curp.mdoc);
	if (curp.man)
		man_free(curp.man);
d304 10
a313 3
	(void)fprintf(stderr, "usage: %s [-V] [-foption] "
			"[-mformat] [-Ooption] [-Toutput] "
			"[-Werr] [file...]\n", progname);
a316 1

d321 7
d329 1
d457 24
a480 3
	struct man	*man;
	struct mdoc	*mdoc;
	struct roff	*roff;
a483 4
	man  = curp->man;
	mdoc = curp->mdoc;
	roff = curp->roff;

d489 1
a489 1
	if ( ! (man || mdoc)) {
d497 1
a497 1
	if (mdoc && ! mdoc_endparse(mdoc)) {
d501 2
a502 1
	if (man && ! man_endparse(man)) {
d506 3
a508 1
	if (roff && ! roff_endparse(roff)) {
d574 4
a577 4
	if (man && curp->outman)
		(*curp->outman)(curp->outdata, man);
	if (mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, mdoc);
d580 1
d582 10
a591 6
	if (mdoc)
		mdoc_reset(mdoc);
	if (man)
		man_reset(man);
	if (roff)
		roff_reset(roff);
a595 1

d602 7
d614 1
a614 3
	if (NULL == curp->roff) 
		curp->roff = roff_alloc(&curp->regs, curp, mmsg);
	assert(curp->roff);
d617 1
d630 3
a632 1
	int		 i, pos, lnn, of;
d634 6
a639 7
	struct man	*man;
	struct mdoc	*mdoc;
	struct roff	*roff;

	man  = curp->man;
	mdoc = curp->mdoc;
	roff = curp->roff;
d643 2
a644 2
	lnn = curp->line;  /* line number in the real file */
	pos = 0;  /* byte number in the ln buffer */
d646 1
a646 1
	for (i = 0; i < (int)blk.sz;) {
d649 1
d670 3
a672 1
			if ( ! (isascii(c) && (isgraph(c) || isblank(c)))) {
d679 2
a680 1
			/* Trailing backslash is like a plain character. */
d687 3
a689 1
			/* Found an escape and at least one other character. */
d691 1
a692 1
				i += 2;
d696 1
d707 1
d717 3
a719 1
			/* Some other escape sequence, copy and continue. */
d729 1
d742 1
d744 5
a748 2
		switch (roff_parseln(roff, curp->line, &ln.buf, &ln.sz,
		    of, &of)) {
d781 2
a782 2
		if ( ! (man || mdoc))
			pset(ln.buf + of, pos - of, curp, &man, &mdoc);
d784 12
a795 1
		/* Lastly, push down into the parsers themselves. */
d797 4
a800 7
		if (man && ! man_parseln(man, curp->line, ln.buf, of)) {
			assert(MANDOCLEVEL_FATAL <= exit_status);
			break;
		}
		if (mdoc && ! mdoc_parseln(mdoc, curp->line, ln.buf, of)) {
			assert(MANDOCLEVEL_FATAL <= exit_status);
			break;
d804 1
d809 1
a815 1

d817 1
a817 2
pset(const char *buf, int pos, struct curparse *curp,
		struct man **man, struct mdoc **mdoc)
d827 3
d842 5
a846 4
		if (NULL == curp->mdoc) 
			curp->mdoc = mdoc_alloc(&curp->regs, curp, mmsg);
		assert(curp->mdoc);
		*mdoc = curp->mdoc;
d849 5
a853 4
		if (NULL == curp->man) 
			curp->man = man_alloc(&curp->regs, curp, mmsg);
		assert(curp->man);
		*man = curp->man;
d860 5
a864 4
		if (NULL == curp->mdoc) 
			curp->mdoc = mdoc_alloc(&curp->regs, curp, mmsg);
		assert(curp->mdoc);
		*mdoc = curp->mdoc;
d868 4
a871 4
	if (NULL == curp->man) 
		curp->man = man_alloc(&curp->regs, curp, mmsg);
	assert(curp->man);
	*man = curp->man;
a873 1

a891 1

a919 1

a958 1

@


1.110
log
@Re-ordering of roff requests as per OpenBSD.

Made `rm' be an error (again, OpenBSD...).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.109 2010/11/29 15:45:15 kristaps Exp $ */
d82 1
d197 2
d201 1
d327 29
a441 4
	struct buf	 ln, blk;
	int		 i, pos, lnn, lnn_start, with_mmap, of;
	enum rofferr	 re;
	unsigned char	 c;
d446 1
a446 3
	man = NULL;
	mdoc = NULL;
	roff = NULL;
d448 29
a476 1
	memset(&ln, 0, sizeof(struct buf));
d479 2
a480 2
	 * Two buffers: ln and buf.  buf is the input file and may be
	 * memory mapped.  ln is a line buffer and grows on-demand.
d483 80
d571 22
d595 12
a606 4
	for (i = 0, lnn = 1; i < (int)blk.sz;) {
		pos = 0;
		lnn_start = lnn;
		while (i < (int)blk.sz) {
d625 1
a625 1
				    lnn_start, pos, "ignoring byte");
d685 14
a698 6
		do {
			re = roff_parseln(roff, lnn_start, 
					&ln.buf, &ln.sz, of, &of);
		} while (ROFF_RERUN == re);

		if (ROFF_IGN == re) {
d700 1
a700 1
		} else if (ROFF_ERR == re) {
d702 9
a710 1
			goto cleanup;
d725 1
a725 1
		if (man && ! man_parseln(man, lnn_start, ln.buf, of)) {
d727 1
a727 1
			goto cleanup;
d729 1
a729 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf, of)) {
d731 1
a731 1
			goto cleanup;
a732 3
	}

	/* NOTE a parser may not have been assigned, yet. */
d734 2
a735 35
	if ( ! (man || mdoc)) {
		fprintf(stderr, "%s: Not a manual\n", curp->file);
		exit_status = MANDOCLEVEL_FATAL;
		goto cleanup;
	}

	/* Clean up the parse routine ASTs. */

	if (mdoc && ! mdoc_endparse(mdoc)) {
		assert(MANDOCLEVEL_FATAL <= exit_status);
		goto cleanup;
	}
	if (man && ! man_endparse(man)) {
		assert(MANDOCLEVEL_FATAL <= exit_status);
		goto cleanup;
	}
	if (roff && ! roff_endparse(roff)) {
		assert(MANDOCLEVEL_FATAL <= exit_status);
		goto cleanup;
	}

	/*
	 * With -Wstop and warnings or errors of at least
	 * the requested level, do not produce output.
	 */

	if (MANDOCLEVEL_OK != exit_status && curp->wstop)
		goto cleanup;

	/* If unset, allocate output dev now (if applicable). */

	if ( ! (curp->outman && curp->outmdoc)) {
		switch (curp->outtype) {
		case (OUTT_XHTML):
			curp->outdata = xhtml_alloc(curp->outopts);
a736 18
		case (OUTT_HTML):
			curp->outdata = html_alloc(curp->outopts);
			break;
		case (OUTT_ASCII):
			curp->outdata = ascii_alloc(curp->outopts);
			curp->outfree = ascii_free;
			break;
		case (OUTT_PDF):
			curp->outdata = pdf_alloc(curp->outopts);
			curp->outfree = pspdf_free;
			break;
		case (OUTT_PS):
			curp->outdata = ps_alloc(curp->outopts);
			curp->outfree = pspdf_free;
			break;
		default:
			break;
		}
d738 2
a739 23
		switch (curp->outtype) {
		case (OUTT_HTML):
			/* FALLTHROUGH */
		case (OUTT_XHTML):
			curp->outman = html_man;
			curp->outmdoc = html_mdoc;
			curp->outfree = html_free;
			break;
		case (OUTT_TREE):
			curp->outman = tree_man;
			curp->outmdoc = tree_mdoc;
			break;
		case (OUTT_PDF):
			/* FALLTHROUGH */
		case (OUTT_ASCII):
			/* FALLTHROUGH */
		case (OUTT_PS):
			curp->outman = terminal_man;
			curp->outmdoc = terminal_mdoc;
			break;
		default:
			break;
		}
d742 1
a742 23
	/* Execute the out device, if it exists. */

	if (man && curp->outman)
		(*curp->outman)(curp->outdata, man);
	if (mdoc && curp->outmdoc)
		(*curp->outmdoc)(curp->outdata, mdoc);

 cleanup:
	memset(&curp->regs, 0, sizeof(struct regset));
	if (mdoc)
		mdoc_reset(mdoc);
	if (man)
		man_reset(man);
	if (roff)
		roff_reset(roff);
	if (ln.buf)
		free(ln.buf);
	if (with_mmap)
		munmap(blk.buf, blk.sz);
	else
		free(blk.buf);

	return;
@


1.109
log
@Remove left-over rsord[] in mdoc_actions.c.

Remove MANDOCERR_BADLIB (not used).

Moved `St' handling from mdoc_action.c into mdoc_validate.c.

Moved relevant MDOC_LITERAL macros (`Dl', `Bd' subtypes) from
mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.108 2010/10/11 15:46:19 kristaps Exp $ */
d162 1
@


1.108
log
@Use proper error for `An' multiple arguments.

Making IGNARGV be an ERROR, not a WARNING, as information is lost.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.107 2010/09/27 09:26:27 kristaps Exp $ */
a127 2
	"bad standard",
	"bad library",
d146 1
@


1.107
log
@Ignore double-`Pp' and `Pp' before `Bd' and `Bl' (unless -compact is
specified).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.106 2010/09/26 20:22:28 schwarze Exp $ */
a134 1
	"ignoring argument",
d151 1
@


1.106
log
@If an explicit scope is still open at the end of an input file,
report an ERROR:  We can still render the page by just closing
the open scope, but it is likely that information will be missing
or document structure mangled.
Before, man(7) only reported a WARNING (which is dangerous because
we cannot be sure rendering is correct) and mdoc(7) ran into FATAL
(which is too drastic, there is no reason not to show what we have).
"looks good" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.105 2010/09/04 20:18:53 kristaps Exp $ */
d177 1
@


1.105
log
@Churny commit to quiet lint.  No functional changes.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.104 2010/08/20 08:13:43 schwarze Exp $ */
a141 1
	"scope open on exit",
d167 1
a184 1
	"scope broken, syntax violated",
@


1.104
log
@fix previous: when bailing out due to -Wstop,
skip output functions, but not *_endparse;
problem reported by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.103 2010/08/20 01:02:07 schwarze Exp $ */
d234 1
a234 1
				return(MANDOCLEVEL_BADARG);
d242 1
a242 1
				return(MANDOCLEVEL_BADARG);
d246 1
a246 1
				return(MANDOCLEVEL_BADARG);
d282 1
a282 1
	return(exit_status);
d291 1
a291 1
	exit(MANDOCLEVEL_OK);
d302 1
a302 1
	exit(MANDOCLEVEL_BADARG);
d332 1
a332 1
		exit(MANDOCLEVEL_SYSERR);
d812 1
@


1.103
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.102 2010/08/08 14:45:59 schwarze Exp $ */
a553 8
	/*
	 * With -Wstop and warnings or errors of at least
	 * the requested level, do not produce output.
	 */

	if (MANDOCLEVEL_OK != exit_status && curp->wstop)
		goto cleanup;

d577 8
@


1.102
log
@Make sure we really throw away non-ASCII characters.
For example, on OpenBSD without locale settings,
isgraph(3) returns true for some eight-bit characters.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.101 2010/07/29 22:00:39 joerg Exp $ */
d82 2
a83 11
	int		  wflags;
	/* FIXME: set by max error */
#define	WARN_WALL	 (1 << 0)	/* All-warnings mask. */
#define	WARN_WERR	 (1 << 2)	/* Warnings->errors. */
	int		  fflags;
#define	FL_IGN_SCOPE	 (1 << 0) 	/* Ignore scope errors. */
#define	FL_NIGN_ESCAPE	 (1 << 1) 	/* Don't ignore bad escapes. */
#define	FL_NIGN_MACRO	 (1 << 2) 	/* Don't ignore bad macros. */
#define	FL_IGN_ERRORS	 (1 << 4)	/* Ignore failed parse. */
#define	FL_STRICT	  FL_NIGN_ESCAPE | \
			  FL_NIGN_MACRO /* ignore nothing */
d97 20
d193 1
a193 1
	"memory exhausted",
a197 4
static	int		  foptions(int *, char *);
static	struct man	 *man_init(struct curparse *);
static	struct mdoc	 *mdoc_init(struct curparse *);
static	struct roff	 *roff_init(struct curparse *);
d201 1
a201 1
static	int		  pset(const char *, int, struct curparse *,
d206 1
a206 1
static	int		  woptions(int *, char *);
d209 1
a209 2
static	int		  with_fatal;
static	int		  with_error;
d227 1
d230 1
a230 1
	while (-1 != (c = getopt(argc, argv, "f:m:O:T:VW:")))
a231 4
		case ('f'):
			if ( ! foptions(&curp.fflags, optarg))
				return(EXIT_FAILURE);
			break;
d234 1
a234 1
				return(EXIT_FAILURE);
d242 1
a242 1
				return(EXIT_FAILURE);
d245 2
a246 2
			if ( ! woptions(&curp.wflags, optarg))
				return(EXIT_FAILURE);
d268 1
a268 2

		if (with_fatal && !(curp.fflags & FL_IGN_ERRORS))
d282 1
a282 2
	return((with_fatal || with_error) ? 
			EXIT_FAILURE :  EXIT_SUCCESS);
d291 1
a291 1
	exit(EXIT_SUCCESS);
d302 1
a302 47
	exit(EXIT_FAILURE);
}


static struct man *
man_init(struct curparse *curp)
{
	int		 pflags;

	/* Defaults from mandoc.1. */

	pflags = MAN_IGN_MACRO | MAN_IGN_ESCAPE;

	if (curp->fflags & FL_NIGN_MACRO)
		pflags &= ~MAN_IGN_MACRO;
	if (curp->fflags & FL_NIGN_ESCAPE)
		pflags &= ~MAN_IGN_ESCAPE;

	return(man_alloc(&curp->regs, curp, pflags, mmsg));
}


static struct roff *
roff_init(struct curparse *curp)
{

	return(roff_alloc(&curp->regs, mmsg, curp));
}


static struct mdoc *
mdoc_init(struct curparse *curp)
{
	int		 pflags;

	/* Defaults from mandoc.1. */

	pflags = MDOC_IGN_MACRO | MDOC_IGN_ESCAPE;

	if (curp->fflags & FL_IGN_SCOPE)
		pflags |= MDOC_IGN_SCOPE;
	if (curp->fflags & FL_NIGN_ESCAPE)
		pflags &= ~MDOC_IGN_ESCAPE;
	if (curp->fflags & FL_NIGN_MACRO)
		pflags &= ~MDOC_IGN_MACRO;

	return(mdoc_alloc(&curp->regs, curp, pflags, mmsg));
d313 1
a313 1
		with_fatal = 1;
d324 1
a324 1
static int
a326 2
	void *tmp;
	size_t sz;
d328 3
a330 6
	if (buf->sz == 0)
		sz = initial;
	else
		sz = 2 * buf->sz;
	tmp = realloc(buf->buf, sz);
	if (NULL == tmp) {
d332 1
a332 1
		return(0);
a333 3
	buf->buf = tmp;
	buf->sz = sz;
	return(1);
a345 1
		with_fatal = 1;
a359 1
			with_fatal = 1;
d386 1
a386 2
			if (! resize_buf(fb, 65536))
				break;
a401 1
	with_fatal = 1;
d428 2
a429 1
	if ( ! read_whole_file(curp, &blk, &with_mmap))
d431 1
d434 3
a436 3
		curp->roff = roff_init(curp);
	if (NULL == (roff = curp->roff))
		goto bailout;
d459 2
a460 4
				if ( ! mmsg(MANDOCERR_BADCHAR, curp, 
						lnn_start, pos, 
						"ignoring byte"))
					goto bailout;
d468 1
a468 2
					if (! resize_buf(&ln, 256))
						goto bailout;
d500 1
a500 2
				if (! resize_buf(&ln, 256))
					goto bailout;
d507 1
a507 2
			if (! resize_buf(&ln, 256))
				goto bailout;
d525 1
a525 1
		if (ROFF_IGN == re)
d527 4
a530 2
		else if (ROFF_ERR == re)
			goto bailout;
d540 1
a540 2
			if ( ! pset(ln.buf + of, pos - of, curp, &man, &mdoc))
				goto bailout;
d544 8
a551 4
		if (man && ! man_parseln(man, lnn_start, ln.buf, of))
			goto bailout;
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf, of))
			goto bailout;
d554 8
d566 2
a567 1
		goto bailout;
d572 12
a583 6
	if (mdoc && ! mdoc_endparse(mdoc))
		goto bailout;
	if (man && ! man_endparse(man))
		goto bailout;
	if (roff && ! roff_endparse(roff))
		goto bailout;
a658 4

 bailout:
	with_fatal = 1;
	goto cleanup;
d662 1
a662 1
static int
d680 2
a681 2
		if (0 == buf[i])
			return(1);
d687 4
a690 4
			curp->mdoc = mdoc_init(curp);
		if (NULL == (*mdoc = curp->mdoc))
			return(0);
		return(1);
d693 4
a696 4
			curp->man = man_init(curp);
		if (NULL == (*man = curp->man))
			return(0);
		return(1);
d703 4
a706 4
			curp->mdoc = mdoc_init(curp);
		if (NULL == (*mdoc = curp->mdoc))
			return(0);
		return(1);
d710 3
a712 4
		curp->man = man_init(curp);
	if (NULL == (*man = curp->man))
		return(0);
	return(1);
d743 1
a743 2
		curp->wflags |= WARN_WALL;
		curp->fflags |= FL_STRICT;
d765 1
a765 1
foptions(int *fflags, char *arg)
d768 1
a768 1
	const char	*toks[8];
d770 6
a775 7
	toks[0] = "ign-scope";
	toks[1] = "no-ign-escape";
	toks[2] = "no-ign-macro";
	toks[3] = "ign-errors";
	toks[4] = "strict";
	toks[5] = "ign-escape";
	toks[6] = NULL;
d781 1
a781 1
			*fflags |= FL_IGN_SCOPE;
d784 1
a784 2
			*fflags |= FL_NIGN_ESCAPE;
			break;
d786 1
a786 1
			*fflags |= FL_NIGN_MACRO;
d789 1
a789 1
			*fflags |= FL_IGN_ERRORS;
d792 1
a792 4
			*fflags |= FL_STRICT;
			break;
		case (5):
			*fflags &= ~FL_NIGN_ESCAPE;
d795 1
a795 30
			fprintf(stderr, "%s: Bad argument\n", o);
			return(0);
		}
	}

	return(1);
}


static int
woptions(int *wflags, char *arg)
{
	char		*v, *o;
	const char	*toks[3]; 

	toks[0] = "all";
	toks[1] = "error";
	toks[2] = NULL;

	while (*arg) {
		o = arg;
		switch (getsubopt(&arg, UNCONST(toks), &v)) {
		case (0):
			*wflags |= WARN_WALL;
			break;
		case (1):
			*wflags |= WARN_WERR;
			break;
		default:
			fprintf(stderr, "%s: Bad argument\n", o);
d808 5
a812 2
	const char *level;
	int rc;
d815 2
a816 19
	level = NULL;
	rc = 1;

	if (t >= MANDOCERR_FATAL) {
		with_fatal = 1;
		level = "FATAL";
		rc = 0;
	} else {
		if ( ! (WARN_WALL & cp->wflags))
			return(1);
		if (t >= MANDOCERR_ERROR) {
			with_error = 1;
			level = "ERROR";
		}
		if (WARN_WERR & cp->wflags) {
			with_fatal = 1;
			rc = 0;
		}
	}
d818 2
a819 4
	fprintf(stderr, "%s:%d:%d:", cp->file, ln, col + 1);
	if (level)
		fprintf(stderr, " %s:", level);
	fprintf(stderr, " %s", mandocerrs[t]);
d824 4
a827 1
	return(rc);
@


1.101
log
@Use 0 for MAP_FILE if it doesn't exist. From Hans Rosenfeld.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.100 2010/07/25 11:44:31 kristaps Exp $ */
d469 1
d512 2
a513 2
			if ( ! isgraph((u_char)blk.buf[i]) &&
					! isblank((u_char)blk.buf[i])) {
@


1.100
log
@Initial PDF shim over PS.  This produces working PDF output with -Tpdf.
It's currently missing the xref table, so you'll get a warning in most
PDF viewers).  It also produces lots of redundant output, which will go
away once I get a better handle on the PDF spec.  The code doesn't
really touch any existing functionality; it's a bunch of conditionals
atop the -Tps (term_ps.c) implementation.  I'm checking it in now to
have it exist and be auditable.  It needs clean-up, polish, and general
care (and xref!).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.99 2010/07/20 14:56:42 kristaps Exp $ */
d40 4
@


1.99
log
@Strip non-graphable input characters from input.  The manuals
specifically say that this is not allowed, and were it allowed, output
would be inconsistent across output media (-Tps will puke,
non-your-charset terminals will puke, etc.).

With this done, simplify check_text() to only check escapes and for
tabs.  Add in a new tab warning, too.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.98 2010/07/07 15:04:54 kristaps Exp $ */
d71 2
a72 1
	OUTT_PS
d634 4
d640 1
a640 1
			curp->outfree = ps_free;
d658 2
d794 2
@


1.98
log
@Re-constitution of `ds' symbol processing.  First, push the
roff_getstr() family of functions into roff.c with the "first_string"
directly in struct roff.  Second, pre-process each line for reserved
words in libroff, splicing and re-running a line if it has one (this
allows defined symbols to be macros).  Remove term.c's invocation of the
roff_getstrn() function.  Removed function documentation in roff.3 and
added roff.7 `ds' documentation.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.97 2010/07/04 22:04:04 schwarze Exp $ */
d26 1
d114 1
d496 20
@


1.97
log
@Assert my copyright, making it explicit that i'm granting the same license
on those parts of the code and text that i have written as Kristaps is.
"fine with me" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.96 2010/07/02 12:54:33 kristaps Exp $ */
a33 1
#include "regs.h"
@


1.96
log
@Stash `Bf' parameters into struct mdoc_bf.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.95 2010/07/01 15:38:56 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.95
log
@Improve .Nm indentation in the SYNOPSIS;
kristaps@@ will do the missing HTML part soon.
"looks nicer" jmc@@
"seems perfect to me" sobrado@@
"slap it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.94 2010/06/30 20:32:15 schwarze Exp $ */
d156 1
a162 1
	"missing font type",
@


1.94
log
@improve error reporting:
* avoid error exit code after mere warnings
* add ERROR: and FATAL: to messages when appropriate
* sort the code in mmsg() to make it easier on the eye
* make the mandocerrs[] list easier to maintain
* update a few comments in mandoc.h
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.93 2010/06/29 14:53:14 kristaps Exp $ */
d123 1
a146 1
	"scope broken",
d165 2
a166 1
	"no scope to rewind: syntax violated",
@


1.93
log
@Add in -Opaper=xxx support for -Tps postscript.  This doesn't have any
functional changes beyond the getsubopt() parse in term_ps.c.  If you
want to test this (it only does -Opaper=a4 and -Opaper=letter; adding
more is trivial), make sure you specify (e.g.) -sPAPERSIZE=a4 to gs(1).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.92 2010/06/27 15:52:41 kristaps Exp $ */
d102 3
d124 3
d158 3
d194 2
a195 2
static 	int		  with_error;
static	int		  with_warning;
d258 1
a258 1
		if (with_error && !(curp.fflags & FL_IGN_ERRORS))
d272 1
a272 1
	return((with_warning || with_error) ? 
d350 1
a350 1
		with_error = 1;
d391 1
a391 1
		with_error = 1;
d406 1
a406 1
			with_error = 1;
d450 1
a450 1
	with_error = 1;
d666 1
a666 1
	with_error = 1;
d851 2
d855 2
d858 6
a863 2
	if (t <= MANDOCERR_ERROR) {
		if ( ! (cp->wflags & WARN_WALL))
d865 9
a873 6
		with_warning = 1;
	} else
		with_error = 1;

	fprintf(stderr, "%s:%d:%d: %s", cp->file, 
			ln, col + 1, mandocerrs[t]);
d875 4
a880 1

d883 1
a883 8
	/* This is superfluous, but whatever. */
	if (t > MANDOCERR_ERROR)
		return(0);
	if (cp->wflags & WARN_WERR) {
		with_error = 1;
		return(0);
	}
	return(1);
@


1.92
log
@Downstream maintainers: this removes UGLY!  I don't want diverging
functionality and UGLY works quite well thanks to schwarze@@'s careful
attention.

This also backs out function-prototype changes for struct regset,
instead stuffing a pointer to the regset directly into struct
mdoc/man/roff.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.91 2010/06/26 15:36:37 kristaps Exp $ */
d602 1
a602 1
			curp->outdata = ps_alloc();
@


1.91
log
@Churn-ish check-in getting mdoc_parseln() and man_parseln() to accept a
const struct regset pointer.  No functionality.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.90 2010/06/26 15:22:19 kristaps Exp $ */
d91 1
d302 1
a302 1
	return(man_alloc(curp, pflags, mmsg));
d310 1
a310 1
	return(roff_alloc(mmsg, curp));
d330 1
a330 1
	return(mdoc_alloc(curp, pflags, mmsg));
a454 1
	struct regset	 regs;
d459 1
a460 1
	memset(&regs, 0, sizeof(struct regset));
d543 1
a543 1
			re = roff_parseln(roff, &regs, lnn_start, 
d565 1
a565 1
		if (man && ! man_parseln(man, &regs, lnn_start, ln.buf, of))
d567 1
a567 1
		if (mdoc && ! mdoc_parseln(mdoc, &regs, lnn_start, ln.buf, of))
d640 1
@


1.90
log
@First step of adding register support.  This is inspired by a significant
patch by schwarze@@.  This commit adds support to libroff parsing `nr'
into register set defined in regs.h.  This will propogate into libmdoc
and libman in later commits.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.89 2010/06/19 20:46:27 kristaps Exp $ */
d565 1
a565 1
		if (man && ! man_parseln(man, lnn_start, ln.buf, of))
d567 1
a567 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf, of))
@


1.89
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.88 2010/06/12 11:41:50 kristaps Exp $ */
d33 2
a37 1
#include "main.h"
d454 1
d460 1
d543 1
a543 1
			re = roff_parseln(roff, lnn_start, 
@


1.88
log
@Removed stipulation that an empty `Bd -offset' will default to 6n.  Not
sure where this came about.  Added regression tests to convince myself
that this is so.  Also consolidated COMPATIBILITY notes regarding `Bd'.
Added COMPATIBILITY note to the effect that old groff pukes on `Bd
-compact -ragged' (regression test will fail on old groff).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.87 2010/06/12 10:09:19 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.87
log
@Added enum mdoc_disp (similar to enum mdoc_list).  Display types are now
only calculated once in mdoc_validate.c.

Noted that `Bd -file xxx' is not supported:  it now raises a fatal
warning.  This is noted in mdoc.7.

Empty `Bd' now defaults to LIST_ragged, which is not quite what groff
does, but close enough (gross just throws away the `Bd' and gets upset
when it encounters an `Ed').
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.86 2010/06/08 13:22:37 kristaps Exp $ */
d112 1
@


1.86
log
@No functionality changes: just restructuring.  Deprecated
terminal_free() in favour of ps_free() and ascii_free().  Moved ps_*()
functions into term_ps.c so that they don't clutter up term.c.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.85 2010/06/07 20:57:09 kristaps Exp $ */
d146 1
a150 1
	"missing display type",
d152 1
@


1.85
log
@First check-in of PostScript output.  This does not change any logic
within term.c, but does add a small shim over putchar() that switches on
the output engine.  Prints, for this initial version, only monospace and
without font decorations.  It's a start.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.84 2010/06/07 10:52:44 kristaps Exp $ */
d594 1
d598 1
a620 1
			curp->outfree = terminal_free;
@


1.84
log
@Add -Owidth=width option to mandoc -Tascii.  Asked for by joerg@@ about a
thousand years ago.  Note that this is normalised to >=60.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.83 2010/06/06 20:44:53 joerg Exp $ */
d68 2
a69 1
	OUTT_LINT
a587 3
			curp->outman = html_man;
			curp->outmdoc = html_mdoc;
			curp->outfree = html_free;
d591 15
d614 3
a616 4
		case (OUTT_LINT):
			break;
		default:
			curp->outdata = ascii_alloc(curp->outopts);
d621 2
d746 2
@


1.83
log
@Add MAP_SHARED for mmap, at least NetBSD with DIAGNOSTIC is quite noisy
otherwise.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.82 2010/06/03 13:44:36 kristaps Exp $ */
d604 1
a604 1
			curp->outdata = ascii_alloc(80);
@


1.82
log
@Consolidated list processing to a single loop in mdoc_validate.c.  This
relieves having to repeat running over the argument list in
mdoc_action.c and mdoc_validate.c.

Default to LIST_item for type-less lists (groff technically doesn't do
this: it just ignores the `It' lines altogether).

Make MANDOC_LISTTYPE be a recoverable error.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.81 2010/06/01 14:54:37 kristaps Exp $ */
d398 1
a398 1
				MAP_FILE, curp->fd, 0);
@


1.81
log
@Spelling patches provided by Ulrich Spoerlein.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.80 2010/05/31 23:40:25 kristaps Exp $ */
d144 1
a149 1
	"missing list type",
@


1.80
log
@Cleanup post_bl_head() to use enum mdoc_list (avoid traversing that
list).

Reverted MANDOC_COLUMNS to be a bad-bad syntax error: we don't, and
apparently never have, allowed mixing of -column syntaxes.  This would
have segfaulted if encountered.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.79 2010/05/17 22:11:42 kristaps Exp $ */
d100 1
a100 1
	"sections out of conentional order",
d113 1
a113 1
	"unknown manual sction",
@


1.79
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.78 2010/05/16 22:28:33 kristaps Exp $ */
a104 1
	"column syntax is inconsistent",
d146 1
@


1.78
log
@`ig' support in all its glory.  Try

  .ig ig
  asdf
  .ig
  fdsa
  ..

or

  .ig if
  asdf
  .if n \
  foo

for a laugh.  It all works.  Lots of regression tests supporting this
and documentation for the same.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.77 2010/05/16 19:08:11 kristaps Exp $ */
d84 77
a160 11
			  FL_NIGN_MACRO
	enum intt	  inttype;	/* Input parsers... */
	struct man	 *man;
	struct mdoc	 *mdoc;
	struct roff	 *roff;
	enum outt	  outtype;	/* Output devices... */
	out_mdoc	  outmdoc;
	out_man	  	  outman;
	out_free	  outfree;
	void		 *outdata;
	char		  outopts[BUFSIZ];
a168 1
static	int		  merr(void *, int, int, const char *); /* DEPRECATED */
a169 1
static	int		  mwarn(void *, int, int, const char *); /* DEPRECATED */
a286 4
	struct man_cb	 mancb;

	mancb.man_err = merr;
	mancb.man_warn = mwarn;
d297 1
a297 1
	return(man_alloc(curp, pflags, &mancb));
a312 4
	struct mdoc_cb	 mdoccb;

	mdoccb.mdoc_err = merr;
	mdoccb.mdoc_warn = mwarn;
d325 1
a325 1
	return(mdoc_alloc(curp, pflags, &mdoccb));
a814 53
/* ARGSUSED */
static int
merr(void *arg, int line, int col, const char *msg)
{
	struct curparse *curp;

	curp = (struct curparse *)arg;

	(void)fprintf(stderr, "%s:%d:%d: error: %s\n", 
			curp->file, line, col + 1, msg);

	with_error = 1;

	return(0);
}


static int
mwarn(void *arg, int line, int col, const char *msg)
{
	struct curparse *curp;

	curp = (struct curparse *)arg;

	if ( ! (curp->wflags & WARN_WALL))
		return(1);

	(void)fprintf(stderr, "%s:%d:%d: warning: %s\n", 
			curp->file, line, col + 1, msg);

	with_warning = 1;
	if (curp->wflags & WARN_WERR) {
		with_error = 1;
		return(0);
	}

	return(1);
}

static	const char * const	mandocerrs[MANDOCERR_MAX] = {
	"ok",
	"multi-line scope open on exit",
	"request for scope closure when no matching scope is open: ignored",
	"macro requires line argument(s): ignored",
	"line arguments will be lost",
	"memory exhausted"
};

/*
 * XXX: this is experimental code that will eventually become the
 * generic means of covering all warnings and errors!
 */
/* ARGSUSED */
a817 1
#if 0
d822 7
d836 8
a843 1
#endif
@


1.77
log
@Regression tests in place for `.if' in libroff.
Check against some strange `.if' constructs I missed.
Added initial roff.7 manual.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.76 2010/05/16 10:59:36 kristaps Exp $ */
d801 2
a802 2
	"request for scope closure when no matching scope is open",
	"macro requires line argument(s)",
@


1.76
log
@Allow roff_parseln() to be re-run.
Allow roff_parseln() to manipulate the line buffer offset.  This is used
in situations like `.ie n .TH FOO 1' or `.ie n .ie n', where the line
buffer offset is recalculated then the roff parser re-run.
Fix mdoc_parseln() and man_parseln() to accept the initial line offset.
WARNING: backed-out ALL roff macros whilst accomodating for how roff
handles multi-line conditionals (in short, re-running the parser).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.75 2010/05/16 00:04:46 kristaps Exp $ */
d802 1
@


1.75
log
@Fix allowing silly '\'' control character.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.74 2010/05/15 22:28:22 kristaps Exp $ */
d389 1
a389 1
	int		 i, pos, lnn, lnn_start, with_mmap;
d470 15
a484 1
		re = roff_parseln(roff, lnn_start, &ln.buf, &ln.sz);
d490 6
a495 1
		/* If unset, assign parser in pset(). */
d497 3
a499 2
		if ( ! (man || mdoc) && ! pset(ln.buf, pos, curp, &man, &mdoc))
			goto bailout;
d501 1
a501 1
		/* Pass down into parsers. */
d503 1
a503 1
		if (man && ! man_parseln(man, lnn_start, ln.buf))
d505 1
a505 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn_start, ln.buf))
d516 2
@


1.74
log
@Backed-out warning messages (lots).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.73 2010/05/15 21:53:11 kristaps Exp $ */
d577 1
a577 1
	if (buf[0] == '.') {
@


1.73
log
@The `ig' now supports `ig end-macro'.
Initial warning/error messages in place (still experimental).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.72 2010/05/15 18:43:59 kristaps Exp $ */
d792 1
d804 1
@


1.72
log
@Segfault fix and letting warnings slip through for now.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.71 2010/05/15 18:35:14 kristaps Exp $ */
d776 8
d796 5
a800 1
	/*fprintf(stderr, "%s:%d:%d: %s\n", cp->file, ln, col + 1, msg);*/
d802 1
@


1.71
log
@Add mandoc.h, which will eventually replace compilers' inner enum errors with unified ones.
Add initial roff pre-processor shim, a compiler sitting outside of the other compilers that processes pure roff instructions.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.70 2010/05/15 16:20:12 joerg Exp $ */
d788 1
a788 1
	fprintf(stderr, "%s:%d:%d: %s\n", cp->file, ln, col + 1, msg);
@


1.70
log
@Reorganise the comment stripping and line merging to be easier to follow
and slightly faster.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.69 2010/05/15 16:18:23 joerg Exp $ */
d32 1
d35 1
d75 1
d88 1
d102 2
a103 1
static	int		  merr(void *, int, int, const char *);
d105 3
a107 1
static	int		  mwarn(void *, int, int, const char *);
d187 6
d241 8
d340 1
a340 1
		fb->sz = st.st_size;
d366 1
a366 1
		ssz = read(curp->fd, fb->buf + off, fb->sz - off);
d375 1
a375 1
		off += ssz;
d390 1
d393 1
d397 1
d405 1
a405 1
	if (!read_whole_file(curp, &blk, &with_mmap))
d408 5
d468 7
a474 1
		ln.buf[pos] = 0;
d483 1
a483 1
		if (man && ! man_parseln(man, lnn, ln.buf))
d485 1
a485 1
		if (mdoc && ! mdoc_parseln(mdoc, lnn, ln.buf))
d500 2
d542 6
a547 8
	if (curp->mdoc) {
		mdoc_free(curp->mdoc);
		curp->mdoc = NULL;
	}
	if (curp->man) {
		man_free(curp->man);
		curp->man = NULL;
	}
d554 1
d776 16
@


1.69
log
@Make the output width an option for ascii_alloc and use that to compute
the default margin. Hard-code 80 chars/line for now.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.68 2010/05/15 09:46:31 joerg Exp $ */
d368 1
a368 1
	int		 j, i, pos, lnn, comment, with_mmap;
d377 2
a378 3
	 * Two buffers: ln and buf.  buf is the input buffer optimised
	 * here for each file's block size.  ln is a line buffer.  Both
	 * growable, hence passed in by ptr-ptr.
d384 15
a398 10
	/* Fill buf with file blocksize. */

	for (i = lnn = pos = comment = 0; i < (int)blk.sz; ++i) {
		if (pos >= (int)ln.sz) {
			if (! resize_buf(&ln, 256))
				goto bailout;
		}

		if ('\n' != blk.buf[i]) {
			if (comment)
d400 6
a405 5
			ln.buf[pos++] = blk.buf[i];

			/* Handle in-line `\"' comments. */

			if (1 == pos || '\"' != ln.buf[pos - 1])
a406 15

			for (j = pos - 2; j >= 0; j--)
				if ('\\' != ln.buf[j])
					break;

			if ( ! ((pos - 2 - j) % 2))
				continue;

			comment = 1;
			pos -= 2;
			for (; pos > 0; --pos) {
				if (ln.buf[pos - 1] != ' ')
					break;
				if (pos > 2 && ln.buf[pos - 2] == '\\')
					break;
d408 23
a430 4
			continue;
		} 

		/* Handle escaped `\\n' newlines. */
d432 2
a433 9
		if (pos > 0 && 0 == comment && '\\' == ln.buf[pos - 1]) {
			for (j = pos - 1; j >= 0; j--)
				if ('\\' != ln.buf[j])
					break;
			if ( ! ((pos - j) % 2)) {
				pos--;
				lnn++;
				continue;
			}
d436 3
a439 1
		lnn++;
a445 2
		pos = comment = 0;

@


1.68
log
@Push buffer resizing into its own function.  Keep initial allocations the
same size as before.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.67 2010/05/15 05:50:19 joerg Exp $ */
d487 1
a487 1
			curp->outdata = ascii_alloc();
@


1.67
log
@Cleanup indentation after moving the read buffering out of the loop.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.66 2010/05/15 05:11:50 kristaps Exp $ */
d271 21
d295 1
a295 2
	char		*buf;
	size_t		 sz, off;
d342 1
a342 7
			if (fb->sz == 0)
				sz = 65536;
			else
				sz = 2 * fb->sz;
			buf = realloc(fb->buf, sz);
			if (NULL == buf) {
				perror(NULL);
a343 3
			}
			fb->buf = buf;
			fb->sz = sz;
a366 1
	size_t		 sz;
a371 1
	sz = BUFSIZ;
d389 1
a389 4
			ln.sz += 256; /* Step-size. */
			ln.buf = realloc(ln.buf, ln.sz);
			if (NULL == ln.buf) {
				perror(NULL);
a390 1
			}
@


1.66
log
@"Push down the buffer to where they are used.
Handle the stdin/file argument in one function.
On top, use either mmap or if that failed reading the whole file into a
single buffer." (patches by Joerg Sonnenberger, ed. Kristaps)
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.65 2010/05/15 04:46:10 kristaps Exp $ */
d379 6
a384 7
			if (pos >= (int)ln.sz) {
				ln.sz += 256; /* Step-size. */
				ln.buf = realloc(ln.buf, ln.sz);
				if (NULL == ln.buf) {
					perror(NULL);
					goto bailout;
				}
d386 11
d398 5
a402 25
			if ('\n' != blk.buf[i]) {
				if (comment)
					continue;
				ln.buf[pos++] = blk.buf[i];

				/* Handle in-line `\"' comments. */

				if (1 == pos || '\"' != ln.buf[pos - 1])
					continue;

				for (j = pos - 2; j >= 0; j--)
					if ('\\' != ln.buf[j])
						break;

				if ( ! ((pos - 2 - j) % 2))
					continue;

				comment = 1;
				pos -= 2;
				for (; pos > 0; --pos) {
					if (ln.buf[pos - 1] != ' ')
						break;
					if (pos > 2 && ln.buf[pos - 2] == '\\')
						break;
				}
a403 1
			} 
d405 12
a416 1
			/* Handle escaped `\\n' newlines. */
d418 8
a425 10
			if (pos > 0 && 0 == comment && 
					'\\' == ln.buf[pos - 1]) {
				for (j = pos - 1; j >= 0; j--)
					if ('\\' != ln.buf[j])
						break;
				if ( ! ((pos - j) % 2)) {
					pos--;
					lnn++;
					continue;
				}
d427 1
d429 2
a430 2
			ln.buf[pos] = 0;
			lnn++;
d432 1
a432 1
			/* If unset, assign parser in pset(). */
d434 2
a435 3
			if ( ! (man || mdoc) && ! pset(ln.buf, 
						pos, curp, &man, &mdoc))
				goto bailout;
d437 1
a437 1
			pos = comment = 0;
d439 1
a439 1
			/* Pass down into parsers. */
d441 4
a444 4
			if (man && ! man_parseln(man, lnn, ln.buf))
				goto bailout;
			if (mdoc && ! mdoc_parseln(mdoc, lnn, ln.buf))
				goto bailout;
@


1.65
log
@Whacked lastman and lastmdoc (not being used).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.64 2010/05/14 17:59:07 kristaps Exp $ */
d21 1
d80 2
d93 2
a94 3
#define	FL_STRICT	  FL_NIGN_ESCAPE | \
			  FL_NIGN_MACRO

d96 3
a98 1
static	int		  toptions(struct curparse *, char *);
a99 2
static	int		  woptions(int *, char *);
static	int		  merr(void *, int, int, const char *);
a100 4
static	void		  ffile(struct buf *, struct buf *, 
				const char *, struct curparse *);
static	void		  fdesc(struct buf *, struct buf *,
				struct curparse *);
d103 2
a104 2
static	struct man	 *man_init(struct curparse *);
static	struct mdoc	 *mdoc_init(struct curparse *);
d106 1
a106 1
static	void		  usage(void) __attribute__((noreturn));
d109 2
a110 1
static 	int		  with_error, with_warning;
a115 1
	struct buf	 ln, blk;
a162 3
	memset(&ln, 0, sizeof(struct buf));
	memset(&blk, 0, sizeof(struct buf));

d167 1
a167 1
		fdesc(&blk, &ln, &curp);
d171 1
a171 1
		ffile(&blk, &ln, *argv, &curp);
a177 4
	if (blk.buf)
		free(blk.buf);
	if (ln.buf)
		free(ln.buf);
d181 2
a182 1
	return((with_warning || with_error) ? EXIT_FAILURE :  EXIT_SUCCESS );
d253 1
a253 2
ffile(struct buf *blk, struct buf *ln, 
		const char *file, struct curparse *curp)
d263 1
a263 1
	fdesc(blk, ln, curp);
d270 83
d354 1
a354 1
fdesc(struct buf *blk, struct buf *ln, struct curparse *curp)
d357 2
a358 3
	ssize_t		 ssz;
	struct stat	 st;
	int		 j, i, pos, lnn, comment;
d365 1
d373 1
a373 3
	if (-1 == fstat(curp->fd, &st)) {
		perror(curp->file);
		with_error = 1;
a374 15
	}
	if ((size_t)st.st_blksize > sz)
		sz = st.st_blksize;

	if (sz > blk->sz) {
		void *buf = realloc(blk->buf, sz);

		if (NULL == buf) {
			perror(NULL);
			with_error = 1;
			return;
		}
		blk->buf = buf;
		blk->sz = sz;
	}
d378 5
a382 14
	for (lnn = pos = comment = 0; ; ) {
		if (-1 == (ssz = read(curp->fd, blk->buf, sz))) {
			perror(curp->file);
			goto bailout;
		} else if (0 == ssz) 
			break;

		/* Parse the read block into partial or full lines. */

		for (i = 0; i < (int)ssz; i++) {
			if (pos >= (int)ln->sz) {
				ln->sz += 256; /* Step-size. */
				ln->buf = realloc(ln->buf, ln->sz);
				if (NULL == ln->buf) {
d388 1
a388 1
			if ('\n' != blk->buf[i]) {
d391 1
a391 1
				ln->buf[pos++] = blk->buf[i];
d395 1
a395 1
				if (1 == pos || '\"' != ln->buf[pos - 1])
d399 1
a399 1
					if ('\\' != ln->buf[j])
d408 1
a408 1
					if (ln->buf[pos - 1] != ' ')
d410 1
a410 1
					if (pos > 2 && ln->buf[pos - 2] == '\\')
d419 1
a419 1
					'\\' == ln->buf[pos - 1]) {
d421 1
a421 1
					if ('\\' != ln->buf[j])
d430 1
a430 1
			ln->buf[pos] = 0;
d435 1
a435 1
			if ( ! (man || mdoc) && ! pset(ln->buf, 
d443 1
a443 1
			if (man && ! man_parseln(man, lnn, ln->buf))
d445 1
a445 1
			if (mdoc && ! mdoc_parseln(mdoc, lnn, ln->buf))
a446 1
		}
d508 6
@


1.64
log
@"Accumulate errors and warnings in global variables and exit with error
if either is not null on exit." (patch by Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.63 2010/05/14 13:54:15 kristaps Exp $ */
a80 1
	struct man	 *lastman;
a81 1
	struct mdoc	 *lastmdoc;
a496 1
		curp->lastmdoc = *mdoc;
a502 1
		curp->lastman = *man;
a512 1
		curp->lastmdoc = *mdoc;
a519 1
	curp->lastman = *man;
@


1.63
log
@Fix for Joerg's patch stripping of pre-comment whitespace (by Joerg).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.62 2010/05/09 21:19:42 kristaps Exp $ */
d101 1
a101 1
static	int		  ffile(struct buf *, struct buf *, 
d103 1
a103 1
static	int		  fdesc(struct buf *, struct buf *,
d113 1
a113 1

d118 1
a118 1
	int		 c, rc;
a169 2
	rc = 1;

d174 9
a182 23
		c = fdesc(&blk, &ln, &curp);
		if ( ! (FL_IGN_ERRORS & curp.fflags)) 
			rc = 1 == c ? 1 : 0;
		else
			rc = -1 == c ? 0 : 1;
	}

	while (rc && *argv) {
		c = ffile(&blk, &ln, *argv, &curp);
		if ( ! (FL_IGN_ERRORS & curp.fflags)) 
			rc = 1 == c ? 1 : 0;
		else
			rc = -1 == c ? 0 : 1;

		argv++;
		if (*argv && rc) {
			if (curp.lastman)
				man_reset(curp.lastman);
			if (curp.lastmdoc)
				mdoc_reset(curp.lastmdoc);
			curp.lastman = NULL;
			curp.lastmdoc = NULL;
		}
a190 4
	if (curp.mdoc)
		mdoc_free(curp.mdoc);
	if (curp.man)
		man_free(curp.man);
d192 1
a192 1
	return(rc ? EXIT_SUCCESS : EXIT_FAILURE);
d262 1
a262 1
static int
a265 1
	int		 c;
d270 2
a271 1
		return(-1);
d274 1
a274 1
	c = fdesc(blk, ln, curp);
a277 2

	return(c);
d281 1
a281 1
static int
d301 1
a301 1
	if (-1 == fstat(curp->fd, &st))
d303 4
a306 1
	else if ((size_t)st.st_blksize > sz)
d310 3
a312 2
		blk->buf = realloc(blk->buf, sz);
		if (NULL == blk->buf) {
d314 2
a315 1
			exit(EXIT_FAILURE);
d317 1
d326 1
a326 1
			return(-1);
d338 1
a338 1
					return(EXIT_FAILURE);
d391 1
a391 1
				return(-1);
d398 1
a398 1
				return(0);
d400 1
a400 1
				return(0);
d408 1
a408 1
		return(0);
d412 1
a412 1
		return(0);
d414 1
a414 1
		return(0);
d454 14
a467 1
	return(1);
d660 2
d679 7
a685 4
	if ( ! (curp->wflags & WARN_WERR))
		return(1);
	
	return(0);
@


1.62
log
@Remove -fno-ign-chars as well-argued by Ingo Schwarze.  Patch by Ingo Schwarze, too.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.61 2010/04/12 19:27:22 kristaps Exp $ */
d378 1
a378 1
					if (ln->buf[pos] != ' ')
d380 1
a380 1
					if (ln->buf[pos - 1] == '\\')
@


1.61
log
@Merge patch by Jason McIntyre cleaning on mandoc.1: `Ar' -> `Cm' and other readability fixes.
Merge modified patch by Joerg Sonnenberger that rewinds to whitespace when encountering trailing line-comments.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.60 2010/03/22 20:43:00 kristaps Exp $ */
a77 1
#define	FL_NIGN_CHARS	 (1 << 3)	/* Don't ignore bad chars. */
d93 1
a93 2
			  FL_NIGN_MACRO | \
 			  FL_NIGN_CHARS
d247 1
a247 1
	pflags = MAN_IGN_MACRO | MAN_IGN_ESCAPE | MAN_IGN_CHARS;
a250 2
	if (curp->fflags & FL_NIGN_CHARS)
		pflags &= ~MAN_IGN_CHARS;
d269 1
a269 1
	pflags = MDOC_IGN_MACRO | MDOC_IGN_ESCAPE | MDOC_IGN_CHARS;
a276 2
	if (curp->fflags & FL_NIGN_CHARS)
		pflags &= ~MDOC_IGN_CHARS;
d587 4
a590 5
	toks[3] = "no-ign-chars";
	toks[4] = "ign-errors";
	toks[5] = "strict";
	toks[6] = "ign-escape";
	toks[7] = NULL;
d605 1
a605 1
			*fflags |= FL_NIGN_CHARS;
d608 1
a608 1
			*fflags |= FL_IGN_ERRORS;
a610 3
			*fflags |= FL_STRICT;
			break;
		case (6):
@


1.60
log
@Have -Tlint imply -Wall and -fstrict.  Based on a patch submitted by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.59 2010/01/29 14:39:38 kristaps Exp $ */
d231 1
a231 1
	(void)fprintf(stderr, "usage: %s [-V] [-foption...] "
d233 1
a233 1
			"[-Werr...]\n", progname);
d383 6
@


1.59
log
@Fixed Makefile for `make lint' dep. on config.h
Added -Txhtml for XHTML output (minimal increase to programme logic).  Because groff has it and it bothers me that we don't.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.58 2010/01/01 17:14:27 kristaps Exp $ */
d75 5
a79 5
#define	IGN_SCOPE	 (1 << 0) 	/* Ignore scope errors. */
#define	NO_IGN_ESCAPE	 (1 << 1) 	/* Don't ignore bad escapes. */
#define	NO_IGN_MACRO	 (1 << 2) 	/* Don't ignore bad macros. */
#define	NO_IGN_CHARS	 (1 << 3)	/* Don't ignore bad chars. */
#define	IGN_ERRORS	 (1 << 4)	/* Ignore failed parse. */
d93 4
d98 1
a98 1
static	int		  toptions(enum outt *, char *);
d151 1
a151 1
			if ( ! toptions(&curp.outtype, optarg))
d179 1
a179 1
		if ( ! (IGN_ERRORS & curp.fflags)) 
d187 1
a187 1
		if ( ! (IGN_ERRORS & curp.fflags)) 
d251 1
a251 1
	if (curp->fflags & NO_IGN_MACRO)
d253 1
a253 1
	if (curp->fflags & NO_IGN_CHARS)
d255 1
a255 1
	if (curp->fflags & NO_IGN_ESCAPE)
d275 1
a275 1
	if (curp->fflags & IGN_SCOPE)
d277 1
a277 1
	if (curp->fflags & NO_IGN_ESCAPE)
d279 1
a279 1
	if (curp->fflags & NO_IGN_MACRO)
d281 1
a281 1
	if (curp->fflags & NO_IGN_CHARS)
d553 1
a553 1
toptions(enum outt *tflags, char *arg)
d557 6
a562 3
		*tflags = OUTT_ASCII;
	else if (0 == strcmp(arg, "lint"))
		*tflags = OUTT_LINT;
d564 1
a564 1
		*tflags = OUTT_TREE;
d566 1
a566 1
		*tflags = OUTT_HTML;
d568 1
a568 1
		*tflags = OUTT_XHTML;
d597 1
a597 1
			*fflags |= IGN_SCOPE;
d600 1
a600 1
			*fflags |= NO_IGN_ESCAPE;
d603 1
a603 1
			*fflags |= NO_IGN_MACRO;
d606 1
a606 1
			*fflags |= NO_IGN_CHARS;
d609 1
a609 1
			*fflags |= IGN_ERRORS;
d612 1
a612 2
			*fflags |= NO_IGN_ESCAPE | 
			 	   NO_IGN_MACRO | NO_IGN_CHARS;
d615 1
a615 1
			*fflags &= ~NO_IGN_ESCAPE;
@


1.58
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.57 2009/11/02 08:29:25 kristaps Exp $ */
d64 1
d432 6
d560 2
@


1.57
log
@Added forgotten newline terminators in main.c.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.56 2009/11/02 08:13:48 kristaps Exp $ */
d17 4
a44 5
#ifdef __linux__
extern	int		  getsubopt(char **, char * const *, char **);
extern	size_t	  	  strlcat(char *, const char *, size_t);
#endif

@


1.56
log
@Added lint to __attribute__ defines.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.55 2009/11/02 08:08:23 kristaps Exp $ */
d534 1
a534 1
		fprintf(stderr, "%s: Bad argument", arg);
d555 1
a555 1
		fprintf(stderr, "%s: Bad argument", arg);
d604 1
a604 1
			fprintf(stderr, "%s: Bad argument", o);
d633 1
a633 1
			fprintf(stderr, "%s: Bad argument", o);
@


1.55
log
@Using straight-up __attribute__ (inspired by portable openssh).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.54 2009/10/31 06:17:19 kristaps Exp $ */
d36 3
a38 1
# define __attribute__(x)
@


1.54
log
@Removed non-portable __progname (thanks Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.53 2009/10/31 06:10:57 kristaps Exp $ */
d33 5
a37 1
/* Account for FreeBSD and Linux in our declarations. */
a41 7
# ifndef __dead
#  define __dead __attribute__((__noreturn__))
# endif
#elif defined(__dead2)
# ifndef __dead
#  define __dead __dead2
# endif
d105 2
a106 2
__dead	static void	  version(void);
__dead	static void	  usage(void);
d212 1
a212 1
__dead static void
d221 1
a221 1
__dead static void
@


1.53
log
@Using perror() instead of fprintf for failure from library functions.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.52 2009/10/30 05:58:37 kristaps Exp $ */
d111 1
a111 1
extern	char		 *__progname;
d121 6
d219 1
a219 1
	(void)printf("%s %s\n", __progname, VERSION);
d230 1
a230 1
			"[-Werr...]\n", __progname);
@


1.52
log
@libmdoc and libman now using non-recoverable allocations (simpler code).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.51 2009/10/27 08:26:11 kristaps Exp $ */
a19 1
#include <err.h>
d287 1
a287 1
		warn("%s", curp->file);
d294 1
a294 1
		warn("%s", curp->file);
d321 1
a321 1
		warn("%s", curp->file);
d328 2
a329 2
			warn("realloc");
			return(-1);
d338 1
a338 1
			warn("%s", curp->file);
d350 2
a351 2
					warn("realloc");
					return(-1);
d414 1
a414 2
		(void)fprintf(stderr, "%s: not a manual\n", 
				curp->file);
d529 1
a529 1
		warnx("bad argument: -m%s", arg);
d550 1
a550 1
		warnx("bad argument: -T%s", arg);
d599 1
a599 1
			warnx("bad argument: -f%s", o);
d628 1
a628 1
			warnx("bad argument: -W%s", o);
@


1.51
log
@bzero() -> memset() (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.50 2009/10/26 15:44:51 kristaps Exp $ */
d187 1
a187 2
				if ( ! man_reset(curp.lastman))
					rc = 0;
d189 1
a189 2
				if ( ! mdoc_reset(curp.lastmdoc))
					rc = 0;
a233 1
	struct man	*man;
d250 1
a250 4
	if (NULL == (man = man_alloc(curp, pflags, &mancb)))
		warnx("memory exhausted");

	return(man);
a257 1
	struct mdoc	*mdoc;
d276 1
a276 4
	if (NULL == (mdoc = mdoc_alloc(curp, pflags, &mdoccb)))
		warnx("memory exhausted");

	return(mdoc);
@


1.50
log
@Merged patch to allow -fign-escape (thanks Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.49 2009/10/26 08:42:37 kristaps Exp $ */
d122 1
a122 1
	bzero(&curp, sizeof(struct curparse));
d161 2
a162 2
	bzero(&ln, sizeof(struct buf));
	bzero(&blk, sizeof(struct buf));
@


1.49
log
@Allowed -O to be invoked multiple times.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.48 2009/10/26 08:18:16 kristaps Exp $ */
d574 1
a574 1
	const char	*toks[7];
d582 2
a583 1
	toks[6] = NULL;
d607 3
@


1.48
log
@Portability: replaced queue macros in html.c (Joerg Sonnenberger).
Fixed "-o" residue.
Added "-O" to usage() (-o didn't appear there either).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.47 2009/10/26 04:15:42 kristaps Exp $ */
d38 1
d92 1
a92 1
	char		 *outopts;
d139 2
a140 1
			curp.outopts = optarg;
@


1.47
log
@Changed `-o' to `-O' for clarity.  THIS BREAKS UTILITIES DEPENDING ON -o!
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.46 2009/10/13 10:57:25 kristaps Exp $ */
d137 1
a137 1
		case ('o'):
d224 2
a225 2
			"[-mformat] [-Toutput] [-Werr...]\n", 
			__progname);
@


1.46
log
@Moved output definitions into main.h.
Pushed terminal_{mdoc,man} into {mdoc,man}_term.c.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.45 2009/10/13 10:21:24 kristaps Exp $ */
d127 1
a127 1
	while (-1 != (c = getopt(argc, argv, "f:m:o:T:VW:")))
@


1.45
log
@Clean up consts (noted by Joerg Sonnenberger and Ulrich Sporlein).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.44 2009/09/21 13:06:13 kristaps Exp $ */
d30 1
a93 11
extern	void		 *html_alloc(char *);
extern	void		  html_mdoc(void *, const struct mdoc *);
extern	void		  html_man(void *, const struct man *);
extern	void		  html_free(void *);
extern	void		 *ascii_alloc(void);
extern	void		  tree_mdoc(void *, const struct mdoc *);
extern	void		  tree_man(void *, const struct man *);
extern	void		  terminal_mdoc(void *, const struct mdoc *);
extern	void		  terminal_man(void *, const struct man *);
extern	void		  terminal_free(void *);

@


1.44
log
@Removed new-born out.{h,c} (not a good idea).
Removed if 0 for HTML-mode output (why not).
Added option -oxxxx for passing options to output devices.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.43 2009/09/16 22:17:27 kristaps Exp $ */
d23 1
d31 2
d582 1
a582 1
	char		*toks[7];
d594 1
a594 1
		switch (getsubopt(&arg, toks, &v)) {
d628 1
a628 1
	char		*toks[3]; 
d636 1
a636 1
		switch (getsubopt(&arg, toks, &v)) {
@


1.43
log
@More updates to html.c.
Secretly enabled -Thtml in main.c (obviously not yet documented).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.42 2009/09/16 09:41:24 kristaps Exp $ */
a60 1
#if 1
a61 1
#endif
d87 1
d90 1
a90 2
#if 1
extern	void		 *html_alloc(void);
a93 1
#endif
d134 1
a134 1
	while (-1 != (c = getopt(argc, argv, "f:m:VW:T:")))
d144 3
a443 1
#if 1
d445 1
a445 1
			curp->outdata = html_alloc();
a449 1
#endif
a563 1
#if 1
a565 1
#endif
@


1.42
log
@Made tree/term/out() functions return void.
Put err() functions back into front-ends (no use making it needlessly complex).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.41 2009/07/28 10:15:12 kristaps Exp $ */
d61 3
d91 6
d444 8
d566 4
@


1.41
log
@Fix in newline.
Correct printing of N-char predefined/special strings.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.40 2009/07/27 19:43:02 kristaps Exp $ */
d43 2
a44 2
typedef	int		(*out_mdoc)(void *, const struct mdoc *);
typedef	int		(*out_man)(void *, const struct man *);
d89 4
a92 4
extern	int		  tree_mdoc(void *, const struct mdoc *);
extern	int		  tree_man(void *, const struct man *);
extern	int		  terminal_mdoc(void *, const struct mdoc *);
extern	int		  terminal_man(void *, const struct man *);
d453 1
a453 2
		if ( ! (*curp->outman)(curp->outdata, man))
			return(-1);
d455 1
a455 2
		if ( ! (*curp->outmdoc)(curp->outdata, mdoc))
			return(-1);
@


1.40
log
@main.c using fprintf instead of warnx for parse errors (like cc).
Error string is now file:line:col: message.
Removed sed from vim -q example in manuals.7.
Fixed column reporting (off by one).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.39 2009/07/24 14:00:59 kristaps Exp $ */
d421 2
a422 1
		(void)fprintf(stderr, "%s: not a manual", curp->file);
@


1.39
log
@Added -fign-errors for VERY fast checking of many manuals without stopping at errors.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.38 2009/07/07 09:52:08 kristaps Exp $ */
d421 1
a421 1
		warnx("%s: not a manual", curp->file);
d642 2
a643 2
	warnx("%s:%d: error: %s (column %d)", 
			curp->file, line, msg, col);
d659 2
a660 2
	warnx("%s:%d: warning: %s (column %d)", 
			curp->file, line, msg, col);
a664 1
	warnx("considering warnings as errors");
@


1.38
log
@Small clean-ups in error message usage.
Version.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.37 2009/07/06 13:08:12 kristaps Exp $ */
d75 1
d165 6
a170 2
		if ( ! fdesc(&blk, &ln, &curp))
			rc = 0;
d174 6
a179 2
		if ( ! ffile(&blk, &ln, *argv, &curp))
			rc = 0;
d295 1
a295 1
		return(0);
d336 1
a336 1
			return(0);
d346 1
a346 1
			return(0);
d358 1
a358 1
					return(0);
d405 1
a405 1
				return(0);
d453 1
a453 1
			return(0);
d456 1
a456 1
			return(0);
d563 1
a563 1
	char		*toks[6];
d569 3
a571 2
	toks[4] = "strict";
	toks[5] = NULL;
d589 3
@


1.37
log
@Cleaned out duplicate {mdoc,man}warn in main.c.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.36 2009/07/06 09:34:29 kristaps Exp $ */
d646 1
a646 1
	warnx("%s:%d: syntax warning: %s (column %d)", 
@


1.36
log
@Backed -Wcompat,syntax out of front-end.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.35 2009/07/06 09:21:24 kristaps Exp $ */
d99 1
a99 2
static	int		  manwarn(void *, int, int, const char *);
static	int		  mdocwarn(void *, int, int, const char *);
d227 1
a227 1
	mancb.man_warn = manwarn;
d255 1
a255 1
	mdoccb.mdoc_warn = mdocwarn;
d637 1
a637 1
mdocwarn(void *arg, int line, int col, const char *msg)
a655 20

static int
manwarn(void *arg, int line, int col, const char *msg)
{
	struct curparse *curp;

	curp = (struct curparse *)arg;

	if ( ! (curp->wflags & WARN_WALL))
		return(1);

	warnx("%s:%d: syntax warning: %s (column %d)", 
			curp->file, line, msg, col);

	if ( ! (curp->wflags & WARN_WERR))
		return(1);

	warnx("considering warnings as errors");
	return(0);
}
@


1.35
log
@Initial removal of enum mdoc_warn from mdoc warnings (unnecessary complication).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.34 2009/07/04 11:10:36 kristaps Exp $ */
d68 1
a68 3
#define	WARN_WALL	  0x03		/* All-warnings mask. */
#define	WARN_WCOMPAT	 (1 << 0)	/* Compatibility warnings. */
#define	WARN_WSYNTAX	 (1 << 1)	/* Syntax warnings. */
d597 1
a597 1
	char		*toks[5]; 
d600 2
a601 4
	toks[1] = "compat";
	toks[2] = "syntax";
	toks[3] = "error";
	toks[4] = NULL;
a609 6
			*wflags |= WARN_WCOMPAT;
			break;
		case (2):
			*wflags |= WARN_WSYNTAX;
			break;
		case (3):
d629 1
d644 4
a647 1
	warnx("%s:%d: warning: %s (column %d)", 
d665 1
a665 1
	if ( ! (curp->wflags & WARN_WSYNTAX))
@


1.34
log
@suboptarg is not portable to Linux (fixed).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.33 2009/07/04 09:01:55 kristaps Exp $ */
d102 1
a102 2
static	int		  mdocwarn(void *, int, int, 
				enum mdoc_warn, const char *);
d647 1
a647 2
mdocwarn(void *arg, int line, int col, 
		enum mdoc_warn type, const char *msg)
a649 1
	char		*wtype;
a651 1
	wtype = NULL;
d653 2
a654 16
	switch (type) {
	case (WARN_COMPAT):
		wtype = "compat";
		if (curp->wflags & WARN_WCOMPAT)
			break;
		return(1);
	case (WARN_SYNTAX):
		wtype = "syntax";
		if (curp->wflags & WARN_WSYNTAX)
			break;
		return(1);
	}

	assert(wtype);
	warnx("%s:%d: %s warning: %s (column %d)", 
			curp->file, line, wtype, msg, col);
@


1.33
log
@Moved escape validation into libmandoc.h/mandoc.c (common between libman/libmdoc1).
libman supports MAN_IGN_ESCAPE (like MDOC_IGN_ESCAPE).
All popular escapes now handled consistently.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.32 2009/06/27 09:03:03 kristaps Exp $ */
d557 1
a557 1
	char		*v;
d567 2
a568 1
	while (*arg) 
d587 1
a587 1
			warnx("bad argument: -f%s", suboptarg);
d590 1
d599 1
a599 1
	char		*v;
d608 2
a609 1
	while (*arg) 
d624 1
a624 1
			warnx("bad argument: -W%s", suboptarg);
d627 1
@


1.32
log
@Removed escape-deprecation note (better solution in progress, schwarze@@openbsd.org).
Using EXIT_FAILURE for parse errors (nicm@@openbsd.org).
Fixed use of warn/warnx (nicm@@openbsd.org).
Fixed use of getsubopt (nicm@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.31 2009/06/18 10:32:00 kristaps Exp $ */
d235 1
a235 1
	pflags = MAN_IGN_MACRO | MAN_IGN_CHARS;
d241 2
@


1.31
log
@Added -fno-ign-chars support to libman.
man_validate.c checks for non-tab/isprint words.
libman hashtable fixed (was ignoring .br).
Added ncount field to man_node, deprecating count() functions.
Documented use of tabs in man.7.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.30 2009/06/16 20:22:23 kristaps Exp $ */
d135 1
a135 1
				return(0);
d139 1
a139 1
				return(0);
d143 1
a143 1
				return(0);
d147 1
a147 1
				return(0);
d321 1
a321 1
		warnx("%s", curp->file);
d584 1
a584 1
			warnx("bad argument: -f%s", arg);
d619 1
a619 1
			warnx("bad argument: -W%s", arg);
@


1.30
log
@Clean-up: in-source documentation.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.29 2009/06/16 19:13:28 kristaps Exp $ */
d235 1
a235 1
	pflags = MAN_IGN_MACRO;
d239 2
@


1.29
log
@Modernised comment handling: text following \" is thrown away before
either parser is invoked.  Single-dot lines correctly handled.  This
confirms with both new- and old-groff.  "Comment" subsection added to
mdoc.7 and man.7.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.28 2009/06/15 10:36:01 kristaps Exp $ */
a103 2
static	int		  fstdin(struct buf *, struct buf *, 
				struct curparse *);
a159 2
	/* Configure buffers. */

d165 4
a168 2
	if (NULL == *argv)
		if ( ! fstdin(&blk, &ln, &curp))
d170 1
a191 2

	/* TODO: have a curp_free routine. */
d233 1
a233 4
	/*
	 * Default behaviour is to ignore unknown macros.  This is
	 * specified in mandoc.1.
	 */
a236 2
	/* Override default behaviour... */

d257 1
a257 5
	/* 
	 * Default behaviour is to ignore unknown macros, escape
	 * sequences and characters (very liberal).  This is specified
	 * in mandoc.1.
	 */
a260 2
	/* Override default behaviour... */

a277 10
fstdin(struct buf *blk, struct buf *ln, struct curparse *curp)
{

	curp->file = "<stdin>";
	curp->fd = STDIN_FILENO;
	return(fdesc(blk, ln, curp));
}


static int
d400 2
d463 1
a463 1
	 * line: either skip comments, use -mdoc when finding `.Dt', or
a549 4
/*
 * Parse out the options for [-fopt...] setting compiler options.  These
 * can be comma-delimited or called again.
 */
a589 4
/* 
 * Parse out the options for [-Werr...], which sets warning modes.
 * These can be comma-delimited or called again.  
 */
a634 1
	/* Always exit on errors... */
d669 1
a669 7
	/*
	 * If the -Werror flag is passed in, as in gcc, then all
	 * warnings are considered as errors.
	 */

	warnx("%s: considering warnings as errors", 
			__progname);
d690 1
a690 7
	/* 
	 * If the -Werror flag is passed in, as in gcc, then all
	 * warnings are considered as errors.
	 */

	warnx("%s: considering warnings as errors", 
			__progname);
@


1.28
log
@Deprecated mdoc_msg (not being used anywhere).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.27 2009/06/11 12:07:49 kristaps Exp $ */
d77 1
a77 1
	enum intt	  inttype;	/* Input parsers. */
d82 1
a82 1
	enum outt	  outtype;	/* Output devices. */
d328 1
a328 1
	int		 j, i, pos, lnn;
d358 1
a358 1
	for (lnn = 0, pos = 0; ; ) {
d378 2
d381 15
d397 1
a397 1
			}
d399 1
a399 1
			/* Check for CPP-escaped newline. */
d401 2
a402 1
			if (pos > 0 && '\\' == ln->buf[pos - 1]) {
a405 1

d415 2
a416 7
			
			/*
			 * If no manual parser has been assigned, then
			 * try to assign one in pset(), which may do
			 * nothing at all.  After this, parse the manual
			 * line accordingly.
			 */
d422 1
a422 1
			pos = 0;
d431 1
a431 1
	/* Note that a parser may not have been assigned, yet. */
d443 1
a443 6
	/*
	 * If an output device hasn't been allocated, see if we should
	 * do so now.  Note that not all outtypes have functions, so
	 * this switch statement may be superfluous, but it's
	 * low-overhead enough not to matter very much.
	 */
d479 1
d489 7
a495 2
	if (pos >= 3 && 0 == memcmp(buf, ".\\\"", 3))
		return(1);
@


1.27
log
@Documented some un-clear parts of main.c.
Fixed footer to be new-groff style (OS DATE OS).
Removed sanity check from mdoc_term (unnecessary).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.26 2009/06/10 20:18:43 kristaps Exp $ */
a261 1
	mdoccb.mdoc_msg = NULL;
@


1.26
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.25 2009/04/12 19:45:26 kristaps Exp $ */
d193 2
d236 8
a243 1
	pflags = MAN_IGN_MACRO; /* XXX */
d266 6
d274 2
d383 1
a383 1
			/* Check for CPP-escaped newline.  */
a649 1

d652 2
d687 5
d715 5
@


1.25
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.24 2009/04/12 19:19:57 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.24
log
@Manual .Dt fields CAPITALISED.
Indent set to 5 chars (nroff compat).
Half-indent set to 3 chars (nroff compat).
Default behaviour is loose-y (ignore macro/char/escape).
Added -fstrict.
Added unknown-character ignoring.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.23 2009/04/03 12:27:18 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.23
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.22 2009/04/03 11:08:39 kristaps Exp $ */
d76 3
a78 3
#define	IGN_ESCAPE	 (1 << 1) 	/* Ignore bad escapes. */
#define	IGN_MACRO	 (1 << 2) 	/* Ignore unknown macros. */
#define	NO_IGN_MACRO	 (1 << 3) 
d259 1
a259 1
	pflags = 0; /* XXX */
d263 6
a268 4
	if (curp->fflags & IGN_ESCAPE)
		pflags |= MDOC_IGN_ESCAPE;
	if (curp->fflags & IGN_MACRO)
		pflags |= MDOC_IGN_MACRO;
d271 1
a271 1
		warnx("memory allocated");
d553 1
a553 1
	char		*toks[5];
d556 5
a560 4
	toks[1] = "ign-escape";
	toks[2] = "ign-macro";
	toks[3] = "no-ign-macro";
	toks[4] = NULL;
d568 1
a568 1
			*fflags |= IGN_ESCAPE;
d571 1
a571 1
			*fflags |= IGN_MACRO;
d574 5
a578 1
			*fflags |= NO_IGN_MACRO;
@


1.22
log
@Proper resetting of memory.
Array boundary fixed (-W).
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.21 2009/04/02 16:42:35 kristaps Exp $ */
d74 5
a78 1
	int		  fflags;	/* Per-intt flags. */
a90 5
#define	IGN_SCOPE	 (1 << 0) 	/* Ignore scope errors. */
#define	IGN_ESCAPE	 (1 << 1) 	/* Ignore bad escapes. */
#define	IGN_MACRO	 (1 << 2) 	/* Ignore unknown macros. */
#define	NO_IGN_MACRO	 (1 << 3) 

@


1.21
log
@Documented -mandoc behaviour.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.20 2009/04/02 16:37:40 kristaps Exp $ */
d45 4
d67 2
a68 2
	const char	 *file;
	int		  fd;
d74 2
a75 2
	int		  fflags;
	enum intt	  inttype;
d77 1
d79 6
a91 6
typedef	int		(*out_run)(void *, const struct man *,
				const struct mdoc *);
typedef	void		(*out_free)(void *);

extern	char		 *__progname;

d93 4
a96 4
extern	int		  terminal_run(void *, const struct man *, 
				const struct mdoc *);
extern	int		  tree_run(void *, const struct man *,
				const struct mdoc *);
d113 1
a113 1
static	int		  pset(const char *, size_t, struct curparse *,
d120 2
a126 2
	void		*outdata;
	enum outt	 outtype;
a127 2
	out_run		 outrun;
	out_free	 outfree;
a129 2
	outtype = OUTT_ASCII;

d133 1
d147 1
a147 1
			if ( ! toptions(&outtype, optarg))
a164 25
	/*
	 * Allocate the appropriate front-end.  Note that utf8, latin1
	 * (both not yet implemented) and ascii all resolve to the
	 * terminal front-end with different encodings (see terminal.c).
	 * Not all frontends have cleanup or alloc routines.
	 */

	switch (outtype) {
	case (OUTT_TREE):
		outdata = NULL;
		outrun = tree_run;
		outfree = NULL;
		break;
	case (OUTT_LINT):
		outdata = NULL;
		outrun = NULL;
		outfree = NULL;
		break;
	default:
		outdata = ascii_alloc();
		outrun = terminal_run;
		outfree = terminal_free;
		break;
	}

d170 1
a170 3
	/*
	 * Main loop around available files.
	 */
d172 17
a188 22
	if (NULL == *argv) {
		rc = 0;
		c = fstdin(&blk, &ln, &curp);

		if (c && NULL == outrun)
			rc = 1;
		/*else if (c && outrun && (*outrun)(outdata, curp.man, curp.mdoc))
			rc = 1;*/
	} else {
		while (*argv) {
			c = ffile(&blk, &ln, *argv, &curp);
			if ( ! c)
				break;
			/*if (outrun && ! (*outrun)(outdata, curp.man, curp.mdoc))
				break;*/
			if (curp.man)
				man_reset(curp.man);
			if (curp.mdoc && ! mdoc_reset(curp.mdoc)) {
				warnx("memory exhausted");
				break;
			}
			argv++;
a189 1
		rc = NULL == *argv;
d196 2
a197 2
	if (outfree)
		(*outfree)(outdata);
d237 1
a237 2
	/* Set command defaults. */
	pflags = MAN_IGN_MACRO;
d260 1
a260 1
	pflags = 0;
d406 9
a414 4
	if (mdoc)
	       return(mdoc_endparse(mdoc));
	if (man)
		return(man_endparse(man));
d416 34
a449 2
	warnx("%s: not a manual", curp->file);
	return(0);
d454 1
a454 1
pset(const char *buf, size_t pos, struct curparse *curp,
d475 1
a475 1
		warnx("inheriting -mdoc parser");
d482 1
a482 1
		warnx("inheriting -man parser");
d493 1
d501 1
d557 2
a558 2
	toks[4] = "no-ign-macro";
	toks[5] = NULL;
@


1.20
log
@Added -p1003.1-2008 specification.
Fixed invalid memory accesses (concat()).
Made -fign-macro be the default for libman.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.19 2009/04/02 16:26:35 kristaps Exp $ */
a270 2
	if (curp->fflags & IGN_MACRO)
		pflags |= MAN_IGN_MACRO;
@


1.19
log
@Initial -mandoc auto-switch in place.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.18 2009/03/31 13:50:19 kristaps Exp $ */
d79 1
d268 2
a269 1
	pflags = 0;
d273 2
d547 1
a547 1
	char		*toks[4];
d552 2
a553 1
	toks[3] = NULL;
d566 3
@


1.18
log
@General clean-ups.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.17 2009/03/26 16:23:22 kristaps Exp $ */
d50 12
d64 1
d70 4
a79 11
enum	intt {
	INTT_MDOC = 0,
	INTT_MAN
};

enum	outt {
	OUTT_ASCII = 0,
	OUTT_TREE,
	OUTT_LINT
};

d101 4
a104 3
static	int		  file(struct buf *, struct buf *, 
				const char *, 
				struct man *, struct mdoc *);
d106 5
a110 2
				const char *, int, 
				struct man *, struct mdoc *);
d118 1
a118 5
	int		 c, rc, fflags, pflags;
	struct mdoc_cb	 mdoccb;
	struct man_cb	 mancb;
	struct man	*man;
	struct mdoc	*mdoc;
a120 1
	enum intt	 inttype;
a125 1
	fflags = 0;
a126 1
	inttype = INTT_MDOC;
d130 2
d136 1
a136 1
			if ( ! foptions(&fflags, optarg))
d140 1
a140 1
			if ( ! moptions(&inttype, optarg))
a186 12
	/*
	 * All callbacks route into here, where we print them onto the
	 * screen.  XXX - for now, no path for debugging messages.
	 */

	mdoccb.mdoc_msg = NULL;
	mdoccb.mdoc_err = merr;
	mdoccb.mdoc_warn = mdocwarn;

	mancb.man_err = merr;
	mancb.man_warn = manwarn;

a191 29
	man = NULL;
	mdoc = NULL;
	pflags = 0;

	/*
	 * Allocate the parser.  There are two kinds of parser: libman
	 * and libmdoc.  We must separately copy over the flags that
	 * we'll use internally.
	 */

	switch (inttype) {
	case (INTT_MAN):
		if (fflags & IGN_MACRO)
			pflags |= MAN_IGN_MACRO;
		man = man_alloc(&curp, pflags, &mancb);
		break;
	default:
		if (fflags & IGN_SCOPE)
			pflags |= MDOC_IGN_SCOPE;
		if (fflags & IGN_ESCAPE)
			pflags |= MDOC_IGN_ESCAPE;
		if (fflags & IGN_MACRO)
			pflags |= MDOC_IGN_MACRO;
		mdoc = mdoc_alloc(&curp, pflags, &mdoccb);
		if (NULL == mdoc)
			errx(1, "memory exhausted");
		break;
	}

a196 1
		curp.file = "<stdin>";
d198 1
a198 1
		c = fdesc(&blk, &ln, "stdin", STDIN_FILENO, man, mdoc);
d202 2
a203 2
		else if (c && outrun && (*outrun)(outdata, man, mdoc))
			rc = 1;
d206 1
a206 2
			curp.file = *argv;
			c = file(&blk, &ln, *argv, man, mdoc);
d209 5
a213 5
			if (outrun && ! (*outrun)(outdata, man, mdoc))
				break;
			if (man)
				man_reset(man);
			if (mdoc && ! mdoc_reset(mdoc)) {
d228 4
a231 4
	if (mdoc)
		mdoc_free(mdoc);
	if (man)
		man_free(man);
d257 59
d317 2
a318 2
file(struct buf *blk, struct buf *ln, const char *file, 
		struct man *man, struct mdoc *mdoc)
d320 1
a320 1
	int		 fd, c;
d322 3
a324 2
	if (-1 == (fd = open(file, O_RDONLY, 0))) {
		warn("%s", file);
d328 1
a328 1
	c = fdesc(blk, ln, file, fd, man, mdoc);
d330 2
a331 2
	if (-1 == close(fd))
		warn("%s", file);
d338 1
a338 3
fdesc(struct buf *blk, struct buf *ln,
		const char *f, int fd, 
		struct man *man, struct mdoc *mdoc)
d344 2
d347 3
a349 1
	assert( ! (man && mdoc));
d352 2
a353 2
	 * Two buffers: ln and buf.  buf is the input buffer, optimised
	 * for each file's block size.  ln is a line buffer.  Both
d357 2
a358 4
	sz = BUFSIZ;

	if (-1 == fstat(fd, &st))
		warnx("%s", f);
d364 4
a367 2
		if (NULL == blk->buf)
			err(1, "realloc");
d371 1
a371 3
	/*
	 * Fill buf with file blocksize and parse newlines into ln.
	 */
d373 3
a375 3
	for (lnn = 1, pos = 0; ; ) {
		if (-1 == (ssz = read(fd, blk->buf, sz))) {
			warn("%s", f);
d380 2
d386 4
a389 2
				if (NULL == ln->buf)
					err(1, "realloc");
d412 11
a422 1
			if (mdoc && ! mdoc_parseln(mdoc, lnn, ln->buf))
d424 3
d429 2
a430 2
			lnn++;
			pos = 0;
d434 2
d438 23
d462 32
a493 1
	return(man_endparse(man));
d503 2
@


1.17
log
@All macro-invocations, for consistency, begin with `.' in documentation.
Fixed \\ -> \e in manual documentation.
All preliminary -man macros in place.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.16 2009/03/25 21:46:24 kristaps Exp $ */
d223 2
d251 4
a254 2
			if (mdoc)
				mdoc_reset(mdoc);
d280 1
a280 2
	exit(0);
	/* NOTREACHED */
d291 1
a291 2
	exit(1);
	/* NOTREACHED */
@


1.16
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.15 2009/03/25 21:03:13 kristaps Exp $ */
d404 1
a404 1
	if (0 == strcmp(arg, "mdoc"))
d406 1
a406 1
	else if (0 == strcmp(arg, "man"))
@


1.15
log
@Added pflags to man_alloc.
Abstract fflags -> pflags in main.c.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.14 2009/03/25 15:17:49 kristaps Exp $ */
d32 2
d59 3
a61 3
#define	IGN_SCOPE	 (1 << 0) /* Flag to ignore scope. */
#define	IGN_ESCAPE	 (1 << 1) /* Flag to ignore bad escapes. */
#define	IGN_MACRO	 (1 << 2) /* Flag to ignore unknown macros. */
a69 2
	OUTT_LATIN1,
	OUTT_UTF8,
a80 2
extern	void		 *latin1_alloc(void);
extern	void		 *utf8_alloc(void);
a100 1

d158 4
a161 4
	 * Allocate the appropriate front-end.  Note that utf8, ascii
	 * and latin1 all resolve to the terminal front-end with
	 * different encodings (see terminal.c).  Not all frontends have
	 * cleanup or alloc routines.
a164 10
	case (OUTT_LATIN1):
		outdata = latin1_alloc();
		outrun = terminal_run;
		outfree = terminal_free;
		break;
	case (OUTT_UTF8):
		outdata = utf8_alloc();
		outrun = terminal_run;
		outfree = terminal_free;
		break;
d194 2
d203 6
a212 1

a221 1

d227 1
a227 1
	 * Loop around available files.
d233 1
a233 2
		c = fdesc(&blk, &ln, "stdin", 
				STDIN_FILENO, man, mdoc);
a250 1

a422 4
	else if (0 == strcmp(arg, "latin1"))
		*tflags = OUTT_LATIN1;
	else if (0 == strcmp(arg, "utf8"))
		*tflags = OUTT_UTF8;
@


1.14
log
@Added man validator, renamed mdoc validator.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.13 2009/03/23 21:20:24 kristaps Exp $ */
d57 4
d111 1
a111 1
	int		 c, rc, fflags;
d212 1
d216 4
a219 1
		man = man_alloc(&curp, &mancb);
d222 8
a229 1
		mdoc = mdoc_alloc(&curp, fflags, &mdoccb);
d467 1
a467 1
			*fflags |= MDOC_IGN_SCOPE;
d470 1
a470 1
			*fflags |= MDOC_IGN_ESCAPE;
d473 1
a473 1
			*fflags |= MDOC_IGN_MACRO;
@


1.13
log
@Fixed inclusion of MANSRCS (sorry, Ulrich).
Added DragonFlyBSD __dead2.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.12 2009/03/23 15:41:09 kristaps Exp $ */
d90 2
a91 1
static	int		  mwarn(void *, int, int, 
d108 2
a109 1
	struct mdoc_cb	 cb;
d196 6
a201 3
	cb.mdoc_msg = NULL;
	cb.mdoc_err = merr;
	cb.mdoc_warn = mwarn;
d211 1
a211 1
		man = man_alloc();
d214 1
a214 1
		mdoc = mdoc_alloc(&curp, fflags, &cb);
d523 1
a523 1
mwarn(void *arg, int line, int col, 
d558 20
@


1.12
log
@-man linked to mandoc in documentation.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.11 2009/03/23 15:20:51 kristaps Exp $ */
d37 1
a37 1
#elif defined(__FreeBSD__)
@


1.11
log
@-man printing linked to -Ttree.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.10 2009/03/23 14:22:11 kristaps Exp $ */
d274 3
a276 1
	(void)fprintf(stderr, "usage: %s\n", __progname);
@


1.10
log
@First addition of -man macro support.
Abstraction of mdoc.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.9 2009/03/22 19:10:48 kristaps Exp $ */
d70 2
a71 1
typedef	int		(*out_run)(void *, const struct mdoc *);
d79 4
a82 2
extern	int		  terminal_run(void *, const struct mdoc *);
extern	int		  tree_run(void *, const struct mdoc *);
d225 1
a225 2
#if 0
		else if (c && outrun && (*outrun)(outdata, mdoc))
a226 1
#endif
d233 1
a233 2
#if 0
			if (outrun && ! (*outrun)(outdata, mdoc))
a234 1
#endif
@


1.9
log
@Lint fixes.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.8 2009/03/22 19:01:11 kristaps Exp $ */
d30 1
d37 4
d57 7
a63 2
enum outt {
	OUTT_ASCII,
a81 2
__dead	static void	  version(void);
__dead	static void	  usage(void);
d84 1
d89 3
a91 2
static	int		  file(struct buf *, struct buf *,
				const char *, struct mdoc *);
d93 5
a97 1
				const char *, int, struct mdoc *);
d105 1
d109 1
d117 1
d122 1
a122 1
	while (-1 != (c = getopt(argc, argv, "f:VW:T:")))
d128 4
d198 11
a208 1
	mdoc = mdoc_alloc(&curp, fflags, &cb);
a215 1
		c = fdesc(&blk, &ln, "stdin", STDIN_FILENO, mdoc);
d217 3
d222 1
d225 1
d229 1
a229 1
			c = file(&blk, &ln, *argv, mdoc);
d232 1
d235 6
a240 2
			/* Reset the parser for another file. */
			mdoc_reset(mdoc);
d252 4
a255 2

	mdoc_free(mdoc);
d282 2
a283 2
file(struct buf *blk, struct buf *ln,
		const char *file, struct mdoc *mdoc)
d292 1
a292 1
	c = fdesc(blk, ln, file, fd, mdoc);
d303 2
a304 1
		const char *f, int fd, struct mdoc *mdoc)
d310 2
a311 3
#ifdef	STRIP_XO
	int		 macro, xo, xeoln;
#endif
a335 3
#ifdef	STRIP_XO
	macro = xo = xeoln = 0;
#endif
a352 60
				/*
				 * Ugly of uglies.  Here we handle the
				 * dreaded `Xo/Xc' scoping.  Cover the
				 * eyes of any nearby children.  This
				 * makes `Xo/Xc' enclosures look like
				 * one huge line.
				 */
#ifdef	STRIP_XO
				/*
				 * First, note whether we're in a macro
				 * line.
				 */
				if (0 == pos && '.' == blk->buf[i])
					macro = 1;

				/*
				 * If we're in an `Xo' context and just
				 * nixed a newline, remove the control
				 * character for new macro lines:
				 * they're going to show up as all part
				 * of the same line.
				 */
				if (xo && xeoln && '.' == blk->buf[i]) {
					xeoln = 0;
					continue;
				}
				xeoln = 0;

				/*
				 * If we've parsed `Xo', enter an xo
				 * context.  `Xo' must be in a parsable
				 * state.  This is the ugly part.  IT IS
				 * NOT SMART ENOUGH TO HANDLE ESCAPED
				 * WHITESPACE.
				 */
				if (macro && pos && 'o' == blk->buf[i]) {
					if (xo && 'X' == ln->buf[pos - 1])  {
						if (' ' == ln->buf[pos - 2])
							xo++;
					} else if ('X' == ln->buf[pos - 1]) {
						if (2 == pos && '.' == ln->buf[pos - 2])
							xo++;
						else if (' ' == ln->buf[pos - 2])
							xo++;
					}
				}

				/*
				 * If we're parsed `Xc', leave an xo
				 * context if one's already pending.
				 * `Xc' must be in a parsable state.
				 * THIS IS NOT SMART ENOUGH TO HANDLE
				 * ESCAPED WHITESPACE.
				 */
				if (macro && pos && 'c' == blk->buf[i])
					if (xo && 'X' == ln->buf[pos - 1])
						if (' ' == ln->buf[pos - 2])
							xo--;
#endif	/* STRIP_XO */

a370 15
#ifdef	STRIP_XO
			/*
			 * If we're in an xo context, put a space in
			 * place of the newline and continue parsing.
			 * Mark that we just did a newline.
			 */
			if (xo) {
				xeoln = 1;
				ln->buf[pos++] = ' ';
				lnn++;
				continue;
			}
			macro = 0;
#endif	/* STRIP_XO */

d372 3
a374 1
			if ( ! mdoc_parseln(mdoc, lnn, ln->buf))
d381 21
a401 1
	return(mdoc_endparse(mdoc));
@


1.8
log
@Stripping of Xo/Xc macros in main.c (ifdef STRIP_XO).
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.7 2009/03/20 21:58:38 kristaps Exp $ */
d404 1
d411 1
a411 1
			macro = pos = 0;
@


1.7
log
@Lintification.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.6 2009/03/20 21:29:29 kristaps Exp $ */
d267 3
d294 3
d314 60
d392 14
d410 1
a410 1
			pos = 0;
@


1.6
log
@Casting fix.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.5 2009/03/20 19:56:25 kristaps Exp $ */
d89 1
a89 1
	int		 c, rc, fflags, wflags;
d99 1
a99 1
	fflags = wflags = 0;
@


1.5
log
@Proper .Dl literalism.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.4 2009/03/19 18:30:26 kristaps Exp $ */
d274 3
a276 1
	if (-1 == fstat(fd, &st)) {
d278 2
a279 4
		sz = BUFSIZ;
	} else 
		sz = (unsigned)BUFSIZ > st.st_blksize ?
			(size_t)BUFSIZ : st.st_blksize;
@


1.4
log
@Fixed mandoc read from stdin.
Added some more groff_chars.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.3 2009/03/19 16:40:49 kristaps Exp $ */
d38 8
d50 1
d80 1
a80 1
static	int		  file(char **, size_t *, char **, size_t *, 
d82 1
a82 1
static	int		  fdesc(char **, size_t *, char **, size_t *, 
a91 2
	char		*buf, *line;
	size_t		 bufsz, linesz;
d94 1
d97 1
d102 2
d116 1
a116 1
			if ( ! woptions(&wflags, optarg))
d174 2
a175 2
	buf = line = NULL;
	bufsz = linesz = 0;
d177 1
a177 1
	mdoc = mdoc_alloc(&wflags, fflags, &cb);
d184 2
a185 2
		c = fdesc(&line, &linesz, &buf, &bufsz, 
				"stdin", STDIN_FILENO, mdoc);
d193 2
a194 2
			c = file(&line, &linesz, &buf, 
					&bufsz, *argv, mdoc);
d206 4
a209 4
	if (buf)
		free(buf);
	if (line)
		free(line);
d240 1
a240 1
file(char **ln, size_t *lnsz, char **buf, size_t *bufsz, 
d250 1
a250 1
	c = fdesc(ln, lnsz, buf, bufsz, file, fd, mdoc);
d260 1
a260 1
fdesc(char **lnp, size_t *lnsz, char **bufp, size_t *bufsz, 
a266 4
	char		*ln, *buf;

	buf = *bufp;
	ln = *lnp;
d281 3
a283 2
	if (sz > *bufsz) {
		if (NULL == (buf = realloc(buf, sz)))
d285 1
a285 2
		*bufp = buf;
		*bufsz = sz;
d293 1
a293 1
		if (-1 == (ssz = read(fd, buf, sz))) {
d300 4
a303 4
			if (pos >= (int)*lnsz) {
				*lnsz += 256; /* Step-size. */
				ln = realloc(ln, *lnsz);
				if (NULL == ln)
a304 1
				*lnp = ln;
d307 2
a308 2
			if ('\n' != buf[i]) {
				ln[pos++] = buf[i];
d314 1
a314 1
			if (pos > 0 && '\\' == ln[pos - 1]) {
d316 1
a316 1
					if ('\\' != ln[j])
d326 2
a327 2
			ln[pos] = 0;
			if ( ! mdoc_parseln(mdoc, lnn, ln))
d439 3
d443 2
a444 1
	warnx("error: %s (line %d, column %d)", msg, line, col);
d453 1
a453 1
	int		 flags;
d456 1
a456 1
	flags = *(int *)arg;
d462 1
a462 1
		if (flags & WARN_WCOMPAT)
d467 1
a467 1
		if (flags & WARN_WSYNTAX)
d473 2
a474 2
	warnx("%s warning: %s (line %d, column %d)", 
			wtype, msg, line, col);
d476 1
a476 1
	if ( ! (flags & WARN_WERR))
@


1.3
log
@Some Linux-isms.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.2 2009/03/19 16:18:36 kristaps Exp $ */
d168 3
a170 5
	while (*argv) {
		if ( ! file(&line, &linesz, &buf, &bufsz, *argv, mdoc))
			break;
		if (outrun && ! (*outrun)(outdata, mdoc))
			break;
d172 21
a192 3
		/* Reset the parser for another file. */
		mdoc_reset(mdoc);
		argv++;
a194 2
	rc = NULL == *argv;

@


1.2
log
@Lintified & versioned.
@
text
@d1 1
a1 1
/* $Id: main.c,v 1.1 2009/03/19 16:17:27 kristaps Exp $ */
d31 7
@


1.1
log
@Split mdocterm.c -> main.c terminal.c.
Abstracted output with -T selector (default ascii).
Name change: mdocterm -> mandoc.
Re-imported tree with -Ttree.
@
text
@d1 1
a1 1
/* $Id: mdocterm.c,v 1.49 2009/03/19 11:49:00 kristaps Exp $ */
d408 1
@
