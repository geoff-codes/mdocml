head	1.8;
access;
symbols
	VERSION_1_13_3:1.8
	VERSION_1_13_2:1.7
	VERSION_1_12_4:1.6
	VERSION_1_13_1:1.5
	VERSION_1_12_3:1.4
	VERSION_1_12_2:1.4
	VERSION_1_12:1.6.0.2
	VERSION_1_12_1:1.4
	VERSION_1_12_0:1.4
	VERSION_1_11_7:1.4
	VERSION_1_11_6:1.4
	VERSION_1_11_5:1.4;
locks; strict;
comment	@ * @;


1.8
date	2015.01.01.15.36.08;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2014.10.12.14.49.39;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2014.04.20.16.46.04;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.24.10.09.03;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.23.22.57.13;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.23.12.01.54;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.22.10.50.46;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Don't dereference NULL pointers when formatting missing denominators,
subscripts, superscripts, or "from" or "to" arguments.
Found by jsg@@ with afl.
@
text
@/*	$Id: eqn_term.c,v 1.7 2014/10/12 14:49:39 schwarze Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "out.h"
#include "term.h"

static	const enum termfont fontmap[EQNFONT__MAX] = {
	TERMFONT_NONE, /* EQNFONT_NONE */
	TERMFONT_NONE, /* EQNFONT_ROMAN */
	TERMFONT_BOLD, /* EQNFONT_BOLD */
	TERMFONT_BOLD, /* EQNFONT_FAT */
	TERMFONT_UNDER /* EQNFONT_ITALIC */
};

static void	eqn_box(struct termp *, const struct eqn_box *);


void
term_eqn(struct termp *p, const struct eqn *ep)
{

	eqn_box(p, ep->root);
	p->flags &= ~TERMP_NOSPACE;
}

static void
eqn_box(struct termp *p, const struct eqn_box *bp)
{
	const struct eqn_box *child;

	if (bp->type == EQN_LIST ||
	    (bp->type == EQN_PILE && (bp->prev || bp->next)) ||
	    (bp->parent != NULL && bp->parent->pos == EQNPOS_SQRT)) {
		if (bp->parent->type == EQN_SUBEXPR && bp->prev != NULL)
			p->flags |= TERMP_NOSPACE;
		term_word(p, bp->left != NULL ? bp->left : "(");
		p->flags |= TERMP_NOSPACE;
	}
	if (bp->font != EQNFONT_NONE)
		term_fontpush(p, fontmap[(int)bp->font]);

	if (bp->text != NULL)
		term_word(p, bp->text);

	if (bp->pos == EQNPOS_SQRT) {
		term_word(p, "sqrt");
		p->flags |= TERMP_NOSPACE;
		eqn_box(p, bp->first);
	} else if (bp->type == EQN_SUBEXPR) {
		child = bp->first;
		eqn_box(p, child);
		p->flags |= TERMP_NOSPACE;
		term_word(p, bp->pos == EQNPOS_OVER ? "/" :
		    (bp->pos == EQNPOS_SUP ||
		     bp->pos == EQNPOS_TO) ? "^" : "_");
		p->flags |= TERMP_NOSPACE;
		child = child->next;
		if (child != NULL) {
			eqn_box(p, child);
			if (bp->pos == EQNPOS_FROMTO ||
			    bp->pos == EQNPOS_SUBSUP) {
				p->flags |= TERMP_NOSPACE;
				term_word(p, "^");
				p->flags |= TERMP_NOSPACE;
				child = child->next;
				if (child != NULL)
					eqn_box(p, child);
			}
		}
	} else {
		child = bp->first;
		if (bp->type == EQN_MATRIX && child->type == EQN_LIST)
			child = child->first;
		while (child != NULL) {
			eqn_box(p,
			    bp->type == EQN_PILE &&
			    child->type == EQN_LIST &&
			    child->args == 1 ?
			    child->first : child);
			child = child->next;
		}
	}

	if (bp->font != EQNFONT_NONE)
		term_fontpop(p);
	if (bp->type == EQN_LIST ||
	    (bp->type == EQN_PILE && (bp->prev || bp->next)) ||
	    (bp->parent != NULL && bp->parent->pos == EQNPOS_SQRT)) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, bp->right != NULL ? bp->right : ")");
		if (bp->parent->type == EQN_SUBEXPR && bp->next != NULL)
			p->flags |= TERMP_NOSPACE;
	}

	if (bp->top != NULL) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, bp->top);
	}
	if (bp->bottom != NULL) {
		p->flags |= TERMP_NOSPACE;
		term_word(p, "_");
	}
}
@


1.7
log
@major upgrade to eqn(7) terminal output;
column vectors ("piles") and matrices are not yet pretty,
but everything else is now more or less readable
@
text
@d1 1
a1 1
/*	$Id: eqn_term.c,v 1.6 2014/08/10 23:54:41 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
d82 1
a82 7
		eqn_box(p, child);
		if (bp->pos == EQNPOS_FROMTO ||
		    bp->pos == EQNPOS_SUBSUP) {
			p->flags |= TERMP_NOSPACE;
			term_word(p, "^");
			p->flags |= TERMP_NOSPACE;
			child = child->next;
d84 9
@


1.6
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: eqn_term.c,v 1.5 2014/04/20 16:46:04 schwarze Exp $ */
d4 1
a45 1
	p->flags |= TERMP_NONOSPACE;
d47 1
a47 2
	term_word(p, " ");
	p->flags &= ~TERMP_NONOSPACE;
d53 1
d55 9
a63 1
	if (EQNFONT_NONE != bp->font)
a64 4
	if (bp->left)
		term_word(p, bp->left);
	if (EQN_SUBEXPR == bp->type)
		term_word(p, "(");
d66 1
a66 1
	if (bp->text)
d69 3
a71 1
	if (bp->first)
d73 31
d105 1
a105 5
	if (EQN_SUBEXPR == bp->type)
		term_word(p, ")");
	if (bp->right)
		term_word(p, bp->right);
	if (EQNFONT_NONE != bp->font)
d107 17
a123 3

	if (bp->next)
		eqn_box(p, bp->next);
@


1.5
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: eqn_term.c,v 1.4 2011/07/24 10:09:03 kristaps Exp $ */
a16 1
#ifdef HAVE_CONFIG_H
d18 2
a19 1
#endif
@


1.4
log
@Tuned the initial eqn output, making it completely simple.  This
completes a full initial eqn system, so I'm tagging a release on it.
@
text
@d1 1
a1 1
/*	$Id: eqn_term.c,v 1.3 2011/07/23 22:57:13 kristaps Exp $ */
d40 1
d72 1
a72 1
	if (EQNFONT_NONE != bp->font) 
@


1.3
log
@Flip on equation printing for -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: eqn_term.c,v 1.2 2011/07/23 12:01:54 kristaps Exp $ */
d30 8
a38 3
static void	eqn_box_post(struct termp *, const struct eqn_box *);
static void	eqn_box_pre(struct termp *, const struct eqn_box *);
static void	eqn_text(struct termp *, const struct eqn_box *);
d46 1
d54 9
a62 2
	eqn_box_pre(p, bp);
	eqn_text(p, bp);
d67 6
a72 1
	eqn_box_post(p, bp);
a76 24

static void
eqn_box_pre(struct termp *p, const struct eqn_box *bp)
{

	if (bp->left)
		term_word(p, bp->left);
}

static void
eqn_box_post(struct termp *p, const struct eqn_box *bp)
{

	if (bp->right)
		term_word(p, bp->right);
}

static void
eqn_text(struct termp *p, const struct eqn_box *bp)
{

	if (bp->text)
		term_word(p, bp->text);
}
@


1.2
log
@Add matrix support.  Also remove "above" notion, as all elements in a
list are delimited by their "aboveness" and it's superfluous.
@
text
@d1 1
a1 1
/*	$Id: eqn_term.c,v 1.1 2011/07/22 10:50:46 kristaps Exp $ */
d30 4
a33 4
static void	eqn_box(struct termp *p, const struct eqn_box *);
static void	eqn_box_post(struct termp *p, const struct eqn_box *);
static void	eqn_box_pre(struct termp *p, const struct eqn_box *);
static void	eqn_text(struct termp *p, const struct eqn_box *);
@


1.1
log
@Add character output (-Tpdf, -Tps, -Tascii) for equations.  This is the
minimum: unseparated terms.
@
text
@d1 1
a1 1
/*	$Id: tbl_term.c,v 1.19 2011/01/25 12:07:30 schwarze Exp $ */
a63 2
	if (EQN_LIST == bp->type)
		term_word(p, "{");
a71 2
	if (EQN_LIST == bp->type)
		term_word(p, "}");
a73 2
	if (bp->above)
		term_word(p, "|");
@
