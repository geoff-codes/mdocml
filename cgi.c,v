head	1.115;
access;
symbols
	VERSION_1_13_3:1.104
	VERSION_1_13_2:1.102
	VERSION_1_13_1:1.92
	VERSION_1_12_3:1.46
	VERSION_1_12_2:1.45
	VERSION_1_12:1.51.0.2
	VERSION_1_12_1:1.42;
locks; strict;
comment	@ * @;


1.115
date	2015.11.07.17.58.55;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2015.11.05.20.55.41;	author schwarze;	state Exp;
branches;
next	1.113;

1.113
date	2015.11.05.17.47.51;	author schwarze;	state Exp;
branches;
next	1.112;

1.112
date	2015.10.22.22.06.43;	author schwarze;	state Exp;
branches;
next	1.111;

1.111
date	2015.10.20.02.01.31;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.109;

1.109
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.108;

1.108
date	2015.04.18.16.34.25;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2015.04.18.16.06.39;	author schwarze;	state Exp;
branches;
next	1.106;

1.106
date	2015.03.27.21.33.20;	author schwarze;	state Exp;
branches;
next	1.105;

1.105
date	2015.03.27.17.37.25;	author schwarze;	state Exp;
branches;
next	1.104;

1.104
date	2015.02.10.08.05.30;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2015.01.15.04.26.39;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2014.11.26.17.55.27;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2014.11.11.19.04.55;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2014.10.07.18.20.06;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2014.09.27.11.17.36;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2014.09.14.19.44.28;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2014.08.26.11.21.40;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2014.08.21.16.05.21;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2014.08.17.03.24.47;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2014.08.05.15.29.30;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2014.07.25.21.05.41;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2014.07.25.20.09.09;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2014.07.25.19.37.34;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2014.07.25.18.20.39;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2014.07.25.17.52.04;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2014.07.25.17.34.06;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2014.07.25.16.56.06;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2014.07.25.16.43.37;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2014.07.25.16.07.13;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2014.07.24.20.30.45;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2014.07.24.08.26.57;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2014.07.22.18.14.13;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2014.07.21.22.33.01;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2014.07.21.15.45.17;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2014.07.19.13.15.11;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2014.07.19.11.35.12;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2014.07.18.19.03.39;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2014.07.18.14.46.25;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2014.07.13.15.38.36;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2014.07.13.12.55.45;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2014.07.13.12.45.23;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2014.07.13.12.31.23;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2014.07.13.09.39.32;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2014.07.12.23.46.44;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2014.07.12.18.32.47;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2014.07.12.17.21.45;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2014.07.12.16.14.35;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2014.07.12.01.55.30;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2014.07.11.22.27.35;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2014.07.11.22.25.44;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2014.07.10.00.52.50;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2014.07.09.17.03.07;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2014.07.09.16.23.01;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2014.07.09.14.18.59;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2014.07.09.12.09.04;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2014.07.09.11.34.46;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2014.07.09.09.27.01;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2014.07.09.09.19.03;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2014.07.09.08.53.28;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2014.07.09.07.30.47;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2014.04.23.21.40.47;	author schwarze;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2014.03.23.12.19.03;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2014.03.19.22.20.43;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.19.22.05.10;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2014.01.05.20.41.04;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.11.00.06.48;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2013.06.05.02.00.26;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2012.05.27.17.48.57;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2012.03.25.00.46.39;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2012.03.24.01.46.25;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2012.03.24.00.31.55;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2012.03.23.09.03.07;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2011.12.25.17.49.52;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.16.20.06.58;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.16.20.05.31;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.16.18.37.12;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2011.12.16.12.06.35;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.16.08.04.34;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.15.12.18.57;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.15.12.05.19;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.14.13.36.59;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.12.02.00.49;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.11.00.22.47;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.10.23.09.25;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2011.12.10.23.04.31;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2011.12.10.22.45.47;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.10.22.20.59;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.10.21.51.07;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.10.10.59.21;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.10.00.06.34;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.09.23.18.51;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.09.11.29.19;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.08.22.47.09;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.08.18.39.14;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.08.00.48.28;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.07.16.18.52;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2011.12.07.16.08.55;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2011.12.07.15.55.06;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2011.12.07.15.12.34;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.07.13.00.40;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.07.11.52.36;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.07.00.23.04;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.04.22.52.50;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.27.11.46.44;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.24.12.27.18;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2011.11.23.10.01.04;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.11.20.12.39.08;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.11.13.10.49.57;	author schwarze;	state Exp;
branches;
next	1.3;

1.3
date	2011.11.13.10.12.05;	author schwarze;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.09.22.05.56;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.09.01.24.23;	author kristaps;	state Exp;
branches;
next	;

1.51.2.1
date	2014.08.05.00.42.53;	author schwarze;	state dead;
branches;
next	;


desc
@@


1.115
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
Remove the related compatibility code.
@
text
@/*	$Id: cgi.c,v 1.114 2015/11/05 20:55:41 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@usta.de>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>
#include <sys/time.h>

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <limits.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "main.h"
#include "manconf.h"
#include "mansearch.h"
#include "cgi.h"

/*
 * A query as passed to the search function.
 */
struct	query {
	char		*manpath; /* desired manual directory */
	char		*arch; /* architecture */
	char		*sec; /* manual section */
	char		*query; /* unparsed query expression */
	int		 equal; /* match whole names, not substrings */
};

struct	req {
	struct query	  q;
	char		**p; /* array of available manpaths */
	size_t		  psz; /* number of available manpaths */
};

static	void		 catman(const struct req *, const char *);
static	void		 format(const struct req *, const char *);
static	void		 html_print(const char *);
static	void		 html_putchar(char);
static	int		 http_decode(char *);
static	void		 http_parse(struct req *, const char *);
static	void		 http_print(const char *);
static	void		 http_putchar(char);
static	void		 http_printquery(const struct req *, const char *);
static	void		 pathgen(struct req *);
static	void		 pg_error_badrequest(const char *);
static	void		 pg_error_internal(void);
static	void		 pg_index(const struct req *);
static	void		 pg_noresult(const struct req *, const char *);
static	void		 pg_search(const struct req *);
static	void		 pg_searchres(const struct req *,
				struct manpage *, size_t);
static	void		 pg_show(struct req *, const char *);
static	void		 resp_begin_html(int, const char *);
static	void		 resp_begin_http(int, const char *);
static	void		 resp_copy(const char *);
static	void		 resp_end_html(void);
static	void		 resp_searchform(const struct req *);
static	void		 resp_show(const struct req *, const char *);
static	void		 set_query_attr(char **, char **);
static	int		 validate_filename(const char *);
static	int		 validate_manpath(const struct req *, const char *);
static	int		 validate_urifrag(const char *);

static	const char	 *scriptname; /* CGI script name */

static	const int sec_prios[] = {1, 4, 5, 8, 6, 3, 7, 2, 9};
static	const char *const sec_numbers[] = {
    "0", "1", "2", "3", "3p", "4", "5", "6", "7", "8", "9"
};
static	const char *const sec_names[] = {
    "All Sections",
    "1 - General Commands",
    "2 - System Calls",
    "3 - Library Functions",
    "3p - Perl Library",
    "4 - Device Drivers",
    "5 - File Formats",
    "6 - Games",
    "7 - Miscellaneous Information",
    "8 - System Manager\'s Manual",
    "9 - Kernel Developer\'s Manual"
};
static	const int sec_MAX = sizeof(sec_names) / sizeof(char *);

static	const char *const arch_names[] = {
    "amd64",       "alpha",       "armish",      "armv7",
    "aviion",      "hppa",        "hppa64",      "i386",
    "ia64",        "landisk",     "loongson",    "luna88k",
    "macppc",      "mips64",      "octeon",      "sgi",
    "socppc",      "solbourne",   "sparc",       "sparc64",
    "vax",         "zaurus",
    "amiga",       "arc",         "arm32",       "atari",
    "beagle",      "cats",        "hp300",       "mac68k",
    "mvme68k",     "mvme88k",     "mvmeppc",     "palm",
    "pc532",       "pegasos",     "pmax",        "powerpc",
    "sun3",        "wgrisc",      "x68k"
};
static	const int arch_MAX = sizeof(arch_names) / sizeof(char *);

/*
 * Print a character, escaping HTML along the way.
 * This will pass non-ASCII straight to output: be warned!
 */
static void
html_putchar(char c)
{

	switch (c) {
	case ('"'):
		printf("&quote;");
		break;
	case ('&'):
		printf("&amp;");
		break;
	case ('>'):
		printf("&gt;");
		break;
	case ('<'):
		printf("&lt;");
		break;
	default:
		putchar((unsigned char)c);
		break;
	}
}

static void
http_printquery(const struct req *req, const char *sep)
{

	if (NULL != req->q.query) {
		printf("query=");
		http_print(req->q.query);
	}
	if (0 == req->q.equal)
		printf("%sapropos=1", sep);
	if (NULL != req->q.sec) {
		printf("%ssec=", sep);
		http_print(req->q.sec);
	}
	if (NULL != req->q.arch) {
		printf("%sarch=", sep);
		http_print(req->q.arch);
	}
	if (strcmp(req->q.manpath, req->p[0])) {
		printf("%smanpath=", sep);
		http_print(req->q.manpath);
	}
}

static void
http_print(const char *p)
{

	if (NULL == p)
		return;
	while ('\0' != *p)
		http_putchar(*p++);
}

/*
 * Call through to html_putchar().
 * Accepts NULL strings.
 */
static void
html_print(const char *p)
{

	if (NULL == p)
		return;
	while ('\0' != *p)
		html_putchar(*p++);
}

/*
 * Transfer the responsibility for the allocated string *val
 * to the query structure.
 */
static void
set_query_attr(char **attr, char **val)
{

	free(*attr);
	if (**val == '\0') {
		*attr = NULL;
		free(*val);
	} else
		*attr = *val;
	*val = NULL;
}

/*
 * Parse the QUERY_STRING for key-value pairs
 * and store the values into the query structure.
 */
static void
http_parse(struct req *req, const char *qs)
{
	char		*key, *val;
	size_t		 keysz, valsz;

	req->q.manpath	= NULL;
	req->q.arch	= NULL;
	req->q.sec	= NULL;
	req->q.query	= NULL;
	req->q.equal	= 1;

	key = val = NULL;
	while (*qs != '\0') {

		/* Parse one key. */

		keysz = strcspn(qs, "=;&");
		key = mandoc_strndup(qs, keysz);
		qs += keysz;
		if (*qs != '=')
			goto next;

		/* Parse one value. */

		valsz = strcspn(++qs, ";&");
		val = mandoc_strndup(qs, valsz);
		qs += valsz;

		/* Decode and catch encoding errors. */

		if ( ! (http_decode(key) && http_decode(val)))
			goto next;

		/* Handle key-value pairs. */

		if ( ! strcmp(key, "query"))
			set_query_attr(&req->q.query, &val);

		else if ( ! strcmp(key, "apropos"))
			req->q.equal = !strcmp(val, "0");

		else if ( ! strcmp(key, "manpath")) {
#ifdef COMPAT_OLDURI
			if ( ! strncmp(val, "OpenBSD ", 8)) {
				val[7] = '-';
				if ('C' == val[8])
					val[8] = 'c';
			}
#endif
			set_query_attr(&req->q.manpath, &val);
		}

		else if ( ! (strcmp(key, "sec")
#ifdef COMPAT_OLDURI
		    && strcmp(key, "sektion")
#endif
		    )) {
			if ( ! strcmp(val, "0"))
				*val = '\0';
			set_query_attr(&req->q.sec, &val);
		}

		else if ( ! strcmp(key, "arch")) {
			if ( ! strcmp(val, "default"))
				*val = '\0';
			set_query_attr(&req->q.arch, &val);
		}

		/*
		 * The key must be freed in any case.
		 * The val may have been handed over to the query
		 * structure, in which case it is now NULL.
		 */
next:
		free(key);
		key = NULL;
		free(val);
		val = NULL;

		if (*qs != '\0')
			qs++;
	}
}

static void
http_putchar(char c)
{

	if (isalnum((unsigned char)c)) {
		putchar((unsigned char)c);
		return;
	} else if (' ' == c) {
		putchar('+');
		return;
	}
	printf("%%%.2x", c);
}

/*
 * HTTP-decode a string.  The standard explanation is that this turns
 * "%4e+foo" into "n foo" in the regular way.  This is done in-place
 * over the allocated string.
 */
static int
http_decode(char *p)
{
	char             hex[3];
	char		*q;
	int              c;

	hex[2] = '\0';

	q = p;
	for ( ; '\0' != *p; p++, q++) {
		if ('%' == *p) {
			if ('\0' == (hex[0] = *(p + 1)))
				return 0;
			if ('\0' == (hex[1] = *(p + 2)))
				return 0;
			if (1 != sscanf(hex, "%x", &c))
				return 0;
			if ('\0' == c)
				return 0;

			*q = (char)c;
			p += 2;
		} else
			*q = '+' == *p ? ' ' : *p;
	}

	*q = '\0';
	return 1;
}

static void
resp_begin_http(int code, const char *msg)
{

	if (200 != code)
		printf("Status: %d %s\r\n", code, msg);

	printf("Content-Type: text/html; charset=utf-8\r\n"
	     "Cache-Control: no-cache\r\n"
	     "Pragma: no-cache\r\n"
	     "\r\n");

	fflush(stdout);
}

static void
resp_copy(const char *filename)
{
	char	 buf[4096];
	ssize_t	 sz;
	int	 fd;

	if ((fd = open(filename, O_RDONLY)) != -1) {
		fflush(stdout);
		while ((sz = read(fd, buf, sizeof(buf))) > 0)
			write(STDOUT_FILENO, buf, sz);
	}
}

static void
resp_begin_html(int code, const char *msg)
{

	resp_begin_http(code, msg);

	printf("<!DOCTYPE html>\n"
	       "<HTML>\n"
	       "<HEAD>\n"
	       "<META CHARSET=\"UTF-8\" />\n"
	       "<LINK REL=\"stylesheet\" HREF=\"%s/mandoc.css\""
	       " TYPE=\"text/css\" media=\"all\">\n"
	       "<TITLE>%s</TITLE>\n"
	       "</HEAD>\n"
	       "<BODY>\n"
	       "<!-- Begin page content. //-->\n",
	       CSS_DIR, CUSTOMIZE_TITLE);

	resp_copy(MAN_DIR "/header.html");
}

static void
resp_end_html(void)
{

	resp_copy(MAN_DIR "/footer.html");

	puts("</BODY>\n"
	     "</HTML>");
}

static void
resp_searchform(const struct req *req)
{
	int		 i;

	puts("<!-- Begin search form. //-->");
	printf("<DIV ID=\"mancgi\">\n"
	       "<FORM ACTION=\"%s\" METHOD=\"get\">\n"
	       "<FIELDSET>\n"
	       "<LEGEND>Manual Page Search Parameters</LEGEND>\n",
	       scriptname);

	/* Write query input box. */

	printf(	"<TABLE><TR><TD>\n"
		"<INPUT TYPE=\"text\" NAME=\"query\" VALUE=\"");
	if (NULL != req->q.query)
		html_print(req->q.query);
	puts("\" SIZE=\"40\">");

	/* Write submission and reset buttons. */

	printf(	"<INPUT TYPE=\"submit\" VALUE=\"Submit\">\n"
		"<INPUT TYPE=\"reset\" VALUE=\"Reset\">\n");

	/* Write show radio button */

	printf(	"</TD><TD>\n"
		"<INPUT TYPE=\"radio\" ");
	if (req->q.equal)
		printf("CHECKED=\"checked\" ");
	printf(	"NAME=\"apropos\" ID=\"show\" VALUE=\"0\">\n"
		"<LABEL FOR=\"show\">Show named manual page</LABEL>\n");

	/* Write section selector. */

	puts(	"</TD></TR><TR><TD>\n"
		"<SELECT NAME=\"sec\">");
	for (i = 0; i < sec_MAX; i++) {
		printf("<OPTION VALUE=\"%s\"", sec_numbers[i]);
		if (NULL != req->q.sec &&
		    0 == strcmp(sec_numbers[i], req->q.sec))
			printf(" SELECTED=\"selected\"");
		printf(">%s</OPTION>\n", sec_names[i]);
	}
	puts("</SELECT>");

	/* Write architecture selector. */

	printf(	"<SELECT NAME=\"arch\">\n"
		"<OPTION VALUE=\"default\"");
	if (NULL == req->q.arch)
		printf(" SELECTED=\"selected\"");
	puts(">All Architectures</OPTION>");
	for (i = 0; i < arch_MAX; i++) {
		printf("<OPTION VALUE=\"%s\"", arch_names[i]);
		if (NULL != req->q.arch &&
		    0 == strcmp(arch_names[i], req->q.arch))
			printf(" SELECTED=\"selected\"");
		printf(">%s</OPTION>\n", arch_names[i]);
	}
	puts("</SELECT>");

	/* Write manpath selector. */

	if (req->psz > 1) {
		puts("<SELECT NAME=\"manpath\">");
		for (i = 0; i < (int)req->psz; i++) {
			printf("<OPTION ");
			if (strcmp(req->q.manpath, req->p[i]) == 0)
				printf("SELECTED=\"selected\" ");
			printf("VALUE=\"");
			html_print(req->p[i]);
			printf("\">");
			html_print(req->p[i]);
			puts("</OPTION>");
		}
		puts("</SELECT>");
	}

	/* Write search radio button */

	printf(	"</TD><TD>\n"
		"<INPUT TYPE=\"radio\" ");
	if (0 == req->q.equal)
		printf("CHECKED=\"checked\" ");
	printf(	"NAME=\"apropos\" ID=\"search\" VALUE=\"1\">\n"
		"<LABEL FOR=\"search\">Search with apropos query</LABEL>\n");

	puts("</TD></TR></TABLE>\n"
	     "</FIELDSET>\n"
	     "</FORM>\n"
	     "</DIV>");
	puts("<!-- End search form. //-->");
}

static int
validate_urifrag(const char *frag)
{

	while ('\0' != *frag) {
		if ( ! (isalnum((unsigned char)*frag) ||
		    '-' == *frag || '.' == *frag ||
		    '/' == *frag || '_' == *frag))
			return 0;
		frag++;
	}
	return 1;
}

static int
validate_manpath(const struct req *req, const char* manpath)
{
	size_t	 i;

	if ( ! strcmp(manpath, "mandoc"))
		return 1;

	for (i = 0; i < req->psz; i++)
		if ( ! strcmp(manpath, req->p[i]))
			return 1;

	return 0;
}

static int
validate_filename(const char *file)
{

	if ('.' == file[0] && '/' == file[1])
		file += 2;

	return ! (strstr(file, "../") || strstr(file, "/..") ||
	    (strncmp(file, "man", 3) && strncmp(file, "cat", 3)));
}

static void
pg_index(const struct req *req)
{

	resp_begin_html(200, NULL);
	resp_searchform(req);
	printf("<P>\n"
	       "This web interface is documented in the\n"
	       "<A HREF=\"%s/mandoc/man8/man.cgi.8\">man.cgi</A>\n"
	       "manual, and the\n"
	       "<A HREF=\"%s/mandoc/man1/apropos.1\">apropos</A>\n"
	       "manual explains the query syntax.\n"
	       "</P>\n",
	       scriptname, scriptname);
	resp_end_html();
}

static void
pg_noresult(const struct req *req, const char *msg)
{
	resp_begin_html(200, NULL);
	resp_searchform(req);
	puts("<P>");
	puts(msg);
	puts("</P>");
	resp_end_html();
}

static void
pg_error_badrequest(const char *msg)
{

	resp_begin_html(400, "Bad Request");
	puts("<H1>Bad Request</H1>\n"
	     "<P>\n");
	puts(msg);
	printf("Try again from the\n"
	       "<A HREF=\"%s\">main page</A>.\n"
	       "</P>", scriptname);
	resp_end_html();
}

static void
pg_error_internal(void)
{
	resp_begin_html(500, "Internal Server Error");
	puts("<P>Internal Server Error</P>");
	resp_end_html();
}

static void
pg_searchres(const struct req *req, struct manpage *r, size_t sz)
{
	char		*arch, *archend;
	size_t		 i, iuse, isec;
	int		 archprio, archpriouse;
	int		 prio, priouse;
	char		 sec;

	for (i = 0; i < sz; i++) {
		if (validate_filename(r[i].file))
			continue;
		fprintf(stderr, "invalid filename %s in %s database\n",
		    r[i].file, req->q.manpath);
		pg_error_internal();
		return;
	}

	if (1 == sz) {
		/*
		 * If we have just one result, then jump there now
		 * without any delay.
		 */
		printf("Status: 303 See Other\r\n");
		printf("Location: http://%s%s/%s/%s?",
		    HTTP_HOST, scriptname, req->q.manpath, r[0].file);
		http_printquery(req, "&");
		printf("\r\n"
		     "Content-Type: text/html; charset=utf-8\r\n"
		     "\r\n");
		return;
	}

	resp_begin_html(200, NULL);
	resp_searchform(req);
	puts("<DIV CLASS=\"results\">");
	puts("<TABLE>");

	for (i = 0; i < sz; i++) {
		printf("<TR>\n"
		       "<TD CLASS=\"title\">\n"
		       "<A HREF=\"%s/%s/%s?",
		    scriptname, req->q.manpath, r[i].file);
		http_printquery(req, "&amp;");
		printf("\">");
		html_print(r[i].names);
		printf("</A>\n"
		       "</TD>\n"
		       "<TD CLASS=\"desc\">");
		html_print(r[i].output);
		puts("</TD>\n"
		     "</TR>");
	}

	puts("</TABLE>\n"
	     "</DIV>");

	/*
	 * In man(1) mode, show one of the pages
	 * even if more than one is found.
	 */

	if (req->q.equal) {
		puts("<HR>");
		iuse = 0;
		priouse = 10;
		archpriouse = 3;
		for (i = 0; i < sz; i++) {
			isec = strcspn(r[i].file, "123456789");
			sec = r[i].file[isec];
			if ('\0' == sec)
				continue;
			prio = sec_prios[sec - '1'];
			if (NULL == req->q.arch) {
				archprio =
				    (NULL == (arch = strchr(
					r[i].file + isec, '/'))) ? 3 :
				    (NULL == (archend = strchr(
					arch + 1, '/'))) ? 0 :
				    strncmp(arch, "amd64/",
					archend - arch) ? 2 : 1;
				if (archprio < archpriouse) {
					archpriouse = archprio;
					priouse = prio;
					iuse = i;
					continue;
				}
				if (archprio > archpriouse)
					continue;
			}
			if (prio >= priouse)
				continue;
			priouse = prio;
			iuse = i;
		}
		resp_show(req, r[iuse].file);
	}

	resp_end_html();
}

static void
catman(const struct req *req, const char *file)
{
	FILE		*f;
	char		*p;
	size_t		 sz;
	ssize_t		 len;
	int		 i;
	int		 italic, bold;

	if ((f = fopen(file, "r")) == NULL) {
		puts("<P>You specified an invalid manual file.</P>");
		return;
	}

	puts("<DIV CLASS=\"catman\">\n"
	     "<PRE>");

	p = NULL;
	sz = 0;

	while ((len = getline(&p, &sz, f)) != -1) {
		bold = italic = 0;
		for (i = 0; i < len - 1; i++) {
			/*
			 * This means that the catpage is out of state.
			 * Ignore it and keep going (although the
			 * catpage is bogus).
			 */

			if ('\b' == p[i] || '\n' == p[i])
				continue;

			/*
			 * Print a regular character.
			 * Close out any bold/italic scopes.
			 * If we're in back-space mode, make sure we'll
			 * have something to enter when we backspace.
			 */

			if ('\b' != p[i + 1]) {
				if (italic)
					printf("</I>");
				if (bold)
					printf("</B>");
				italic = bold = 0;
				html_putchar(p[i]);
				continue;
			} else if (i + 2 >= len)
				continue;

			/* Italic mode. */

			if ('_' == p[i]) {
				if (bold)
					printf("</B>");
				if ( ! italic)
					printf("<I>");
				bold = 0;
				italic = 1;
				i += 2;
				html_putchar(p[i]);
				continue;
			}

			/*
			 * Handle funny behaviour troff-isms.
			 * These grok'd from the original man2html.c.
			 */

			if (('+' == p[i] && 'o' == p[i + 2]) ||
					('o' == p[i] && '+' == p[i + 2]) ||
					('|' == p[i] && '=' == p[i + 2]) ||
					('=' == p[i] && '|' == p[i + 2]) ||
					('*' == p[i] && '=' == p[i + 2]) ||
					('=' == p[i] && '*' == p[i + 2]) ||
					('*' == p[i] && '|' == p[i + 2]) ||
					('|' == p[i] && '*' == p[i + 2]))  {
				if (italic)
					printf("</I>");
				if (bold)
					printf("</B>");
				italic = bold = 0;
				putchar('*');
				i += 2;
				continue;
			} else if (('|' == p[i] && '-' == p[i + 2]) ||
					('-' == p[i] && '|' == p[i + 1]) ||
					('+' == p[i] && '-' == p[i + 1]) ||
					('-' == p[i] && '+' == p[i + 1]) ||
					('+' == p[i] && '|' == p[i + 1]) ||
					('|' == p[i] && '+' == p[i + 1]))  {
				if (italic)
					printf("</I>");
				if (bold)
					printf("</B>");
				italic = bold = 0;
				putchar('+');
				i += 2;
				continue;
			}

			/* Bold mode. */

			if (italic)
				printf("</I>");
			if ( ! bold)
				printf("<B>");
			bold = 1;
			italic = 0;
			i += 2;
			html_putchar(p[i]);
		}

		/*
		 * Clean up the last character.
		 * We can get to a newline; don't print that.
		 */

		if (italic)
			printf("</I>");
		if (bold)
			printf("</B>");

		if (i == len - 1 && p[i] != '\n')
			html_putchar(p[i]);

		putchar('\n');
	}
	free(p);

	puts("</PRE>\n"
	     "</DIV>");

	fclose(f);
}

static void
format(const struct req *req, const char *file)
{
	struct manoutput conf;
	struct mparse	*mp;
	struct roff_man	*man;
	void		*vp;
	int		 fd;
	int		 usepath;

	if (-1 == (fd = open(file, O_RDONLY, 0))) {
		puts("<P>You specified an invalid manual file.</P>");
		return;
	}

	mchars_alloc();
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_BADARG, NULL, req->q.manpath);
	mparse_readfd(mp, fd, file);
	close(fd);

	memset(&conf, 0, sizeof(conf));
	conf.fragment = 1;
	usepath = strcmp(req->q.manpath, req->p[0]);
	mandoc_asprintf(&conf.man, "%s?query=%%N&sec=%%S%s%s%s%s",
	    scriptname,
	    req->q.arch	? "&arch="       : "",
	    req->q.arch	? req->q.arch    : "",
	    usepath	? "&manpath="    : "",
	    usepath	? req->q.manpath : "");

	mparse_result(mp, &man, NULL);
	if (man == NULL) {
		fprintf(stderr, "fatal mandoc error: %s/%s\n",
		    req->q.manpath, file);
		pg_error_internal();
		mparse_free(mp);
		mchars_free();
		return;
	}

	vp = html_alloc(&conf);

	if (man->macroset == MACROSET_MDOC) {
		mdoc_validate(man);
		html_mdoc(vp, man);
	} else {
		man_validate(man);
		html_man(vp, man);
	}

	html_free(vp);
	mparse_free(mp);
	mchars_free();
	free(conf.man);
}

static void
resp_show(const struct req *req, const char *file)
{

	if ('.' == file[0] && '/' == file[1])
		file += 2;

	if ('c' == *file)
		catman(req, file);
	else
		format(req, file);
}

static void
pg_show(struct req *req, const char *fullpath)
{
	char		*manpath;
	const char	*file;

	if ((file = strchr(fullpath, '/')) == NULL) {
		pg_error_badrequest(
		    "You did not specify a page to show.");
		return;
	}
	manpath = mandoc_strndup(fullpath, file - fullpath);
	file++;

	if ( ! validate_manpath(req, manpath)) {
		pg_error_badrequest(
		    "You specified an invalid manpath.");
		free(manpath);
		return;
	}

	/*
	 * Begin by chdir()ing into the manpath.
	 * This way we can pick up the database files, which are
	 * relative to the manpath root.
	 */

	if (chdir(manpath) == -1) {
		fprintf(stderr, "chdir %s: %s\n",
		    manpath, strerror(errno));
		pg_error_internal();
		free(manpath);
		return;
	}

	if (strcmp(manpath, "mandoc")) {
		free(req->q.manpath);
		req->q.manpath = manpath;
	} else
		free(manpath);

	if ( ! validate_filename(file)) {
		pg_error_badrequest(
		    "You specified an invalid manual file.");
		return;
	}

	resp_begin_html(200, NULL);
	resp_searchform(req);
	resp_show(req, file);
	resp_end_html();
}

static void
pg_search(const struct req *req)
{
	struct mansearch	  search;
	struct manpaths		  paths;
	struct manpage		 *res;
	char			**argv;
	char			 *query, *rp, *wp;
	size_t			  ressz;
	int			  argc;

	/*
	 * Begin by chdir()ing into the root of the manpath.
	 * This way we can pick up the database files, which are
	 * relative to the manpath root.
	 */

	if (-1 == (chdir(req->q.manpath))) {
		fprintf(stderr, "chdir %s: %s\n",
		    req->q.manpath, strerror(errno));
		pg_error_internal();
		return;
	}

	search.arch = req->q.arch;
	search.sec = req->q.sec;
	search.outkey = "Nd";
	search.argmode = req->q.equal ? ARG_NAME : ARG_EXPR;
	search.firstmatch = 1;

	paths.sz = 1;
	paths.paths = mandoc_malloc(sizeof(char *));
	paths.paths[0] = mandoc_strdup(".");

	/*
	 * Break apart at spaces with backslash-escaping.
	 */

	argc = 0;
	argv = NULL;
	rp = query = mandoc_strdup(req->q.query);
	for (;;) {
		while (isspace((unsigned char)*rp))
			rp++;
		if (*rp == '\0')
			break;
		argv = mandoc_reallocarray(argv, argc + 1, sizeof(char *));
		argv[argc++] = wp = rp;
		for (;;) {
			if (isspace((unsigned char)*rp)) {
				*wp = '\0';
				rp++;
				break;
			}
			if (rp[0] == '\\' && rp[1] != '\0')
				rp++;
			if (wp != rp)
				*wp = *rp;
			if (*rp == '\0')
				break;
			wp++;
			rp++;
		}
	}

	if (0 == mansearch(&search, &paths, argc, argv, &res, &ressz))
		pg_noresult(req, "You entered an invalid query.");
	else if (0 == ressz)
		pg_noresult(req, "No results found.");
	else
		pg_searchres(req, res, ressz);

	free(query);
	mansearch_free(res, ressz);
	free(paths.paths[0]);
	free(paths.paths);
}

int
main(void)
{
	struct req	 req;
	struct itimerval itimer;
	const char	*path;
	const char	*querystring;
	int		 i;

	/* Poor man's ReDoS mitigation. */

	itimer.it_value.tv_sec = 2;
	itimer.it_value.tv_usec = 0;
	itimer.it_interval.tv_sec = 2;
	itimer.it_interval.tv_usec = 0;
	if (setitimer(ITIMER_VIRTUAL, &itimer, NULL) == -1) {
		fprintf(stderr, "setitimer: %s\n", strerror(errno));
		pg_error_internal();
		return EXIT_FAILURE;
	}

	/* Scan our run-time environment. */

	if (NULL == (scriptname = getenv("SCRIPT_NAME")))
		scriptname = "";

	if ( ! validate_urifrag(scriptname)) {
		fprintf(stderr, "unsafe SCRIPT_NAME \"%s\"\n",
		    scriptname);
		pg_error_internal();
		return EXIT_FAILURE;
	}

	/*
	 * First we change directory into the MAN_DIR so that
	 * subsequent scanning for manpath directories is rooted
	 * relative to the same position.
	 */

	if (-1 == chdir(MAN_DIR)) {
		fprintf(stderr, "MAN_DIR: %s: %s\n",
		    MAN_DIR, strerror(errno));
		pg_error_internal();
		return EXIT_FAILURE;
	}

	memset(&req, 0, sizeof(struct req));
	pathgen(&req);

	/* Next parse out the query string. */

	if (NULL != (querystring = getenv("QUERY_STRING")))
		http_parse(&req, querystring);

	if (req.q.manpath == NULL)
		req.q.manpath = mandoc_strdup(req.p[0]);
	else if ( ! validate_manpath(&req, req.q.manpath)) {
		pg_error_badrequest(
		    "You specified an invalid manpath.");
		return EXIT_FAILURE;
	}

	if ( ! (NULL == req.q.arch || validate_urifrag(req.q.arch))) {
		pg_error_badrequest(
		    "You specified an invalid architecture.");
		return EXIT_FAILURE;
	}

	/* Dispatch to the three different pages. */

	path = getenv("PATH_INFO");
	if (NULL == path)
		path = "";
	else if ('/' == *path)
		path++;

	if ('\0' != *path)
		pg_show(&req, path);
	else if (NULL != req.q.query)
		pg_search(&req);
	else
		pg_index(&req);

	free(req.q.manpath);
	free(req.q.arch);
	free(req.q.sec);
	free(req.q.query);
	for (i = 0; i < (int)req.psz; i++)
		free(req.p[i]);
	free(req.p);
	return EXIT_SUCCESS;
}

/*
 * Scan for indexable paths.
 */
static void
pathgen(struct req *req)
{
	FILE	*fp;
	char	*dp;
	size_t	 dpsz;
	ssize_t	 len;

	if (NULL == (fp = fopen("manpath.conf", "r"))) {
		fprintf(stderr, "%s/manpath.conf: %s\n",
			MAN_DIR, strerror(errno));
		pg_error_internal();
		exit(EXIT_FAILURE);
	}

	dp = NULL;
	dpsz = 0;

	while ((len = getline(&dp, &dpsz, fp)) != -1) {
		if (dp[len - 1] == '\n')
			dp[--len] = '\0';
		req->p = mandoc_realloc(req->p,
		    (req->psz + 1) * sizeof(char *));
		if ( ! validate_urifrag(dp)) {
			fprintf(stderr, "%s/manpath.conf contains "
			    "unsafe path \"%s\"\n", MAN_DIR, dp);
			pg_error_internal();
			exit(EXIT_FAILURE);
		}
		if (NULL != strchr(dp, '/')) {
			fprintf(stderr, "%s/manpath.conf contains "
			    "path with slash \"%s\"\n", MAN_DIR, dp);
			pg_error_internal();
			exit(EXIT_FAILURE);
		}
		req->p[req->psz++] = dp;
		dp = NULL;
		dpsz = 0;
	}
	free(dp);

	if ( req->p == NULL ) {
		fprintf(stderr, "%s/manpath.conf is empty\n", MAN_DIR);
		pg_error_internal();
		exit(EXIT_FAILURE);
	}
}
@


1.114
log
@Use include files "header.html" and "footer.html" rather than a
compiled-in string.  This is not a security risk, we read the file
manpath.conf from the same directory, anyway.  No error handling
is needed; even if the files are absent, that's not an error.

This is more flexible without causing complication of the code or
the user interface.  It helps the upcoming revamp of the online
manual pages on man.NetBSD.org.

Based on an idea by Jean-Yves Migeon <jeanyves dot migeon at free dot fr>,
but implemented in a much simpler way.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.113 2015/11/05 17:47:51 schwarze Exp $ */
d707 3
a709 1
	size_t		 len;
a710 1
	char		*p;
d713 1
a713 1
	if (NULL == (f = fopen(file, "r"))) {
d721 4
a724 1
	while (NULL != (p = fgetln(f, &len))) {
d726 1
a726 1
		for (i = 0; i < (int)len - 1; i++) {
d751 1
a751 1
			} else if (i + 2 >= (int)len)
d827 1
a827 1
		if (i == (int)len - 1 && '\n' != p[i])
d832 1
d1142 1
d1151 6
a1156 3
	while (NULL != (dp = fgetln(fp, &dpsz))) {
		if ('\n' == dp[dpsz - 1])
			dpsz--;
a1158 1
		dp = mandoc_strndup(dp, dpsz);
d1172 2
d1175 1
@


1.113
log
@Unify the three stylesheets into a single CSS file.
Many thanks to bentley@@ for doing this work.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.112 2015/10/22 22:06:43 schwarze Exp $ */
d80 1
d372 14
d402 2
d410 2
a420 1
	puts(CUSTOMIZE_BEGIN);
@


1.112
log
@use the new function man_validate() here, too
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.111 2015/10/20 02:01:31 schwarze Exp $ */
d380 1
a380 3
	       "<LINK REL=\"stylesheet\" HREF=\"%s/man-cgi.css\""
	       " TYPE=\"text/css\" media=\"all\">\n"
	       "<LINK REL=\"stylesheet\" HREF=\"%s/man.css\""
d386 1
a386 1
	       CSS_DIR, CSS_DIR, CUSTOMIZE_TITLE);
@


1.111
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.110 2015/10/13 22:59:54 schwarze Exp $ */
d37 1
d864 2
a865 1
	} else
d867 1
@


1.110
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.109 2015/10/06 18:32:19 schwarze Exp $ */
d36 1
d860 2
a861 1
	if (man->macroset == MACROSET_MDOC)
d863 1
a863 1
	else
@


1.109
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.108 2015/04/18 16:34:25 schwarze Exp $ */
a821 1
	struct mchars	*mchars;
d832 2
a833 3
	mchars = mchars_alloc();
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_BADARG, NULL,
	    mchars, req->q.manpath);
d853 1
a853 1
		mchars_free(mchars);
d857 1
a857 1
	vp = html_alloc(mchars, &conf);
d866 1
a866 1
	mchars_free(mchars);
@


1.108
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.107 2015/04/18 16:06:39 schwarze Exp $ */
d335 1
a335 1
				return(0);
d337 1
a337 1
				return(0);
d339 1
a339 1
				return(0);
d341 1
a341 1
				return(0);
d350 1
a350 1
	return(1);
d502 1
a502 1
			return(0);
d505 1
a505 1
	return(1);
d514 1
a514 1
		return(1);
d518 1
a518 1
			return(1);
d520 1
a520 1
	return(0);
d530 2
a531 2
	return ( ! (strstr(file, "../") || strstr(file, "/..") ||
	    (strncmp(file, "man", 3) && strncmp(file, "cat", 3))));
d1034 1
a1034 1
		return(EXIT_FAILURE);
d1046 1
a1046 1
		return(EXIT_FAILURE);
d1059 1
a1059 1
		return(EXIT_FAILURE);
d1075 1
a1075 1
		return(EXIT_FAILURE);
d1081 1
a1081 1
		return(EXIT_FAILURE);
d1106 1
a1106 1
	return(EXIT_SUCCESS);
@


1.107
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.106 2015/03/27 21:33:20 schwarze Exp $ */
d33 1
d35 1
a35 1
#include "mandoc_aux.h"
a822 1
	struct roff_man	*mdoc;
d849 2
a850 2
	mparse_result(mp, &mdoc, &man, NULL);
	if (NULL == man && NULL == mdoc) {
d861 2
a862 2
	if (NULL != mdoc)
		html_mdoc(vp, mdoc);
@


1.106
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.105 2015/03/27 17:37:25 schwarze Exp $ */
d822 2
a823 2
	struct mdoc	*mdoc;
	struct man	*man;
@


1.105
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.104 2015/02/10 08:05:30 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@usta.de>
d819 1
a824 1
	char		*opts;
d839 2
d842 1
a842 2
	mandoc_asprintf(&opts,
	    "fragment,man=%s?query=%%N&sec=%%S%s%s%s%s",
d859 1
a859 1
	vp = html_alloc(mchars, opts);
d869 1
a869 1
	free(opts);
@


1.104
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.103 2015/01/15 04:26:39 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d36 1
a36 1
#include "manpath.h"
@


1.103
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.102 2014/11/26 17:55:27 schwarze Exp $ */
d61 1
a61 1
static	int 		 http_decode(char *);
d64 1
a64 1
static	void 		 http_putchar(char);
d189 1
a189 1
	
d624 1
a624 1
		       "<A HREF=\"%s/%s/%s?", 
d704 1
a704 1
			/* 
d745 1
a745 1
			/* 
d783 1
a783 1
			
d794 1
a794 1
		/* 
d796 1
a796 1
		 * We can get to a newline; don't print that. 
d894 1
a894 1
	} 
d1059 1
a1059 1
	} 
@


1.102
log
@Make the code sipler and more robust by always assigning a value
to q.manpath and dropping the (incomplete) later NULL checks.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.101 2014/11/11 19:04:55 schwarze Exp $ */
a824 1
	enum mandoclevel rc;
d834 1
a834 1
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_FATAL, NULL,
d836 1
a836 1
	rc = mparse_readfd(mp, fd, file);
a838 7
	if (rc >= MANDOCLEVEL_FATAL) {
		fprintf(stderr, "fatal mandoc error: %s/%s\n",
		    req->q.manpath, file);
		pg_error_internal();
		return;
	}

@


1.101
log
@In man(1) mode without -a, stop searching after the first manual tree
that contained at least one match in order to not prefer mdoc(1) from
ports over mdoc(7).  As a bonus, this results in a speedup.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.100 2014/10/28 17:36:19 schwarze Exp $ */
d166 1
a166 2
	if (NULL != req->q.manpath &&
	    strcmp(req->q.manpath, req->p[0])) {
a299 5

	/* Fall back to the default manpath. */

	if (req->q.manpath == NULL)
		req->q.manpath = mandoc_strdup(req->p[0]);
d466 1
a466 2
			if (NULL == req->q.manpath ? 0 == i :
			    0 == strcmp(req->q.manpath, req->p[i]))
d1077 3
a1079 2
	if ( ! (NULL == req.q.manpath ||
	    validate_manpath(&req, req.q.manpath))) {
@


1.100
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.99 2014/10/07 18:20:06 schwarze Exp $ */
d980 1
@


1.99
log
@be a bit more patient, 1s is sometimes insufficient for legitimate queries
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.98 2014/09/27 11:17:36 kristaps Exp $ */
d827 1
d841 1
d843 1
a843 1
	    req->q.manpath);
d869 1
d873 1
a873 1
	vp = html_alloc(opts);
d882 1
@


1.98
log
@Modify man.cgi to use HTML5.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.97 2014/09/14 19:44:28 schwarze Exp $ */
d1036 1
a1036 1
	itimer.it_value.tv_sec = 1;
d1038 1
a1038 1
	itimer.it_interval.tv_sec = 1;
@


1.97
log
@Support backslash-escaping of white space in the query expression,
to be more similar to apropos(1) called from the shell.
Missing feature reported by Marcus MERIGHI <mcmer dash openbsd at
tor dot at> on misc@@.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.96 2014/08/26 11:21:40 schwarze Exp $ */
d379 1
a379 3
	printf("<!DOCTYPE HTML PUBLIC "
	       " \"-//W3C//DTD HTML 4.01//EN\""
	       " \"http://www.w3.org/TR/html4/strict.dtd\">\n"
d382 1
a382 2
	       "<META HTTP-EQUIV=\"Content-Type\""
	       " CONTENT=\"text/html; charset=utf-8\">\n"
@


1.96
log
@Sync section titles with OpenBSD.

For section 4, "Kernel Interfaces" is just too confusing,
the difference from sections 2 and 9 is too hard to see.

The 3p change was suggested by bluhm@@; that part
of the manual describes more modules than functions.

Align the CGI section titles with the console section titles.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.95 2014/08/21 16:05:21 schwarze Exp $ */
d957 2
a958 2
	char			**cp;
	const char		 *ep, *start;
d960 1
a960 1
	int			  i, sz;
d985 1
a985 2
	 * Poor man's tokenisation: just break apart by spaces.
	 * Yes, this is half-ass.  But it works for now.
d988 25
a1012 16
	ep = req->q.query;
	while (ep && isspace((unsigned char)*ep))
		ep++;

	sz = 0;
	cp = NULL;
	while (ep && '\0' != *ep) {
		cp = mandoc_reallocarray(cp, sz + 1, sizeof(char *));
		start = ep;
		while ('\0' != *ep && ! isspace((unsigned char)*ep))
			ep++;
		cp[sz] = mandoc_malloc((ep - start) + 1);
		memcpy(cp[sz], start, ep - start);
		cp[sz++][ep - start] = '\0';
		while (isspace((unsigned char)*ep))
			ep++;
d1015 1
a1015 1
	if (0 == mansearch(&search, &paths, sz, cp, &res, &ressz))
d1022 2
a1023 11
	for (i = 0; i < sz; i++)
		free(cp[i]);
	free(cp);

	for (i = 0; i < (int)ressz; i++) {
		free(res[i].file);
		free(res[i].names);
		free(res[i].output);
	}
	free(res);

@


1.95
log
@limit CGI process execution time to make REDoS attacks less effective;
attack surface pointed out by Sebastien Marie
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.94 2014/08/17 03:24:47 schwarze Exp $ */
d95 3
a97 3
    "3 - Subroutines",
    "3p - Perl Subroutines",
    "4 - Special Files",
d100 3
a102 3
    "7 - Macros and Conventions",
    "8 - Maintenance Commands",
    "9 - Kernel Interface"
@


1.94
log
@Fully integrate apropos(1) into mandoc(1).
Switch the argmode on the progname, including man(1).
Provide -f and -k options to switch the argmode.
Store the argmode inside struct search, generalizing the flags.
Derive the deftype from the argmode when needed instead of storing it.
Store the outkey inside struct search instead of passing it alone.
While here, get rid of the trailing blanks in Makefile.depend.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.93 2014/08/10 23:54:41 schwarze Exp $ */
d21 1
d1033 1
d1038 12
@


1.93
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.92 2014/08/05 15:29:30 schwarze Exp $ */
d976 2
a977 2
	search.deftype = req->q.equal ? TYPE_Nm : (TYPE_Nm | TYPE_Nd);
	search.flags = req->q.equal ? MANSEARCH_MAN : 0;
d1006 1
a1006 1
	if (0 == mansearch(&search, &paths, sz, cp, "Nd", &res, &ressz))
@


1.92
log
@mansearch.h uses uint64_t, so it needs stdint.h; found on Linux
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.91 2014/07/25 21:05:41 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
d19 2
a20 1
#endif
@


1.91
log
@Choosing the right encoding is a tricky business...

Printing query strings for URIs *always* needs URI-encoding, and when
embedding the URI into an HTML document, it needs replacement of
the "&" separators by "&amp;" *in addition to that*, not instead.
Delete the function html_primtquery(), it was completely wrong.

You can see the badness by entering "mandoc &sec=2" into the query input
box before this patch and click "Submit".  You come to the right page at
first (...man.cgi?query=mandoc+%26sec%3D2&apropos=0&sec=0&...), but now
the link to mandoc(1) is wrong: ...mandoc.1?query=mandoc &amp;sec=2&amp;...
Clicking on that, the "&sec=2" disappears from the query input box and
suddenly you have the first dropdown set to "2 - System Calls".  Oops.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.90 2014/07/25 20:09:09 schwarze Exp $ */
d26 1
@


1.90
log
@Sort the URI keys for .Xr links in the same order used by the search form,
and leave out the manpath when it is the default.
For building the HTML formatter options, do not use a static buffer.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.89 2014/07/25 19:37:34 schwarze Exp $ */
a57 1
static	void		 html_printquery(const struct req *);
d63 1
a63 1
static	void		 http_printquery(const struct req *);
d147 1
a147 1
http_printquery(const struct req *req)
d155 1
a155 1
		printf("&apropos=1");
d157 1
a157 1
		printf("&sec=");
d161 1
a161 1
		printf("&arch=");
d166 1
a166 1
		printf("&manpath=");
a171 25
html_printquery(const struct req *req)
{

	if (NULL != req->q.query) {
		printf("query=");
		html_print(req->q.query);
	}
	if (0 == req->q.equal)
		printf("&amp;apropos=1");
	if (NULL != req->q.sec) {
		printf("&amp;sec=");
		html_print(req->q.sec);
	}
	if (NULL != req->q.arch) {
		printf("&amp;arch=");
		html_print(req->q.arch);
	}
	if (NULL != req->q.manpath &&
	    strcmp(req->q.manpath, req->p[0])) {
		printf("&amp;manpath=");
		html_print(req->q.manpath);
	}
}

static void
d617 1
a617 1
		http_printquery(req);
d634 1
a634 1
		html_printquery(req);
@


1.89
log
@oops, we must not try to validate a manpath we don't have;
fixing an oversight introduced in rev. 1.77
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.88 2014/07/25 18:20:39 schwarze Exp $ */
a853 1
	int		 fd;
d857 1
d859 2
a860 1
	char		 opts[PATH_MAX + 128];
d879 8
a886 5
	snprintf(opts, sizeof(opts), "fragment,man=%s?"
	    "manpath=%s&query=%%N&sec=%%S%s%s",
	    scriptname, req->q.manpath,
	    req->q.arch ? "&arch=" : "",
	    req->q.arch ? req->q.arch : "");
d906 1
@


1.88
log
@We cannot easily control the order of the QUERY_STRING keys generated
by the search form, it's just the order of the fields in the form.
Actually, that's not too bad; the generated URI resembles the
generating form.

To minimize confusion for people looking at URIs, give the keys
in the same order when generating URIs for search listings and
search redirections, the latter being used instead of search
listings that would have only one single entry.  Also, if the
manpath is the default, remove it form the generated URIs.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.87 2014/07/25 17:52:04 schwarze Exp $ */
d1089 2
a1090 1
	if ( ! validate_manpath(&req, req.q.manpath)) {
@


1.87
log
@In generated .Xr links, avoid double encoding of ampersands
and avoid empty arch= keys.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.86 2014/07/25 17:34:06 schwarze Exp $ */
d151 3
a153 3
	if (NULL != req->q.manpath) {
		printf("&manpath=");
		http_print(req->q.manpath);
d155 2
d165 4
a168 3
	if (NULL != req->q.query) {
		printf("&query=");
		http_print(req->q.query);
a169 2
	if (0 == req->q.equal)
		printf("&apropos=1");
d176 3
a178 3
	if (NULL != req->q.manpath) {
		printf("&amp;manpath=");
		html_print(req->q.manpath);
d180 2
d190 4
a193 3
	if (NULL != req->q.query) {
		printf("&amp;query=");
		html_print(req->q.query);
a194 2
	if (0 == req->q.equal)
		printf("&amp;apropos=1");
@


1.86
log
@Even though this is not XHTML yet, remove some gratuitious violations
of XHTML syntax.  Also add some cosmetic newlines to the HTML code.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.85 2014/07/25 16:56:06 schwarze Exp $ */
d877 1
a877 1
	    "manpath=%s&amp;query=%%N&amp;sec=%%S&amp;arch=%s",
d879 1
@


1.85
log
@The names of all other struct query memebers match the corresponding
QUERY_STRING keys, so rename "expr" to "query".
Also add some missing function prototypes.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.84 2014/07/25 16:43:37 schwarze Exp $ */
d458 1
a458 1
		printf("CHECKED ");
d464 1
a464 1
	printf(	"</TD></TR><TR><TD>\n"
d470 1
a470 1
			printf(" SELECTED");
d480 1
a480 1
		printf(" SELECTED");
d486 1
a486 1
			printf(" SELECTED");
d499 1
a499 1
				printf("SELECTED ");
d514 1
a514 1
		printf("CHECKED ");
d572 4
a575 4
	       "This web interface is documented in the "
	       "<A HREF=\"%s/mandoc/man8/man.cgi.8\">man.cgi</A> "
	       "manual, and the "
	       "<A HREF=\"%s/mandoc/man1/apropos.1\">apropos</A> "
@


1.84
log
@clean up pg_show() to not modify a string returned from getenv(3)
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.83 2014/07/25 16:07:13 schwarze Exp $ */
d45 1
a45 1
	char		*expr; /* unparsed expression string */
d79 4
d163 1
a163 1
	if (NULL != req->q.expr) {
d165 1
a165 1
		http_print(req->q.expr);
d187 1
a187 1
	if (NULL != req->q.expr) {
d189 1
a189 1
		html_print(req->q.expr);
d249 1
a249 1
	req->q.expr	= NULL;
d277 1
a277 1
			set_query_attr(&req->q.expr, &val);
d444 2
a445 2
	if (NULL != req->q.expr)
		html_print(req->q.expr);
d1005 1
a1005 1
	ep = req->q.expr;
d1108 1
a1108 1
	else if (NULL != req.q.expr)
d1116 1
a1116 1
	free(req.q.expr);
@


1.83
log
@Rewrite http_parse() completely:
1. Make sure the last occurrence of each key is used, even if
it is empty, in which case it resets the value to the default.
2. When there is an HTTP encoding error, skip the affected
key-value pair only, but not all subsequent key-value pairs.
3. Do not modify a string returned from getenv(3).
4. Do not assume the NULL pointer is all null bits.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.82 2014/07/24 20:30:45 schwarze Exp $ */
d911 1
a911 1
pg_show(struct req *req, const char *path)
d913 2
a914 1
	char		*sub;
d916 1
a916 1
	if (NULL == path || NULL == (sub = strchr(path, '/'))) {
d921 2
a922 1
	*sub++ = '\0';
d924 1
a924 1
	if ( ! validate_manpath(req, path)) {
d927 1
d937 1
a937 1
	if (-1 == chdir(path)) {
d939 1
a939 1
		    path, strerror(errno));
d941 1
d945 7
a951 1
	if ( ! validate_filename(sub)) {
a956 5
	if (strcmp(path, "mandoc")) {
		free(req->q.manpath);
		req->q.manpath = mandoc_strdup(path);
	}

d959 1
a959 1
	resp_show(req, sub);
@


1.82
log
@Sort result pages first by section number, then by name.
By moving the sort from cgi.c to mansearch.c, we get two advantages:
Easier access to the data needed for sorting, in particular the section
number, and the apropos(1) command line utility profits as well.

Feature requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.81 2014/07/24 08:26:57 schwarze Exp $ */
d42 4
a45 4
	const char	*manpath; /* desired manual directory */
	const char	*arch; /* architecture */
	const char	*sec; /* manual section */
	const char	*expr; /* unparsed expression string */
d61 1
a61 1
static	void		 http_parse(struct req *, char *);
d216 2
a217 3
 * Parse out key-value pairs from an HTTP request variable.
 * This can be either a cookie or a POST/GET string, although man.cgi
 * uses only GET for simplicity.
d220 1
a220 1
http_parse(struct req *req, char *p)
a221 1
	char            *key, *val;
d223 27
a249 3
	memset(&req->q, 0, sizeof(struct query));
	req->q.manpath = req->p[0];
	req->q.equal = 1;
d251 15
a265 3
	while ('\0' != *p) {
		key = p;
		val = NULL;
d267 2
a268 5
		p += (int)strcspn(p, ";&");
		if ('\0' != *p)
			*p++ = '\0';
		if (NULL != (val = strchr(key, '=')))
			*val++ = '\0';
d270 1
a270 2
		if ('\0' == *key || NULL == val || '\0' == *val)
			continue;
d272 2
a273 1
		/* Just abort handling. */
d275 4
a278 8
		if ( ! http_decode(key))
			break;
		if (NULL != val && ! http_decode(val))
			break;

		if (0 == strcmp(key, "query"))
			req->q.expr = val;
		else if (0 == strcmp(key, "manpath")) {
d280 1
a280 1
			if (0 == strncmp(val, "OpenBSD ", 8)) {
d286 4
a289 6
			req->q.manpath = val;
		} else if (0 == strcmp(key, "apropos"))
			req->q.equal = !strcmp(val, "0");
		else if (0 == strcmp(key, "sec")) {
			if (strcmp(val, "0"))
				req->q.sec = val;
d291 1
a291 3
		} else if (0 == strcmp(key, "sektion")) {
			if (strcmp(val, "0"))
				req->q.sec = val;
d293 4
a296 3
		} else if (0 == strcmp(key, "arch")) {
			if (strcmp(val, "default"))
				req->q.arch = val;
d298 20
d319 5
d947 4
a950 2
	if (strcmp(path, "mandoc"))
		req->q.manpath = path;
d1041 1
a1041 1
	char		*querystring;
d1104 4
@


1.81
log
@Provide a dropdown entry "All Architectures" and make it the default.
Still, amd64 remains the default in the following sense:
If a man(1) mode search returns more than one page of the same name,
prefer amd64 over other architectures for immediate display.
ok deraadt@@ daniel@@
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.80 2014/07/22 18:14:13 schwarze Exp $ */
a55 1
static	int	 	 cmp(const void *, const void *);
a594 2
	qsort(r, sz, sizeof(struct manpage), cmp);

a1058 8
static int
cmp(const void *p1, const void *p2)
{

	return(strcasecmp(((const struct manpage *)p1)->names,
	    ((const struct manpage *)p2)->names));
}

@


1.80
log
@Security fix to prevent XSS attacks:
Restrict the character set of strings passed into html_alloc(),
in particular architecture names that come from the QUERY_STRING,
but also SCRIPT_NAME and manpath.conf content for additional safety,
and bail out safely on violations.
Issue reported by Sebastien Marie <semarie-openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.79 2014/07/21 22:33:01 schwarze Exp $ */
d425 5
a429 1
	puts("<SELECT NAME=\"arch\">");
d566 1
d568 1
d631 1
d638 17
@


1.79
log
@fix a minibug reported by kristaps@@:
preserve manpath and arch in .Xr links
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.78 2014/07/21 15:45:17 schwarze Exp $ */
d470 14
d977 7
d1011 6
d1068 14
a1081 1
		req->p[req->psz++] = mandoc_strndup(dp, dpsz);
@


1.78
log
@Kristaps points out that the current HTTP/1.1 draft standard (RFC
2616) requires the Location: response-header field to be an absolute
URI (14.30), and only the most recent proposed standard (RFC 7231),
which is barely a month old, allows a relative Location: (7.1.2).
While most modern browsers appear to support relative Location:
headers, some may not, and it's maybe a bit early to rely on relative
Location: headers.

I'm not going back to the HTTP_HOST or SERVER_NAME CGI variables,
though.  While some CGI programs certainly require those, in which
case both the CGI programmer and the web server admin have to be
very careful to keep the system secure and reliable, man.cgi(8)
does not really need them.  We always know at compile time which
domain we are running for, and for man.cgi(8), security and reliability
are definitely much more important than flexibility.  So make HTTP_HOST
a compile-time definition for now.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.77 2014/07/19 13:15:11 schwarze Exp $ */
d74 1
a74 1
static	void		 pg_show(const struct req *, const char *);
d788 4
a791 3
	snprintf(opts, sizeof(opts),
	    "fragment,man=%s?query=%%N&amp;sec=%%S",
	    scriptname);
d827 1
a827 1
pg_show(const struct req *req, const char *path)
d863 3
@


1.77
log
@Security fix:
Validate the manpath up front and report a Bad Request if it is not
listed in manpath.conf, such that clients can't probe which directories
exist on the server.  In case of configuration errors, consistently
report Internal Server Error without disclosing any further information.

Partially based on a patch from Sebastien Marie <semarie-openbsd at
latrappe dot fr>, but avoiding a couple of issues with that patch
and approaching the issue in a somewhat more rigorous way.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.76 2014/07/19 11:35:12 schwarze Exp $ */
d567 2
a568 2
		printf("Location: %s/%s/%s?",
		    scriptname, req->q.manpath, r[0].file);
@


1.76
log
@Security fix:
Validate the name of the file to show before opening it.
Only allow relative filenames starting with "man" or "cat"
and containing neither "/.." nor "../".

While here, correct the condition discarding an initial "./".

Vulnerability found by Sebastien Marie <semarie-openbsd at latrappe dot fr>.
Many thanks for sending a patch; however, i did not use it but made the
checks even stricter.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.75 2014/07/18 19:03:39 schwarze Exp $ */
d470 15
d837 6
d850 3
a852 2
		pg_error_badrequest(
		    "You specified an invalid manpath.");
d886 3
a888 2
		pg_error_badrequest(
		    "You specified an invalid manpath.");
d980 6
@


1.75
log
@Do not use the HTTP_HOST CGI variable,
just make the HTTP redirect Location: relative.
Less user input is good, it reduces the attack surface.
Besides, this removes one global variable and 4 lines of code.

Patch from Sebastien Marie <semarie-openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.74 2014/07/18 14:46:25 schwarze Exp $ */
d469 11
d537 9
d800 2
a801 1
	if ('.' == file[0] || '/' == file[1])
d834 6
@


1.74
log
@When the MAN_DIR/manpath.conf configuration file does not exist or is empty,
log the problem, hand the pg_error_internal() error page to the client,
and exit(3) in a controlled way instead of stumbling on and segfaulting
later.

Patch from Sebastien Marie <semarie-openbsd at latrappe dot fr>,
messages tweaked by me.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.73 2014/07/13 15:38:36 schwarze Exp $ */
a81 1
static	const char	 *httphost; /* hostname used in the URIs */
d532 2
a533 2
		printf("Location: http://%s%s/%s/%s?",
		    httphost, scriptname, req->q.manpath, r[0].file);
a908 3
	if (NULL == (httphost = getenv("HTTP_HOST")))
		httphost = "localhost";

@


1.73
log
@Compatibility hack for the old "manpath=OpenBSD<blank>" query parameter format;
unfortunate, more than 400 links needing this are scattered all around
the www.openbsd.org website, and CVSweb needs this as well.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.72 2014/07/13 12:55:45 schwarze Exp $ */
d973 6
a978 2
	if (NULL == (fp = fopen("manpath.conf", "r")))
		return;
d987 6
@


1.72
log
@Make the calltree a bit easier to understand by giving the
functions that call resp_begin_html() names starting with "pg_"
and those called after resp_begin_html() names with "resp_".
No functional change, purely renaming functions.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.71 2014/07/13 12:45:23 schwarze Exp $ */
d253 8
a260 1
		else if (0 == strcmp(key, "manpath"))
d262 1
a262 1
		else if (0 == strcmp(key, "apropos"))
d264 1
a264 2
		else if (0 == strcmp(key, "sec") ||
			 0 == strcmp(key, "sektion")) {
d267 5
@


1.71
log
@make source vs. formatted guessing a bit more robust
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.70 2014/07/13 12:31:23 schwarze Exp $ */
d67 4
d72 2
a77 7
static	void		 resp_error_badrequest(const char *);
static	void		 resp_error_internal(void);
static	void		 resp_index(const struct req *);
static	void		 resp_noresult(const struct req *,
				const char *);
static	void		 resp_search(const struct req *,
				struct manpage *, size_t);
d460 1
a460 1
resp_index(const struct req *req)
d477 1
a477 1
resp_noresult(const struct req *req, const char *msg)
d488 1
a488 1
resp_error_badrequest(const char *msg)
d502 1
a502 1
resp_error_internal(void)
d510 1
a510 1
resp_search(const struct req *req, struct manpage *r, size_t sz)
d739 1
a739 1
		resp_error_internal();
d751 1
a751 1
		resp_error_internal();
d785 1
a785 1
		resp_error_badrequest(
d798 1
a798 1
		resp_error_badrequest(
d827 1
a827 1
		resp_error_badrequest(
d865 1
a865 1
		resp_noresult(req, "You entered an invalid query.");
d867 1
a867 1
		resp_noresult(req, "No results found.");
d869 1
a869 1
		resp_search(req, res, ressz);
d911 1
a911 1
		resp_error_internal();
d936 1
a936 1
		resp_index(&req);
@


1.70
log
@By popular demand, bring man.cgi default mode closer to what man(1) does:
Even when there are multiple pages with the same name in different
sections, show one of them, using the same priorities as in the
default man.conf(5) file.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.69 2014/07/13 09:39:32 schwarze Exp $ */
d771 2
@


1.69
log
@Install the manuals of the web interface below the same directory
as manpath.conf, such that we do not need to mix our own documentation
into the documentation we are serving, which may not even be possible
if the latter is updated automatically.

Based on an idea by beck@@.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.68 2014/07/12 23:46:44 schwarze Exp $ */
d80 1
d85 1
d513 3
a515 1
	size_t		 i;
d557 24
d594 1
a594 2
		resp_error_badrequest(
		    "You specified an invalid manual file.");
a597 2
	resp_begin_html(200, NULL);
	resp_searchform(req);
d711 1
a711 3
	     "</DIV>\n"
	     "</BODY>\n"
	     "</HTML>");
d728 1
a728 2
		resp_error_badrequest(
		    "You specified an invalid manual file.");
a756 3
	resp_begin_html(200, NULL);
	resp_searchform(req);

a763 3
	puts("</BODY>\n"
	     "</HTML>");

d769 10
d802 4
a805 4
	if ('c' == *sub)
		catman(req, sub);
	else
		format(req, sub);
@


1.68
log
@Polish the search form using feedback from beck@@ and others,
in particular introduce a section dropdown and an architecture dropdown.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.67 2014/07/12 18:32:47 schwarze Exp $ */
d466 4
a469 4
	       "<A HREF=\"%s?query=man.cgi&amp;sec=8\">"
	       "man.cgi</A> manual, and the "
	       "<A HREF=\"%s?query=apropos&amp;sec=1\">"
	       "apropos</A> manual explains the query syntax.\n"
@


1.67
log
@No need for run-time configuration, add minimal compile-time
configuration facilities, just two paths and two HTML strings.
Show the title on all pages, not just the index page.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.66 2014/07/12 17:21:45 schwarze Exp $ */
d84 33
d374 1
a374 3
	       "<LEGEND>Search Parameters</LEGEND>\n"
	       "<INPUT TYPE=\"submit\" VALUE=\"Search\"> "
	       "for manuals \n",
d376 18
a393 2
	printf("<SELECT NAME=\"apropos\">\n"
	       "<OPTION VALUE=\"0\"");
d395 31
a425 18
		printf(" SELECTED=\"selected\"");
	printf(">named</OPTION>\n"
	       "<OPTION VALUE=\"1\"");
	if (0 == req->q.equal)
		printf(" SELECTED=\"selected\"");
	printf(">matching</OPTION>\n"
	       "</SELECT>\n"
	       "<INPUT TYPE=\"text\" NAME=\"query\" VALUE=\"");
	html_print(req->q.expr ? req->q.expr : "");
	printf("\">, section "
	       "<INPUT TYPE=\"text\""
	       " SIZE=\"4\" NAME=\"sec\" VALUE=\"");
	html_print(req->q.sec ? req->q.sec : "");
	printf("\">, arch "
	       "<INPUT TYPE=\"text\""
	       " SIZE=\"8\" NAME=\"arch\" VALUE=\"");
	html_print(req->q.arch ? req->q.arch : "");
	printf("\">");
d427 1
a427 1
		puts(", in <SELECT NAME=\"manpath\">");
d432 1
a432 1
				printf("SELECTED=\"selected\" ");
d441 11
a451 2
	puts("&mdash;\n"
	     "<INPUT TYPE=\"reset\" VALUE=\"Reset\">\n"
@


1.66
log
@Simplify: Delete 74 lines of code including one enum type, one
global lookup table, two functions, two function arguments, one
struct member, one local variable, and the "search/" and "show/"
part of the URIs, all without losing functionality.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.65 2014/07/12 16:14:35 schwarze Exp $ */
d36 1
a81 2
static	const char	 *mandir; /* contains all manpath directories */
static	const char	 *cssdir; /* css directory */
d316 1
a316 1
	       "<TITLE>System Manpage Reference</TITLE>\n"
d320 1
a320 1
	       cssdir, cssdir);
d336 1
a393 4
	puts("<H1>\n"
	     "Online manuals with "
	     "<A HREF=\"http://mdocml.bsd.lv/\">mandoc</A>\n"
	     "</H1>");
a799 3
	if (NULL == (mandir = getenv("MAN_DIR")))
		mandir = "/man";

a802 3
	if (NULL == (cssdir = getenv("CSS_DIR")))
		cssdir = "";

d807 1
a807 1
	 * First we change directory into the mandir so that
d812 1
a812 1
	if (-1 == chdir(mandir)) {
d814 1
a814 1
		    mandir, strerror(errno));
@


1.65
log
@Start fixing issues that beck@@ helped find:

Distinguish between man(1) and apropos(1) mode by adding back the classical
QUERY_STRING variable "apropos=".  Change the default back to "apropos=0".
Control it by adding a HTML <SELECT> element for it.

Rename the "expr=" QUERY_STRING variable back to its classical name "query=",
i don't see how the new name is better than the classical one.

While here, drop the concept of a "legacy mode".  Simply continue to
support the features, and use what we consider best.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.64 2014/07/12 01:55:30 schwarze Exp $ */
a36 7
enum	page {
	PAGE_INDEX,
	PAGE_SEARCH,
	PAGE_SHOW,
	PAGE__MAX
};

a51 1
	enum page	  page;
d66 2
a67 3
static	void		 pg_index(const struct req *, char *);
static	void		 pg_search(const struct req *, char *);
static	void		 pg_show(const struct req *, char *);
a72 1
static	void		 resp_error_notfound(const char *);
a84 6
static	const char * const pages[PAGE__MAX] = {
	"index", /* PAGE_INDEX */ 
	"search", /* PAGE_SEARCH */
	"show", /* PAGE_SHOW */
};

d339 1
a339 1
	       "<FORM ACTION=\"%s/search\" METHOD=\"get\">\n"
d401 1
a401 1
	       "<A HREF=\"%s/search?expr=Nm~^man\\.cgi$&amp;sec=8\">"
d403 1
a403 1
	       "<A HREF=\"%s/search?expr=Nm~^apropos$&amp;sec=1\">"
a435 18
resp_error_notfound(const char *page)
{

	resp_begin_html(404, "Not Found");
	puts("<H1>Page Not Found</H1>\n"
	     "<P>\n"
	     "The page you're looking for, ");
	printf("<B>");
	html_print(page);
	printf("</B>,\n"
	       "could not be found.\n"
	       "Try searching from the\n"
	       "<A HREF=\"%s\">main page</A>.\n"
	       "</P>", scriptname);
	resp_end_html();
}

static void
d454 1
a454 1
		printf("Location: http://%s%s/show/%s/%s?",
d473 1
a473 1
		       "<A HREF=\"%s/show/%s/%s?", 
a490 8
/* ARGSUSED */
static void
pg_index(const struct req *req, char *path)
{

	resp_index(req);
}

d658 1
a658 1
	    "fragment,man=%s/search?sec=%%S&expr=Nm~^%%N$",
d688 1
a688 1
pg_show(const struct req *req, char *path)
d718 1
a718 1
pg_search(const struct req *req, char *path)
d797 3
a800 2
	struct req	 req;
	char		*querystring, *path, *subpath;
d837 1
a837 6
	/*
	 * Now juggle paths to extract information.
	 * We want to extract our filetype (the file suffix), the
	 * initial path component, then the trailing component(s).
	 * Start with leading subpath component. 
	 */
d839 12
a850 39
	subpath = path = NULL;
	req.page = PAGE__MAX;

	if (NULL == (path = getenv("PATH_INFO")) || '\0' == *path)
		req.page = PAGE_INDEX;

	if (NULL != path && '/' == *path && '\0' == *++path)
		req.page = PAGE_INDEX;

	/* Resolve subpath component. */

	if (NULL != path && NULL != (subpath = strchr(path, '/')))
		*subpath++ = '\0';

	/* Map path into one we recognise. */

	if (NULL != path && '\0' != *path)
		for (i = 0; i < (int)PAGE__MAX; i++) 
			if (0 == strcmp(pages[i], path)) {
				req.page = (enum page)i;
				break;
			}

	/* Route pages. */

	switch (req.page) {
	case (PAGE_INDEX):
		pg_index(&req, subpath);
		break;
	case (PAGE_SEARCH):
		pg_search(&req, subpath);
		break;
	case (PAGE_SHOW):
		pg_show(&req, subpath);
		break;
	default:
		resp_error_notfound(path);
		break;
	}
@


1.64
log
@fix the two manual links on the index page
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.63 2014/07/11 22:27:35 schwarze Exp $ */
d52 1
a52 1
	int		 legacy; /* whether legacy mode */
d145 2
a146 2
		printf("&expr=");
		http_print(req->q.expr ? req->q.expr : "");
d148 2
d169 1
a169 1
		printf("&amp;expr=");
d172 2
a208 1
	int		 legacy;
d212 1
a213 1
	legacy = -1;
d234 1
a234 1
		if (0 == strcmp(key, "expr"))
a235 8
		else if (0 == strcmp(key, "query"))
			req->q.expr = val;
		else if (0 == strcmp(key, "sec"))
			req->q.sec = val;
		else if (0 == strcmp(key, "sektion"))
			req->q.sec = val;
		else if (0 == strcmp(key, "arch"))
			req->q.arch = val;
d239 9
a247 1
			legacy = 0 == strcmp(val, "0");
a248 16

	/* Test for old man.cgi compatibility mode. */

	req->q.legacy = legacy > 0;

	/* 
	 * Section "0" means no section when in legacy mode.
	 * For some man.cgi scripts, "default" arch is none.
	 */

	if (req->q.legacy && NULL != req->q.sec)
		if (0 == strcmp(req->q.sec, "0"))
			req->q.sec = NULL;
	if (req->q.legacy && NULL != req->q.arch)
		if (0 == strcmp(req->q.arch, "default"))
			req->q.arch = NULL;
d358 2
a359 3
	       "<INPUT TYPE=\"submit\" "
	       " VALUE=\"Search\"> for manuals matching \n"
	       "<INPUT TYPE=\"text\" NAME=\"expr\" VALUE=\"",
d361 11
d784 2
a785 2
	search.deftype = TYPE_Nm | TYPE_Nd;
	search.flags = 0;
@


1.63
log
@merge OpenBSD rev. 1.3 by tedu@@:
make http decode linear time.
also remove a redundant null check.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.62 2014/07/11 22:25:44 schwarze Exp $ */
d418 8
a425 7
	puts("<P>\n"
	     "This web interface is documented in the "
	     "<A HREF=\"search?expr=Nm~^man\\.cgi$&amp;sec=8\">"
	     "man.cgi</A> manual, and the "
	     "<A HREF=\"search?expr=Nm~^apropos$&amp;sec=1\">"
	     "apropos</A> manual explains the query syntax.\n"
	     "</P>");
@


1.62
log
@merge OpenBSD rev. 1.2 by tedu@@:
http headers must end lines with CRLF.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.61 2014/07/10 00:52:50 schwarze Exp $ */
d168 1
a168 1
		html_print(req->q.expr ? req->q.expr : "");
d287 1
d292 2
a293 1
	for ( ; '\0' != *p; p++) {
d304 2
a305 2
			*p = (char)c;
			memmove(p + 1, p + 3, strlen(p + 3) + 1);
d307 1
a307 1
			*p = '+' == *p ? ' ' : *p;
d310 1
a310 1
	*p = '\0';
@


1.61
log
@Link to the new man.cgi(8) manual, now that we have it!   :-)
While here, s/satisfy/match/ when talking about queries.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.60 2014/07/09 17:03:07 schwarze Exp $ */
d317 1
a317 1
		printf("Status: %d %s\n", code, msg);
d319 4
a322 4
	puts("Content-Type: text/html; charset=utf-8\n"
	     "Cache-Control: no-cache\n"
	     "Pragma: no-cache\n"
	     "");
d487 1
a487 1
		puts("Status: 303 See Other");
d491 3
a493 2
		puts("\n"
		     "Content-Type: text/html; charset=utf-8\n");
@


1.60
log
@some sugar for the index page
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.59 2014/07/09 16:23:01 schwarze Exp $ */
d370 1
a370 1
	       " VALUE=\"Search\"> for manuals satisfying \n"
d417 4
a420 1
	     "The <A HREF=\"search?expr=Nm~^apropos$&amp;sec=1\">"
@


1.59
log
@Clean up error reporting:
* Consistent naming and use of resp_* functions.
* Split resp_noresult() out of resp_search() and reuse it.
* Log information about internal errors.
* And some minor fixes.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.58 2014/07/09 14:18:59 schwarze Exp $ */
d384 1
a384 1
		puts(", <SELECT NAME=\"manpath\">");
d398 1
a398 1
	puts(".\n"
d411 4
d416 4
@


1.58
log
@namespace cleanups:
CGI variable: s/CACHE_DIR/MAN_DIR/  because it's static, not a cache
default MAN_DIR: /cache/man.cgi/ -> /man/  see above
global variable: s/cache/mandir/  see above
global variable: s/css/cssdir/  for consistency with mandir
global variable: s/host/httphost/  for consistency with HTTP_HOST
global variable: s/progname/scriptname/  for consistency with SCRIPT_NAME
struct query: member s/manroot/manpath/  for consistency with QUERY_STRING
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.57 2014/07/09 12:09:04 schwarze Exp $ */
a76 4
static	void		 resp_bad(void);
static	void		 resp_baddb(void);
static	void		 resp_error400(void);
static	void		 resp_error404(const char *);
d80 3
d84 2
d416 12
a427 1
resp_error400(void)
d430 6
a435 6
	resp_begin_html(400, "Query Malformed");
	printf("<H1>Malformed Query</H1>\n"
	       "<P>\n"
	       "The query your entered was malformed.\n"
	       "Try again from the\n"
	       "<A HREF=\"%s/index.html\">main page</A>.\n"
d441 1
a441 1
resp_error404(const char *page)
d459 1
a459 1
resp_bad(void)
a466 9
resp_baddb(void)
{

	resp_begin_html(500, "Internal Server Error");
	puts("<P>Your database is broken.</P>");
	resp_end_html();
}

static void
d485 2
a488 1

a489 12

	if (0 == sz) {
		puts("<P>\n"
		     "No results found.\n"
		     "</P>\n"
		     "</DIV>");
		resp_end_html();
		return;
	}

	qsort(r, sz, sizeof(struct manpage), cmp);

d531 2
a532 1
		resp_baddb();
d670 2
a671 1
		resp_baddb();
d681 3
a683 1
		resp_baddb();
d693 3
a695 1
		resp_baddb();
d723 2
a724 1
		resp_error400();
d736 2
a737 2
		perror(path);
		resp_baddb();
d765 2
a766 2
		perror(req->q.manpath);
		resp_search(req, NULL, 0);
d802 5
a806 1
	if (mansearch(&search, &paths, sz, cp, "Nd", &res, &ressz))
a807 2
	else
		resp_baddb();
d854 1
a854 1
		resp_bad();
d909 1
a909 1
		resp_error404(path);
@


1.57
log
@remove obsolete __sun includes
and improve some whitespace and comments
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.56 2014/07/09 11:34:46 schwarze Exp $ */
d23 1
d48 1
a48 1
	const char	*manroot; /* manual root directory */
d56 4
a59 4
	struct query	 q;
	char		**p; /* array of available manroots */
	size_t		 psz; /* number of available manroots */
	enum page	 page;
d89 4
a92 4
static	const char	 *progname; /* cgi script name */
static	const char	 *cache; /* cache directory */
static	const char	 *css; /* css directory */
static	const char	 *host; /* hostname */
d131 1
a131 1
	if (NULL != req->q.manroot) {
d133 1
a133 1
		http_print(req->q.manroot);
d153 1
a153 1
	if (NULL != req->q.manroot) {
d155 1
a155 1
		html_print(req->q.manroot);
d207 1
a207 1
	req->q.manroot = req->p[0];
d241 1
a241 1
			req->q.manroot = val;
d346 2
a347 1
	       "<!-- Begin page content. //-->\n", css, css);
d371 1
a371 1
	       progname);
d386 2
a387 2
			if (NULL == req->q.manroot ? 0 == i :
			    0 == strcmp(req->q.manroot, req->p[i]))
d424 1
a424 1
	       "</P>", progname);
d441 2
a442 2
	       "<A HREF=\"%s/index.html\">main page</A>.\n"
	       "</P>", progname);
d450 1
a450 1
	puts("<P>Generic badness happened.</P>");
d475 1
a475 1
		    host, progname, req->q.manroot, r[0].file);
d504 1
a504 1
		    progname, req->q.manroot, r[i].file);
d682 1
a682 1
	    req->q.manroot);
d693 1
a693 1
	    progname);
d731 1
a731 1
	 * Begin by chdir()ing into the manroot.
d765 2
a766 2
	if (-1 == (chdir(req->q.manroot))) {
		perror(req->q.manroot);
d828 1
a828 1
	char		*p, *path, *subpath;
d832 2
a833 2
	if (NULL == (cache = getenv("CACHE_DIR")))
		cache = "/cache/man.cgi";
d835 2
a836 2
	if (NULL == (progname = getenv("SCRIPT_NAME")))
		progname = "";
d838 2
a839 2
	if (NULL == (css = getenv("CSS_DIR")))
		css = "";
d841 2
a842 2
	if (NULL == (host = getenv("HTTP_HOST")))
		host = "localhost";
d845 1
a845 1
	 * First we change directory into the cache directory so that
d850 3
a852 2
	if (-1 == chdir(cache)) {
		perror(cache);
d862 2
a863 2
	if (NULL != (p = getenv("QUERY_STRING")))
		http_parse(&req, p);
@


1.56
log
@set a reasonable default for .Os
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.55 2014/07/09 09:27:01 schwarze Exp $ */
a29 7
#if defined(__sun)
/* for stat() */
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#endif

d57 1
a57 1
	size_t		 psz;
d125 1
a147 1

@


1.55
log
@oops, forgot to trim the newline character
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.54 2014/07/09 09:19:03 schwarze Exp $ */
d686 2
a687 1
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_FATAL, NULL, NULL);
@


1.54
log
@Simplify pathgen() even more.
Let manpath.conf be a plain text list of the directories to use.
As a bonus, this makes the order configurable.
Get rid of <dirent.h>, opendir(3), readdir(3), stat(2).
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.53 2014/07/09 08:53:28 schwarze Exp $ */
d943 2
@


1.53
log
@include manpath= when printing queries, and omit empty parameters
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.52 2014/07/09 07:30:47 schwarze Exp $ */
a22 1
#include <dirent.h>
d79 1
a79 1
static	void		 pathgen(DIR *, struct req *);
a830 1
	DIR		*cwd;
a857 4
	} else if (NULL == (cwd = opendir(cache))) {
		perror(cache);
		resp_bad();
		return(EXIT_FAILURE);
d861 1
a861 3

	pathgen(cwd, &req);
	closedir(cwd);
d933 1
a933 1
pathgen(DIR *dir, struct req *req)
d935 6
a940 4
	struct dirent	*d;
#if defined(__sun)
	struct stat	 sb;
#endif
d942 4
a945 12
	while (NULL != (d = readdir(dir))) {
#if defined(__sun)
		stat(d->d_name, &sb);
		if (!(S_IFDIR & sb.st_mode)
#else
		if (DT_DIR != d->d_type
#endif
		    || '.' != d->d_name[0]) {
			req->p = mandoc_realloc(req->p,
			    (req->psz + 1) * sizeof(char *));
			req->p[req->psz++] = mandoc_strdup(d->d_name);
		}
@


1.52
log
@Switch over man.cgi to SQLite.  While here:
* Simplify pathgen(), just use the subdirs of the cache dir.
* Simplify URI paths, just use show/<manpath>/<filename>.
* Drop struct paths, just use plain strings.
* Garbage collect unused headers.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.51 2014/04/23 21:40:47 schwarze Exp $ */
d137 16
a152 6
	printf("&expr=");
	http_print(req->q.expr ? req->q.expr : "");
	printf("&sec=");
	http_print(req->q.sec ? req->q.sec : "");
	printf("&arch=");
	http_print(req->q.arch ? req->q.arch : "");
d160 16
a175 6
	printf("&amp;expr=");
	html_print(req->q.expr ? req->q.expr : "");
	printf("&amp;sec=");
	html_print(req->q.sec ? req->q.sec : "");
	printf("&amp;arch=");
	html_print(req->q.arch ? req->q.arch : "");
@


1.51
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
First committed to wrong branch, sorry.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.50.2.1 2014/04/23 21:31:38 schwarze Exp $ */
d4 1
a21 3
#include <sys/wait.h>

#include <assert.h>
a22 1
#include <errno.h>
a25 1
#include <regex.h>
a26 2
#include <stdarg.h>
#include <stdint.h>
a37 1
#include "apropos_db.h"
a39 2
#include "mdoc.h"
#include "man.h"
d42 1
a42 7
#include "mandocdb.h"

#if defined(__linux__) || defined(__sun)
# include <db_185.h>
#else
# include <db.h>
#endif
a50 5
struct	paths {
	char		*name;
	char		*path;
};

d55 1
a58 1
	int		 manroot; /* manroot index (or -1)*/
d64 1
a64 1
	struct paths	*p;
a68 1
static	int		 atou(const char *, unsigned *);
d80 1
a80 2
static	int		 pathstop(DIR *);
static	void		 pathgen(DIR *, char *, struct req *);
d92 2
a93 1
static	void		 resp_search(struct res *, size_t, void *);
a107 23
 * This is just OpenBSD's strtol(3) suggestion.
 * I use it instead of strtonum(3) for portability's sake.
 */
static int
atou(const char *buf, unsigned *v)
{
	char		*ep;
	long		 lval;

	errno = 0;
	lval = strtol(buf, &ep, 10);
	if (buf[0] == '\0' || *ep != '\0')
		return(0);
	if ((errno == ERANGE && (lval == LONG_MAX || 
					lval == LONG_MIN)) ||
			(lval > INT_MAX || lval < 0))
		return(0);

	*v = (unsigned int)lval;
	return(1);
}

/*
d190 2
a191 2
	char            *key, *val, *manroot;
	int		 i, legacy;
d194 1
a196 2
	manroot = NULL;

d228 1
a228 1
			manroot = val;
a247 9

	/* Default to first manroot. */

	if (NULL != manroot) {
		for (i = 0; i < (int)req->psz; i++)
			if (0 == strcmp(req->p[i].name, manroot))
				break;
		req->q.manroot = i < (int)req->psz ? i : -1;
	}
d351 1
a351 1
	       "<FORM ACTION=\"%s/search.html\" METHOD=\"get\">\n"
d371 6
a376 5
			printf("<OPTION %s VALUE=\"",
				(i == req->q.manroot) ||
				(0 == i && -1 == req->q.manroot) ?
				"SELECTED=\"selected\"" : "");
			html_print(req->p[i].name);
d378 1
a378 1
			html_print(req->p[i].name);
d450 1
a450 1
resp_search(struct res *r, size_t sz, void *arg)
d452 1
a452 2
	size_t		 i, matched;
	const struct req *req;
d454 1
a454 13
	req = (const struct req *)arg;

	if (sz > 0)
		assert(req->q.manroot >= 0);

	for (matched = i = 0; i < sz; i++)
		if (r[i].matched)
			matched++;
	
	if (1 == matched) {
		for (i = 0; i < sz; i++)
			if (r[i].matched)
				break;
d460 2
a461 3
		printf("Location: http://%s%s/show/%d/%u/%u.html?",
				host, progname, req->q.manroot,
				r[i].volume, r[i].rec);
d473 1
a473 1
	if (0 == matched) {
d482 1
a482 1
	qsort(r, sz, sizeof(struct res), cmp);
a486 2
		if ( ! r[i].matched)
			continue;
d489 2
a490 3
		       "<A HREF=\"%s/show/%d/%u/%u.html?", 
				progname, req->q.manroot,
				r[i].volume, r[i].rec);
d493 2
a494 8
		html_print(r[i].title);
		putchar('(');
		html_print(r[i].cat);
		if (r[i].arch && '\0' != *r[i].arch) {
			putchar('/');
			html_print(r[i].arch);
		}
		printf(")</A>\n"
d497 1
a497 1
		html_print(r[i].desc);
d676 3
a678 4
	snprintf(opts, sizeof(opts), "fragment,"
			"man=%s/search.html?sec=%%S&expr=Nm~^%%N$,"
			/*"includes=/cgi-bin/man.cgi/usr/include/%%I"*/,
			progname);
a706 2
	struct manpaths	 ps;
	size_t		 sz;
a707 10
	char		 file[PATH_MAX];
	const char	*cp;
	int		 rc, catm;
	unsigned int	 vol, rec, mr;
	DB		*idx;
	DBT		 key, val;

	idx = NULL;

	/* Parse out mroot, volume, and record from the path. */
a713 17
	if ( ! atou(path, &mr)) {
		resp_error400();
		return;
	}
	path = sub;
	if (NULL == (sub = strchr(path, '/'))) {
		resp_error400();
		return;
	}
	*sub++ = '\0';
	if ( ! atou(path, &vol) || ! atou(sub, &rec)) {
		resp_error400();
		return;
	} else if (mr >= (unsigned int)req->psz) {
		resp_error400();
		return;
	}
d721 2
a722 2
	if (-1 == chdir(req->p[(int)mr].path)) {
		perror(req->p[(int)mr].path);
d727 4
a730 51
	memset(&ps, 0, sizeof(struct manpaths));
	manpath_manconf(&ps, "etc/catman.conf");

	if (vol >= (unsigned int)ps.sz) {
		resp_error400();
		goto out;
	}

	sz = strlcpy(file, ps.paths[vol], PATH_MAX);
	assert(sz < PATH_MAX);
	strlcat(file, "/", PATH_MAX);
	strlcat(file, MANDOC_IDX, PATH_MAX);

	/* Open the index recno(3) database. */

	idx = dbopen(file, O_RDONLY, 0, DB_RECNO, NULL);
	if (NULL == idx) {
		perror(file);
		resp_baddb();
		goto out;
	}

	key.data = &rec;
	key.size = 4;

	if (0 != (rc = (*idx->get)(idx, &key, &val, 0))) {
		rc < 0 ? resp_baddb() : resp_error400();
		goto out;
	} else if (0 == val.size) {
		resp_baddb();
		goto out;
	}

	cp = (char *)val.data;
	catm = 'c' == *cp++;

	if (NULL == memchr(cp, '\0', val.size - 1)) 
		resp_baddb();
	else {
 		file[(int)sz] = '\0';
 		strlcat(file, "/", PATH_MAX);
 		strlcat(file, cp, PATH_MAX);
		if (catm) 
			catman(req, file);
		else
			format(req, file);
	}
out:
	if (idx)
		(*idx->close)(idx);
	manpath_free(&ps);
d736 7
a742 24
	size_t		  tt, ressz;
	struct manpaths	  ps;
	int		  i, sz, rc;
	const char	 *ep, *start;
	struct res	*res;
	char		**cp;
	struct opts	  opt;
	struct expr	 *expr;

	if (req->q.manroot < 0 || 0 == req->psz) {
		resp_search(NULL, 0, (void *)req);
		return;
	}

	memset(&opt, 0, sizeof(struct opts));

	ep 	 = req->q.expr;
	opt.arch = req->q.arch;
	opt.cat  = req->q.sec;
	rc 	 = -1;
	sz 	 = 0;
	cp	 = NULL;
	ressz	 = 0;
	res	 = NULL;
d750 3
a752 4
	assert(req->q.manroot < (int)req->psz);
	if (-1 == (chdir(req->p[req->q.manroot].path))) {
		perror(req->p[req->q.manroot].path);
		resp_search(NULL, 0, (void *)req);
d756 8
a763 2
	memset(&ps, 0, sizeof(struct manpaths));
	manpath_manconf(&ps, "etc/catman.conf");
d770 1
d774 2
d788 3
a790 16
	/*
	 * Pump down into apropos backend.
	 * The resp_search() function is called with the results.
	 */

	expr = req->q.legacy ? 
		termcomp(sz, cp, &tt) : exprcomp(sz, cp, &tt);

	if (NULL != expr)
		rc = apropos_search
			(ps.sz, ps.paths, &opt, expr, tt, 
			 (void *)req, &ressz, &res, resp_search);

	/* ...unless errors occured. */

	if (0 == rc)
a791 2
	else if (-1 == rc)
		resp_search(NULL, 0, NULL);
d795 8
d804 2
a805 4
	free(cp);
	resfree(res, ressz);
	exprfree(expr);
	manpath_free(&ps);
a811 1
	char		 buf[PATH_MAX];
d848 1
a848 2
	strlcpy(buf, ".", PATH_MAX);
	pathgen(cwd, buf, &req);
a871 6
	/* Strip file suffix. */

	if (NULL != path && NULL != (p = strrchr(path, '.')))
		if (NULL != p && NULL == strchr(p, '/'))
			*p++ = '\0';

d903 2
a904 5
	for (i = 0; i < (int)req.psz; i++) {
		free(req.p[i].path);
		free(req.p[i].name);
	}

d913 2
a914 29
	return(strcasecmp(((const struct res *)p1)->title,
				((const struct res *)p2)->title));
}

/*
 * Check to see if an "etc" path consists of a catman.conf file.  If it
 * does, that means that the path contains a tree created by catman(8)
 * and should be used for indexing.
 */
static int
pathstop(DIR *dir)
{
	struct dirent	*d;
#if defined(__sun)
	struct stat	 sb;
#endif

	while (NULL != (d = readdir(dir))) {
#if defined(__sun)
		stat(d->d_name, &sb);
		if (S_IFREG & sb.st_mode)
#else
		if (DT_REG == d->d_type)
#endif
			if (0 == strcmp(d->d_name, "catman.conf"))
				return(1);
  }

	return(0);
a918 1
 * This adds all paths with "etc/catman.conf" to the buffer.
d921 1
a921 1
pathgen(DIR *dir, char *path, struct req *req)
a923 4
	char		*cp;
	DIR		*cd;
	int		 rc;
	size_t		 sz, ssz;
a927 67
	sz = strlcat(path, "/", PATH_MAX);
	if (sz >= PATH_MAX) {
		fprintf(stderr, "%s: Path too long", path);
		return;
	} 

	/* 
	 * First, scan for the "etc" directory.
	 * If it's found, then see if it should cause us to stop.  This
	 * happens when a catman.conf is found in the directory.
	 */

	rc = 0;
	while (0 == rc && NULL != (d = readdir(dir))) {
#if defined(__sun)
		stat(d->d_name, &sb);
		if (!(S_IFDIR & sb.st_mode)
#else
		if (DT_DIR != d->d_type
#endif
        || strcmp(d->d_name, "etc"))
			continue;

		path[(int)sz] = '\0';
		ssz = strlcat(path, d->d_name, PATH_MAX);

		if (ssz >= PATH_MAX) {
			fprintf(stderr, "%s: Path too long", path);
			return;
		} else if (NULL == (cd = opendir(path))) {
			perror(path);
			return;
		} 
		
		rc = pathstop(cd);
		closedir(cd);
	}

	if (rc > 0) {
		/* This also strips the trailing slash. */
		path[(int)--sz] = '\0';
		req->p = mandoc_reallocarray(req->p, 
		    req->psz + 1, sizeof(struct paths));
		/*
		 * Strip out the leading "./" unless we're just a ".",
		 * in which case use an empty string as our name.
		 */
		req->p[(int)req->psz].path = mandoc_strdup(path);
		req->p[(int)req->psz].name = 
			cp = mandoc_strdup(path + (1 == sz ? 1 : 2));
		req->psz++;
		/* 
		 * The name is just the path with all the slashes taken
		 * out of it.  Simple but effective. 
		 */
		for ( ; '\0' != *cp; cp++) 
			if ('/' == *cp)
				*cp = ' ';
		return;
	} 

	/*
	 * If no etc/catman.conf was found, recursively enter child
	 * directory and continue scanning.
	 */

	rewinddir(dir);
d935 4
a938 12
        || '.' == d->d_name[0])
			continue;

		path[(int)sz] = '\0';
		ssz = strlcat(path, d->d_name, PATH_MAX);

		if (ssz >= PATH_MAX) {
			fprintf(stderr, "%s: Path too long", path);
			return;
		} else if (NULL == (cd = opendir(path))) {
			perror(path);
			return;
a939 3

		pathgen(cd, path, req);
		closedir(cd);
@


1.51.2.1
log
@Remove the old man.cgi.
Running that would not be a responsible thing to do, nowadays.
@
text
@d1 1233
@


1.50
log
@needs mandoc_aux, too
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.49 2014/03/19 22:20:43 schwarze Exp $ */
d939 1
a939 1
		cp = mandoc_realloc(cp, (sz + 1) * sizeof(char *));
d1183 2
a1184 3
		req->p = mandoc_realloc
			(req->p, 
			 (req->psz + 1) * sizeof(struct paths));
@


1.49
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.48 2014/03/19 22:05:10 schwarze Exp $ */
d46 1
@


1.48
log
@cope with mparse_alloc() interface change
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.47 2014/01/05 20:41:04 schwarze Exp $ */
d756 1
a756 1
	mparse_result(mp, &mdoc, &man);
@


1.47
log
@Cope with mparse_alloc() interface change.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.46 2013/10/11 00:06:48 schwarze Exp $ */
d742 1
a742 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL, 0);
@


1.46
log
@Thomas Klausner <wiz at NetBSD dot org> finally succeeded to build
on SmartOS and sent these additional patches, thanks!
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.45 2013/06/05 02:00:26 schwarze Exp $ */
d742 1
a742 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL, NULL);
@


1.45
log
@Some places used PATH_MAX from <limits.h>, some MAXPATHLEN from <sys/param.h>.
Consistently use the PATH_MAX since it is specified by POSIX,
while MAXPATHLEN is not.
In preparation for using this at a few more places.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.44 2012/05/27 17:48:57 schwarze Exp $ */
d37 7
d52 1
a52 1
#ifdef __linux__
d1107 3
d1111 5
a1115 1
	while (NULL != (d = readdir(dir)))
d1117 1
d1120 1
d1137 3
d1155 7
a1161 1
		if (DT_DIR != d->d_type || strcmp(d->d_name, "etc"))
d1210 7
a1216 1
		if (DT_DIR != d->d_type || '.' == d->d_name[0])
@


1.44
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.43 2012/03/25 00:46:39 kristaps Exp $ */
a20 1
#include <sys/param.h>
d728 1
a728 1
	char		 opts[MAXPATHLEN + 128];
d779 1
a779 1
	char		 file[MAXPATHLEN];
d833 4
a836 4
	sz = strlcpy(file, ps.paths[vol], MAXPATHLEN);
	assert(sz < MAXPATHLEN);
	strlcat(file, "/", MAXPATHLEN);
	strlcat(file, MANDOC_IDX, MAXPATHLEN);
d865 2
a866 2
 		strlcat(file, "/", MAXPATHLEN);
 		strlcat(file, cp, MAXPATHLEN);
d975 1
a975 1
	char		 buf[MAXPATHLEN];
d1012 1
a1012 1
	strlcpy(buf, ".", MAXPATHLEN);
d1122 2
a1123 2
	sz = strlcat(path, "/", MAXPATHLEN);
	if (sz >= MAXPATHLEN) {
d1140 1
a1140 1
		ssz = strlcat(path, d->d_name, MAXPATHLEN);
d1142 1
a1142 1
		if (ssz >= MAXPATHLEN) {
d1189 1
a1189 1
		ssz = strlcat(path, d->d_name, MAXPATHLEN);
d1191 1
a1191 1
		if (ssz >= MAXPATHLEN) {
@


1.43
log
@Fix lookup not to use full-out regexp search.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.42 2012/03/24 01:46:25 kristaps Exp $ */
d736 1
a736 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
@


1.42
log
@Be insane.  Make apropos(1) subsume man(1).
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.41 2012/03/24 00:31:55 kristaps Exp $ */
d746 1
a746 1
			"man=%s/search.html?sec=%%S&expr=%%N,"
@


1.41
log
@Simplify by not pre-filtering the result vector for satisfied matches:
we can do this in the frontend.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.40 2012/03/23 09:03:07 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.40
log
@Knock out useless & confusing whatis mode.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.39 2011/12/25 17:49:52 kristaps Exp $ */
d498 1
a498 1
	int		  i;
d505 4
d510 4
a513 1
	if (1 == sz) {
d521 1
a521 1
				r[0].volume, r[0].rec);
a527 2
	qsort(r, sz, sizeof(struct res), cmp);

d533 1
a533 1
	if (0 == sz) {
d542 2
d546 3
a548 1
	for (i = 0; i < (int)sz; i++) {
d882 1
a882 1
	size_t		  tt;
d886 1
d904 2
d953 2
a954 2
			(ps.sz, ps.paths, &opt,
			 expr, tt, (void *)req, resp_search);
d961 1
a961 1
		resp_search(NULL, 0, (void *)req);
d967 1
@


1.39
log
@Continue changing mandoc.{index,db} into whatis.{index,db}.  Use mandocdb.h
to do so.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.38 2011/12/16 20:06:58 kristaps Exp $ */
a71 1
	int		 whatis; /* whether whatis mode */
a231 1
	req->q.whatis = 1;
a268 2
		else if (0 == strcmp(key, "op"))
			req->q.whatis = 0 == strcasecmp(val, "whatis");
d273 1
a273 7
	if (legacy == 0) {
		req->q.whatis = 0;
		req->q.legacy = 1;
	} else if (legacy > 0) {
		req->q.legacy = 1;
		req->q.whatis = 1;
	}
d401 2
a402 4
	       "<INPUT TYPE=\"submit\" NAME=\"op\""
	       " VALUE=\"Whatis\"> or \n"
	       "<INPUT TYPE=\"submit\" NAME=\"op\""
	       " VALUE=\"apropos\"> for manuals satisfying \n"
d529 4
a532 12
		printf("<P>\n"
		       "No %s results found.\n",
		       req->q.whatis ? "whatis" : "apropos");
		if (req->q.whatis) {
			printf("(Try "
			       "<A HREF=\"%s/search.html?op=apropos",
			       progname);
			html_printquery(req);
			puts("\">apropos</A>?)");
		}
		puts("</P>");
		puts("</DIV>");
d936 1
a936 1
	expr = req->q.whatis ? 
@


1.38
log
@Two lint fixes.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.37 2011/12/16 20:05:31 kristaps Exp $ */
d44 1
d847 2
a848 1
	strlcat(file, "/mandoc.index", MAXPATHLEN);
@


1.37
log
@Fix assertion found when plugging legacy man.cgi query string into my
man.cgi.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.36 2011/12/16 18:37:12 kristaps Exp $ */
d137 1
a137 1
			(lval > UINT_MAX || lval < 0))
@


1.36
log
@When routing to a "result" page in the cgi, remember our input parameters
and repeat them in the search bar.  This is handy.  While here, make the
QUERY_STRING parser a bit simpler.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.35 2011/12/16 12:06:35 kristaps Exp $ */
d513 3
a515 1
	assert(req->q.manroot >= 0);
@


1.35
log
@Make the stored "cat"/"mdoc"/"man" strings just be c/d/a single-character
bytes.  This cuts down a little in index size and allows for cleaner
extraction of information.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.34 2011/12/16 08:04:34 kristaps Exp $ */
d87 1
d91 3
d170 34
a227 1
	size_t		 sz;
d236 1
a236 4
	while (p && '\0' != *p) {
		while (' ' == *p)
			p++;

d240 2
a241 1
		if (NULL != (p = strchr(p, '='))) {
d243 2
a244 13
			val = p;

			sz = strcspn(p, ";&");
			/* LINTED */
			p += sz;

			if ('\0' != *p)
				*p++ = '\0';
		} else {
			p = key;
			sz = strcspn(p, ";&");
			/* LINTED */
			p += sz;
d246 1
a246 6
			if ('\0' != *p)
				p++;
			continue;
		}

		if ('\0' == *key || '\0' == *val)
d253 1
a253 1
		if ( ! http_decode(val))
d306 14
d514 1
a514 1

d521 1
a521 1
		printf("Location: http://%s%s/show/%d/%u/%u.html\n",
d524 3
a526 1
		puts("Content-Type: text/html; charset=utf-8\n");
d542 4
a545 7
			printf("(Try <A HREF=\"%s/search.html?"
			       "op=apropos&amp;expr=", progname);
			html_print(req->q.expr ? req->q.expr : "");
			printf("&amp;sec=");
			html_print(req->q.sec ? req->q.sec : "");
			printf("&amp;arch=");
			html_print(req->q.arch ? req->q.arch : "");
d559 1
a559 1
		       "<A HREF=\"%s/show/%d/%u/%u.html\">", 
d562 2
@


1.34
log
@Make paths in the mandocdb(8) index relative to the databases' path
prefix.  This means that an index in, say, /usr/share/man will point to
man1/foo.1 instead of /usr/share/man/man1/foo.1.  Not only does this
save a lot of space, it also allows manual trees to be moved around
without any side effects to the mandocdb(8) databases.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.33 2011/12/15 12:18:57 kristaps Exp $ */
d755 2
a756 2
	const char	*fn, *cp;
	int		 rc;
d827 4
a830 1
	} 
d833 1
d835 1
a835 5
	if (NULL == (fn = memchr(cp, '\0', val.size)))
		resp_baddb();
	else if (++fn - cp >= (int)val.size)
		resp_baddb();
	else if (NULL == memchr(fn, '\0', val.size - (fn - cp)))
d840 2
a841 2
 		strlcat(file, fn, MAXPATHLEN);
		if (0 == strcmp(cp, "cat"))
@


1.33
log
@Further tweaks for output consistency.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.32 2011/12/15 12:05:19 kristaps Exp $ */
d752 1
d808 2
a809 1
	strlcpy(file, ps.paths[vol], MAXPATHLEN);
d838 3
d842 1
a842 1
			catman(req, fn + 1);
d844 1
a844 1
			format(req, fn + 1);
@


1.32
log
@Some presentation polish in man.cgi:

 - include search bar above result page (I relent: it's annoying to
   follow three links then press back three times to get a search page);
 - make man.cgi.css into man-cgi.css so Apache isn't confused by two
   handlers (css, cgi);
 - finally consolidate example.style.css to be under the div.mandoc css
   selector;
 - put catman pages under div.catman;
 - put search bar under div#mancgi;
 - reflect this properly in the bundled CSS files.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.31 2011/12/14 13:36:59 kristaps Exp $ */
d500 2
d517 1
d522 1
a522 2
	puts("<P></P>\n"
	     "<TABLE>");
d545 2
a546 1
	puts("</TABLE>");
@


1.31
log
@Unbreak man.cgi's css directories when CSS_DIR isn't specified.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.30 2011/12/12 02:00:49 schwarze Exp $ */
d83 1
a83 1
static	void		 catman(const char *);
d85 1
a85 1
static	void		 format(const char *);
d349 3
a351 1
	       "<LINK REL=\"stylesheet\" HREF=\"%s/man.cgi.css\""
d356 1
a356 1
	       "<!-- Begin page content. //-->\n", css);
d373 2
a374 1
	printf("<FORM ACTION=\"%s/search.html\" METHOD=\"get\">\n"
d410 2
a411 1
	     "</FORM>");
d556 1
a556 1
catman(const char *file)
d569 4
a572 15
	resp_begin_http(200, NULL);
	printf("<!DOCTYPE HTML PUBLIC "
	       " \"-//W3C//DTD HTML 4.01//EN\""
	       " \"http://www.w3.org/TR/html4/strict.dtd\">\n"
	       "<HTML>\n"
	       "<HEAD>\n"
	       "<META HTTP-EQUIV=\"Content-Type\""
	       " CONTENT=\"text/html; charset=utf-8\">\n"
	       "<LINK REL=\"stylesheet\" HREF=\"%s/catman.css\""
	       " TYPE=\"text/css\" media=\"all\">\n"
	       "<TITLE>System Manpage Reference</TITLE>\n"
	       "</HEAD>\n"
	       "<BODY>\n"
	       "<!-- Begin page content. //-->\n"
	       "<PRE>\n", css);
d684 1
d692 1
a692 1
format(const char *file)
d716 1
a716 1
	snprintf(opts, sizeof(opts), "style=%s/man.css,"
d719 1
a719 1
			css, progname);
d722 9
d733 1
a733 2
	if (NULL != mdoc) {
		resp_begin_http(200, NULL);
d735 1
a735 2
	} else if (NULL != man) {
		resp_begin_http(200, NULL);
d737 3
a739 2
	} else
		resp_baddb();
d834 1
a834 1
			catman(fn + 1);
d836 1
a836 1
			format(fn + 1);
@


1.30
log
@implement -C (alternative config file) for apropos(1) and mandocdb(8),
including various tweaks to the whatis(8) manual;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.29 2011/12/11 00:22:47 kristaps Exp $ */
d949 1
a949 1
		css = "/";
@


1.29
log
@When 303'ing a search directly to a page, remember to specify its manroot.
Also allow for a CSS_DIR to specify alternate CSS locations.
Finally, some clutter as I assume that "css" and "progname" are already
HTML-safe.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.28 2011/12/10 23:09:25 kristaps Exp $ */
d795 1
a795 1
	manpath_manconf("etc/catman.conf", &ps);
d881 1
a881 1
	manpath_manconf("etc/catman.conf", &ps);
@


1.28
log
@Slip in a fix to allow for empty cache directories.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.27 2011/12/10 23:04:31 kristaps Exp $ */
d106 4
a109 3
static	const char	 *progname;
static	const char	 *cache;
static	const char	 *host;
d342 13
a354 13
	puts("<!DOCTYPE HTML PUBLIC "
	     " \"-//W3C//DTD HTML 4.01//EN\""
	     " \"http://www.w3.org/TR/html4/strict.dtd\">\n"
	     "<HTML>\n"
	     "<HEAD>\n"
	     "<META HTTP-EQUIV=\"Content-Type\""
	     " CONTENT=\"text/html; charset=utf-8\">\n"
	     "<LINK REL=\"stylesheet\" HREF=\"/man.cgi.css\""
	     " TYPE=\"text/css\" media=\"all\">\n"
	     "<TITLE>System Manpage Reference</TITLE>\n"
	     "</HEAD>\n"
	     "<BODY>\n"
	     "<!-- Begin page content. //-->");
d371 2
a372 4
	printf("<FORM ACTION=\"");
	html_print(progname);
	printf("/search.html\" METHOD=\"get\">\n");
	printf("<FIELDSET>\n"
d378 2
a379 1
	       "<INPUT TYPE=\"text\" NAME=\"expr\" VALUE=\"");
d475 3
d484 2
a485 2
		printf("Location: http://%s%s/show/%u/%u.html\n",
				host, progname,
a493 2

	req = (const struct req *)arg;
d501 2
a502 3
			printf("(Try <A HREF=\"");
			html_print(progname);
			printf("/search.html?op=apropos&amp;expr=");
a517 1
	assert(req->q.manroot >= 0);
d521 2
a522 4
		       "<A HREF=\"");
		html_print(progname);
		printf("/show/%d/%u/%u.html\">", 
				req->q.manroot,
d566 14
a579 14
	puts("<!DOCTYPE HTML PUBLIC "
	     " \"-//W3C//DTD HTML 4.01//EN\""
	     " \"http://www.w3.org/TR/html4/strict.dtd\">\n"
	     "<HTML>\n"
	     "<HEAD>\n"
	     "<META HTTP-EQUIV=\"Content-Type\""
	     " CONTENT=\"text/html; charset=utf-8\">\n"
	     "<LINK REL=\"stylesheet\" HREF=\"/catman.css\""
	     " TYPE=\"text/css\" media=\"all\">\n"
	     "<TITLE>System Manpage Reference</TITLE>\n"
	     "</HEAD>\n"
	     "<BODY>\n"
	     "<!-- Begin page content. //-->\n"
	     "<PRE>");
d722 1
a722 1
	snprintf(opts, sizeof(opts), "style=/man.css,"
d725 1
a725 1
			progname);
d942 4
a945 2
	progname = getenv("SCRIPT_NAME");
	if (NULL == progname)
d948 2
a949 3
	cache = getenv("CACHE_DIR");
	if (NULL == cache)
		cache = "/cache/man.cgi";
d951 1
a951 2
	host = getenv("HTTP_HOST");
	if (NULL == host)
@


1.27
log
@Finishing touches on multi-manroot man.cgi.  If more than one root is
specified, write them out using a SELECT box.  Else write nothing (the
manroot will still be checked if it's specified).
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.26 2011/12/10 22:45:47 kristaps Exp $ */
d856 1
a856 1
	if (req->q.manroot < 0) {
@


1.26
log
@Switch on "manpath=" handling, which I call the "manroot" (as "manpath" is
reserved for paths within a manroot).  This functionality is bare-bones:
right now, the default manroot is the first one scanned from the cache
directory.  At some point this will be sexy and smooth, but it's easy to
upgrade functionality by modifying pathgen() and so forth.  If a manroot
isn't parsed from the "manpath=", results are always empty.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.25 2011/12/10 22:20:59 kristaps Exp $ */
d367 1
d389 16
a404 1
	puts("\">.\n"
d1119 1
a1119 1
		path[(int)sz - 1] = '\0';
d1123 4
a1127 1
		/* And this strips out the leading "./". */
d1129 1
a1129 1
			cp = mandoc_strdup(path + 2);
@


1.25
log
@Encode "manroot" into file URL and parse it properly.  Right now this
just uses the first manroot by default.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.24 2011/12/10 21:51:07 kristaps Exp $ */
d70 1
d89 1
a89 1
static	void		 http_parse(struct query *, char *);
d186 1
a186 1
http_parse(struct query *q, char *p)
d188 1
a188 1
	char            *key, *val;
d190 1
a190 1
	int		 legacy;
d192 1
a192 1
	memset(q, 0, sizeof(struct query));
d194 1
a194 1
	q->whatis = 1;
d196 1
d237 1
a237 1
			q->expr = val;
d239 1
a239 1
			q->expr = val;
d241 1
a241 1
			q->sec = val;
d243 1
a243 1
			q->sec = val;
d245 3
a247 1
			q->arch = val;
d251 1
a251 1
			q->whatis = 0 == strcasecmp(val, "whatis");
d257 2
a258 2
		q->whatis = 0;
		q->legacy = 1;
d260 2
a261 2
		q->legacy = 1;
		q->whatis = 1;
d269 15
a283 6
	if (q->legacy && NULL != q->sec)
		if (0 == strcmp(q->sec, "0"))
			q->sec = NULL;
	if (q->legacy && NULL != q->arch)
		if (0 == strcmp(q->arch, "default"))
			q->arch = NULL;
d502 1
d508 3
a510 1
		printf("/show/0/%u/%u.html\">", r[i].volume, r[i].rec);
d770 1
a770 1
	 * Begin by chdir()ing into the root of the manpath.
d840 1
a840 1
	if (0 == req->psz) {
d860 3
a862 2
	if (-1 == (chdir(req->p[0].path))) {
		perror(req->p[0].path);
d966 1
a966 1
		http_parse(&req.q, p);
@


1.24
log
@Big upgrade and polish for cgi.c.

- Deprecate kvals (key/value pairs for QUERY_STRING values).  Since there's
only one place that uses this, kval_parse (now http_parse()) dumps directly
into struct query, which is more high-level.

- Put query values directly into struct req.

- The biggest difference is dynamic support for multiple "manroots".  A
"manroot" is a path with an "etc/catman.conf" file.  When the cgi starts,
it (prefix) recurses through its CACHE_DIR searching for "etc" directories.
When one's found, it sees if a catman.conf file exists.  This is marked
as a manroot and appended to a list.  The name of a manroot is the path
without slashes (e.g., OpenBSD/4.9 -> "OpenBSD 4.9").

Right now "manroot" isn't enabled.  The first manroot is chosen as the
real one.  I'll add the interface to it in the next checkins, but it'll be
quite simple.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.23 2011/12/10 10:59:21 kristaps Exp $ */
d494 1
a494 1
		printf("/show/%u/%u.html\">", r[i].volume, r[i].rec);
d722 1
a722 1
	unsigned int	 vol, rec;
d728 3
a730 1
	if (0 == req->psz || NULL == path) {
d733 8
a740 1
	} else if (NULL == (sub = strrchr(path, '/'))) {
d743 9
a751 2
	} else
		*sub++ = '\0';
d759 3
a761 3
	if (-1 == chdir(req->p[0].path)) {
		perror(req->p[0].path);
		resp_error400();
d768 1
a768 4
	if ( ! (atou(path, &vol) && atou(sub, &rec))) {
		resp_error400();
		goto out;
	} else if (vol >= (unsigned int)ps.sz) {
@


1.23
log
@FreeBSD's man.cgi uses a "default" value for no arch.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.22 2011/12/10 00:06:34 kristaps Exp $ */
d27 1
d58 5
a64 1
 * See kval_query() on how this is parsed.
a73 5
struct	kval {
	char		*key;
	char		*val;
};

d75 3
a77 2
	struct kval	*fields;
	size_t		 fieldsz;
d87 7
a93 11
static	int 		 kval_decode(char *);
static	void		 kval_free(struct kval *, size_t);
static	void		 kval_parse(struct kval **, size_t *, char *);
static	void		 kval_query(struct query *, 
				const struct kval *, size_t);
static	void		 pg_index(const struct manpaths *,
				const struct req *, char *);
static	void		 pg_search(const struct manpaths *,
				const struct req *, char *);
static	void		 pg_show(const struct manpaths *,
				const struct req *, char *);
a115 57
 * Initialise and parse a query structure from input.
 * This accomodates for mdocml's man.cgi and also for legacy man.cgi
 * input keys ("sektion" and "apropos").
 * Note that legacy mode has some quirks: if apropos legacy mode is
 * detected, we unset the section and architecture string.
 */
static void
kval_query(struct query *q, const struct kval *fields, size_t sz)
{
	int		 i, legacy;

	memset(q, 0, sizeof(struct query));
	q->whatis = 1;
	legacy = -1;

	for (i = 0; i < (int)sz; i++)
		if (0 == strcmp(fields[i].key, "expr"))
			q->expr = fields[i].val;
		else if (0 == strcmp(fields[i].key, "query"))
			q->expr = fields[i].val;
		else if (0 == strcmp(fields[i].key, "sec"))
			q->sec = fields[i].val;
		else if (0 == strcmp(fields[i].key, "sektion"))
			q->sec = fields[i].val;
		else if (0 == strcmp(fields[i].key, "arch"))
			q->arch = fields[i].val;
		else if (0 == strcmp(fields[i].key, "apropos"))
			legacy = 0 == strcmp
				(fields[i].val, "0");
		else if (0 == strcmp(fields[i].key, "op"))
			q->whatis = 0 == strcasecmp
				(fields[i].val, "whatis");

	/* Test for old man.cgi compatibility mode. */

	if (legacy == 0) {
		q->whatis = 0;
		q->legacy = 1;
	} else if (legacy > 0) {
		q->legacy = 1;
		q->whatis = 1;
	}

	/* 
	 * Section "0" means no section when in legacy mode.
	 * For some man.cgi scripts, "default" arch is none.
	 */

	if (q->legacy && NULL != q->sec)
		if (0 == strcmp(q->sec, "0"))
			q->sec = NULL;
	if (q->legacy && NULL != q->arch)
		if (0 == strcmp(q->arch, "default"))
			q->arch = NULL;
}

/*
a178 12
static void
kval_free(struct kval *p, size_t sz)
{
	int		 i;

	for (i = 0; i < (int)sz; i++) {
		free(p[i].key);
		free(p[i].val);
	}
	free(p);
}

d185 1
a185 1
kval_parse(struct kval **kv, size_t *kvsz, char *p)
d188 2
a189 1
	size_t           sz, cur;
d191 4
a194 1
	cur = 0;
d229 20
a248 4
		if ( ! kval_decode(key))
			return;
		if ( ! kval_decode(val))
			return;
d250 1
a250 5
		if (*kvsz + 1 >= cur) {
			cur++;
			*kv = mandoc_realloc
				(*kv, cur * sizeof(struct kval));
		}
d252 6
a257 3
		(*kv)[(int)*kvsz].key = mandoc_strdup(key);
		(*kv)[(int)*kvsz].val = mandoc_strdup(val);
		(*kvsz)++;
d259 12
d279 1
a279 1
kval_decode(char *p)
a353 3
	struct query	 q;

	kval_query(&q, req->fields, req->fieldsz);
d366 1
a366 1
	html_print(q.expr ? q.expr : "");
d370 1
a370 1
	html_print(q.sec ? q.sec : "");
d374 1
a374 1
	html_print(q.arch ? q.arch : "");
a443 1
	struct query	  q;
a464 1
	kval_query(&q, req->fields, req->fieldsz);
d468 3
a470 3
		       "No %s results found.",
		       q.whatis ? "whatis" : "apropos");
		if (q.whatis) {
d474 1
a474 1
			html_print(q.expr ? q.expr : "");
d476 1
a476 1
			html_print(q.sec ? q.sec : "");
d478 1
a478 1
			html_print(q.arch ? q.arch : "");
d516 1
a516 1
pg_index(const struct manpaths *ps, const struct req *req, char *path)
d715 1
a715 1
pg_show(const struct manpaths *ps, const struct req *req, char *path)
d717 1
d726 3
a728 1
	if (NULL == path) {
d737 15
d754 2
a755 2
		return;
	} else if (vol >= (unsigned int)ps->sz) {
d757 1
a757 1
		return;
d760 1
a760 1
	strlcpy(file, ps->paths[vol], MAXPATHLEN);
d767 1
d769 1
a769 1
		return;
a788 3
		strlcpy(file, cache, MAXPATHLEN);
		strlcat(file, "/", MAXPATHLEN);
		strlcat(file, fn, MAXPATHLEN);
d790 1
a790 1
			catman(file);
d792 1
a792 1
			format(file);
d795 3
a797 1
	(*idx->close)(idx);
d801 1
a801 1
pg_search(const struct manpaths *ps, const struct req *req, char *path)
d804 1
a809 1
	struct query	  q;
d811 5
a815 1
	kval_query(&q, req->fields, req->fieldsz);
d818 3
a820 3
	ep 	 = q.expr;
	opt.arch = q.arch;
	opt.cat  = q.sec;
d826 16
a841 2
	 * Poor man's tokenisation.
	 * Just break apart by spaces.
d865 2
a866 2
	expr = q.whatis ? termcomp(sz, cp, &tt) :
		          exprcomp(sz, cp, &tt);
d870 1
a870 1
			(ps->sz, ps->paths, &opt,
d885 1
d892 2
a895 1
	struct manpaths	 paths;
d897 1
a897 1
	/* HTTP init: read and parse the query string. */
d907 10
d918 5
d925 3
a927 1
	}
d929 3
a931 3
	host = getenv("HTTP_HOST");
	if (NULL == host)
		host = "localhost";
d933 1
a933 1
	memset(&req, 0, sizeof(struct req));
d936 1
a936 1
		kval_parse(&req.fields, &req.fieldsz, p);
d938 6
a943 1
	/* Resolve leading subpath component. */
a973 5
	/* Initialise MANPATH. */

	memset(&paths, 0, sizeof(struct manpaths));
	manpath_manconf("etc/catman.conf", &paths);

d978 1
a978 1
		pg_index(&paths, &req, subpath);
d981 1
a981 1
		pg_search(&paths, &req, subpath);
d984 1
a984 1
		pg_show(&paths, &req, subpath);
d991 4
a994 2
	manpath_free(&paths);
	kval_free(req.fields, req.fieldsz);
d996 1
d1008 109
@


1.22
log
@Add some periods (just to see if mlmmj is working again...).
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.21 2011/12/09 23:18:51 kristaps Exp $ */
d162 4
a165 1
	/* Section "0" means no section when in legacy mode. */
d167 6
a172 2
	if (q->legacy && NULL != q->sec && 0 == strcmp(q->sec, "0"))
		q->sec = NULL;
@


1.21
log
@Forgot to make whatis the default during abstraction.  Do it again.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.20 2011/12/09 11:29:19 kristaps Exp $ */
d437 1
a437 1
	       "<A HREF=\"%s/index.html\">main page</A>\n"
d455 1
a455 1
	       "<A HREF=\"%s/index.html\">main page</A>\n"
@


1.20
log
@Abstract query extraction code.  Perform some readability fixes while here.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.19 2011/12/08 22:47:09 kristaps Exp $ */
d131 1
d506 3
a508 2
		puts("<P>\n"
		     "No results found.");
@


1.19
log
@If no man.cgi `whatis' results are found, offer a quick link to the apropos
query mode.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.18 2011/12/08 18:39:14 kristaps Exp $ */
d57 12
d87 1
d89 2
a90 1
static	void		 kval_free(struct kval *, size_t);
d119 49
d190 4
d218 2
a219 2
 * Print a word, escaping HTML along the way.
 * This will pass non-ASCII straight to output: be warned!
d347 3
a349 3
	puts("Content-Type: text/html; charset=utf-8"		"\n"
	     "Cache-Control: no-cache"				"\n"
	     "Pragma: no-cache"					"\n"
d361 12
a372 12
	puts("<!DOCTYPE HTML PUBLIC "				"\n"
	     " \"-//W3C//DTD HTML 4.01//EN\""			"\n"
	     " \"http://www.w3.org/TR/html4/strict.dtd\">"	"\n"
	     "<HTML>"						"\n"
	     " <HEAD>"						"\n"
	     "  <META HTTP-EQUIV=\"Content-Type\" "		"\n"
	     "        CONTENT=\"text/html; charset=utf-8\">"	"\n"
	     "  <LINK REL=\"stylesheet\" HREF=\"/man.cgi.css\""	"\n"
	     "        TYPE=\"text/css\" media=\"all\">"		"\n"
	     "  <TITLE>System Manpage Reference</TITLE>"	"\n"
	     " </HEAD>"						"\n"
	     " <BODY>"						"\n"
d380 2
a381 1
	puts(" </BODY>\n</HTML>");
d387 1
a387 4
	int	 	 i;
	const char	*expr, *sec, *arch;

	expr = sec = arch = "";
d389 1
a389 14
	for (i = 0; i < (int)req->fieldsz; i++)
		if (0 == strcmp(req->fields[i].key, "expr"))
			expr = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "query"))
			expr = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "sec"))
			sec = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "sektion"))
			sec = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "arch"))
			arch = req->fields[i].val;

	if (NULL != sec && 0 == strcmp(sec, "0"))
		sec = NULL;
d397 4
a400 4
	       "<INPUT TYPE=\"submit\" NAME=\"op\" "
	        "VALUE=\"Whatis\"> or \n"
	       "<INPUT TYPE=\"submit\" NAME=\"op\" "
	        "VALUE=\"apropos\"> for manuals satisfying \n"
d402 1
a402 1
	html_print(expr);
d404 3
a406 3
	       "<INPUT TYPE=\"text\" "
	        "SIZE=\"4\" NAME=\"sec\" VALUE=\"");
	html_print(sec);
d408 3
a410 3
	       "<INPUT TYPE=\"text\" "
	        "SIZE=\"8\" NAME=\"arch\" VALUE=\"");
	html_print(arch);
d414 2
a415 2
	     "</FORM>\n"
	     "<!-- End search form. //-->");
d434 3
a436 3
	       "  The query your entered was malformed.\n"
	       "  Try again from the\n"
	       "  <A HREF=\"%s/index.html\">main page</A>\n"
d448 2
a449 2
	     "  The page you're looking for, ");
	printf("  <B>");
d452 3
a454 3
	       "  could not be found.\n"
	       "  Try searching from the\n"
	       "  <A HREF=\"%s/index.html\">main page</A>\n"
d479 2
a480 2
	int		 i, whatis;
	const char	*ep, *sec, *arch;
a482 3
	whatis = 1;
	ep = sec = arch = NULL;

a495 20
	req = (const struct req *)arg;

	for (i = 0; i < (int)req->fieldsz; i++)
		if (0 == strcmp(req->fields[i].key, "expr"))
			ep = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "query"))
			ep = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "sec"))
			sec = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "sektion"))
			sec = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "arch"))
			arch = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "apropos"))
			whatis = 0 == strcmp
				(req->fields[i].val, "0");
		else if (0 == strcmp(req->fields[i].key, "op"))
			whatis = 0 == strcasecmp
				(req->fields[i].val, "whatis");

d499 2
d502 1
d507 1
a507 1
		if (whatis) {
d511 1
a511 1
			html_print(ep ? ep : "");
d513 1
a513 1
			html_print(sec ? sec : "");
d515 1
a515 1
			html_print(arch ? arch : "");
d527 3
a529 1
		printf("<TR><TD CLASS=\"title\"><A HREF=\"");
d539 3
a541 1
		printf(")</A></TD><TD CLASS=\"desc\">");
d543 2
a544 1
		puts("</TD></TR>");
a547 1

d574 14
a587 13
	puts("<!DOCTYPE HTML PUBLIC "				"\n"
	     " \"-//W3C//DTD HTML 4.01//EN\""			"\n"
	     " \"http://www.w3.org/TR/html4/strict.dtd\">"	"\n"
	     "<HTML>"						"\n"
	     " <HEAD>"						"\n"
	     "  <META HTTP-EQUIV=\"Content-Type\" "		"\n"
	     "        CONTENT=\"text/html; charset=utf-8\">"	"\n"
	     "  <LINK REL=\"stylesheet\" HREF=\"/catman.css\""	"\n"
	     "        TYPE=\"text/css\" media=\"all\">"		"\n"
	     "  <TITLE>System Manpage Reference</TITLE>"	"\n"
	     " </HEAD>"						"\n"
	     " <BODY>"						"\n"
	     "<!-- Begin page content. //-->");
a588 1
	puts("<PRE>");
d823 1
a823 1
	int		  i, sz, rc, whatis;
d828 1
d830 1
a830 6
	expr = NULL;
	cp = NULL;
	ep = NULL;
	sz = 0;
	whatis = 1;

d833 6
a838 20
	for (sz = i = 0; i < (int)req->fieldsz; i++)
		if (0 == strcmp(req->fields[i].key, "expr"))
			ep = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "query"))
			ep = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "sec"))
			opt.cat = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "sektion"))
			opt.cat = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "arch"))
			opt.arch = req->fields[i].val;
		else if (0 == strcmp(req->fields[i].key, "apropos"))
			whatis = 0 == strcmp
				(req->fields[i].val, "0");
		else if (0 == strcmp(req->fields[i].key, "op"))
			whatis = 0 == strcasecmp
				(req->fields[i].val, "whatis");

	if (NULL != opt.cat && 0 == strcmp(opt.cat, "0"))
		opt.cat = NULL;
a860 2
	rc = -1;

d866 2
a867 2
	expr = whatis ? termcomp(sz, cp, &tt) :
		        exprcomp(sz, cp, &tt);
@


1.18
log
@Fix stupid typo: strlcpy() instead of strlcat().
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.17 2011/12/08 00:48:28 kristaps Exp $ */
d427 6
a432 1
	int		 i;
d447 20
d470 1
a470 1
	resp_searchform((const struct req *)arg);
d473 14
a486 1
		puts("<P>No results found.</P>");
@


1.17
log
@Look for man.cgi files in the cache, not under the volume path.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.16 2011/12/07 16:18:52 kristaps Exp $ */
d734 1
a734 1
		strlcpy(file, "/", MAXPATHLEN);
@


1.16
log
@Tweak to make man.cgi's search results validate properly.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.15 2011/12/07 16:08:55 kristaps Exp $ */
d733 2
a734 2
		strlcpy(file, ps->paths[vol], MAXPATHLEN);
		strlcat(file, "/", MAXPATHLEN);
@


1.15
log
@Apropos and man.cgi should strcasecmp their output sorting.
man.cgi should sort in the first place -- it wasn't before.
Revert uppercasing of man.cgi title.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.14 2011/12/07 15:55:06 kristaps Exp $ */
d344 1
d472 2
@


1.14
log
@Add skeleton man.cgi.css file.  I don't think this should become more
complicated than this.  Also make the title be printed out in caps as it
is in apropos(1) and whatis(1).
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.13 2011/12/07 15:12:34 kristaps Exp $ */
d70 1
a426 1
	char		*cp;
d441 2
d459 1
a459 2
		for (cp = r[i].title; '\0' != *cp; cp++)
			html_putchar(toupper((unsigned char)*cp));
d756 1
a756 1
	whatis = 0;
d921 9
@


1.13
log
@Accept old-school man.cgi parameters like "sektion" and "query".  This still
needs work because specifying an arch with "arch=i386" will return results
that don't have an arch specified.  I think this is weird, but it will need
to be supported if we want backwards compatibility.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.12 2011/12/07 13:00:40 kristaps Exp $ */
d298 2
a299 2
	     "   <META HTTP-EQUIV=\"Content-Type\" "		"\n"
	     "         CONTENT=\"text/html; charset=utf-8\">"	"\n"
d342 6
a347 7
	puts("<FIELDSET>\n"
	     "<INPUT TYPE=\"submit\" NAME=\"op\" "
	      "VALUE=\"Whatis\"> or \n"
	     "<INPUT TYPE=\"submit\" NAME=\"op\" "
	      "VALUE=\"apropos\"> for manuals satisfying \n"
	     "<INPUT TYPE=\"text\" SIZE=\"40\" "
	      "NAME=\"expr\" VALUE=\"");
d349 3
a351 3
	puts("\">, section "
	     "<INPUT TYPE=\"text\" "
	      "SIZE=\"4\" NAME=\"sec\" VALUE=\"");
d353 3
a355 3
	puts("\">, arch "
	     "<INPUT TYPE=\"text\" "
	      "SIZE=\"8\" NAME=\"arch\" VALUE=\"");
d426 1
d444 1
a444 1
	if (0 == sz)
d446 6
d454 1
a454 1
		printf("<P><A HREF=\"");
d457 2
a458 1
		html_print(r[i].title);
d465 1
a465 1
		printf(")</A> ");
d467 1
a467 1
		puts("</P>");
@


1.12
log
@Have a whatis/apropos mode, with the default (hitting enter within the
expression text) be whatis.  This is a much nicer default than apropos,
which can be scary.  While here, fix the cat.css location (erroneously
put in the response page instead of the catman page) and add bits for
a default style-sheet.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.11 2011/12/07 11:52:36 kristaps Exp $ */
d326 2
d330 2
d335 3
d755 2
d759 2
d763 3
d770 3
@


1.11
log
@By default, man.cgi should compile with -static (this was unset by mistake).
Also, set a custom CSS for man.cgi catman files.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.10 2011/12/07 00:23:04 kristaps Exp $ */
d300 2
d335 7
a341 4
	puts(" <FIELDSET>\n"
	     "  <INPUT TYPE=\"submit\" VALUE=\"Search:\">");
	printf("  Terms: <INPUT TYPE=\"text\" "
			"SIZE=\"60\" NAME=\"expr\" VALUE=\"");
d343 3
a345 3
	puts("\">");
	printf("  Section: <INPUT TYPE=\"text\" "
			"SIZE=\"4\" NAME=\"sec\" VALUE=\"");
d347 3
a349 3
	puts("\">");
	printf("  Arch: <INPUT TYPE=\"text\" "
			"SIZE=\"8\" NAME=\"arch\" VALUE=\"");
d351 5
a355 2
	puts("\">");
	puts(" </FIELDSET>\n</FORM>\n<!-- End search form. //-->");
d372 6
a377 6
	puts("<H1>Malformed Query</H1>\n"
	     "<P>\n"
	     "  The query your entered was malformed.\n"
	     "  Try again from the\n"
	     "  <A HREF=\"/index.html\">main page</A>\n"
	     "</P>");
d391 5
a395 5
	puts("</B>,\n"
	     "  could not be found.\n"
	     "  Try searching from the\n"
	     "  <A HREF=\"/index.html\">main page</A>\n"
	     "</P>");
d434 1
a434 15
	resp_begin_http(200, NULL);
	puts("<!DOCTYPE HTML PUBLIC "				"\n"
	     " \"-//W3C//DTD HTML 4.01//EN\""			"\n"
	     " \"http://www.w3.org/TR/html4/strict.dtd\">"	"\n"
	     "<HTML>"						"\n"
	     " <HEAD>"						"\n"
	     "  <META HTTP-EQUIV=\"Content-Type\" "		"\n"
	     "        CONTENT=\"text/html; charset=utf-8\">"	"\n"
	     "  <LINK REL=\"stylesheet\" HREF=\"/catman.css\""	"\n"
	     "        TYPE=\"text/css\" media=\"all\">"		"\n"
	     "  <TITLE>System Manpage Reference</TITLE>"	"\n"
	     " </HEAD>"						"\n"
	     " <BODY>"						"\n"
	     "<!-- Begin page content. //-->");

d481 14
a494 1
	resp_begin_html(200, NULL);
d731 1
a731 1
	int		  i, sz, rc;
d741 1
d752 3
d784 4
a787 1
	if (NULL != (expr = exprcomp(sz, cp, &tt)))
@


1.10
log
@Add cat2html functionality.  This keeps track of italic/bold mode per line
and properly handles some funny troff-isms we've exposed.  I originally
wanted to use man2html.c (found on W3's website with no known author)
but the code is dodgy.  This will need some more work (links, etc.) but
does a decent job thusfar.

Note: I think it's better style NOT to use <pre>, and instead have each
line employ <BR> afterward.  This allows browsers to break the lines if
necessary.  This can be changed trivially (replacing the newline and pre
tags with the <BR> and new tag).
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.9 2011/12/04 22:52:50 kristaps Exp $ */
d426 15
a440 1
	resp_begin_html(200, NULL);
d631 1
a631 1
	snprintf(opts, sizeof(opts), "style=/style.css,"
d633 1
a633 1
			"includes=/cgi-bin/man.cgi/usr/include/%%I",
@


1.9
log
@Make catman and man.cgi understand the index type-field.
Also make catman's man.conf be generated as catman.conf to avoid clobbering
a real man.conf file.
Finally, add a placeholder catman() function to man.cgi for preformatted
manuals in the cache.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.8 2011/11/27 11:46:44 kristaps Exp $ */
d72 1
d84 2
a85 3
static	void		 resp_badexpr(const struct req *);
static	void		 resp_badmanual(void);
static	void		 resp_badpage(void);
d126 23
a155 1
	char		 c;
a158 1

d160 1
a160 17
		switch ((c = *p++)) {
		case ('"'):
			printf("&quote;");
			break;
		case ('&'):
			printf("&amp;");
			break;
		case ('>'):
			printf("&gt;");
			break;
		case ('<'):
			printf("&lt;");
			break;
		default:
			putchar((unsigned char)c);
			break;
		}
d298 2
d333 1
a333 1
	puts(" <FIELDSET>"					"\n"
d360 1
a360 1
resp_badpage(void)
d363 7
a369 2
	resp_begin_html(404, "Not Found");
	puts("<P>Page not found.</P>");
d374 1
a374 1
resp_badmanual(void)
d378 10
a387 11
	puts("<P>Requested manual not found.</P>");
	resp_end_html();
}

static void
resp_badexpr(const struct req *req)
{

	resp_begin_html(200, NULL);
	resp_searchform(req);
	puts("<P>Your search didn't work.</P>");
d462 5
a466 3
	int		 fd;
	char		 buf[BUFSIZ];
	ssize_t		 ssz;
d468 1
a468 1
	if (-1 == (fd = open(file, O_RDONLY, 0))) {
d473 100
a572 1
	resp_begin_http(200, NULL);
d574 4
a577 2
	while ((ssz = read(fd, buf, BUFSIZ)) > 0)
		write(STDOUT_FILENO, buf, (size_t)ssz);
d579 2
a580 2
	if (ssz < 0)
		perror(file);
d582 8
a589 1
	close(fd);
d601 1
d617 5
d623 1
a623 1
	vp = html_alloc(NULL);
d650 1
a650 1
		resp_badmanual();
d653 1
a653 1
		resp_badmanual();
d659 1
a659 1
		resp_badmanual();
d662 1
a662 1
		resp_badmanual();
d681 1
a681 1
		rc < 0 ? resp_baddb() : resp_badmanual();
d769 1
a769 1
		resp_badexpr(req);
d859 1
a859 1
		resp_badpage();
@


1.8
log
@Removing INSECURE mode.  This is a work in progress!  Logic for
formatting manpages is now linked into man.cgi.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.7 2011/11/24 12:27:18 kristaps Exp $ */
d69 1
d85 1
d325 1
a325 1
	printf("/search\" METHOD=\"get\">\n");
d353 9
d449 23
d516 1
d519 1
a519 1
	DB		*db;
d544 2
a545 2
	db = dbopen(file, O_RDONLY, 0, DB_RECNO, NULL);
	if (NULL == db) {
d553 1
a553 1
	if (0 != (rc = (*db->get)(db, &key, &val, 0))) {
d555 1
a555 2
		(*db->close)(db);
		return;
d558 1
a558 1
	/* Extra filename: the first nil-terminated entry. */
d560 17
a576 7
	strlcpy(file, ps->paths[vol], MAXPATHLEN);
	strlcat(file, "/", MAXPATHLEN);
	strlcat(file, (char *)val.data, MAXPATHLEN);

	(*db->close)(db);

	format(file);
d717 1
a717 1
	manpath_manconf("etc/man.conf", &paths);
d732 1
@


1.7
log
@Let man.cgi run in two modes:

 (1) Insecure.  This means that we're operating over the full file-system
     with access to mandoc(1).  In this mode, mandocdb entries are formatted
     on-the-fly.  The $INSECURE environment variable must be passed to
     man.cgi for this mode to work.

 (2) Secure.  Manuals are assumed to be pre-formatted in a cache directory,
     which may be set with $CACHE_DIR but default to /cache/man.cgi.
     This mode works with manup(8), which updates the cached pages from
     outside of the jail.  man.cgi simply locates the manual file and
     outputs it to stdout.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.6 2011/11/23 10:01:04 kristaps Exp $ */
d39 3
d69 1
a69 2
static	void		 format_insecure(const char *);
static	void		 format_secure(const char *);
a90 1
static	int		  insecure = 1;
d438 1
a438 1
format_insecure(const char *file)
d440 6
a445 2
	pid_t		 pid;
	char		 cmd[MAXPATHLEN];
d447 2
a448 11
	strlcpy(cmd, "man=", MAXPATHLEN);
	strlcat(cmd, progname, MAXPATHLEN);
	strlcat(cmd, "/search?expr=%N&sec=%S", MAXPATHLEN);

	/* Get ready to call the child mandoc(1) process. */

	if (-1 == (pid = fork()))
		exit(EXIT_FAILURE);

	if (pid > 0) {
		waitpid(pid, NULL, 0);
d452 3
a454 16
	dup2(STDOUT_FILENO, STDERR_FILENO);

	puts("Content-Type: text/html; charset=utf-8\n");

	fflush(stdout);

	execlp("mandoc", "mandoc", "-T", 
		"html", "-O", cmd, file, (char *)NULL);
}

static void
format_secure(const char *file)
{
	char		 buf[BUFSIZ];
	int		 fd;
	ssize_t		 ssz;
d456 1
a456 1
	if (-1 == (fd = open(file, O_RDONLY, 0))) {
d461 2
a462 1
	resp_begin_http(200, NULL);
d464 8
a471 5
	do {
		ssz = read(fd, buf, BUFSIZ);
		if (ssz > 0)
			write(STDOUT_FILENO, buf, ssz);
	} while (ssz > 0);
d473 2
a474 1
	close(fd);
a525 2
	(*db->close)(db);

d530 3
a532 5
	if ( ! insecure) {
		strlcat(file, ".html", MAXPATHLEN);
		format_secure(file);
	} else
		format_insecure(file);
d625 3
a627 6
	if (NULL == getenv("INSECURE")) {
		insecure = 0;
		if (-1 == chdir(cache)) {
			resp_bad();
			return(EXIT_FAILURE);
		}
d673 1
a673 4
	if ( ! insecure)
		manpath_manconf("etc/man.conf", &paths);
	else
		manpath_parse(&paths, NULL, NULL);
@


1.6
log
@man.cgi works for the non-jailed case.
In other words, if you smash this into a cgi-bin directory, it will Just
Work for your system's manuals (it of course needs access to mandoc(1) and
your file-system, hence "non-jailed").
The notion of a jailed case is much more subtle and being worked on now.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.5 2011/11/20 12:39:08 kristaps Exp $ */
d66 2
d78 1
d89 1
d91 1
d369 8
d437 53
a491 1
	pid_t		 pid;
d493 1
a493 1
	char		 file[MAXPATHLEN], cmd[MAXPATHLEN];
d538 2
d544 5
a548 24
	(*db->close)(db);

	strlcpy(cmd, "man=", MAXPATHLEN);
	strlcat(cmd, progname, MAXPATHLEN);
	strlcat(cmd, "/search?expr=%N&sec=%S", MAXPATHLEN);

	/* Get ready to call the child mandoc(1) process. */

	if (-1 == (pid = fork()))
		exit(EXIT_FAILURE);

	if (pid > 0) {
		waitpid(pid, NULL, 0);
		return;
	}

	dup2(STDOUT_FILENO, STDERR_FILENO);

	puts("Content-Type: text/html; charset=utf-8\n");

	fflush(stdout);

	execlp("mandoc", "mandoc", "-T", 
		"html", "-O", cmd, file, (char *)NULL);
d637 12
d692 4
a695 1
	manpath_parse(&paths, NULL, NULL);
@


1.5
log
@Merge schwarze@@'s work for 64-bit types.  This is based on a tweaked patch
submitted to tech@@ on 16/11/2011, 01:39.  It has been updated to account
for the logical-operator functions and to avoid keeping a live pointer into
the DBT value, which is not guaranteed to be consistent across calls into
the bdb library.
@
text
@d1 23
a23 1
/*	$Id: cgi.c,v 1.4 2011/11/13 10:49:57 schwarze Exp $ */
d25 2
d28 1
d35 1
d37 1
d39 7
a45 2
#include "mandocdb.h"
#include "apropos_db.h"
a46 3
/*
 * The page a request is trying to make.
 */
d50 1
a53 4
/*
 * Key-value pair.  
 * Both key and val are on the heap.
 */
a58 12
/*
 * The media type, determined by suffix, of the requesting or responding
 * context.
 */
enum	media {
	MEDIA_HTML,
	MEDIA__MAX
};

/*
 * An HTTP request.
 */
d60 1
a60 1
	struct kval	*fields; /* query fields */
a61 1
	enum media	 media;
d65 2
a66 3
#if 0
static	void		 html_printtext(const char *);
#endif
d70 18
a87 5
static	void		 pg_index(const struct req *, char *);
static	void		 pg_search(const struct req *, char *);
#if 0
static	void		 pg_searchres(struct rec *, size_t, void *);
#endif
d92 1
d95 22
a116 3
static	const char * const medias[MEDIA__MAX] = {
	"html", /* MEDIA_HTML */
};
d118 4
a121 1
#if 0
d123 1
a123 1
html_printtext(const char *p)
d126 3
a148 1
#endif
d164 2
a165 1
 * This can be either a cookie or a POST/GET string.
d226 3
a228 3
 * In-place HTTP-decode a string.  The standard explanation is that this
 * turns "%4e+foo" into "n foo" in the regular way.  This is done
 * in-place over the allocated string.
d259 103
a362 1
/* ARGSUSED */
d364 1
a364 1
pg_index(const struct req *req, char *path)
d367 3
a371 1
#if 0
d373 1
a373 1
pg_searchres(struct rec *recs, size_t sz, void *arg)
a375 1
	const char	*pg;
d377 18
a394 2
	if (NULL == (pg = getenv("SCRIPT_NAME")))
		pg = "";
d397 4
a400 3
		printf("<A HREF=\"%s/show/%u.html\">", 
				pg, recs[i].rec);
		html_printtext(recs[i].title);
d402 8
a409 2
		html_printtext(recs[i].cat);
		puts(")</A>");
d411 10
a421 1
#endif
d424 1
a424 1
pg_search(const struct req *req, char *path)
d426 58
a483 2
	int		 i;
	struct opts	 opt;
d485 2
a486 3
	for (i = 0; i < (int)req->fieldsz; i++)
		if (0 == strcmp(req->fields[i].key, "key"))
			break;
d488 2
a489 1
	if (i == (int)req->fieldsz)
d491 26
d519 54
a572 2
	/*opt.types = TYPE_NAME | TYPE_DESC;
	apropos_search(&opt, req->fields[i].val, NULL, pg_searchres);*/
d580 12
a591 2
	char		*p;
	char		*path, *subpath, *suffix;
d598 1
a598 1
	suffix = subpath = path = NULL;
d600 1
a600 1
	req.media = MEDIA_HTML;
d605 1
d609 7
a615 3
	if (NULL != path && NULL != (suffix = strrchr(path, '.')))
		if (NULL != suffix && NULL == strchr(suffix, '/'))
			*suffix++ = '\0';
d618 1
a618 1
			*subpath++ = '\0';
d620 1
a620 6
	if (NULL != suffix && '\0' != *suffix)
		for (i = 0; i < (int)MEDIA__MAX; i++)
			if (0 == strcmp(medias[i], suffix)) {
				req.media = (enum media)i;
				break;
			}
d629 7
d638 1
a638 1
		pg_index(&req, subpath);
d641 4
a644 1
		pg_search(&req, subpath);
a646 1
		/* Blah */
d650 1
d652 1
@


1.4
log
@Inventing new keywords for mostly the same thing when a well-established
set of keywords already exists is a bad idea, so reuse the mdoc(7)
macro names as apropos(1) search types.  This is a gain in brevity
as well.  Some time ago, kristaps@@ agreed in principle.

The search type bit field constants are used by both mandocdb(8) and
apropos(1) and should better stay in sync, so give them their own
header file.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.3 2011/11/13 10:12:05 schwarze Exp $ */
d7 1
@


1.3
log
@Less misleading file names; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.2 2011/11/09 22:05:56 kristaps Exp $ */
d10 2
a12 1
#include "mandoc.h"
@


1.2
log
@Make apropos's lookup use a find(1)-like expression.  I'll write more on
this when it completes; this is to keep it in-tree.

Right now this uses prefix notation.  Ignore it.  I'll make this into
infix notation real soon.

The goal of this (exprcomp and exprexec) is to have arbitrary logical
expressions.
@
text
@d1 1
a1 1
/*	$Id: cgi.c,v 1.1 2011/11/09 01:24:23 kristaps Exp $ */
d10 1
a10 1
#include "apropos.h"
@


1.1
log
@Split apropos.c into db.c and apropos.h with simpler code (re-written, but
inspired by apropos.c and mandoc-tools' mandoc-cgi.c).  This uses UTF-8
right now for its re-writing, but will soon accomodate for the regular
suspects (this is a rather simple matter).

I also introduce man.cgi (cgi.c), which is a standalone CGI that replaces
mandoc-tools' mandoc.cgi.  Right now it's just a framework.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.2 2011/11/04 15:53:19 kristaps Exp $ */
d50 1
d52 1
d58 1
d60 1
d71 1
d96 1
d214 1
d233 1
d249 2
a250 2
	opt.types = TYPE_NAME | TYPE_DESC;
	apropos_search(&opt, req->fields[i].val, NULL, pg_searchres);
@
