head	1.191;
access;
symbols
	VERSION_1_13_3:1.185
	VERSION_1_13_2:1.183
	VERSION_1_12_4:1.163
	VERSION_1_13_1:1.159
	VERSION_1_12_3:1.152
	VERSION_1_12_2:1.152
	VERSION_1_12:1.163.0.2
	VERSION_1_12_1:1.150
	VERSION_1_12_0:1.150
	VERSION_1_11_7:1.149
	VERSION_1_11_6:1.149
	VERSION_1_11_5:1.149
	VERSION_1_11_4:1.149
	VERSION_1_11_3:1.147
	VERSION_1_11_2:1.137
	VERSION_1_11_1:1.131
	VERSION_1_10_10:1.129
	VERSION_1_10_9:1.124
	VERSION_1_10_8:1.123
	VERSION_1_10_7:1.113
	VERSION_1_10_6:1.112
	VERSION_1_10_5:1.110
	VERSION_1_10_5_PREPDF:1.109
	VERSION_1_10_4:1.105
	VERSION_1_10_3:1.103
	VERSION_1_10_2:1.102
	VERSION_1_10_1:1.101
	VERSION_1_9_24:1.99
	VERSION_1_9_25:1.99
	VERSION_1_9_23:1.97
	VERSION_1_9_22:1.96
	VERSION_1_9_21:1.96
	VERSION_1_9_20:1.96
	VERSION_1_9_19:1.96
	VERSION_1_9_18:1.96
	VERSION_1_9_17:1.96
	VERSION_1_9_16:1.96
	VERSION_1_9_15:1.96
	VERSION_1_9_15-pre2:1.92
	VERSION_1_9_15-pre1:1.91
	VERSION_1_9_14:1.91
	VERSION_1_9_13:1.80
	VERSION_1_9_12:1.75
	VERSION_1_9_11:1.66
	VERSION_1_9_10:1.66
	VERSION_1_9_9:1.65
	VERSION_1_9_8:1.62
	VERSION_1_9_7:1.62
	VERSION_1_9_6:1.52
	VERSION_1_9_5:1.51
	VERSION_1_8_5:1.28
	VERSION_1_8_1:1.28
	VERSION_1_7_16:1.28
	VERSION_1_7_15:1.28
	OPENBSD_CHECKIN:1.28
	VERSION_1_6_5:1.28
	VERSION_1_5_1:1.28
	VERSION_1_3_15:1.28
	VERSION_1_3_6:1.28
	VERSION_1_2_0:1.28
	VERSION_1_0_2:1.23
	VERSION_1_0_1:1.15;
locks; strict;
comment	@ * @;


1.191
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2015.10.12.00.15.31;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2015.10.12.00.08.15;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2015.09.26.00.54.03;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2015.03.27.21.33.20;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2015.01.21.20.33.25;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2014.12.20.00.20.11;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2014.12.02.10.08.06;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2014.12.01.04.34.06;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2014.10.29.00.17.43;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2014.10.27.16.29.06;	author schwarze;	state Exp;
branches;
next	1.178;

1.178
date	2014.10.27.13.31.04;	author schwarze;	state Exp;
branches;
next	1.177;

1.177
date	2014.10.26.17.12.03;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2014.10.10.15.26.29;	author schwarze;	state Exp;
branches;
next	1.175;

1.175
date	2014.10.10.08.44.24;	author kristaps;	state Exp;
branches;
next	1.174;

1.174
date	2014.09.28.20.14.20;	author kristaps;	state Exp;
branches;
next	1.173;

1.173
date	2014.09.28.11.33.15;	author kristaps;	state Exp;
branches;
next	1.172;

1.172
date	2014.09.27.11.17.19;	author kristaps;	state Exp;
branches;
next	1.171;

1.171
date	2014.09.27.10.56.18;	author kristaps;	state Exp;
branches;
next	1.170;

1.170
date	2014.09.27.09.26.01;	author kristaps;	state Exp;
branches;
next	1.169;

1.169
date	2014.09.27.09.20.03;	author kristaps;	state Exp;
branches;
next	1.168;

1.168
date	2014.09.27.09.13.39;	author kristaps;	state Exp;
branches;
next	1.167;

1.167
date	2014.09.27.09.05.57;	author kristaps;	state Exp;
branches;
next	1.166;

1.166
date	2014.09.27.09.03.24;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2014.09.27.09.02.19;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2014.09.27.08.54.34;	author kristaps;	state Exp;
branches;
next	1.163;

1.163
date	2014.08.14.00.31.43;	author schwarze;	state Exp;
branches;
next	1.162;

1.162
date	2014.08.13.20.34.29;	author kristaps;	state Exp;
branches;
next	1.161;

1.161
date	2014.08.13.15.25.22;	author schwarze;	state Exp;
branches;
next	1.160;

1.160
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.159;

1.159
date	2014.07.23.15.00.08;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2014.07.22.22.41.35;	author schwarze;	state Exp;
branches;
next	1.157;

1.157
date	2014.04.23.16.08.33;	author schwarze;	state Exp;
branches;
next	1.156;

1.156
date	2014.04.20.16.46.04;	author schwarze;	state Exp;
branches;
next	1.155;

1.155
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.154;

1.154
date	2014.01.22.20.58.39;	author schwarze;	state Exp;
branches;
next	1.153;

1.153
date	2014.01.05.19.10.56;	author joerg;	state Exp;
branches;
next	1.152;

1.152
date	2013.08.08.20.07.47;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2012.05.31.22.29.13;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2011.10.05.21.35.17;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2011.07.07.14.34.11;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.04.09.42.38;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2011.05.24.21.40.14;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2011.05.24.21.31.23;	author kristaps;	state Exp;
branches;
next	1.145;

1.145
date	2011.05.18.23.59.08;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2011.05.17.11.50.20;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2011.05.17.11.38.18;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2011.05.17.11.34.31;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2011.05.17.11.19.45;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2011.05.17.10.48.06;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2011.05.15.15.47.46;	author kristaps;	state Exp;
branches;
next	1.138;

1.138
date	2011.05.14.16.28.23;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2011.04.30.22.24.31;	author kristaps;	state Exp;
branches;
next	1.136;

1.136
date	2011.04.30.22.14.42;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2011.04.30.22.14.02;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.30.10.18.24;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2011.04.29.22.18.12;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2011.04.09.15.29.40;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2011.03.22.14.05.45;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2011.03.22.10.13.01;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2011.03.17.09.16.38;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2011.03.17.08.49.34;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2011.01.30.16.05.37;	author schwarze;	state Exp;
branches;
next	1.125;

1.125
date	2011.01.13.14.30.13;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2010.12.27.21.41.05;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2010.12.24.14.14.00;	author kristaps;	state Exp;
branches;
next	1.122;

1.122
date	2010.12.24.00.46.49;	author kristaps;	state Exp;
branches;
next	1.121;

1.121
date	2010.12.22.11.15.16;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2010.12.20.13.07.55;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.20.10.40.11;	author kristaps;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.17.10.37.26;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.17.08.17.40;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.15.17.19.41;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.15.15.59.23;	author kristaps;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.15.14.52.16;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2010.10.01.21.51.13;	author schwarze;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.04.20.18.53;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2010.07.26.22.26.05;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2010.07.23.00.08.57;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2010.07.21.20.35.03;	author kristaps;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.16.22.33.30;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.13.23.53.20;	author schwarze;	state Exp;
branches;
next	1.105;

1.105
date	2010.07.06.12.37.17;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.06.11.10.53;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2010.06.25.19.50.23;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2010.06.19.20.46.27;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.07.10.52.44;	author kristaps;	state Exp;
branches;
next	1.100;

1.100
date	2010.05.25.12.37.20;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.12.19.45.39;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.08.07.05.38;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2010.04.03.12.46.35;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2010.02.17.19.48.33;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2010.01.30.08.42.20;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2010.01.30.06.55.56;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2010.01.29.14.39.37;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2010.01.01.17.14.27;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2009.11.16.08.46.58;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2009.11.16.06.07.49;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2009.11.15.06.45.31;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2009.11.14.19.23.58;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.14.12.04.59;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2009.11.14.12.00.24;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2009.11.14.11.58.36;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.12.08.21.05;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.10.16.32.00;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2009.11.09.05.11.46;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.05.10.16.01;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2009.11.02.06.22.44;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2009.11.01.15.34.44;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2009.11.01.15.34.15;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.01.08.15.20;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.01.07.44.32;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2009.10.31.06.10.57;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2009.10.30.18.53.08;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2009.10.30.18.50.11;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.30.18.43.24;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2009.10.30.04.57.17;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2009.10.28.08.00.18;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2009.10.28.06.54.12;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2009.10.28.05.08.17;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.27.04.50.14;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2009.10.26.08.18.15;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2009.10.20.05.45.21;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.13.10.57.25;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.13.10.21.24;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.09.06.54.11;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.07.15.27.11;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.07.15.06.03;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.07.14.39.00;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.07.12.35.23;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.04.09.02.40;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2009.10.03.16.37.23;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2009.10.03.16.36.06;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.03.15.26.26;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.03.15.08.09;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.09.24.09.50.31;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.09.21.14.56.56;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.09.21.14.40.31;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.21.14.08.13;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.09.21.14.07.07;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.09.21.13.47.40;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.09.21.13.44.56;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.09.21.13.43.21;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.09.21.13.42.01;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.21.13.06.13;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.21.09.32.30;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.21.00.39.02;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.20.19.44.16;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.20.19.25.06;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.20.17.48.13;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.20.17.24.57;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.20.13.43.31;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.20.11.05.22;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.17.23.35.41;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.17.13.17.30;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.17.08.21.42;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.17.07.41.28;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.16.22.17.27;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.16.09.41.24;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.15.01.54.58;	author kristaps;	state dead;
branches;
next	1.27;

1.27
date	2008.12.12.10.11.10;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.10.17.40.56;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.10.17.31.57;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.10.13.41.58;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.10.12.09.47;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.10.12.05.33;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.10.10.43.57;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.10.00.58.15;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.10.00.52.46;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.09.19.57.26;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.09.17.09.12;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.08.16.29.57;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.08.12.46.28;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.07.21.30.49;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.06.21.10.31;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.06.19.41.41;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.05.22.54.44;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.05.22.34.30;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.05.19.45.15;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.05.17.43.14;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.05.11.28.16;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.04.23.10.51;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.04.16.19.52;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.04.11.25.29;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.03.21.27.56;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.03.19.21.58;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.03.14.39.59;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.191
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@/*	$Id: html.c,v 1.190 2015/10/12 00:15:31 schwarze Exp $ */
/*
 * Copyright (c) 2008-2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011-2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "out.h"
#include "html.h"
#include "manconf.h"
#include "main.h"

struct	htmldata {
	const char	 *name;
	int		  flags;
#define	HTML_CLRLINE	 (1 << 0)
#define	HTML_NOSTACK	 (1 << 1)
#define	HTML_AUTOCLOSE	 (1 << 2) /* Tag has auto-closure. */
};

static	const struct htmldata htmltags[TAG_MAX] = {
	{"html",	HTML_CLRLINE}, /* TAG_HTML */
	{"head",	HTML_CLRLINE}, /* TAG_HEAD */
	{"body",	HTML_CLRLINE}, /* TAG_BODY */
	{"meta",	HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_META */
	{"title",	HTML_CLRLINE}, /* TAG_TITLE */
	{"div",		HTML_CLRLINE}, /* TAG_DIV */
	{"h1",		0}, /* TAG_H1 */
	{"h2",		0}, /* TAG_H2 */
	{"span",	0}, /* TAG_SPAN */
	{"link",	HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_LINK */
	{"br",		HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_BR */
	{"a",		0}, /* TAG_A */
	{"table",	HTML_CLRLINE}, /* TAG_TABLE */
	{"tbody",	HTML_CLRLINE}, /* TAG_TBODY */
	{"col",		HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_COL */
	{"tr",		HTML_CLRLINE}, /* TAG_TR */
	{"td",		HTML_CLRLINE}, /* TAG_TD */
	{"li",		HTML_CLRLINE}, /* TAG_LI */
	{"ul",		HTML_CLRLINE}, /* TAG_UL */
	{"ol",		HTML_CLRLINE}, /* TAG_OL */
	{"dl",		HTML_CLRLINE}, /* TAG_DL */
	{"dt",		HTML_CLRLINE}, /* TAG_DT */
	{"dd",		HTML_CLRLINE}, /* TAG_DD */
	{"blockquote",	HTML_CLRLINE}, /* TAG_BLOCKQUOTE */
	{"pre",		HTML_CLRLINE }, /* TAG_PRE */
	{"b",		0 }, /* TAG_B */
	{"i",		0 }, /* TAG_I */
	{"code",	0 }, /* TAG_CODE */
	{"small",	0 }, /* TAG_SMALL */
	{"style",	HTML_CLRLINE}, /* TAG_STYLE */
	{"math",	HTML_CLRLINE}, /* TAG_MATH */
	{"mrow",	0}, /* TAG_MROW */
	{"mi",		0}, /* TAG_MI */
	{"mo",		0}, /* TAG_MO */
	{"msup",	0}, /* TAG_MSUP */
	{"msub",	0}, /* TAG_MSUB */
	{"msubsup",	0}, /* TAG_MSUBSUP */
	{"mfrac",	0}, /* TAG_MFRAC */
	{"msqrt",	0}, /* TAG_MSQRT */
	{"mfenced",	0}, /* TAG_MFENCED */
	{"mtable",	0}, /* TAG_MTABLE */
	{"mtr",		0}, /* TAG_MTR */
	{"mtd",		0}, /* TAG_MTD */
	{"munderover",	0}, /* TAG_MUNDEROVER */
	{"munder",	0}, /* TAG_MUNDER*/
	{"mover",	0}, /* TAG_MOVER*/
};

static	const char	*const htmlattrs[ATTR_MAX] = {
	"name", /* ATTR_NAME */
	"rel", /* ATTR_REL */
	"href", /* ATTR_HREF */
	"type", /* ATTR_TYPE */
	"media", /* ATTR_MEDIA */
	"class", /* ATTR_CLASS */
	"style", /* ATTR_STYLE */
	"id", /* ATTR_ID */
	"colspan", /* ATTR_COLSPAN */
	"charset", /* ATTR_CHARSET */
	"open", /* ATTR_OPEN */
	"close", /* ATTR_CLOSE */
	"mathvariant", /* ATTR_MATHVARIANT */
};

static	const char	*const roffscales[SCALE_MAX] = {
	"cm", /* SCALE_CM */
	"in", /* SCALE_IN */
	"pc", /* SCALE_PC */
	"pt", /* SCALE_PT */
	"em", /* SCALE_EM */
	"em", /* SCALE_MM */
	"ex", /* SCALE_EN */
	"ex", /* SCALE_BU */
	"em", /* SCALE_VS */
	"ex", /* SCALE_FS */
};

static	void	 bufncat(struct html *, const char *, size_t);
static	void	 print_ctag(struct html *, struct tag *);
static	int	 print_escape(char);
static	int	 print_encode(struct html *, const char *, int);
static	void	 print_metaf(struct html *, enum mandoc_esc);
static	void	 print_attr(struct html *, const char *, const char *);


void *
html_alloc(const struct manoutput *outopts)
{
	struct html	*h;

	h = mandoc_calloc(1, sizeof(struct html));

	h->tags.head = NULL;
	h->style = outopts->style;
	h->base_man = outopts->man;
	h->base_includes = outopts->includes;
	if (outopts->fragment)
		h->oflags |= HTML_FRAGMENT;

	return h;
}

void
html_free(void *p)
{
	struct tag	*tag;
	struct html	*h;

	h = (struct html *)p;

	while ((tag = h->tags.head) != NULL) {
		h->tags.head = tag->next;
		free(tag);
	}

	free(h);
}

void
print_gen_head(struct html *h)
{
	struct htmlpair	 tag[4];
	struct tag	*t;

	tag[0].key = ATTR_CHARSET;
	tag[0].val = "utf-8";
	print_otag(h, TAG_META, 1, tag);

	/*
	 * Print a default style-sheet.
	 */
	t = print_otag(h, TAG_STYLE, 0, NULL);
	print_text(h, "table.head, table.foot { width: 100%; }\n"
	      "td.head-rtitle, td.foot-os { text-align: right; }\n"
	      "td.head-vol { text-align: center; }\n"
	      "table.foot td { width: 50%; }\n"
	      "table.head td { width: 33%; }\n"
	      "div.spacer { margin: 1em 0; }\n");
	print_tagq(h, t);

	if (h->style) {
		tag[0].key = ATTR_REL;
		tag[0].val = "stylesheet";
		tag[1].key = ATTR_HREF;
		tag[1].val = h->style;
		tag[2].key = ATTR_TYPE;
		tag[2].val = "text/css";
		tag[3].key = ATTR_MEDIA;
		tag[3].val = "all";
		print_otag(h, TAG_LINK, 4, tag);
	}
}

static void
print_metaf(struct html *h, enum mandoc_esc deco)
{
	enum htmlfont	 font;

	switch (deco) {
	case ESCAPE_FONTPREV:
		font = h->metal;
		break;
	case ESCAPE_FONTITALIC:
		font = HTMLFONT_ITALIC;
		break;
	case ESCAPE_FONTBOLD:
		font = HTMLFONT_BOLD;
		break;
	case ESCAPE_FONTBI:
		font = HTMLFONT_BI;
		break;
	case ESCAPE_FONT:
	case ESCAPE_FONTROMAN:
		font = HTMLFONT_NONE;
		break;
	default:
		abort();
	}

	if (h->metaf) {
		print_tagq(h, h->metaf);
		h->metaf = NULL;
	}

	h->metal = h->metac;
	h->metac = font;

	switch (font) {
	case HTMLFONT_ITALIC:
		h->metaf = print_otag(h, TAG_I, 0, NULL);
		break;
	case HTMLFONT_BOLD:
		h->metaf = print_otag(h, TAG_B, 0, NULL);
		break;
	case HTMLFONT_BI:
		h->metaf = print_otag(h, TAG_B, 0, NULL);
		print_otag(h, TAG_I, 0, NULL);
		break;
	default:
		break;
	}
}

int
html_strlen(const char *cp)
{
	size_t		 rsz;
	int		 skip, sz;

	/*
	 * Account for escaped sequences within string length
	 * calculations.  This follows the logic in term_strlen() as we
	 * must calculate the width of produced strings.
	 * Assume that characters are always width of "1".  This is
	 * hacky, but it gets the job done for approximation of widths.
	 */

	sz = 0;
	skip = 0;
	while (1) {
		rsz = strcspn(cp, "\\");
		if (rsz) {
			cp += rsz;
			if (skip) {
				skip = 0;
				rsz--;
			}
			sz += rsz;
		}
		if ('\0' == *cp)
			break;
		cp++;
		switch (mandoc_escape(&cp, NULL, NULL)) {
		case ESCAPE_ERROR:
			return sz;
		case ESCAPE_UNICODE:
		case ESCAPE_NUMBERED:
		case ESCAPE_SPECIAL:
		case ESCAPE_OVERSTRIKE:
			if (skip)
				skip = 0;
			else
				sz++;
			break;
		case ESCAPE_SKIPCHAR:
			skip = 1;
			break;
		default:
			break;
		}
	}
	return sz;
}

static int
print_escape(char c)
{

	switch (c) {
	case '<':
		printf("&lt;");
		break;
	case '>':
		printf("&gt;");
		break;
	case '&':
		printf("&amp;");
		break;
	case '"':
		printf("&quot;");
		break;
	case ASCII_NBRSP:
		printf("&nbsp;");
		break;
	case ASCII_HYPH:
		putchar('-');
		break;
	case ASCII_BREAK:
		break;
	default:
		return 0;
	}
	return 1;
}

static int
print_encode(struct html *h, const char *p, int norecurse)
{
	size_t		 sz;
	int		 c, len, nospace;
	const char	*seq;
	enum mandoc_esc	 esc;
	static const char rejs[9] = { '\\', '<', '>', '&', '"',
		ASCII_NBRSP, ASCII_HYPH, ASCII_BREAK, '\0' };

	nospace = 0;

	while ('\0' != *p) {
		if (HTML_SKIPCHAR & h->flags && '\\' != *p) {
			h->flags &= ~HTML_SKIPCHAR;
			p++;
			continue;
		}

		sz = strcspn(p, rejs);

		fwrite(p, 1, sz, stdout);
		p += (int)sz;

		if ('\0' == *p)
			break;

		if (print_escape(*p++))
			continue;

		esc = mandoc_escape(&p, &seq, &len);
		if (ESCAPE_ERROR == esc)
			break;

		switch (esc) {
		case ESCAPE_FONT:
		case ESCAPE_FONTPREV:
		case ESCAPE_FONTBOLD:
		case ESCAPE_FONTITALIC:
		case ESCAPE_FONTBI:
		case ESCAPE_FONTROMAN:
			if (0 == norecurse)
				print_metaf(h, esc);
			continue;
		case ESCAPE_SKIPCHAR:
			h->flags |= HTML_SKIPCHAR;
			continue;
		default:
			break;
		}

		if (h->flags & HTML_SKIPCHAR) {
			h->flags &= ~HTML_SKIPCHAR;
			continue;
		}

		switch (esc) {
		case ESCAPE_UNICODE:
			/* Skip past "u" header. */
			c = mchars_num2uc(seq + 1, len - 1);
			break;
		case ESCAPE_NUMBERED:
			c = mchars_num2char(seq, len);
			if (c < 0)
				continue;
			break;
		case ESCAPE_SPECIAL:
			c = mchars_spec2cp(seq, len);
			if (c <= 0)
				continue;
			break;
		case ESCAPE_NOSPACE:
			if ('\0' == *p)
				nospace = 1;
			continue;
		case ESCAPE_OVERSTRIKE:
			if (len == 0)
				continue;
			c = seq[len - 1];
			break;
		default:
			continue;
		}
		if ((c < 0x20 && c != 0x09) ||
		    (c > 0x7E && c < 0xA0))
			c = 0xFFFD;
		if (c > 0x7E)
			printf("&#%d;", c);
		else if ( ! print_escape(c))
			putchar(c);
	}

	return nospace;
}

static void
print_attr(struct html *h, const char *key, const char *val)
{
	printf(" %s=\"", key);
	(void)print_encode(h, val, 1);
	putchar('\"');
}

struct tag *
print_otag(struct html *h, enum htmltag tag,
		int sz, const struct htmlpair *p)
{
	int		 i;
	struct tag	*t;

	/* Push this tags onto the stack of open scopes. */

	if ( ! (HTML_NOSTACK & htmltags[tag].flags)) {
		t = mandoc_malloc(sizeof(struct tag));
		t->tag = tag;
		t->next = h->tags.head;
		h->tags.head = t;
	} else
		t = NULL;

	if ( ! (HTML_NOSPACE & h->flags))
		if ( ! (HTML_CLRLINE & htmltags[tag].flags)) {
			/* Manage keeps! */
			if ( ! (HTML_KEEP & h->flags)) {
				if (HTML_PREKEEP & h->flags)
					h->flags |= HTML_KEEP;
				putchar(' ');
			} else
				printf("&#160;");
		}

	if ( ! (h->flags & HTML_NONOSPACE))
		h->flags &= ~HTML_NOSPACE;
	else
		h->flags |= HTML_NOSPACE;

	/* Print out the tag name and attributes. */

	printf("<%s", htmltags[tag].name);
	for (i = 0; i < sz; i++)
		print_attr(h, htmlattrs[p[i].key], p[i].val);

	/* Accommodate for "well-formed" singleton escaping. */

	if (HTML_AUTOCLOSE & htmltags[tag].flags)
		putchar('/');

	putchar('>');

	h->flags |= HTML_NOSPACE;

	if ((HTML_AUTOCLOSE | HTML_CLRLINE) & htmltags[tag].flags)
		putchar('\n');

	return t;
}

static void
print_ctag(struct html *h, struct tag *tag)
{

	/*
	 * Remember to close out and nullify the current
	 * meta-font and table, if applicable.
	 */
	if (tag == h->metaf)
		h->metaf = NULL;
	if (tag == h->tblt)
		h->tblt = NULL;

	printf("</%s>", htmltags[tag->tag].name);
	if (HTML_CLRLINE & htmltags[tag->tag].flags) {
		h->flags |= HTML_NOSPACE;
		putchar('\n');
	}

	h->tags.head = tag->next;
	free(tag);
}

void
print_gen_decls(struct html *h)
{

	puts("<!DOCTYPE html>");
}

void
print_text(struct html *h, const char *word)
{

	if ( ! (HTML_NOSPACE & h->flags)) {
		/* Manage keeps! */
		if ( ! (HTML_KEEP & h->flags)) {
			if (HTML_PREKEEP & h->flags)
				h->flags |= HTML_KEEP;
			putchar(' ');
		} else
			printf("&#160;");
	}

	assert(NULL == h->metaf);
	switch (h->metac) {
	case HTMLFONT_ITALIC:
		h->metaf = print_otag(h, TAG_I, 0, NULL);
		break;
	case HTMLFONT_BOLD:
		h->metaf = print_otag(h, TAG_B, 0, NULL);
		break;
	case HTMLFONT_BI:
		h->metaf = print_otag(h, TAG_B, 0, NULL);
		print_otag(h, TAG_I, 0, NULL);
		break;
	default:
		break;
	}

	assert(word);
	if ( ! print_encode(h, word, 0)) {
		if ( ! (h->flags & HTML_NONOSPACE))
			h->flags &= ~HTML_NOSPACE;
		h->flags &= ~HTML_NONEWLINE;
	} else
		h->flags |= HTML_NOSPACE | HTML_NONEWLINE;

	if (h->metaf) {
		print_tagq(h, h->metaf);
		h->metaf = NULL;
	}

	h->flags &= ~HTML_IGNDELIM;
}

void
print_tagq(struct html *h, const struct tag *until)
{
	struct tag	*tag;

	while ((tag = h->tags.head) != NULL) {
		print_ctag(h, tag);
		if (until && tag == until)
			return;
	}
}

void
print_stagq(struct html *h, const struct tag *suntil)
{
	struct tag	*tag;

	while ((tag = h->tags.head) != NULL) {
		if (suntil && tag == suntil)
			return;
		print_ctag(h, tag);
	}
}

void
print_paragraph(struct html *h)
{
	struct tag	*t;
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "spacer");
	t = print_otag(h, TAG_DIV, 1, &tag);
	print_tagq(h, t);
}


void
bufinit(struct html *h)
{

	h->buf[0] = '\0';
	h->buflen = 0;
}

void
bufcat_style(struct html *h, const char *key, const char *val)
{

	bufcat(h, key);
	bufcat(h, ":");
	bufcat(h, val);
	bufcat(h, ";");
}

void
bufcat(struct html *h, const char *p)
{

	/*
	 * XXX This is broken and not easy to fix.
	 * When using the -Oincludes option, buffmt_includes()
	 * may pass in strings overrunning BUFSIZ, causing a crash.
	 */

	h->buflen = strlcat(h->buf, p, BUFSIZ);
	assert(h->buflen < BUFSIZ);
}

void
bufcat_fmt(struct html *h, const char *fmt, ...)
{
	va_list		 ap;

	va_start(ap, fmt);
	(void)vsnprintf(h->buf + (int)h->buflen,
	    BUFSIZ - h->buflen - 1, fmt, ap);
	va_end(ap);
	h->buflen = strlen(h->buf);
}

static void
bufncat(struct html *h, const char *p, size_t sz)
{

	assert(h->buflen + sz + 1 < BUFSIZ);
	strncat(h->buf, p, sz);
	h->buflen += sz;
}

void
buffmt_includes(struct html *h, const char *name)
{
	const char	*p, *pp;

	pp = h->base_includes;

	bufinit(h);
	while (NULL != (p = strchr(pp, '%'))) {
		bufncat(h, pp, (size_t)(p - pp));
		switch (*(p + 1)) {
		case'I':
			bufcat(h, name);
			break;
		default:
			bufncat(h, p, 2);
			break;
		}
		pp = p + 2;
	}
	if (pp)
		bufcat(h, pp);
}

void
buffmt_man(struct html *h, const char *name, const char *sec)
{
	const char	*p, *pp;

	pp = h->base_man;

	bufinit(h);
	while (NULL != (p = strchr(pp, '%'))) {
		bufncat(h, pp, (size_t)(p - pp));
		switch (*(p + 1)) {
		case 'S':
			bufcat(h, sec ? sec : "1");
			break;
		case 'N':
			bufcat_fmt(h, "%s", name);
			break;
		default:
			bufncat(h, p, 2);
			break;
		}
		pp = p + 2;
	}
	if (pp)
		bufcat(h, pp);
}

void
bufcat_su(struct html *h, const char *p, const struct roffsu *su)
{
	double		 v;

	v = su->scale;
	if (SCALE_MM == su->unit && 0.0 == (v /= 100.0))
		v = 1.0;
	else if (SCALE_BU == su->unit)
		v /= 24.0;

	bufcat_fmt(h, "%s: %.2f%s;", p, v, roffscales[su->unit]);
}

void
bufcat_id(struct html *h, const char *src)
{

	/* Cf. <http://www.w3.org/TR/html4/types.html#h-6.2>. */

	while ('\0' != *src)
		bufcat_fmt(h, "%.2x", *src++);
}
@


1.190
log
@Fix an obvious bug found during the /* FALLTHROUGH */ cleanup:
ASCII_NBRSP has to be rendered as "&nbsp;", not "-".
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.189 2015/10/12 00:08:15 schwarze Exp $ */
d133 1
a133 1
html_alloc(const struct mchars *mchars, const struct manoutput *outopts)
a139 2
	h->symtab = mchars;

d399 1
a399 1
			c = mchars_spec2cp(h->symtab, seq, len);
@


1.189
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.188 2015/10/06 18:32:19 schwarze Exp $ */
d321 1
a321 1
		putchar('-');
@


1.188
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.187 2015/09/26 00:54:03 schwarze Exp $ */
a220 1
		/* FALLTHROUGH */
a284 1
			/* FALLTHROUGH */
a285 1
			/* FALLTHROUGH */
a286 1
			/* FALLTHROUGH */
d325 1
a325 1
		/* FALLTHROUGH */
a369 1
			/* FALLTHROUGH */
a370 1
			/* FALLTHROUGH */
a371 1
			/* FALLTHROUGH */
a372 1
			/* FALLTHROUGH */
a373 1
			/* FALLTHROUGH */
@


1.187
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.186 2015/03/27 21:33:20 schwarze Exp $ */
d148 1
a148 1
	return(h);
d284 1
a284 1
			return(sz);
d304 1
a304 1
	return(sz);
d333 1
a333 1
		return(0);
d335 1
a335 1
	return(1);
d435 1
a435 1
	return(nospace);
d497 1
a497 1
	return(t);
@


1.186
log
@Actually use the new man.conf(5) "output" directive.
Additional functionality, yet minus 45 lines of code.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.185 2015/01/21 20:33:25 schwarze Exp $ */
a226 1
		/* NOTREACHED */
@


1.185
log
@Rudimentary implementation of the roff(7) \o escape sequence (overstrike).
This is of some relevance because the pod2man(1) preamble abuses it
for the icelandic letter Thorn, instead of simply using \(TP and \(Tp.
Missing feature found by sthen@@ in DateTime::Locale::is_IS(3p).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.184 2014/12/20 00:20:11 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d35 1
d133 1
a133 1
html_alloc(const struct mchars *mchars, char *outopts)
a135 8
	const char	*toks[5];
	char		*v;

	toks[0] = "style";
	toks[1] = "man";
	toks[2] = "includes";
	toks[3] = "fragment";
	toks[4] = NULL;
d142 5
a146 17
	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case 0:
			h->style = v;
			break;
		case 1:
			h->base_man = v;
			break;
		case 2:
			h->base_includes = v;
			break;
		case 3:
			h->oflags |= HTML_FRAGMENT;
			break;
		default:
			break;
		}
@


1.184
log
@resolve some code duplication; no functional change
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.183 2014/12/02 10:08:06 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d310 2
d438 5
@


1.183
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.182 2014/12/01 04:34:06 schwarze Exp $ */
d124 1
a124 1
static	void	 print_ctag(struct html *, enum htmltag);
d514 1
a514 1
print_ctag(struct html *h, enum htmltag tag)
d517 11
a527 2
	printf("</%s>", htmltags[tag].name);
	if (HTML_CLRLINE & htmltags[tag].flags) {
d531 3
d595 1
a595 11
		/*
		 * Remember to close out and nullify the current
		 * meta-font and table, if applicable.
		 */
		if (tag == h->metaf)
			h->metaf = NULL;
		if (tag == h->tblt)
			h->tblt = NULL;
		print_ctag(h, tag->tag);
		h->tags.head = tag->next;
		free(tag);
d609 1
a609 11
		/*
		 * Remember to close out and nullify the current
		 * meta-font and table, if applicable.
		 */
		if (tag == h->metaf)
			h->metaf = NULL;
		if (tag == h->tblt)
			h->tblt = NULL;
		print_ctag(h, tag->tag);
		h->tags.head = tag->next;
		free(tag);
@


1.182
log
@The header libmandoc.h is part of the internal parser interface,
but html.c is not part of the parser at all, so it cannot include
that header, and actually, it doesn't need it.
Found while auditing includes after Theo's recent *.h commit.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.181 2014/10/29 00:17:43 schwarze Exp $ */
d565 1
d567 1
a567 1
		h->flags |= HTML_NOSPACE;
@


1.181
log
@In terminal output, unify handling of Unicode and numbered character
escape sequences just like it was earlier implemented for -Thtml.
Do not let control characters other than ASCII 9 (horizontal tab)
propagate to the output, even though groff allows them; but that
really doesn't look like a great idea.

Let mchars_num2char() return int such that we can distinguish invalid \N
syntax from \N'0'.  This also reduces the danger of signed char issues
popping up.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.180 2014/10/28 17:36:19 schwarze Exp $ */
a32 1
#include "libmandoc.h"
@


1.180
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.179 2014/10/27 16:29:06 schwarze Exp $ */
d425 2
d430 2
d440 2
a441 3
		if (c <= 0)
			continue;
		if (c < 0x20 || (c > 0x7E && c < 0xA0))
@


1.179
log
@Handle output encoding for unicode, numbered and named escape sequences
in one common, safe way instead of three different ways.  In particular,
* skip NUL, it is used to mean "no output desired"
* deny 0x01-0x1F and 0x7F-0x9F, print REPLACEMENT CHARACTER instead
* print 0x20-0x7E literally or name-encoded, as required
* print characters above 0x9F numerically
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.178 2014/10/27 13:31:04 schwarze Exp $ */
a129 1
static	void	 *ml_alloc(char *);
d132 2
a133 2
static void *
ml_alloc(char *outopts)
d148 1
a148 1
	h->symtab = mchars_alloc();
a170 14
void *
html_alloc(char *outopts)
{

	return(ml_alloc(outopts));
}

void *
xhtml_alloc(char *outopts)
{

	return(ml_alloc(outopts));
}

a183 3
	if (h->symtab)
		mchars_free(h->symtab);

@


1.178
log
@Fix a regression in term.c rev. 1.229 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.177 2014/10/26 17:12:03 schwarze Exp $ */
a439 12

			/*
			 * XXX Security warning:
			 * For now, forbid Unicode obfuscation of ASCII
			 * characters.  An audit of the callers is
			 * required before this can be removed.
			 */

			if (c < 0x80)
				c = 0xFFFD;

			printf("&#x%x;", c);
a442 2
			if ( ! ('\0' == c || print_escape(c)))
				putchar(c);
a445 6
			if (c <= 0)
				break;
			if (c < 0x20 || c > 0x7e)
				printf("&#%d;", c);
			else if ( ! print_escape(c))
				putchar(c);
d450 1
a450 1
			break;
d452 1
a452 1
			break;
d454 8
@


1.177
log
@Improve -Tascii output for Unicode escape sequences: For the first 512
code points, provide ASCII approximations.  This is already much better
than what groff does, which prints nothing for most code points.

A few minor fixes while here:
* Handle Unicode escape sequences in the ASCII range.
* In case of errors, use the REPLACEMENT CHARACTER U+FFFD for -Tutf8
and the string "<?>" for -Tascii output.
* Handle all one-character escape sequences in mchars_spec2{cp,str}()
and remove the workarounds on the higher level.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.176 2014/10/10 15:26:29 schwarze Exp $ */
d460 3
a462 1
			if (c > 0)
d464 2
a465 3
			else if (-1 == c && 1 == len &&
			    !print_escape(*seq))
				putchar((int)*seq);
@


1.176
log
@sync Copyright years after merge to OpenBSD; no code change
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.175 2014/10/10 08:44:24 kristaps Exp $ */
d440 12
a451 2
			if ('\0' != c)
				printf("&#x%x;", c);
@


1.175
log
@Re-write of eqn(7) parser and MathML output.
This adds parser-level support for the grammar described by the eqn
second-edition technical paper, "Typesetting Mathematics — User's Guide"
(Kernighan, Cherry).
The reason for this re-write is the grouping rules, which were not
possible given the existing implementation.
The re-write has also considerably simplified the HTML (and, if it ever
is completed, terminal) front-end.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.174 2014/09/28 20:14:20 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.174
log
@Change "to" and "from" commands to use munder, mover, and munderover.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.173 2014/09/28 11:33:15 kristaps Exp $ */
d108 1
@


1.173
log
@Add support for some MathML elements and attributes in our HTML5.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.172 2014/09/27 11:17:19 kristaps Exp $ */
d90 3
@


1.172
log
@Don't pretend we have a separate XHTML and HTML mode any more.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.171 2014/09/27 10:56:18 kristaps Exp $ */
d77 13
d103 2
@


1.171
log
@Remove <p> in favour of <div class="spacer">.
This is good because <p> is brittle: it can't appear within other block
macros.
This fixes a regression of the original HTML5 patch as noted by schwarze@@
on the tech@@ list, 14/8/2014.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.170 2014/09/27 09:26:01 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d111 1
a111 1
static	void	 *ml_alloc(char *, enum htmltype);
d115 1
a115 1
ml_alloc(char *outopts, enum htmltype type)
a128 1
	h->type = type;
d157 1
a157 1
	return(ml_alloc(outopts, HTML_HTML_4_01_STRICT));
d164 1
a164 1
	return(ml_alloc(outopts, HTML_XHTML_1_0_STRICT));
d496 1
a496 1
	/* Accommodate for XML "well-formed" singleton escaping. */
d499 1
a499 7
		switch (h->type) {
		case HTML_XHTML_1_0_STRICT:
			putchar('/');
			break;
		default:
			break;
		}
@


1.170
log
@Remove last hard-coded width attribute.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.169 2014/09/27 09:20:03 kristaps Exp $ */
a70 1
	{"p",		HTML_CLRLINE | HTML_NOSTACK | HTML_AUTOCLOSE}, /* TAG_P */
d205 2
a206 1
	      "table.head td { width: 33%; }\n");
d626 12
@


1.169
log
@HTML5-isation: remove more alignments.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.168 2014/09/27 09:13:39 kristaps Exp $ */
a87 1
	"width", /* ATTR_WIDTH */
d204 3
a206 1
	      "td.head-vol { text-align: center; }\n");
@


1.168
log
@Continue in HTML5-ing by kicking out some hard-coded alignments.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.167 2014/09/27 09:05:57 kristaps Exp $ */
a89 1
	"align", /* ATTR_ALIGN */
d204 2
a205 1
	      "td.head-rtitle, td.foot-os { text-align: right; }\n");
@


1.167
log
@Kick out "summary" attribute, which isn't HTML5.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.166 2014/09/27 09:03:24 kristaps Exp $ */
d200 3
d204 2
a205 1
	print_text(h, "table.head, table.foot { width: 100%; }\n");
@


1.166
log
@Kick out two attibutes we don't use any more in HTML5.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.165 2014/09/27 09:02:19 kristaps Exp $ */
a89 1
	"summary", /* ATTR_SUMMARY */
@


1.165
log
@First, add space for default styling for HTML5 (non-fragment) output.
This uses a <style /> block right before the <link /> for the stylesheet.
Use this to kick out hardcoded header and footer table widths.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.164 2014/09/27 08:54:34 kristaps Exp $ */
a80 2
	"http-equiv", /* ATTR_HTTPEQUIV */
	"content", /* ATTR_CONTENT */
@


1.164
log
@First steps in HTML5: use UTF8 meta-charset and HTML5 doctype identifier.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.163 2014/08/14 00:31:43 schwarze Exp $ */
d77 1
d197 1
d203 4
@


1.163
log
@Revert previous, as requested by kristaps@@.
The .Bf block can contain subblocks, so it has to render as an
element that can contain flow content.  But <em> cannot contain
flow content, only phrasing content.  Rendering .Em and .Bf differently
would by unfortunate, and closing out .Bf before subblocks and
re-opening it afterwards would merely complicate both the C code
of the program and the generated HTML code.  Besides, converting
.Em to semantic HTML markup would require some content to be put
into <em> and some into <i>, but we cannot automatically distinguish
which is which, so strictly speaking, we can't use semantic HTML
here but have to fall back to physical markup.  Wonders of HTML...
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.162 2014/08/13 20:34:29 kristaps Exp $ */
d94 1
d197 3
a199 11
	tag[0].key = ATTR_HTTPEQUIV;
	tag[0].val = "Content-Type";
	tag[1].key = ATTR_CONTENT;
	tag[1].val = "text/html; charset=utf-8";
	print_otag(h, TAG_META, 2, tag);

	tag[0].key = ATTR_NAME;
	tag[0].val = "resource-type";
	tag[1].key = ATTR_CONTENT;
	tag[1].val = "document";
	print_otag(h, TAG_META, 2, tag);
a488 8
	/* Add non-overridable attributes. */

	if (TAG_HTML == tag && HTML_XHTML_1_0_STRICT == h->type) {
		print_attr(h, "xmlns", "http://www.w3.org/1999/xhtml");
		print_attr(h, "xml:lang", "en");
		print_attr(h, "lang", "en");
	}

a523 17
	const char	*doctype;
	const char	*dtd;
	const char	*name;

	switch (h->type) {
	case HTML_HTML_4_01_STRICT:
		name = "HTML";
		doctype = "-//W3C//DTD HTML 4.01//EN";
		dtd = "http://www.w3.org/TR/html4/strict.dtd";
		break;
	default:
		puts("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
		name = "html";
		doctype = "-//W3C//DTD XHTML 1.0 Strict//EN";
		dtd = "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd";
		break;
	}
d525 1
a525 2
	printf("<!DOCTYPE %s PUBLIC \"%s\" \"%s\">\n",
	    name, doctype, dtd);
@


1.162
log
@Begin cleaning up scaling units.
Start with the horizontal terminal specifiers, making sure that they match
up with troff.
Then move on to PS, PDF, and HTML, noting that we stick to the terminal
default width for "u".
Lastly, fix some completely-wrong documentation and note that we diverge
from troff w/r/t "u".
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.161 2014/08/13 15:25:22 schwarze Exp $ */
a76 1
	{"em",		0 }, /* TAG_EM */
@


1.161
log
@Use <em> for .Em and .Bf -emphasis.

The vast majority of .Em in real-world manuals is stress emphasis,
for which <em> is the correct markup.  Admittedly, there are some
instances of .Em usage for alternate quality, for which <i> would
be a better match.  Most of these are technical terms that neither
allow semantic markup nor are keywords - for the latter, .Sy would
be preferable.  A typical example is that the shell breaks input into
.Em words .
Alternate voice or mood, which would also require <i>, is almost
absent from manuals.
We cannot satisfy both stress emphasis and alternate quality, so
pick the one that fits more often and looks less wrong when off.

Patch from Guy Harris <guy at alum dot mit dot edu>.
ok joerg@@ bentley@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.160 2014/08/10 23:54:41 schwarze Exp $ */
d763 2
@


1.160
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.159 2014/07/23 15:00:08 schwarze Exp $ */
d77 1
@


1.159
log
@Security fix:
After decoding numeric (\N) and one-character (\<, \> etc.)
character escape sequences, do not forget to HTML-encode the
resulting ASCII character.  Malicious manuals were able to smuggle
XSS content by roff-escaping the HTML-special characters they need.
That's a classic bug type in many web applications, actually...  :-(

Found myself while auditing the HTML formatter for safe output handling.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.158 2014/07/22 22:41:35 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
@


1.158
log
@Security fix:
The function print_encode() is used both for plain text
and for quoted attribute values.
Escape the '"' character such that malicious manuals cannot pull off
XSS attacks using malformed .Lk, .Mt, .%U, and .UR macros (and maybe
others) to trigger the latter case.
In the former case, escaping does no harm.
Issue found by Sebastien Marie <semarie-openbsd at latrappe dot fr>.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.157 2014/04/23 16:08:33 schwarze Exp $ */
d113 1
d328 31
d385 1
a385 15
		switch (*p++) {
		case '<':
			printf("&lt;");
			continue;
		case '>':
			printf("&gt;");
			continue;
		case '&':
			printf("&amp;");
			continue;
		case '"':
			printf("&quot;");
			continue;
		case ASCII_NBRSP:
			putchar('-');
a386 8
		case ASCII_HYPH:
			putchar('-');
			/* FALLTHROUGH */
		case ASCII_BREAK:
			continue;
		default:
			break;
		}
d421 1
a421 1
			/* Skip passed "u" header. */
d428 1
a428 1
			if ('\0' != c)
d435 2
a436 1
			else if (-1 == c && 1 == len)
@


1.157
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.156 2014/04/20 16:46:04 schwarze Exp $ */
d333 1
a333 1
	static const char rejs[8] = { '\\', '<', '>', '&',
d363 3
@


1.156
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.155 2014/03/23 11:25:26 schwarze Exp $ */
d660 6
@


1.155
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.154 2014/01/22 20:58:39 schwarze Exp $ */
d118 1
d140 1
a140 1
		case (0):
d143 1
a143 1
		case (1):
d146 1
a146 1
		case (2):
d149 1
a149 1
		case (3):
a165 1

a172 1

d182 1
a182 1
		h->tags.head = tag->next;	
d185 1
a185 1
	
a191 1

d228 1
a228 1
	case (ESCAPE_FONTPREV):
d231 1
a231 1
	case (ESCAPE_FONTITALIC):
d234 1
a234 1
	case (ESCAPE_FONTBOLD):
d237 1
a237 1
	case (ESCAPE_FONTBI):
d240 1
a240 1
	case (ESCAPE_FONT):
d242 1
a242 1
	case (ESCAPE_FONTROMAN):
d259 1
a259 1
	case (HTMLFONT_ITALIC):
d262 1
a262 1
	case (HTMLFONT_BOLD):
d265 1
a265 1
	case (HTMLFONT_BI):
d304 1
a304 1
		case (ESCAPE_ERROR):
d306 1
a306 1
		case (ESCAPE_UNICODE):
d308 1
a308 1
		case (ESCAPE_NUMBERED):
d310 1
a310 1
		case (ESCAPE_SPECIAL):
d316 1
a316 1
		case (ESCAPE_SKIPCHAR):
d354 1
a354 1
		case ('<'):
d357 1
a357 1
		case ('>'):
d360 1
a360 1
		case ('&'):
d363 1
a363 1
		case (ASCII_NBRSP):
d366 1
a366 1
		case (ASCII_HYPH):
d369 1
a369 1
		case (ASCII_BREAK):
d380 1
a380 1
		case (ESCAPE_FONT):
d382 1
a382 1
		case (ESCAPE_FONTPREV):
d384 1
a384 1
		case (ESCAPE_FONTBOLD):
d386 1
a386 1
		case (ESCAPE_FONTITALIC):
d388 1
a388 1
		case (ESCAPE_FONTBI):
d390 1
a390 1
		case (ESCAPE_FONTROMAN):
d394 1
a394 1
		case (ESCAPE_SKIPCHAR):
d407 1
a407 1
		case (ESCAPE_UNICODE):
d413 1
a413 1
		case (ESCAPE_NUMBERED):
d418 1
a418 1
		case (ESCAPE_SPECIAL):
d425 1
a425 1
		case (ESCAPE_NOSPACE):
a436 1

a444 1

d446 1
a446 1
print_otag(struct html *h, enum htmltag tag, 
d496 1
a496 1
		case (HTML_XHTML_1_0_STRICT):
a512 1

d516 1
a516 1
	
d521 1
a521 1
	} 
d532 1
a532 1
	case (HTML_HTML_4_01_STRICT):
d545 2
a546 2
	printf("<!DOCTYPE %s PUBLIC \"%s\" \"%s\">\n", 
			name, doctype, dtd);
d565 1
a565 1
	case (HTMLFONT_ITALIC):
d568 1
a568 1
	case (HTMLFONT_BOLD):
d571 1
a571 1
	case (HTMLFONT_BI):
a593 1

d600 1
a600 1
		/* 
a615 1

d624 1
a624 1
		/* 
d670 2
a671 2
	(void)vsnprintf(h->buf + (int)h->buflen, 
			BUFSIZ - h->buflen - 1, fmt, ap);
d691 1
a691 1
	
d696 1
a696 1
		case('I'):
d710 1
a710 2
buffmt_man(struct html *h, 
		const char *name, const char *sec)
d715 1
a715 1
	
d720 1
a720 1
		case('S'):
d723 1
a723 1
		case('N'):
@


1.154
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.153 2014/01/05 19:10:56 joerg Exp $ */
d34 1
@


1.153
log
@Tag functions with format strings as arguments as printf-like.
Fix one case where a non-literal is used as format string.
Fix another case where a variable is formatted using the wrong type.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.152 2013/08/08 20:07:47 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d334 2
a335 1
	static const char rejs[6] = { '\\', '<', '>', '&', ASCII_HYPH, '\0' };
d364 3
d369 2
@


1.152
log
@Implement the roff(7) font-escape sequence \f(BI "bold+italic".
This improves the formatting of about 40 base manuals
and reduces groff-mandoc formatting differences in base by about 5%.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.151 2012/05/31 22:29:13 schwarze Exp $ */
d725 1
a725 1
			bufcat_fmt(h, name);
@


1.151
log
@Implement the roff \z escape sequence, intended to output the next
character without advancing the cursor position; implement it to
simply skip the next character, as it will usually be overwritten.

With this change, the pod2man(1) preamble user-defined string \*:,
intended to render as a diaeresis or umlaut diacritic above the
preceding character, is rendered in a slightly less ugly way,
though still not correctly.  It was rendered as "z.." and is now
rendered as ".".

Given that the definition of \*: uses elaborate manual \h positioning,
there is little chance for mandoc(1) to ever render it correctly,
but at least we can refrain from printing out a spurious "z", and
we can make the \z do something semi-reasonable for easier cases.

"just commit" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.150 2011/10/05 21:35:17 kristaps Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d238 3
d259 14
a272 4
	if (HTMLFONT_NONE != font)
		h->metaf = HTMLFONT_BOLD == font ?
			print_otag(h, TAG_B, 0, NULL) :
			print_otag(h, TAG_I, 0, NULL);
d383 2
d562 14
a575 4
	if (HTMLFONT_NONE != h->metac)
		h->metaf = HTMLFONT_BOLD == h->metac ?
			print_otag(h, TAG_B, 0, NULL) :
			print_otag(h, TAG_I, 0, NULL);
@


1.150
log
@Add the -Ofragment option to -T[]x]html.  This accomodates for embedding
manual output in existing HTML or XHTML documents, e.g., when invoking
mandoc from an SSI or CGI.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.149 2011/07/07 14:34:11 kristaps Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d265 2
a266 2
	int		 ssz, sz;
	const char	*seq, *p;
d277 15
a291 4
	while (NULL != (p = strchr(cp, '\\'))) {
		sz += (int)(p - cp);
		++cp;
		switch (mandoc_escape(&cp, &seq, &ssz)) {
d299 7
a305 1
			sz++;
d311 1
a311 3

	assert(sz >= 0);
	return(sz + strlen(cp));
d326 6
d362 25
a404 13
		case (ESCAPE_FONT):
			/* FALLTHROUGH */
		case (ESCAPE_FONTPREV):
			/* FALLTHROUGH */
		case (ESCAPE_FONTBOLD):
			/* FALLTHROUGH */
		case (ESCAPE_FONTITALIC):
			/* FALLTHROUGH */
		case (ESCAPE_FONTROMAN):
			if (norecurse)
				break;
			print_metaf(h, esc);
			break;
@


1.149
log
@Fix handling of the `\c' escape in -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.148 2011/07/04 09:42:38 kristaps Exp $ */
d121 1
a121 1
	const char	*toks[4];
d127 2
a128 1
	toks[3] = NULL;
d147 3
@


1.148
log
@The bufcat() function in -T[x]html was eating one byte off the end of its
concatenated string.  This for some reason hasn't been found before now... ?
Anyway, fixed, and make the IDs created again be correctly prefixed by a
letter as per the HTML spec.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.147 2011/05/24 21:40:14 kristaps Exp $ */
d516 1
a516 1
	if ( ! print_encode(h, word, 0))
d519 2
@


1.147
log
@Use the correct Unicode value for the zero-width space, which means that
spec2cp never needs to fall through to spec2str.  Then clean out html.c
of its unnecessary print_res() function.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.146 2011/05/24 21:31:23 kristaps Exp $ */
a597 1
	h->buflen--;
@


1.146
log
@Remove all references to ESCAPE_PREDEF, which is now not exposed passed
the libroff point.  This clears up a nice chunk of code.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.145 2011/05/18 23:59:08 kristaps Exp $ */
a110 1
static	void	 print_spec(struct html *, const char *, size_t);
a219 20
print_spec(struct html *h, const char *p, size_t len)
{
	int		 cp;
	const char	*rhs;
	size_t		 sz;

	if ((cp = mchars_spec2cp(h->symtab, p, len)) > 0) {
		printf("&#%d;", cp);
		return;
	} else if (-1 == cp && 1 == len) {
		fwrite(p, 1, len, stdout);
		return;
	} else if (-1 == cp)
		return;

	if (NULL != (rhs = mchars_spec2str(h->symtab, p, len, &sz)))
		fwrite(rhs, 1, sz, stdout);
}

static void
d349 5
a353 1
			print_spec(h, seq, len);
@


1.145
log
@Make any un-recognised font be considered a call for the Roman font.
This makes sequences of \f[unknown] \fP not completely puke.  From a
TODO by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.144 2011/05/17 11:50:20 kristaps Exp $ */
a111 1
static	void	 print_res(struct html *, const char *, size_t);
a239 19

static void
print_res(struct html *h, const char *p, size_t len)
{
	int		 cp;
	const char	*rhs;
	size_t		 sz;

	if ((cp = mchars_res2cp(h->symtab, p, len)) > 0) {
		printf("&#%d;", cp);
		return;
	} else if (-1 == cp)
		return;

	if (NULL != (rhs = mchars_res2str(h->symtab, p, len, &sz)))
		fwrite(rhs, 1, sz, stdout);
}


a303 2
		case (ESCAPE_PREDEF):
			/* FALLTHROUGH */
a368 3
		case (ESCAPE_PREDEF):
			print_res(h, seq, len);
			break;
@


1.144
log
@Flip on unicode output (via \[uNNNN]) in -T[x]html.  Here we go!
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.143 2011/05/17 11:38:18 kristaps Exp $ */
d275 2
d397 2
@


1.143
log
@Clean-up fallout: differentiate ID's and HREF's (where to put the `#').
Make buffmt functions internally bufinit(), too.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.142 2011/05/17 11:34:31 kristaps Exp $ */
d318 2
d378 6
@


1.142
log
@Cleanups in -T[x]html: make html_idcat() use the buffer and be called
bufcat_id(), then collapse it into a little function without so much
crap.  Next, make bufinit() only be called when we really need to do so,
and not simply before pre/post calls.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.141 2011/05/17 11:19:45 kristaps Exp $ */
d659 1
d684 1
a684 1
	/* LINTED */
a721 2
	if (0 == h->buflen)
		bufcat(h, "#x");
@


1.141
log
@Clean-ups in -T[x]html: inline print_num(), as it was just a single
conditional; same for print_xmltype() and print_doctype(), same reason;
make bufncat() be static, as it was only being called from html.c;
have bufcat() simply call through to strlcat().  Finally, assert()
whenever we truncate.

Also rename buffmt() -> bufcat_fmt() to differentiate from buffmt_man et
al., which do not concatenate.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.140 2011/05/17 10:48:06 kristaps Exp $ */
d716 1
a716 1
html_idcat(char *dst, const char *src, int sz)
a717 3
	int		 ssz;

	assert(sz > 2);
d721 4
a724 20
	/* We can't start with a number (bah). */

	if ('#' == *dst) {
		dst++;
		sz--;
	}
	if ('\0' == *dst) {
		*dst++ = 'x';
		*dst = '\0';
		sz--;
	}

	for ( ; *dst != '\0' && sz; dst++, sz--)
		/* Jump to end. */ ;

	for ( ; *src != '\0' && sz > 1; src++) {
		ssz = snprintf(dst, (size_t)sz, "%.2x", *src);
		sz -= ssz;
		dst += ssz;
	}
@


1.140
log
@Clean up -T[x]html by using a table instead of a switch statement for
the roff units.  Also remove a comment about CSS and number types (they
all accept decimal numbers).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.139 2011/05/15 15:47:46 kristaps Exp $ */
d110 8
a117 12
static	void		  print_num(struct html *, const char *, size_t);
static	void		  print_spec(struct html *, const char *, size_t);
static	void		  print_res(struct html *, const char *, size_t);
static	void		  print_ctag(struct html *, enum htmltag);
static	void		  print_doctype(struct html *);
static	void		  print_xmltype(struct html *);
static	int		  print_encode(struct html *, const char *, int);
static	void		  print_metaf(struct html *, enum mandoc_esc);
static	void		  print_attr(struct html *, 
				const char *, const char *);
static	void		 *ml_alloc(char *, enum htmltype);

a220 10
/* ARGSUSED */
static void
print_num(struct html *h, const char *p, size_t len)
{
	char		 c;

	if ('\0' != (c = mchars_num2char(p, len)))
		putchar((int)c);
}

d338 1
a338 1
	int		 len, nospace;
d377 3
a379 1
			print_num(h, seq, len);
a499 1

a502 18

	print_xmltype(h);
	print_doctype(h);
}


static void
print_xmltype(struct html *h)
{

	if (HTML_XHTML_1_0_STRICT == h->type)
		puts("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
}


static void
print_doctype(struct html *h)
{
d514 1
a603 1

a611 1

d617 1
a617 1
	bufncat(h, ":", 1);
d619 1
a619 1
	bufncat(h, ";", 1);
a621 1

d626 3
a628 1
	bufncat(h, p, strlen(p));
a630 1

d632 1
a632 1
buffmt(struct html *h, const char *fmt, ...)
d643 1
a643 2

void
d647 2
a648 4
	if (h->buflen + sz > BUFSIZ - 1)
		sz = BUFSIZ - 1 - h->buflen;

	(void)strncat(h->buf, p, sz);
a651 1

a674 1

d691 1
a691 1
			buffmt(h, name);
a702 1

d712 1
a712 1
	buffmt(h, "%s: %.2f%s;", p, v, roffscales[su->unit]);
a714 1

@


1.139
log
@Fix missing support for \N'n' when calculating string widths in -Tascii
(oops).  Do the same for -Thtml (oops^2).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.138 2011/05/14 16:28:23 kristaps Exp $ */
d97 13
a744 1
	const char	*u;
d747 2
d750 1
a750 40
	switch (su->unit) {
	case (SCALE_CM):
		u = "cm";
		break;
	case (SCALE_IN):
		u = "in";
		break;
	case (SCALE_PC):
		u = "pc";
		break;
	case (SCALE_PT):
		u = "pt";
		break;
	case (SCALE_EM):
		u = "em";
		break;
	case (SCALE_MM):
		if (0 == (v /= 100))
			v = 1;
		u = "em";
		break;
	case (SCALE_EN):
		u = "ex";
		break;
	case (SCALE_BU):
		u = "ex";
		break;
	case (SCALE_VS):
		u = "em";
		break;
	default:
		u = "ex";
		break;
	}

	/* 
	 * XXX: the CSS spec isn't clear as to which types accept
	 * integer or real numbers, so we just make them all decimals.
	 */
	buffmt(h, "%s: %.2f%s;", p, v, u);
@


1.138
log
@Give -Thtml and -Txhtml the gift of recognising escapes when calculating
widths (e.g., `Bl -tag -width "\s[blahblah]bar").  This has long since
been done for -Tascii but escaped noticed with -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.137 2011/04/30 22:24:31 kristaps Exp $ */
d319 2
d322 1
a322 2
			sz++;
			break;
@


1.137
log
@Make mchars_num2char() return a char like it says.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.136 2011/04/30 22:14:42 kristaps Exp $ */
d34 1
d298 35
@


1.136
log
@Rename mchars_init() -> mchars_alloc() for consistency.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.135 2011/04/30 22:14:02 kristaps Exp $ */
d215 1
a215 1
	const char	*rhs;
d217 2
a218 3
	rhs = mchars_num2char(p, len);
	if (rhs)
		putchar((int)*rhs);
@


1.135
log
@Remove enum mcharst, which hasn't been used in quite some time.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.134 2011/04/30 10:18:24 kristaps Exp $ */
d125 1
a125 1
	h->symtab = mchars_init();
@


1.134
log
@No code change: fixing spelling errors.  From a patch by uqs@@.  Thanks!
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.133 2011/04/29 22:18:12 kristaps Exp $ */
d125 1
a125 1
	h->symtab = mchars_init(MCHARS_HTML);
@


1.133
log
@Move "chars" interface out of out.h and into mandoc.h.  This doesn't
change any code but for renaming functions and types to be consistent
with other mandoc.h stuff.  The reason for moving into libmandoc is that
the rendering of special characters is part of mandoc itself---not an
external part.  From mandoc(1)'s perspective, this changes nothing, but
for other utilities, it's important to have these part of libmandoc.
Note this isn't documented [yet] in mandoc.3 because there are some
parts I'd like to change around beforehand.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.132 2011/04/09 15:29:40 kristaps Exp $ */
d430 1
a430 1
	/* Accomodate for XML "well-formed" singleton escaping. */
@


1.132
log
@Remove a2roffdeco() and mandoc_special() functions and replace them with
a public (mandoc.h) function mandoc_escape(), which merges the
functionality of both prior functions.

Reason: code duplication.  The a2roffdeco() and mandoc_special()
functions were pretty much the same thing and both quite complex.  This
allows one function to receive improvements in (e.g.) subexpression
handling and performance, instead of having to replicate functionality.

As such, the mandoc_escape() function already handles a superset of the
escapes handled in previous versions and has improvements in performance
(using strcspn(), for example) and reliable handling of subexpressions.

This code Works For Me, but may need work to catch any regressions.
Since the benefits are great (leaner code, simpler API), I'd rather have
it in-tree than floating as a patch.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.131 2011/03/22 14:05:45 kristaps Exp $ */
d125 1
a125 1
	h->symtab = chars_init(CHARS_HTML);
d175 1
a175 1
		chars_free(h->symtab);
d217 1
a217 1
	rhs = chars_num2char(p, len);
d229 1
a229 1
	if ((cp = chars_spec2cp(h->symtab, p, len)) > 0) {
d238 1
a238 1
	if (NULL != (rhs = chars_spec2str(h->symtab, p, len, &sz)))
d250 1
a250 1
	if ((cp = chars_res2cp(h->symtab, p, len)) > 0) {
d256 1
a256 1
	if (NULL != (rhs = chars_res2str(h->symtab, p, len, &sz)))
@


1.131
log
@Move mandoc_isdelim() back into libmdoc.h.  This fixes an unreported
error where (1) -man pages were punctuating delimiters (e.g., `.B a ;')
and where (2) standalone punctuation in -mdoc or -man (e.g., ";" on its
own line) would also be punctuated.  This introduces a small amount of
complexity of mdoc_{html,term}.c must manage their own spacing with
running print_word() or print_text().  The check for delimiting now
happens in mdoc_macro.c's dword().
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.130 2011/03/22 10:13:01 kristaps Exp $ */
d97 1
a97 2
static	void		  print_spec(struct html *, enum roffdeco,
				const char *, size_t);
d103 1
a103 1
static	void		  print_metaf(struct html *, enum roffdeco);
d223 1
a223 1
print_spec(struct html *h, enum roffdeco d, const char *p, size_t len)
d232 1
a232 1
	} else if (-1 == cp && DECO_SSPECIAL == d) {
d262 1
a262 1
print_metaf(struct html *h, enum roffdeco deco)
d267 1
a267 1
	case (DECO_PREVIOUS):
d270 1
a270 1
	case (DECO_ITALIC):
d273 1
a273 1
	case (DECO_BOLD):
d276 1
a276 1
	case (DECO_ROMAN):
d305 1
a305 1
	enum roffdeco	 deco;
d310 1
a310 1
	for (; *p; p++) {
d314 1
a314 2
		p += /* LINTED */
			sz;
d316 5
a320 1
		if ('<' == *p) {
d323 1
a323 1
		} else if ('>' == *p) {
d326 1
a326 1
		} else if ('&' == *p) {
d329 1
a329 7
		} else if (ASCII_HYPH == *p) {
			/*
			 * Note: "soft hyphens" aren't graphically
			 * displayed when not breaking the text; we want
			 * them to be displayed.
			 */
			/*printf("&#173;");*/
d332 1
a332 1
		} else if ('\0' == *p)
d334 1
d336 3
a338 2
		seq = ++p;
		len = a2roffdeco(&deco, &seq, &sz);
d340 3
a342 3
		switch (deco) {
		case (DECO_NUMBERED):
			print_num(h, seq, sz);
d344 2
a345 2
		case (DECO_RESERVED):
			print_res(h, seq, sz);
d347 2
a348 4
		case (DECO_SSPECIAL):
			/* FALLTHROUGH */
		case (DECO_SPECIAL):
			print_spec(h, deco, seq, sz);
d350 1
a350 1
		case (DECO_PREVIOUS):
d352 1
a352 1
		case (DECO_BOLD):
d354 1
a354 1
		case (DECO_ITALIC):
d356 1
a356 1
		case (DECO_ROMAN):
d359 5
a363 1
			print_metaf(h, deco);
a367 5

		p += len - 1;

		if (DECO_NOSPACE == deco && '\0' == *(p + 1))
			nospace = 1;
@


1.130
log
@Step 4: merge chars.h into out.h.  The functions in this file are
necessary to all [real] front-ends, so stop pretending it's special.
While here, add some documentation to the variable types.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.129 2011/03/17 09:16:38 kristaps Exp $ */
a510 1

a514 4
	if (DELIM_CLOSE == mandoc_isdelim(word))
		if ( ! (HTML_IGNDELIM & h->flags))
			h->flags |= HTML_NOSPACE;

a541 3

	if (DELIM_OPEN == mandoc_isdelim(word))
		h->flags |= HTML_NOSPACE;
@


1.129
log
@Move mdoc_isdelim() into mandoc.h as mandoc_isdelim().  This allows the
removal of manual delimiter checks in html.c and term.c.  Finally, add
the escaped period as a closing delimiter, removing a TODO to this
effect.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.128 2011/03/17 08:49:34 kristaps Exp $ */
a34 1
#include "chars.h"
@


1.128
log
@Move mandoc_{realloc,malloc,calloc} out of libmandoc.h and into mandoc.h
so that everybody can use them.  This follows the convention of
libXXXX.h being internal to a library and XXXX.h being the external
interface.  Not only does this allow the removal of lots of redundant
NULL-checking code, it also sets the tone for adding new mandoc-global
routines.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.127 2011/03/15 16:23:51 kristaps Exp $ */
d517 3
a519 23
	if (word[0] && '\0' == word[1])
		switch (word[0]) {
		case('.'):
			/* FALLTHROUGH */
		case(','):
			/* FALLTHROUGH */
		case(';'):
			/* FALLTHROUGH */
		case(':'):
			/* FALLTHROUGH */
		case('?'):
			/* FALLTHROUGH */
		case('!'):
			/* FALLTHROUGH */
		case(')'):
			/* FALLTHROUGH */
		case(']'):
			if ( ! (HTML_IGNDELIM & h->flags))
				h->flags |= HTML_NOSPACE;
			break;
		default:
			break;
		}
d549 2
a550 14
	/* 
	 * Note that we don't process the pipe: the parser sees it as
	 * punctuation, but we don't in terms of typography.
	 */
	if (word[0] && '\0' == word[1])
		switch (word[0]) {
		case('('):
			/* FALLTHROUGH */
		case('['):
			h->flags |= HTML_NOSPACE;
			break;
		default:
			break;
		}
@


1.127
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.126 2011/01/30 16:05:37 schwarze Exp $ */
d123 1
a123 5
	h = calloc(1, sizeof(struct html));
	if (NULL == h) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d399 1
a399 5
		t = malloc(sizeof(struct tag));
		if (NULL == t) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.126
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ jmc@@ and tested by Matthieu Herrb (matthieu at openbsd dot org)
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.125 2011/01/13 14:30:13 kristaps Exp $ */
d217 1
a217 1

a227 1

@


1.125
log
@Change how -Thtml behaves with tables: use multiple rows, with widths
set by COL, until an external macro is encountered.  At this point in
time, close out the table and process the macro.  When the first table
row is again re-encountered, re-start the table.  This requires a bit of
tracking added to "struct html", but the change is very small and
follows the logic of meta-fonts.  This all follows a bug-report by
joerg@@.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.124 2010/12/27 21:41:05 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d97 1
d219 11
d349 3
@


1.124
log
@In case an ID attribute is written in pieces, only protect the first
piece with a prepended 'x', not each piece, such that quoted and
unquoted .Sh, .Ss, and .Sx arguments are compatible with each other.
Fixing a bug reported by Nicolas Joly <njoly at NetBSD dot org>,
avoiding a regression in my first patch as pointed out by njoly as well.
"feel free to do so" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.123 2010/12/24 14:14:00 kristaps Exp $ */
d93 1
d585 4
d591 2
d610 4
d616 2
@


1.123
log
@Apparently the U tag is deprecated, so use a SPAN instead (blah).  Bump
version date for release.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.122 2010/12/24 00:46:49 kristaps Exp $ */
d774 1
a774 1
	assert(sz);
d778 12
a792 8
	assert(sz > 2);

	/* We can't start with a number (bah). */

	*dst++ = 'x';
	*dst = '\0';
	sz--;

@


1.122
log
@Drastically fix -T[x]html's handling of font-escape mode changes (i.e.,
using \fI or \fP).  Now, using these modes will cause a font to be
rendered for each word; furthermore, setting mode within a word will do
the correct thing.

Second, make -man use real font tags (B, I, SMALL) to set its font
instead of using font modes and fix up the pre-macro unsetting of the
current mode.

This fixes how roff.7 wasn't validating (<P> closing out a font mode)
and has been checked against gcc.1 (more will come).  I considered
failure to validate OUR manual to be a show-stopper for the up-coming
release.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.121 2010/12/22 11:15:16 kristaps Exp $ */
a74 1
	{"u",		0 }, /* TAG_U */
@


1.121
log
@Implement reference-counted version of original union mdoc_data.  This
simplifies clean-up and allows for more types without extra hassle.

Also made in-line literal types in -T[x]html use CODE instead of SPAN to
match how literal blocks use PRE.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.120 2010/12/20 13:07:55 kristaps Exp $ */
d77 1
a77 6
};

static	const char	*const htmlfonts[HTMLFONT_MAX] = {
	"roman",
	"bold",
	"italic"
a254 19
struct tag *
print_ofont(struct html *h, enum htmlfont font)
{
	struct htmlpair	 tag;

	h->metal = h->metac;
	h->metac = font;

	/* FIXME: DECO_ROMAN should just close out preexisting. */

	if (h->metaf && h->tags.head == h->metaf)
		print_tagq(h, h->metaf);

	PAIR_CLASS_INIT(&tag, htmlfonts[font]);
	h->metaf = print_otag(h, TAG_SPAN, 1, &tag);
	return(h->metaf);
}


d278 12
a289 1
	(void)print_ofont(h, font);
d544 6
d555 5
@


1.120
log
@More use default tags, this time I and U.  Also fix a stack overflow
segfault in the last commit.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.119 2010/12/20 10:40:11 kristaps Exp $ */
d76 1
d490 1
a490 1
		printf("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
@


1.119
log
@Give header and footer table cells default widths (using WIDTH and ALIGN
atttributes) if no style is specified.

Give the default-bold elements a B tag instead of a SPAN tag, as this
can be overriden in the stylesheet.

Prune some unused attributes from html.h.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.118 2010/12/17 10:37:26 kristaps Exp $ */
d74 2
@


1.118
log
@Make literal `Bd' use a PRE in -Thtml.  Make `Bd' output in general use
only a single DIV or PRE.  Tag all displays with display class.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.117 2010/12/17 08:17:40 kristaps Exp $ */
d73 1
d83 13
a95 14
	"http-equiv",
	"content",
	"name",
	"rel",
	"href",
	"type",
	"media",
	"class",
	"style",
	"width",
	"valign",
	"target",
	"id",
	"summary",
@


1.117
log
@Have synopsis_pre() in -Thtml emit P or BR, not DIVs.

Banish header and footer TABLE styling to example.style.css.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.116 2010/12/15 17:19:41 kristaps Exp $ */
d72 1
@


1.116
log
@Use a single P tag for paragraph breaks (which can be configured for
paragraph breaking in CSS).

Use -man's handling of `sp' and `br', which accomodates for scaling
widths (-mdoc wasn't).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.115 2010/12/15 15:59:23 kristaps Exp $ */
d452 4
@


1.115
log
@Remove stupid outer DIV tag in favour of regular BODY and HTML that can
be handled in CSS.

Clarified "lit" tag (will be the subject of future clarification).

Removed CSS2 note in mandoc.1, which is no longer the case.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.114 2010/12/15 14:52:16 kristaps Exp $ */
d71 1
@


1.114
log
@In-progress move from -T[x]html using DIVs for its lists to using DL,
OL, and UL.  Issue raised by Will Backman, solution proposed by
schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.113 2010/10/01 21:51:13 schwarze Exp $ */
d70 1
@


1.113
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.112 2010/09/04 20:18:53 kristaps Exp $ */
d60 1
d67 3
a127 1
	h->ords.head = NULL;
a167 1
	struct ord	*ord;
a171 5
	while ((ord = h->ords.head) != NULL) { 
		h->ords.head = ord->next;
		free(ord);
	}

@


1.112
log
@Churny commit to quiet lint.  No functional changes.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.111 2010/08/20 01:02:07 schwarze Exp $ */
d555 2
@


1.111
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.110 2010/07/26 22:26:05 kristaps Exp $ */
d119 1
a119 1
		exit(MANDOCLEVEL_SYSERR);
d401 1
a401 1
			exit(MANDOCLEVEL_SYSERR);
@


1.110
log
@Make `Sm' start no-spacing after the first output word.  Fix in both
-T[x]html and -T{pdf,ps,ascii}.  Reported by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.109 2010/07/23 00:08:57 kristaps Exp $ */
d119 1
a119 1
		exit(EXIT_FAILURE);
d401 1
a401 1
			exit(EXIT_FAILURE);
@


1.109
log
@Add support for `Sm' in -T[x]html -mdoc.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.108 2010/07/21 20:35:03 kristaps Exp $ */
d422 2
@


1.108
log
@Accomodate for groff's crappy behaviour wherein an unrecognised
single-character escape (and ONLY this type of escape) will map back
into itself:

       "If a backslash is followed by a character that does not
	constitute a defined escape sequence the backslash is silently
        ignored and the  character maps to itself."

(From groff.7.)

Found by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.107 2010/07/16 22:33:30 kristaps Exp $ */
d420 3
d550 2
a551 1
		h->flags &= ~HTML_NOSPACE;
@


1.107
log
@Change chars.in HTML encoding to be a Unicode codepoint (int), which is
later formatted in html.c.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.106 2010/07/13 23:53:20 schwarze Exp $ */
d91 2
a92 1
static	void		  print_spec(struct html *, const char *, size_t);
d219 1
a219 1
print_spec(struct html *h, const char *p, size_t len)
d228 3
d349 2
d352 1
a352 1
			print_spec(h, seq, sz);
@


1.106
log
@correct lots of copyright notices;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.105 2010/07/06 12:37:17 kristaps Exp $ */
d220 1
d224 5
a228 1
	rhs = chars_a2ascii(h->symtab, p, len, &sz);
d230 2
a231 3
	if (NULL == rhs) 
		return;
	fwrite(rhs, 1, sz, stdout);
d238 1
d242 5
a246 1
	rhs = chars_a2res(h->symtab, p, len, &sz);
d248 2
a249 3
	if (NULL == rhs)
		return;
	fwrite(rhs, 1, sz, stdout);
@


1.105
log
@Give -T[x]html `Bk -words' capability.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.104 2010/07/06 11:10:53 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.104
log
@Brought function arguments and style in ine with term_word() in term.c
to make sharing of TERMP_KEEP easier.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.103 2010/06/25 19:50:23 kristaps Exp $ */
d396 9
a404 2
		if ( ! (HTML_CLRLINE & htmltags[tag].flags))
			putchar(' ');
d521 9
a529 2
	if ( ! (h->flags & HTML_NOSPACE))
		putchar(' ');
@


1.103
log
@Remove "pt" from struct roffsu, as CSS (the only reason it was there) is
unclear about which units accept floats/integers, which leads me to
assume that it handles either and rounds as appropriate.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.102 2010/06/19 20:46:27 kristaps Exp $ */
d487 1
a487 1
print_text(struct html *h, const char *p)
d490 2
a491 2
	if (*p && 0 == *(p + 1))
		switch (*p) {
d517 2
a518 2
	assert(p);
	if ( ! print_encode(h, p, 0))
d525 2
a526 2
	if (*p && 0 == *(p + 1))
		switch (*p) {
@


1.102
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.101 2010/06/07 10:52:44 kristaps Exp $ */
d721 5
a725 5
	if (su->pt)
		buffmt(h, "%s: %f%s;", p, v, u);
	else
		/* LINTED */
		buffmt(h, "%s: %d%s;", p, (int)v, u);
@


1.101
log
@Add -Owidth=width option to mandoc -Tascii.  Asked for by joerg@@ about a
thousand years ago.  Note that this is normalised to >=60.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.100 2010/05/25 12:37:20 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.100
log
@Modified version of Ingo Schwarze's patch for hyphen-breaking.
Breakable hyphens are cued in the back-ends (with ASCII_HYPH) and acted
upon in term.c or ignored in html.c.

Also cleaned up XML decl printing (no need for extra vars).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.99 2010/04/12 19:45:39 kristaps Exp $ */
a37 2
#define	UNCONST(a)	((void *)(uintptr_t)(const void *)(a))

@


1.99
log
@Fix to auto-closing of LINK tag in -Txhtml (thanks to Daniel Friesel).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.98 2010/04/08 07:05:38 kristaps Exp $ */
d32 1
d300 1
d305 1
a305 1
		sz = strcspn(p, "\\<>&");
d320 9
a456 13
	const char	*decl;

	switch (h->type) {
	case (HTML_XHTML_1_0_STRICT):
		decl = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
		break;
	default:
		decl = NULL;
		break;
	}

	if (NULL == decl)
		return;
d458 2
a459 1
	printf("%s\n", decl);
@


1.98
log
@Removed pipe from front-end ("typographic") recognition as punctuation (noted by Ingo Schwarze).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.97 2010/04/03 12:46:35 kristaps Exp $ */
d57 1
a57 1
	{"link",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_LINK */
@


1.97
log
@Removed erroneous `{' and `}' as punctuation (see mdoc.samples "General Syntax" for why this mistake was made).  Noted by Ingo Schwarze.
Lines of text now break at a hyphen, unless the hyphen is the first or second subsequent in a word.  Inspired by a Ingo Schwarze's patch.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.96 2010/02/17 19:48:33 kristaps Exp $ */
d524 4
a529 2
		case('|'):
			/* FALLTHROUGH */
@


1.96
log
@Fixed printing of XHTML DOCTYPE "html" vs. "HTML".
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.95 2010/01/30 08:42:20 kristaps Exp $ */
a509 2
			/* FALLTHROUGH */
		case('}'):
d526 2
a530 2
			/* FALLTHROUGH */
		case('{'):
@


1.95
log
@Fix in handling Vt in SYNOPSIS with trailing punctuation.  Spotted by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.94 2010/01/30 06:55:56 kristaps Exp $ */
d469 1
d473 1
d478 1
d484 2
a485 1
	printf("<!DOCTYPE HTML PUBLIC \"%s\" \"%s\">\n", doctype, dtd);
@


1.94
log
@Mandate html attributes for xhtml.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.93 2010/01/29 14:39:37 kristaps Exp $ */
a314 1
		/* FIXME: already escaped? */
@


1.93
log
@Fixed Makefile for `make lint' dep. on config.h
Added -Txhtml for XHTML output (minimal increase to programme logic).  Because groff has it and it bothers me that we don't.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.92 2010/01/01 17:14:27 kristaps Exp $ */
d99 2
d315 1
d357 9
d373 2
d391 2
d394 9
a402 5
	for (i = 0; i < sz; i++) {
		printf(" %s=\"", htmlattrs[p[i].key]);
		assert(p->val);
		(void)print_encode(h, p[i].val, 1);
		putchar('\"');
d405 2
@


1.92
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.91 2009/11/16 08:46:58 kristaps Exp $ */
a38 3
#define	DOCTYPE		"-//W3C//DTD HTML 4.01//EN"
#define	DTD		"http://www.w3.org/TR/html4/strict.dtd"

d44 1
d51 1
a51 1
	{"meta",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_META */
a55 1
	{"p",		HTML_CLRLINE}, /* TAG_P */
d58 1
a58 1
	{"br",		HTML_CLRLINE | HTML_NOSTACK}, /* TAG_LINK */
d61 1
a61 1
	{"col",		HTML_CLRLINE | HTML_NOSTACK}, /* TAG_COL */
a66 1
	{"base",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_BASE */
d95 2
d99 1
d102 2
a103 2
void *
html_alloc(char *outopts)
d120 1
d143 15
d384 10
a412 1
/* ARGSUSED */
d414 1
a414 1
print_gen_doctype(struct html *h)
d416 45
a460 2
	
	printf("<!DOCTYPE HTML PUBLIC \"%s\" \"%s\">", DOCTYPE, DTD);
@


1.91
log
@Enabled -Thtml -mdoc to work with \f (see compat notes in mandoc.1).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.90 2009/11/16 06:07:49 kristaps Exp $ */
d17 4
a95 5
#ifdef __linux__
extern	int		  getsubopt(char **, char * const *, char **);
#endif


@


1.90
log
@Abstraction of -Thtml -man font setting (still experimental).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.89 2009/11/15 06:45:31 kristaps Exp $ */
d240 1
a240 1
	if (h->metaf)
@


1.89
log
@\f escapes appear to work properly for -Thtml -man.  Needs more testing.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.88 2009/11/14 19:23:58 kristaps Exp $ */
d69 6
d230 19
d252 1
a252 2
	const char	*class;
	struct htmlpair	 tag;
d255 2
a256 2
	case (DECO_BOLD):
		class = "bold";
d259 4
a262 1
		class = "italic";
d265 1
a265 1
		class = "roman";
d272 1
a272 8
	if (h->metaf) {
		assert(h->tags.head);
		assert(h->metaf == h->tags.head);
		print_tagq(h, h->metaf);
	}

	PAIR_CLASS_INIT(&tag, class);
	h->metaf = print_otag(h, TAG_SPAN, 1, &tag);
d315 2
a376 1
/* ARGSUSED */
@


1.88
log
@Initial check-in of -man -Thtml \f support (needs testing).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.87 2009/11/14 12:04:59 kristaps Exp $ */
d250 1
a250 1
	
d435 2
d454 2
@


1.87
log
@Removed superfluous HTML_NEWLINE.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.86 2009/11/14 12:00:24 kristaps Exp $ */
d94 2
a95 1
static	int		  print_encode(struct html *, const char *);
d224 32
d257 1
a257 1
print_encode(struct html *h, const char *p)
d295 9
d345 1
a345 1
		(void)print_encode(h, p[i].val);
d411 1
a411 1
	if ( ! print_encode(h, p))
@


1.86
log
@Fix of fix of -Thtml nospace.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.85 2009/11/14 11:58:36 kristaps Exp $ */
a308 5
	if (HTML_CLRLINE & htmltags[tag].flags)
		h->flags |= HTML_NEWLINE;
	else
		h->flags &= ~HTML_NEWLINE;

a320 1
		h->flags |= HTML_NEWLINE;
d322 1
a322 2
	} else
		h->flags &= ~HTML_NEWLINE;
a367 2
	h->flags &= ~HTML_NEWLINE;

@


1.85
log
@Fixed \c handling in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.84 2009/11/12 08:21:05 kristaps Exp $ */
a374 1
	h->flags &= ~HTML_NOSPACE;
d377 3
a379 2
	if (p)
		print_encode(h, p);
@


1.84
log
@Fixed \c support for all input and output modes (documented in mandoc_char.7).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.83 2009/11/10 16:32:00 kristaps Exp $ */
d94 1
a94 1
static	void		  print_encode(struct html *, const char *);
d223 1
a223 1
static void
d227 1
a227 1
	int		 len;
d231 2
d269 1
a269 1
			h->flags |= HTML_NOSPACE;
d271 2
d303 1
a303 1
		print_encode(h, p[i].val);
@


1.83
log
@Lint fixes in function call.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.82 2009/11/09 05:11:46 kristaps Exp $ */
d265 3
@


1.82
log
@Documented \s and cleaned up \f documentation in mdoc.7, man.7.
-Thtml now using a2roffdeco().
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.81 2009/11/05 10:16:01 kristaps Exp $ */
d91 2
a92 2
static	void		  print_spec(struct html *, const char *, int);
static	void		  print_res(struct html *, const char *, int);
d196 1
a196 1
print_spec(struct html *h, const char *p, int len)
d201 1
a201 1
	rhs = chars_a2ascii(h->symtab, p, (size_t)len, &sz);
d210 1
a210 1
print_res(struct html *h, const char *p, int len)
d215 1
a215 1
	rhs = chars_a2res(h->symtab, p, (size_t)len, &sz);
@


1.81
log
@Documented that `\s' and `\f' don't work in HTML mode (and why).
Added support for recognising the many forms of `\s' (doesn't yet render).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.80 2009/11/02 06:22:44 kristaps Exp $ */
d69 1
a69 1
static	const char	 *const htmlattrs[ATTR_MAX] = {
d90 7
a223 98
print_escape(struct html *h, const char **p)
{
	int		 j, type;
	const char	*wp;

	wp = *p;
	type = 1;

	if (0 == *(++wp)) {
		*p = wp;
		return;
	}

	if ('(' == *wp) {
		wp++;
		if (0 == *wp || 0 == *(wp + 1)) {
			*p = 0 == *wp ? wp : wp + 1;
			return;
		}

		print_spec(h, wp, 2);
		*p = ++wp;
		return;

	} else if ('*' == *wp) {
		if (0 == *(++wp)) {
			*p = wp;
			return;
		}

		switch (*wp) {
		case ('('):
			wp++;
			if (0 == *wp || 0 == *(wp + 1)) {
				*p = 0 == *wp ? wp : wp + 1;
				return;
			}

			print_res(h, wp, 2);
			*p = ++wp;
			return;
		case ('['):
			type = 0;
			break;
		default:
			print_res(h, wp, 1);
			*p = wp;
			return;
		}
	
	} else if ('f' == *wp) {
		if (0 == *(++wp)) {
			*p = wp;
			return;
		}

		/* 
		 * These aren't supported, as they're symmetry-breaking
		 * constructs that don't play well with hierarchical
		 * mark-up.  Consider:
		 *
		 * \fBHello.
		 * .PP
		 * World.
		 *
		 * The style started before "Hello" wouldn't be able to
		 * propogate into the next `PP' because we'd exit the
		 * current paragraph's scope.
		 */

		*p = wp;
		return;

	} else if ('[' != *wp) {
		print_spec(h, wp, 1);
		*p = wp;
		return;
	}

	wp++;
	for (j = 0; *wp && ']' != *wp; wp++, j++)
		/* Loop... */ ;

	if (0 == *wp) {
		*p = wp;
		return;
	}

	if (type)
		print_spec(h, wp - j, j);
	else
		print_res(h, wp - j, j);

	*p = wp;
}


static void
d227 3
d238 8
a245 2
		if ('\\' == *p) {
			print_escape(h, &p);
d250 15
a264 6
		if ('<' == *p)
			printf("&lt;");
		else if ('>' == *p)
			printf("&gt;");
		else if ('&' == *p)
			printf("&amp;");
@


1.80
log
@Added mandoc_a2time() for proper date conversion.
Fitted TH and Dd handlers to use mandoc_a2time().
Documented date syntax for -man, fixed documentation for -mdoc.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.79 2009/11/01 15:34:44 kristaps Exp $ */
d273 13
a285 15
		switch (*wp) {
		case ('B'):
			/* TODO */
			break;
		case ('I'):
			/* TODO */
			break;
		case ('P'):
			/* FALLTHROUGH */
		case ('R'):
			/* TODO */
			break;
		default:
			break;
		}
@


1.79
log
@Lint fix.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.78 2009/11/01 15:34:15 kristaps Exp $ */
d325 2
a326 1
		p += (int)sz;
@


1.78
log
@Using putchar for single-character prints (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.77 2009/11/01 08:15:20 kristaps Exp $ */
d325 1
a325 1
		p += sz;
@


1.77
log
@print_encode() using strcspn instead of looping/putchar() (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.76 2009/11/01 07:44:32 kristaps Exp $ */
d364 1
a364 1
			printf(" ");
d371 1
a371 1
		printf("\"");
d373 1
a373 1
	printf(">");
d394 1
a394 1
		printf("\n");
d440 1
a440 1
		printf(" ");
@


1.76
log
@Replaced putchar() loop with fwrite() (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.75 2009/10/31 06:10:57 kristaps Exp $ */
d319 1
d322 5
d330 4
a333 3
		}
		switch (*p) {
		case ('<'):
d335 1
a335 2
			break;
		case ('>'):
d337 1
a337 2
			break;
		case ('&'):
a338 5
			break;
		default:
			putchar(*p);
			break;
		}
@


1.75
log
@Using perror() instead of fprintf for failure from library functions.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.74 2009/10/30 18:53:08 kristaps Exp $ */
d21 1
a22 1
#include <stdarg.h>
a191 1
	int		 i;
d198 1
a198 2
	for (i = 0; i < (int)sz; i++) 
		putchar(rhs[i]);
a205 1
	int		 i;
d212 1
a212 2
	for (i = 0; i < (int)sz; i++) 
		putchar(rhs[i]);
@


1.74
log
@More lint fixes.
Removed err.h from inclusions (less main.c--still in progress).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.73 2009/10/30 18:50:11 kristaps Exp $ */
d104 1
a104 1
		fprintf(stderr, "memory exhausted\n");
d357 1
a357 1
			fprintf(stderr, "memory exhausted\n");
@


1.73
log
@Lint fixes.
Made realloc puke with fprintf.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.72 2009/10/30 18:43:24 kristaps Exp $ */
a20 1
#include <err.h>
@


1.72
log
@Continued safe handling of allocations.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.71 2009/10/30 04:57:17 kristaps Exp $ */
d676 1
a676 1
		ssz = snprintf(dst, sz, "%.2x", *src);
@


1.71
log
@Added newline after block-level closing tags (suggested by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.70 2009/10/28 08:00:18 kristaps Exp $ */
d103 5
a107 2
	if (NULL == (h = calloc(1, sizeof(struct html))))
		return(NULL);
d111 1
a111 5

	if (NULL == (h->symtab = chars_init(CHARS_HTML))) {
		free(h);
		return(NULL);
	}
d356 5
a360 2
		if (NULL == (t = malloc(sizeof(struct tag))))
			err(EXIT_FAILURE, "malloc");
@


1.70
log
@Fixed `sp', `br', `Pp', etc. so as not to have an empty div (-Thtml, -man, -mdoc).
Made html_idcat be completely correct (messy standard) (-Thtml).
Fixed warnings about -ohang and -item lists (-Thtml, -mdoc).
Fixed typo in index.sgml.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.69 2009/10/28 06:54:12 kristaps Exp $ */
d394 1
a394 1
	if (HTML_CLRLINE & htmltags[tag].flags)
a395 1
	if (HTML_CLRLINE & htmltags[tag].flags)
d397 2
a398 1
	else
@


1.69
log
@Removed superfluous memset (thanks Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.68 2009/10/28 05:08:17 kristaps Exp $ */
d654 1
a654 1
html_idcpy(char *dst, const char *src, int sz)
d656 1
a658 9
	dst[0] = '\0';
	html_idcat(dst, src, sz);
}


void
html_idcat(char *dst, const char *src, int sz)
{
	int		 i;
d662 1
a662 1
	for (i = 0; *dst != '\0' && i < sz - 1; dst++, i++)
d665 1
a665 5
	for ( ; *src != '\0' && i < sz - 1; src++, i++, dst++) {
		if (isalnum((u_char)*src)) {
			*dst = *src;
			continue;
		}
d667 1
a667 15
		switch (*src) {
		case (';'):
			*dst = ';';
			break;
		case ('-'):
			*dst = '-';
			break;
		case (':'):
			*dst = ':';
			break;
		default:
			*dst = '_';
			break;
		}
	}
d669 1
d671 7
@


1.68
log
@Fixed un-reset buffer in `.In', -Thtml, -mdoc.
Added html_id[cat,cpy] for transforming id's into well-formed attribute strings (no %s, etc.).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.67 2009/10/27 04:50:14 kristaps Exp $ */
d673 1
a673 1
	for ( ; *src != '\0' && i < sz - 1; src++, i++) {
d675 1
a675 1
			*dst++ = *src;
d681 1
a681 1
			*dst++ = ';';
d684 1
a684 1
			*dst++ = '-';
d687 1
a687 1
			*dst++ = ':';
a688 2
		case ('_'):
			/* FALLTHROUGH */
d690 1
a690 1
			*dst++ = '_';
@


1.67
log
@Added "summary" tag to tables in order to silence HTML-tidy's complaints.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.66 2009/10/26 08:18:15 kristaps Exp $ */
d20 1
d652 47
@


1.66
log
@Portability: replaced queue macros in html.c (Joerg Sonnenberger).
Fixed "-o" residue.
Added "-O" to usage() (-o didn't appear there either).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.65 2009/10/20 05:45:21 kristaps Exp $ */
d83 1
@


1.65
log
@More updates to mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.64 2009/10/13 10:57:25 kristaps Exp $ */
a17 1
#include <sys/queue.h>
d104 2
a105 2
	SLIST_INIT(&h->tags);
	SLIST_INIT(&h->ords);
d140 2
a141 3
	while ( ! SLIST_EMPTY(&h->ords)) {
		ord = SLIST_FIRST(&h->ords);
		SLIST_REMOVE_HEAD(&h->ords, entry);
d145 2
a146 3
	while ( ! SLIST_EMPTY(&h->tags)) {
		tag = SLIST_FIRST(&h->tags);
		SLIST_REMOVE_HEAD(&h->tags, entry);
d358 2
a359 1
		SLIST_INSERT_HEAD(&h->tags, t, entry);
d469 1
a469 2
	while ( ! SLIST_EMPTY(&h->tags)) {
		tag = SLIST_FIRST(&h->tags);
d471 1
a471 1
		SLIST_REMOVE_HEAD(&h->tags, entry);
d484 1
a484 2
	while ( ! SLIST_EMPTY(&h->tags)) {
		tag = SLIST_FIRST(&h->tags);
d488 1
a488 1
		SLIST_REMOVE_HEAD(&h->tags, entry);
@


1.64
log
@Moved output definitions into main.h.
Pushed terminal_{mdoc,man} into {mdoc,man}_term.c.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.63 2009/10/13 10:21:24 kristaps Exp $ */
d653 1
@


1.63
log
@Clean up consts (noted by Joerg Sonnenberger and Ulrich Sporlein).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.62 2009/10/09 06:54:11 kristaps Exp $ */
d32 1
@


1.62
log
@Scaling factor made floating point (as per groff.7) and, e.g., gnu/usr.bin/cvs/man/cvs.1.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.61 2009/10/07 15:27:11 kristaps Exp $ */
d24 1
d33 2
d39 1
a39 1
	char		 *name;
d93 2
a94 1
	char		*toks[4], *v;
d113 1
a113 1
		switch (getsubopt(&outopts, toks, &v)) {
d607 1
a607 1
	char		*u;
@


1.61
log
@Fixed side-effect of linting (oops).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.60 2009/10/07 15:06:03 kristaps Exp $ */
d602 1
a602 1
	int		 v;
d642 5
a646 1
	buffmt(h, "%s: %d%s;", p, v, u);
@


1.60
log
@Lint-ified.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.59 2009/10/07 14:39:00 kristaps Exp $ */
d552 2
a553 2
	p = strchr(pp, '%');
	while (NULL != p) {
d577 3
a579 2
	p = strchr(pp, '%');
	while (NULL != p) {
@


1.59
log
@Made default string units (-Thtml -mdoc) to use `m' and not `n' scaling (better more than less).
Fixed -column widths for -Thtml -mdoc.
Fixed left-hand margin padding for -Thtml -mdoc.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.58 2009/10/07 12:35:23 kristaps Exp $ */
d552 2
a553 1
	while ((p = strchr(pp, '%'))) {
d577 2
a578 1
	while ((p = strchr(pp, '%'))) {
@


1.58
log
@Additions to -Tman -Thtml: all structural components tested & in place.
Fitted both -Thtml with handling of arbitrary vertical and horizontal scaling units (see groff(7)).  Undocumented until fitted into -Tascii (next release).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.57 2009/10/04 09:02:40 kristaps Exp $ */
d617 3
d625 6
a631 2
		/* FALLTHROUGH */
	case (SCALE_EM):
@


1.57
log
@Example style-sheet reflecting modified section/subsection style tags.
Added ATTR_ID and so forth to attrs.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.56 2009/10/03 16:37:23 kristaps Exp $ */
d28 1
d503 11
d580 1
a580 1
			bufcat(h, sec);
d583 1
a583 1
			buffmt(h, name ? name : "1");
d594 40
@


1.56
log
@Lintified (noops).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.55 2009/10/03 16:36:06 kristaps Exp $ */
d78 1
@


1.55
log
@Fixed mandoc.1 examples (new -Thtml options).
Fixed manuals to use `In', not `Fd'.
Moved buf* functions into html.c.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.54 2009/10/03 15:26:26 kristaps Exp $ */
d514 1
a514 1
	(void)vsnprintf(h->buf + h->buflen, 
a517 1
	assert('\0' == h->buf[h->buflen]);
a529 1
	assert('\0' == h->buf[h->buflen]);
d540 1
a540 1
		bufncat(h, pp, p - pp);
d564 1
a564 1
		bufncat(h, pp, p - pp);
@


1.54
log
@Added the -oincludes=FMT option.
The `In' handler now decorates with a hyperlink.
If no -oman= or -oincludes= is stipulated, no link is printed (but the text is still style-decorated).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.53 2009/10/03 15:08:09 kristaps Exp $ */
d23 1
a145 2
	if (h->buf)
		free(h->buf);
d489 94
@


1.53
log
@Element tag buffer is now part of struct html.
buffmt() can be called in sequence.
Noted BUFSIZ-sized buffer in CAVEATS (attribute length for link formats).
Added -oman=FMT -Thtml option for `Xr' manual links.
Removed -obase=URI -Thtml option (obsolete).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.52 2009/09/24 09:50:31 kristaps Exp $ */
d76 1
d91 2
a92 1
	toks[2] = NULL;
a104 2
	h->base_man = "%N.%S.html";

d113 3
@


1.52
log
@Added Bf, Pf, etc. to -Thtml.
Fixed Rs in -Tascii to behave properly when not in "SEE ALSO" section.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.51 2009/09/21 14:56:56 kristaps Exp $ */
d86 1
a86 1
	char		*toks[3], *v;
d89 1
a89 1
	toks[1] = "base";
d103 2
d111 1
a111 1
			h->base = v;
d142 2
d146 1
a178 6

	if (h->base) {
		tag[0].key = ATTR_HREF;
		tag[1].val = h->base;
		print_otag(h, TAG_BASE, 1, tag);
	}
@


1.51
log
@Split html.c into html.h, mdoc_html.c, man_html.c.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.50 2009/09/21 14:40:31 kristaps Exp $ */
d427 2
a428 1
			h->flags |= HTML_NOSPACE;
@


1.50
log
@Removed man handling in -Thtml (for now).
Added some UTF chars to chars.in.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.49 2009/09/21 14:08:13 kristaps Exp $ */
a20 1
#include <ctype.h>
d28 1
a28 2
#include "mdoc.h"
#include "man.h"
a32 43
#define	INDENT		 5
#define	HALFINDENT	 3

enum	htmltag {
	TAG_HTML,
	TAG_HEAD,
	TAG_BODY,
	TAG_META,
	TAG_TITLE,
	TAG_DIV,
	TAG_H1,
	TAG_H2,
	TAG_P,
	TAG_SPAN,
	TAG_LINK,
	TAG_BR,
	TAG_A,
	TAG_TABLE,
	TAG_COL,
	TAG_TR,
	TAG_TD,
	TAG_LI,
	TAG_UL,
	TAG_OL,
	TAG_BASE,
	TAG_MAX
};

enum	htmlattr {
	ATTR_HTTPEQUIV,
	ATTR_CONTENT,
	ATTR_NAME,
	ATTR_REL,
	ATTR_HREF,
	ATTR_TYPE,
	ATTR_MEDIA,
	ATTR_CLASS,
	ATTR_STYLE,
	ATTR_WIDTH,
	ATTR_VALIGN,
	ATTR_MAX
};

a77 112
struct	htmlpair {
	enum htmlattr	  key;
	char		 *val;
};

struct	tag {
	enum htmltag	  tag;
	SLIST_ENTRY(tag)  entry;
};

struct	ord {
	int		  pos;
	const void	 *cookie;
	SLIST_ENTRY(ord)  entry;
};

SLIST_HEAD(tagq, tag);
SLIST_HEAD(ordq, ord);

struct	html {
	int		  flags;
#define	HTML_NOSPACE	 (1 << 0)
#define	HTML_NEWLINE	 (1 << 1)
	struct tagq	  tags;
	struct ordq	  ords;
	void		 *symtab;
	char		 *base;
	char		 *style;
};

#define	MDOC_ARGS	  const struct mdoc_meta *m, \
			  const struct mdoc_node *n, \
			  struct html *h
#define	MAN_ARGS	  const struct man_meta *m, \
			  const struct man_node *n, \
			  struct html *h
struct	htmlmdoc {
	int		(*pre)(MDOC_ARGS);
	void		(*post)(MDOC_ARGS);
};

static	void		  print_gen_doctype(struct html *);
static	void		  print_gen_head(struct html *);
static	void		  print_mdoc(MDOC_ARGS);
static	void		  print_mdoc_head(MDOC_ARGS);
static	void		  print_mdoc_node(MDOC_ARGS);
static	void		  print_mdoc_nodelist(MDOC_ARGS);
static	struct tag	 *print_otag(struct html *, enum htmltag, 
				int, const struct htmlpair *);
static	void		  print_tagq(struct html *, const struct tag *);
static	void		  print_stagq(struct html *, const struct tag *);
static	void		  print_ctag(struct html *, enum htmltag);
static	void		  print_encode(struct html *, const char *);
static	void		  print_escape(struct html *, const char **);
static	void		  print_text(struct html *, const char *);
static	void		  print_res(struct html *, const char *, int);
static	void		  print_spec(struct html *, const char *, int);

static	int		  a2width(const char *);
static	int		  a2offs(const char *);
static	int		  a2list(const struct mdoc_node *);

static	void		  mdoc_root_post(MDOC_ARGS);
static	int		  mdoc_root_pre(MDOC_ARGS);
static	int		  mdoc_tbl_pre(MDOC_ARGS, int);
static	int		  mdoc_tbl_block_pre(MDOC_ARGS, int, int, int, int);
static	int		  mdoc_tbl_body_pre(MDOC_ARGS, int, int);
static	int		  mdoc_tbl_head_pre(MDOC_ARGS, int, int);

static	int		  mdoc_ad_pre(MDOC_ARGS);
static	int		  mdoc_an_pre(MDOC_ARGS);
static	void		  mdoc_aq_post(MDOC_ARGS);
static	int		  mdoc_aq_pre(MDOC_ARGS);
static	int		  mdoc_ar_pre(MDOC_ARGS);
static	int		  mdoc_bd_pre(MDOC_ARGS);
static	void		  mdoc_bl_post(MDOC_ARGS);
static	int		  mdoc_bl_pre(MDOC_ARGS);
static	int		  mdoc_cd_pre(MDOC_ARGS);
static	int		  mdoc_d1_pre(MDOC_ARGS);
static	void		  mdoc_dq_post(MDOC_ARGS);
static	int		  mdoc_dq_pre(MDOC_ARGS);
static	int		  mdoc_dv_pre(MDOC_ARGS);
static	int		  mdoc_fa_pre(MDOC_ARGS);
static	int		  mdoc_fd_pre(MDOC_ARGS);
static	int		  mdoc_fl_pre(MDOC_ARGS);
static	int		  mdoc_fn_pre(MDOC_ARGS);
static	int		  mdoc_ft_pre(MDOC_ARGS);
static	int		  mdoc_em_pre(MDOC_ARGS);
static	int		  mdoc_er_pre(MDOC_ARGS);
static	int		  mdoc_ev_pre(MDOC_ARGS);
static	int		  mdoc_ex_pre(MDOC_ARGS);
static	int		  mdoc_it_pre(MDOC_ARGS);
static	int		  mdoc_nd_pre(MDOC_ARGS);
static	int		  mdoc_nm_pre(MDOC_ARGS);
static	int		  mdoc_ns_pre(MDOC_ARGS);
static	void		  mdoc_op_post(MDOC_ARGS);
static	int		  mdoc_op_pre(MDOC_ARGS);
static	int		  mdoc_pa_pre(MDOC_ARGS);
static	void		  mdoc_pq_post(MDOC_ARGS);
static	int		  mdoc_pq_pre(MDOC_ARGS);
static	void		  mdoc_qq_post(MDOC_ARGS);
static	int		  mdoc_qq_pre(MDOC_ARGS);
static	int		  mdoc_sh_pre(MDOC_ARGS);
static	int		  mdoc_sp_pre(MDOC_ARGS);
static	void		  mdoc_sq_post(MDOC_ARGS);
static	int		  mdoc_sq_pre(MDOC_ARGS);
static	int		  mdoc_ss_pre(MDOC_ARGS);
static	int		  mdoc_sx_pre(MDOC_ARGS);
static	int		  mdoc_vt_pre(MDOC_ARGS);
static	int		  mdoc_xr_pre(MDOC_ARGS);
static	int		  mdoc_xx_pre(MDOC_ARGS);

a79 2
extern	size_t	  	  strlcpy(char *, const char *, size_t);
extern	size_t	  	  strlcat(char *, const char *, size_t);
a81 153
static	const struct htmlmdoc mdocs[MDOC_MAX] = {
	{NULL, NULL}, /* Ap */
	{NULL, NULL}, /* Dd */
	{NULL, NULL}, /* Dt */
	{NULL, NULL}, /* Os */
	{mdoc_sh_pre, NULL }, /* Sh */
	{mdoc_ss_pre, NULL }, /* Ss */ 
	{mdoc_sp_pre, NULL}, /* Pp */ 
	{mdoc_d1_pre, NULL}, /* D1 */
	{mdoc_d1_pre, NULL}, /* Dl */
	{mdoc_bd_pre, NULL}, /* Bd */
	{NULL, NULL}, /* Ed */
	{mdoc_bl_pre, mdoc_bl_post}, /* Bl */
	{NULL, NULL}, /* El */
	{mdoc_it_pre, NULL}, /* It */
	{mdoc_ad_pre, NULL}, /* Ad */ 
	{mdoc_an_pre, NULL}, /* An */
	{mdoc_ar_pre, NULL}, /* Ar */
	{mdoc_cd_pre, NULL}, /* Cd */
	{mdoc_fl_pre, NULL}, /* Cm */
	{mdoc_dv_pre, NULL}, /* Dv */ 
	{mdoc_er_pre, NULL}, /* Er */ 
	{mdoc_ev_pre, NULL}, /* Ev */ 
	{mdoc_ex_pre, NULL}, /* Ex */
	{mdoc_fa_pre, NULL}, /* Fa */ 
	{mdoc_fd_pre, NULL}, /* Fd */ 
	{mdoc_fl_pre, NULL}, /* Fl */
	{mdoc_fn_pre, NULL}, /* Fn */ 
	{mdoc_ft_pre, NULL}, /* Ft */ 
	{NULL, NULL}, /* Ic */ 
	{NULL, NULL}, /* In */ 
	{NULL, NULL}, /* Li */
	{mdoc_nd_pre, NULL}, /* Nd */ 
	{mdoc_nm_pre, NULL}, /* Nm */ 
	{mdoc_op_pre, mdoc_op_post}, /* Op */
	{NULL, NULL}, /* Ot */
	{mdoc_pa_pre, NULL}, /* Pa */
	{NULL, NULL}, /* Rv */
	{NULL, NULL}, /* St */ 
	{NULL, NULL}, /* Va */
	{mdoc_vt_pre, NULL}, /* Vt */ 
	{mdoc_xr_pre, NULL}, /* Xr */
	{NULL, NULL}, /* %A */
	{NULL, NULL}, /* %B */
	{NULL, NULL}, /* %D */
	{NULL, NULL}, /* %I */
	{NULL, NULL}, /* %J */
	{NULL, NULL}, /* %N */
	{NULL, NULL}, /* %O */
	{NULL, NULL}, /* %P */
	{NULL, NULL}, /* %R */
	{NULL, NULL}, /* %T */
	{NULL, NULL}, /* %V */
	{NULL, NULL}, /* Ac */
	{mdoc_aq_pre, mdoc_aq_post}, /* Ao */
	{mdoc_aq_pre, mdoc_aq_post}, /* Aq */
	{NULL, NULL}, /* At */
	{NULL, NULL}, /* Bc */
	{NULL, NULL}, /* Bf */ 
	{NULL, NULL}, /* Bo */
	{NULL, NULL}, /* Bq */
	{mdoc_xx_pre, NULL}, /* Bsx */
	{NULL, NULL}, /* Bx */
	{NULL, NULL}, /* Db */
	{NULL, NULL}, /* Dc */
	{NULL, NULL}, /* Do */
	{mdoc_dq_pre, mdoc_dq_post}, /* Dq */
	{NULL, NULL}, /* Ec */
	{NULL, NULL}, /* Ef */
	{mdoc_em_pre, NULL}, /* Em */ 
	{NULL, NULL}, /* Eo */
	{mdoc_xx_pre, NULL}, /* Fx */
	{NULL, NULL}, /* Ms */
	{NULL, NULL}, /* No */
	{mdoc_ns_pre, NULL}, /* Ns */
	{mdoc_xx_pre, NULL}, /* Nx */
	{mdoc_xx_pre, NULL}, /* Ox */
	{NULL, NULL}, /* Pc */
	{NULL, NULL}, /* Pf */
	{mdoc_pq_pre, mdoc_pq_post}, /* Po */
	{mdoc_pq_pre, mdoc_pq_post}, /* Pq */
	{NULL, NULL}, /* Qc */
	{NULL, NULL}, /* Ql */
	{mdoc_qq_pre, mdoc_qq_post}, /* Qo */
	{mdoc_qq_pre, mdoc_qq_post}, /* Qq */
	{NULL, NULL}, /* Re */
	{NULL, NULL}, /* Rs */
	{NULL, NULL}, /* Sc */
	{mdoc_sq_pre, mdoc_sq_post}, /* So */
	{mdoc_sq_pre, mdoc_sq_post}, /* Sq */
	{NULL, NULL}, /* Sm */
	{mdoc_sx_pre, NULL}, /* Sx */
	{NULL, NULL}, /* Sy */
	{NULL, NULL}, /* Tn */
	{mdoc_xx_pre, NULL}, /* Ux */
	{NULL, NULL}, /* Xc */
	{NULL, NULL}, /* Xo */
	{NULL, NULL}, /* Fo */ 
	{NULL, NULL}, /* Fc */ 
	{NULL, NULL}, /* Oo */
	{NULL, NULL}, /* Oc */
	{NULL, NULL}, /* Bk */
	{NULL, NULL}, /* Ek */
	{NULL, NULL}, /* Bt */
	{NULL, NULL}, /* Hf */
	{NULL, NULL}, /* Fr */
	{NULL, NULL}, /* Ud */
	{NULL, NULL}, /* Lb */
	{mdoc_sp_pre, NULL}, /* Lp */ 
	{NULL, NULL}, /* Lk */ 
	{NULL, NULL}, /* Mt */ 
	{NULL, NULL}, /* Brq */ 
	{NULL, NULL}, /* Bro */ 
	{NULL, NULL}, /* Brc */ 
	{NULL, NULL}, /* %C */ 
	{NULL, NULL}, /* Es */ 
	{NULL, NULL}, /* En */ 
	{mdoc_xx_pre, NULL}, /* Dx */ 
	{NULL, NULL}, /* %Q */ 
	{mdoc_sp_pre, NULL}, /* br */
	{mdoc_sp_pre, NULL}, /* sp */ 
};

static	char		  buf[BUFSIZ]; /* XXX */

#define	bufcat(x)	  (void)strlcat(buf, (x), BUFSIZ) 
#define	bufinit()	  buf[0] = 0
#define	buffmt(...)	  (void)snprintf(buf, BUFSIZ - 1, __VA_ARGS__)

void
html_mdoc(void *arg, const struct mdoc *m)
{
	struct html 	*h;
	struct tag	*t;

	h = (struct html *)arg;

	print_gen_doctype(h);
	t = print_otag(h, TAG_HTML, 0, NULL);
	print_mdoc(mdoc_meta(m), mdoc_node(m), h);
	print_tagq(h, t);

	printf("\n");
}


/* ARGSUSED */
void
html_man(void *arg, const struct man *m)
{
}


d146 1
a146 109
static int
a2list(const struct mdoc_node *n)
{
	int		 i;

	assert(MDOC_BLOCK == n->type && MDOC_Bl == n->tok);
	assert(n->args);

	for (i = 0; i < (int)n->args->argc; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	abort();
	/* NOTREACHED */
}


static int
a2width(const char *p)
{
	int		 i, len;

	if (0 == (len = (int)strlen(p)))
		return(0);
	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p) + 2);

	return(len + 2);
}


static int
a2offs(const char *p)
{
	int		 len, i;

	if (0 == strcmp(p, "left"))
		return(0);
	if (0 == strcmp(p, "indent"))
		return(INDENT + 1);
	if (0 == strcmp(p, "indent-two"))
		return((INDENT + 1) * 2);

	if (0 == (len = (int)strlen(p)))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p));

	return(len);
}


static void
print_mdoc(MDOC_ARGS)
{
	struct tag	*t;
	struct htmlpair	 tag;

	t = print_otag(h, TAG_HEAD, 0, NULL);
	print_mdoc_head(m, n, h);
	print_tagq(h, t);

	t = print_otag(h, TAG_BODY, 0, NULL);

	tag.key = ATTR_CLASS;
	tag.val = "body";
	print_otag(h, TAG_DIV, 1, &tag);

	print_mdoc_nodelist(m, n, h);
	print_tagq(h, t);
}


static void
a182 77
/* ARGSUSED */
static void
print_mdoc_head(MDOC_ARGS)
{
	char		b[BUFSIZ];

	print_gen_head(h);

	(void)snprintf(b, BUFSIZ - 1, 
			"%s(%d)", m->title, m->msec);

	if (m->arch) {
		(void)strlcat(b, " (", BUFSIZ);
		(void)strlcat(b, m->arch, BUFSIZ);
		(void)strlcat(b, ")", BUFSIZ);
	}

	print_otag(h, TAG_TITLE, 0, NULL);
	print_text(h, b);
}


static void
print_mdoc_nodelist(MDOC_ARGS)
{

	print_mdoc_node(m, n, h);
	if (n->next)
		print_mdoc_nodelist(m, n->next, h);
}


static void
print_mdoc_node(MDOC_ARGS)
{
	int		 child;
	struct tag	*t;

	child = 1;
	t = SLIST_FIRST(&h->tags);

	bufinit();

	switch (n->type) {
	case (MDOC_ROOT):
		child = mdoc_root_pre(m, n, h);
		break;
	case (MDOC_TEXT):
		print_text(h, n->string);
		break;
	default:
		if (mdocs[n->tok].pre)
			child = (*mdocs[n->tok].pre)(m, n, h);
		break;
	}

	if (child && n->child)
		print_mdoc_nodelist(m, n->child, h);

	print_stagq(h, t);

	bufinit();

	switch (n->type) {
	case (MDOC_ROOT):
		mdoc_root_post(m, n, h);
		break;
	case (MDOC_TEXT):
		break;
	default:
		if (mdocs[n->tok].post)
			(*mdocs[n->tok].post)(m, n, h);
		break;
	}
}


d342 1
a342 1
static struct tag *
d396 1
a396 1
static void
d404 1
a404 1
static void
d457 1
a457 1
static void
d473 1
a473 1
static void
a486 1179


/* ARGSUSED */
static void
mdoc_root_post(MDOC_ARGS)
{
	struct tm	 tm;
	struct htmlpair	 tag[2];
	struct tag	*t, *tt;
	char		 b[BUFSIZ];

	(void)localtime_r(&m->date, &tm);

	if (0 == strftime(b, BUFSIZ - 1, "%B %e, %Y", &tm))
		err(EXIT_FAILURE, "strftime");

	tag[0].key = ATTR_CLASS;
	tag[0].val = "footer";
	tag[1].key = ATTR_STYLE;
	tag[1].val = "width: 100%;";
	t = print_otag(h, TAG_TABLE, 2, tag);
	tt = print_otag(h, TAG_TR, 0, NULL);

	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 50%;";
	print_otag(h, TAG_TD, 1, tag);
	print_text(h, b);
	print_stagq(h, tt);

	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 50%; text-align: right;";
	print_otag(h, TAG_TD, 1, tag);
	print_text(h, m->os);
	print_tagq(h, t);
}


/* ARGSUSED */
static int
mdoc_root_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];
	struct tag	*t, *tt;
	char		 b[BUFSIZ], title[BUFSIZ];

	(void)strlcpy(b, m->vol, BUFSIZ);

	if (m->arch) {
		(void)strlcat(b, " (", BUFSIZ);
		(void)strlcat(b, m->arch, BUFSIZ);
		(void)strlcat(b, ")", BUFSIZ);
	}

	(void)snprintf(title, BUFSIZ - 1, 
			"%s(%d)", m->title, m->msec);

	tag[0].key = ATTR_CLASS;
	tag[0].val = "header";
	tag[1].key = ATTR_STYLE;
	tag[1].val = "width: 100%;";
	t = print_otag(h, TAG_TABLE, 2, tag);
	tt = print_otag(h, TAG_TR, 0, NULL);

	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 33%;";
	print_otag(h, TAG_TD, 1, tag);
	print_text(h, b);
	print_stagq(h, tt);

	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 33%; text-align: center;";
	print_otag(h, TAG_TD, 1, tag);
	print_text(h, title);
	print_stagq(h, tt);

	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 33%; text-align: right;";
	print_otag(h, TAG_TD, 1, tag);
	print_text(h, b);
	print_tagq(h, t);

	return(1);
}


/* ARGSUSED */
static int
mdoc_sh_pre(MDOC_ARGS)
{
	struct htmlpair		 tag[2];
	const struct mdoc_node	*nn;

	if (MDOC_HEAD == n->type) {
		tag[0].key = ATTR_CLASS;
		tag[0].val = "sec-head";
		print_otag(h, TAG_DIV, 1, tag);
		print_otag(h, TAG_SPAN, 1, tag);

		for (nn = n->child; nn; nn = nn->next) {
			bufcat(nn->string);
			if (nn->next)
				bufcat(" ");
		}
		tag[0].key = ATTR_NAME;
		tag[0].val = buf;
		print_otag(h, TAG_A, 1, tag);
		return(1);
	} else if (MDOC_BLOCK == n->type) {
		tag[0].key = ATTR_CLASS;
		tag[0].val = "sec-block";

		if (n->prev && NULL == n->prev->body->child) {
			print_otag(h, TAG_DIV, 1, tag);
			return(1);
		}

		bufcat("margin-top: 1em;");
		if (NULL == n->next)
			bufcat("margin-bottom: 1em;");

		tag[1].key = ATTR_STYLE;
		tag[1].val = buf;

		print_otag(h, TAG_DIV, 2, tag);
		return(1);
	}

	buffmt("margin-left: %dem;", INDENT);
	
	tag[0].key = ATTR_CLASS;
	tag[0].val = "sec-body";
	tag[1].key = ATTR_STYLE;
	tag[1].val = buf;

	print_otag(h, TAG_DIV, 2, tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_ss_pre(MDOC_ARGS)
{
	struct htmlpair	 	 tag[2];
	int		 	 i;
	const struct mdoc_node	*nn;

	i = 0;

	if (MDOC_BODY == n->type) {
		tag[i].key = ATTR_CLASS;
		tag[i++].val = "ssec-body";
		if (n->parent->next && n->child) {
			bufcat("margin-bottom: 1em;");
			tag[i].key = ATTR_STYLE;
			tag[i++].val = buf;
		}
		print_otag(h, TAG_DIV, i, tag);
		return(1);
	} else if (MDOC_BLOCK == n->type) {
		tag[i].key = ATTR_CLASS;
		tag[i++].val = "ssec-block";
		if (n->prev) {
			bufcat("margin-top: 1em;");
			tag[i].key = ATTR_STYLE;
			tag[i++].val = buf;
		}
		print_otag(h, TAG_DIV, i, tag);
		return(1);
	}

	buffmt("margin-left: -%dem;", INDENT - HALFINDENT);

	tag[0].key = ATTR_CLASS;
	tag[0].val = "ssec-head";
	tag[1].key = ATTR_STYLE;
	tag[1].val = buf;

	print_otag(h, TAG_DIV, 2, tag);
	print_otag(h, TAG_SPAN, 1, tag);

	bufinit();
	for (nn = n->child; nn; nn = nn->next) {
		bufcat(nn->string);
		if (nn->next)
			bufcat(" ");
	}
	tag[0].key = ATTR_NAME;
	tag[0].val = buf;
	print_otag(h, TAG_A, 1, tag);

	return(1);
}


/* ARGSUSED */
static int
mdoc_fl_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	tag.key = ATTR_CLASS;
	tag.val = "flag";

	print_otag(h, TAG_SPAN, 1, &tag);
	if (MDOC_Fl == n->tok) {
		print_text(h, "\\-");
		h->flags |= HTML_NOSPACE;
	}
	return(1);
}


/* ARGSUSED */
static int
mdoc_nd_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (MDOC_BODY != n->type)
		return(1);

	/* XXX - this can contain block elements! */
	print_text(h, "\\(em");
	tag.key = ATTR_CLASS;
	tag.val = "desc-body";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_op_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (MDOC_BODY != n->type)
		return(1);

	/* XXX - this can contain block elements! */
	print_text(h, "\\(lB");
	h->flags |= HTML_NOSPACE;
	tag.key = ATTR_CLASS;
	tag.val = "opt";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static void
mdoc_op_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type) 
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rB");
}


static int
mdoc_nm_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if ( ! (HTML_NEWLINE & h->flags))
		if (SEC_SYNOPSIS == n->sec) {
			tag.key = ATTR_STYLE;
			tag.val = "clear: both;";
			print_otag(h, TAG_BR, 1, &tag);
		}

	tag.key = ATTR_CLASS;
	tag.val = "name";

	print_otag(h, TAG_SPAN, 1, &tag);
	if (NULL == n->child)
		print_text(h, m->name);

	return(1);
}


/* ARGSUSED */
static int
mdoc_xr_pre(MDOC_ARGS)
{
	struct htmlpair	 	 tag[2];
	const char		*name, *sec;
	const struct mdoc_node	*nn;

	nn = n->child;
	name = nn && nn->string ? nn->string : "";
	nn = nn ? nn->next : NULL;
	sec = nn && nn->string ? nn->string : "";

	buffmt("%s%s%s.html", name, name && sec ? "." : "", sec);

	tag[0].key = ATTR_CLASS;
	tag[0].val = "link-man";
	tag[1].key = ATTR_HREF;
	tag[1].val = buf;
	print_otag(h, TAG_A, 2, tag);

	nn = n->child;
	print_text(h, nn->string);
	if (NULL == (nn = nn->next))
		return(0);

	h->flags |= HTML_NOSPACE;
	print_text(h, "(");
	h->flags |= HTML_NOSPACE;
	print_text(h, nn->string);
	h->flags |= HTML_NOSPACE;
	print_text(h, ")");

	return(0);
}


/* ARGSUSED */
static int
mdoc_ns_pre(MDOC_ARGS)
{

	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static int
mdoc_ar_pre(MDOC_ARGS)
{
	struct htmlpair tag;

	tag.key = ATTR_CLASS;
	tag.val = "arg";

	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_xx_pre(MDOC_ARGS)
{
	const char	*pp;
	struct htmlpair	 tag;

	switch (n->tok) {
	case (MDOC_Bsx):
		pp = "BSDI BSD/OS";
		break;
	case (MDOC_Dx):
		pp = "DragonFlyBSD";
		break;
	case (MDOC_Fx):
		pp = "FreeBSD";
		break;
	case (MDOC_Nx):
		pp = "NetBSD";
		break;
	case (MDOC_Ox):
		pp = "OpenBSD";
		break;
	case (MDOC_Ux):
		pp = "UNIX";
		break;
	default:
		return(1);
	}

	tag.key = ATTR_CLASS;
	tag.val = "unix";

	print_otag(h, TAG_SPAN, 1, &tag);
	print_text(h, pp);
	return(1);
}


/* ARGSUSED */
static int
mdoc_tbl_block_pre(MDOC_ARGS, int t, int w, int o, int c)
{
	struct htmlpair	 tag;

	switch (t) {
	case (MDOC_Column):
		/* FALLTHROUGH */
	case (MDOC_Item):
		/* FALLTHROUGH */
	case (MDOC_Ohang):
		buffmt("margin-left: %dem; clear: both;", o);
		break;
	default:
		buffmt("margin-left: %dem; clear: both;", w + o);
		break;
	}

	if ( ! c && MDOC_Column != t) {
	       if (n->prev && n->prev->body->child)
		       bufcat("padding-top: 1em;");
	       else if (NULL == n->prev)
		       bufcat("padding-top: 1em;");
	}

	tag.key = ATTR_STYLE;
	tag.val = buf;
	print_otag(h, TAG_DIV, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_tbl_body_pre(MDOC_ARGS, int t, int w)
{

	print_otag(h, TAG_DIV, 0, NULL);
	return(1);
}


/* ARGSUSED */
static int
mdoc_tbl_head_pre(MDOC_ARGS, int t, int w)
{
	struct htmlpair	 tag;
	struct ord	*ord;
	char		 nbuf[BUFSIZ];

	switch (t) {
	case (MDOC_Item):
		/* FALLTHROUGH */
	case (MDOC_Ohang):
		print_otag(h, TAG_DIV, 0, NULL);
		break;
	case (MDOC_Column):
		buffmt("min-width: %dem;", w);
		bufcat("clear: none;");
		if (n->next && MDOC_HEAD == n->next->type)
			bufcat("float: left;");
		tag.key = ATTR_STYLE;
		tag.val = buf;
		print_otag(h, TAG_DIV, 1, &tag);
		break;
	default:
		buffmt("margin-left: -%dem;", w);
		bufcat("clear: left;");
		bufcat("float: left;");
		bufcat("padding-right: 1em;");
		tag.key = ATTR_STYLE;
		tag.val = buf;
		print_otag(h, TAG_DIV, 1, &tag);
		break;
	}

	switch (t) {
	case (MDOC_Diag):
		tag.key = ATTR_CLASS;
		tag.val = "diag";
		print_otag(h, TAG_SPAN, 1, &tag);
		break;
	case (MDOC_Enum):
		ord = SLIST_FIRST(&h->ords);
		assert(ord);
		nbuf[BUFSIZ - 1] = 0;
		(void)snprintf(nbuf, BUFSIZ - 1, "%d.", ord->pos++);
		print_text(h, nbuf);
		return(0);
	case (MDOC_Dash):
		print_text(h, "\\(en");
		return(0);
	case (MDOC_Hyphen):
		print_text(h, "\\-");
		return(0);
	case (MDOC_Bullet):
		print_text(h, "\\(bu");
		return(0);
	default:
		break;
	}

	return(1);
}


static int
mdoc_tbl_pre(MDOC_ARGS, int type)
{
	int			 i, w, o, c, wp;
	const struct mdoc_node	*bl, *nn;

	bl = n->parent->parent;
	if (MDOC_BLOCK != n->type) 
		bl = bl->parent;

	/* FIXME: fmt_vspace() equivalent. */

	assert(bl->args);

	w = o = c = 0;
	wp = -1;

	for (i = 0; i < (int)bl->args->argc; i++) 
		if (MDOC_Width == bl->args->argv[i].arg) {
			assert(bl->args->argv[i].sz);
			wp = i;
			w = a2width(bl->args->argv[i].value[0]);
		} else if (MDOC_Offset == bl->args->argv[i].arg) {
			assert(bl->args->argv[i].sz);
			o = a2offs(bl->args->argv[i].value[0]);
		} else if (MDOC_Compact == bl->args->argv[i].arg) 
			c = 1;
	
	if (MDOC_HEAD == n->type && MDOC_Column == type) {
		nn = n->parent->child;
		assert(nn && MDOC_HEAD == nn->type);
		for (i = 0; nn && nn != n; nn = nn->next, i++)
			/* Counter... */ ;
		assert(nn);
		if (wp >= 0 && i < (int)bl->args[wp].argv->sz)
			w = a2width(bl->args->argv[wp].value[i]);
	}

	switch (type) {
	case (MDOC_Enum):
		/* FALLTHROUGH */
	case (MDOC_Dash):
		/* FALLTHROUGH */
	case (MDOC_Hyphen):
		/* FALLTHROUGH */
	case (MDOC_Bullet):
		if (w < 4)
			w = 4;
		break;
	case (MDOC_Inset):
		/* FALLTHROUGH */
	case (MDOC_Diag):
		w = 1;
		break;
	default:
		if (0 == w)
			w = 10;
		break;
	}

	switch (n->type) {
	case (MDOC_BLOCK):
		break;
	case (MDOC_HEAD):
		return(mdoc_tbl_head_pre(m, n, h, type, w));
	case (MDOC_BODY):
		return(mdoc_tbl_body_pre(m, n, h, type, w));
	default:
		abort();
		/* NOTREACHED */
	}

	return(mdoc_tbl_block_pre(m, n, h, type, w, o, c));
}


/* ARGSUSED */
static int
mdoc_bl_pre(MDOC_ARGS)
{
	struct ord	*ord;

	if (MDOC_BLOCK != n->type)
		return(1);
	if (MDOC_Enum != a2list(n))
		return(1);

	ord = malloc(sizeof(struct ord));
	if (NULL == ord)
		err(EXIT_FAILURE, "malloc");
	ord->cookie = n;
	ord->pos = 1;
	SLIST_INSERT_HEAD(&h->ords, ord, entry);

	return(1);
}


/* ARGSUSED */
static void
mdoc_bl_post(MDOC_ARGS)
{
	struct ord	*ord;

	if (MDOC_BLOCK != n->type)
		return;
	if (MDOC_Enum != a2list(n))
		return;

	ord = SLIST_FIRST(&h->ords);
	assert(ord);
	SLIST_REMOVE_HEAD(&h->ords, entry);
	free(ord);
}


static int
mdoc_it_pre(MDOC_ARGS)
{
	int		 type;

	if (MDOC_BLOCK == n->type)
		type = a2list(n->parent->parent);
	else
		type = a2list(n->parent->parent->parent);

	return(mdoc_tbl_pre(m, n, h, type));
}


/* ARGSUSED */
static int
mdoc_ex_pre(MDOC_ARGS)
{
	const struct mdoc_node	*nn;
	struct tag		*t;
	struct htmlpair		 tag;

	print_text(h, "The");

	tag.key = ATTR_CLASS;
	tag.val = "utility";

	for (nn = n->child; nn; nn = nn->next) {
		t = print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, nn->string);
		print_tagq(h, t);

		h->flags |= HTML_NOSPACE;

		if (nn->next && NULL == nn->next->next)
			print_text(h, ", and");
		else if (nn->next)
			print_text(h, ",");
		else
			h->flags &= ~HTML_NOSPACE;
	}

	if (n->child->next)
		print_text(h, "utilities exit");
	else
		print_text(h, "utility exits");

       	print_text(h, "0 on success, and >0 if an error occurs.");
	return(0);
}


/* ARGSUSED */
static int
mdoc_dq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lq");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_dq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rq");
}


/* ARGSUSED */
static int
mdoc_pq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\&(");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_pq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	print_text(h, ")");
}


/* ARGSUSED */
static int
mdoc_sq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(oq");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_sq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(aq");
}


/* ARGSUSED */
static int
mdoc_em_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "emph";

	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_d1_pre(MDOC_ARGS)
{
	struct htmlpair	tag[2];

	if (MDOC_BLOCK != n->type)
		return(1);

	buffmt("margin-left: %dem;", INDENT);

	tag[0].key = ATTR_CLASS;
	tag[0].val = "lit-block";
	tag[1].key = ATTR_STYLE;
	tag[1].val = buf;

	print_otag(h, TAG_DIV, 2, tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_sx_pre(MDOC_ARGS)
{
	struct htmlpair		 tag[2];
	const struct mdoc_node	*nn;

	bufcat("#");
	for (nn = n->child; nn; nn = nn->next) {
		bufcat(nn->string);
		if (nn->next)
			bufcat(" ");
	}

	tag[0].key = ATTR_HREF;
	tag[0].val = buf;
	tag[1].key = ATTR_CLASS;
	tag[1].val = "link-sec";

	print_otag(h, TAG_A, 2, tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_aq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(la");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_aq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(ra");
}


/* ARGSUSED */
static int
mdoc_bd_pre(MDOC_ARGS)
{
	struct htmlpair	 	 tag[2];
	int		 	 t, c, o, i;
	const struct mdoc_node	*bl;

	/* FIXME: fmt_vspace() shit. */

	if (MDOC_BLOCK == n->type)
		bl = n;
	else if (MDOC_HEAD == n->type)
		return(0);
	else
		bl = n->parent;

	t = o = c = 0;

	for (i = 0; i < (int)bl->args->argc; i++) 
		switch (bl->args->argv[i].arg) {
		case (MDOC_Offset):
			assert(bl->args->argv[i].sz);
			o = a2offs (bl->args->argv[i].value[0]);
			break;
		case (MDOC_Compact):
			c = 1;
			break;
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			t = bl->args->argv[i].arg;
			break;
		}

	if (MDOC_BLOCK == n->type) {
		if (o)
			buffmt("margin-left: %dem;", o);
		bufcat("margin-top: 1em;");
		tag[0].key = ATTR_STYLE;
		tag[0].val = buf;
		print_otag(h, TAG_DIV, 1, tag);
		return(1);
	}

	switch (t) {
	case (MDOC_Unfilled):
	case (MDOC_Literal):
		break;
	default:
		return(1);
	}

	bufcat("white-space: pre;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = buf;
	tag[1].key = ATTR_CLASS;
	tag[1].val = "lit-block";

	print_otag(h, TAG_DIV, 2, tag);

	for (n = n->child; n; n = n->next) {
		h->flags |= HTML_NOSPACE;
		print_mdoc_node(m, n, h);
		if (n->next)
			print_text(h, "\n");
	}

	return(0);
}


/* ARGSUSED */
static int
mdoc_pa_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "file";

	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_qq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\*q");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_qq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\*q");
}


/* ARGSUSED */
static int
mdoc_ad_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "addr";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_an_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "author";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_cd_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "config";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_dv_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "define";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_ev_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "env";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_er_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "errno";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_fa_pre(MDOC_ARGS)
{
	const struct mdoc_node	*nn;
	struct htmlpair		 tag;
	struct tag		*t;

	tag.key = ATTR_CLASS;
	tag.val = "farg";

	if (n->parent->tok != MDOC_Fo) {
		print_otag(h, TAG_SPAN, 1, &tag);
		return(1);
	}

	for (nn = n->child; nn; nn = nn->next) {
		t = print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, nn->string);
		print_tagq(h, t);
		if (nn->next)
			print_text(h, ",");
	}

	if (n->child && n->next && n->next->tok == MDOC_Fa)
		print_text(h, ",");

	return(0);
}


/* ARGSUSED */
static int
mdoc_fd_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if (SEC_SYNOPSIS == n->sec) {
		if (n->next && MDOC_Fd != n->next->tok) {
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em;";
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}

	tag.key = ATTR_CLASS;
	tag.val = "macro";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_vt_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if (SEC_SYNOPSIS == n->sec) {
		if (n->next && MDOC_Vt != n->next->tok) {
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em;";
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}

	tag.key = ATTR_CLASS;
	tag.val = "type";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}

/* ARGSUSED */
static int
mdoc_ft_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if (SEC_SYNOPSIS == n->sec) {
		if (n->prev && MDOC_Fo == n->prev->tok) {
			tag.key = ATTR_STYLE;
			tag.val = "magin-bottom: 1em;";
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}

	tag.key = ATTR_CLASS;
	tag.val = "type";
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
mdoc_fn_pre(MDOC_ARGS)
{
	struct tag		*t;
	struct htmlpair	 	 tag;
	const struct mdoc_node	*nn;

	if (SEC_SYNOPSIS == n->sec) {
		if (n->next) {
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em";
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}

	tag.key = ATTR_CLASS;
	tag.val = "type";

	t = print_otag(h, TAG_SPAN, 1, &tag);
	print_text(h, n->child->string);
	print_tagq(h, t);

	h->flags |= HTML_NOSPACE;
	print_text(h, "(");

	for (nn = n->child->next; nn; nn = nn->next) {
		tag.key = ATTR_CLASS;
		tag.val = "farg";
		t = print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, nn->string);
		print_tagq(h, t);
		if (nn->next)
			print_text(h, ",");
	}

	print_text(h, ")");

	if (SEC_SYNOPSIS == n->sec)
		print_text(h, ";");

	return(0);
}


/* ARGSUSED */
static int
mdoc_sp_pre(MDOC_ARGS)
{
	int		len;
	struct htmlpair	tag;

	switch (n->tok) {
	case (MDOC_sp):
		len = n->child ? atoi(n->child->string) : 1;
		break;
	case (MDOC_br):
		len = 0;
		break;
	default:
		len = 1;
		break;
	}

	buffmt("height: %dem", len);
	tag.key = ATTR_STYLE;
	tag.val = buf;
	print_otag(h, TAG_DIV, 1, &tag);
	return(1);

}
@


1.49
log
@Fix height of hard-breaks in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.48 2009/09/21 14:07:07 kristaps Exp $ */
a169 2
static	void		  print_man(MAN_ARGS);
static	void		  print_man_head(MAN_ARGS);
d387 1
a390 11
	struct html	*h;
	struct tag	*t;

	h = (struct html *)arg;

	print_gen_doctype(h);
	t = print_otag(h, TAG_HTML, 0, NULL);
	print_man(man_meta(m), man_node(m), h);
	print_tagq(h, t);

	printf("\n");
d607 1
d610 10
d621 1
a621 1
	print_text(h, m->title);
a680 26
print_man(MAN_ARGS)
{
	struct tag	*t;

	t = print_otag(h, TAG_HEAD, 0, NULL);
	print_man_head(m, n, h);
	print_tagq(h, t);

	t = print_otag(h, TAG_BODY, 0, NULL);
	/*print_man_body(m, n, h);*/
	print_tagq(h, t);
}


/* ARGSUSED */
static void
print_man_head(MAN_ARGS)
{

	print_gen_head(h);
	print_otag(h, TAG_TITLE, 0, NULL);
	print_text(h, m->title);
}


static void
@


1.48
log
@Consolidation of Pp/sp/br/Lp stuff.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.47 2009/09/21 13:47:40 kristaps Exp $ */
d2171 2
a2172 1
	if (MDOC_sp == n->tok)
d2174 5
a2178 1
	else
d2180 2
a2183 1

@


1.47
log
@Fix in outopts processing.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.46 2009/09/21 13:44:56 kristaps Exp $ */
a222 1
static	int		  mdoc_pp_pre(MDOC_ARGS);
d228 1
d244 1
a244 1
	{mdoc_pp_pre, NULL}, /* Ap */
d250 1
a250 1
	{mdoc_pp_pre, NULL}, /* Pp */ 
d351 1
a351 1
	{NULL, NULL}, /* Lp */ 
d362 2
a363 2
	{NULL, NULL}, /* br */
	{NULL, NULL}, /* sp */ 
a1225 13
mdoc_pp_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_STYLE;
	tag.val = "clear: both; height: 1em;";
	print_otag(h, TAG_DIV, 1, &tag);
	return(0);
}


/* ARGSUSED */
static int
d2162 22
@


1.46
log
@Fixed body/divbody structure of html pages.
Added example style.css (example.style.css).
Enabled using -Thtml to generate manuals in Makefile.
Stopped making text manuals for webpage.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.45 2009/09/21 13:43:21 kristaps Exp $ */
d427 1
a427 1
	while (*outopts)
@


1.45
log
@getsubopt() is in unistd.h, not stdlib.h (error in xBSD manuals).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.44 2009/09/21 13:42:01 kristaps Exp $ */
d561 1
d568 5
d924 1
a924 1
	printf("<!DOCTYPE HTML PUBLIC \"%s\" \"%s\">\n", DOCTYPE, DTD);
a1067 4
	tag[0].val = "body";
	t = print_otag(h, TAG_DIV, 1, tag);

	tag[0].key = ATTR_CLASS;
d1071 1
a1071 1
	print_otag(h, TAG_TABLE, 2, tag);
d1090 1
a1090 1
	print_stagq(h, t);
d1266 1
d1428 6
a1433 2
	if ( ! c && n->prev && n->prev->body->child)
		bufcat("padding-top: 1em;");
@


1.44
log
@Lint pass (OpenBSD-alpha).  Noops.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.43 2009/09/21 13:06:13 kristaps Exp $ */
d26 1
@


1.43
log
@Removed new-born out.{h,c} (not a good idea).
Removed if 0 for HTML-mode output (why not).
Added option -oxxxx for passing options to output devices.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.42 2009/09/21 09:32:30 kristaps Exp $ */
d409 1
a409 1
	char		*toks[3], *o, *v;
d426 1
a426 2
	while (*outopts) {
		o = outopts;
a436 1
	}
@


1.42
log
@Added example stylesheet.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.41 2009/09/21 00:39:02 kristaps Exp $ */
a29 1
#include "out.h"
d182 4
d237 1
d406 1
a406 1
html_alloc(void)
d409 5
d426 14
a439 2
	/* h->base = xxx; */
	h->style = "style.css"; /* XXX */
d471 87
d1531 1
a1531 1
			w = out_a2width(bl->args->argv[i].value[0]);
d1534 1
a1534 2
			o = out_a2offs
				(bl->args->argv[i].value[0], INDENT);
d1545 1
a1545 1
			w = out_a2width(bl->args->argv[wp].value[i]);
d1594 1
a1594 1
	if (MDOC_Enum != out_a2list(n))
d1616 1
a1616 1
	if (MDOC_Enum != out_a2list(n))
d1632 1
a1632 1
		type = out_a2list(n->parent->parent);
d1634 1
a1634 1
		type = out_a2list(n->parent->parent->parent);
d1859 1
a1859 2
			o = out_a2offs
				(bl->args->argv[i].value[0], INDENT);
@


1.41
log
@Tentative addition of front-end utility functions (out.h) (not sure if it's necessary).
More -Thtml installments.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.40 2009/09/20 19:44:16 kristaps Exp $ */
d418 1
a418 1
	/* h->style = xxx; */
@


1.40
log
@Using inline-blocks for header and footer (works much better).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.39 2009/09/20 19:25:06 kristaps Exp $ */
d17 1
d30 1
a36 1
#define	PX_MULT		 8
d59 1
d106 1
d149 2
a167 1
static	void		  print_mdoc_title(MDOC_ARGS);
a171 1
static	void		  print_man_body(MAN_ARGS);
a182 4
static	int		  a2width(const char *);
static	int		  a2offs(const char *);
static	int		  a2list(const struct mdoc_node *);

d190 2
d198 1
d202 3
d206 2
d209 2
d229 1
d253 2
a254 2
	{NULL, NULL}, /* Ad */ 
	{NULL, NULL}, /* An */
d256 5
a260 5
	{NULL, NULL}, /* Cd */
	{NULL, NULL}, /* Cm */
	{NULL, NULL}, /* Dv */ 
	{NULL, NULL}, /* Er */ 
	{NULL, NULL}, /* Ev */ 
d262 2
a263 2
	{NULL, NULL}, /* Fa */ 
	{NULL, NULL}, /* Fd */ 
d265 2
a266 2
	{NULL, NULL}, /* Fn */ 
	{NULL, NULL}, /* Ft */ 
d278 1
a278 1
	{NULL, NULL}, /* Vt */ 
d416 3
a459 1
	print_mdoc_title(m, n, h);
d468 31
a498 26
	struct htmlpair	 meta0[2];
	struct htmlpair	 meta1[2];
	struct htmlpair	 link[4];

	meta0[0].key = ATTR_HTTPEQUIV;
	meta0[0].val = "Content-Type";
	meta0[1].key = ATTR_CONTENT;
	meta0[1].val = "text/html; charset=utf-8";

	meta1[0].key = ATTR_NAME;
	meta1[0].val = "resource-type";
	meta1[1].key = ATTR_CONTENT;
	meta1[1].val = "document";

	link[0].key = ATTR_REL;
	link[0].val = "stylesheet";
	link[1].key = ATTR_HREF;
	link[1].val = "style.css"; /* XXX */
	link[2].key = ATTR_TYPE;
	link[2].val = "text/css";
	link[3].key = ATTR_MEDIA;
	link[3].val = "all";

	print_otag(h, TAG_META, 2, meta0);
	print_otag(h, TAG_META, 2, meta1);
	print_otag(h, TAG_LINK, 4, link);
d509 1
a509 10
	print_encode(h, m->title);
}


/* ARGSUSED */
static void
print_mdoc_title(MDOC_ARGS)
{

	/* TODO */
d578 1
a578 1
	print_man_body(m, n, h);
d590 1
a590 10
	print_encode(h, m->title);
}


/* ARGSUSED */
static void
print_man_body(MAN_ARGS)
{

	/* TODO */
a899 91
/* FIXME: put in utility file for front-ends. */
static int
a2offs(const char *p)
{
	int		 len, i;

	if (0 == strcmp(p, "left"))
		return(0);
	if (0 == strcmp(p, "indent"))
		return(INDENT + 1);
	if (0 == strcmp(p, "indent-two"))
		return((INDENT + 1) * 2);

	if (0 == (len = (int)strlen(p)))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p));

	return(len);
}


/* FIXME: put in utility file for front-ends. */
static int
a2list(const struct mdoc_node *bl)
{
	int		 i;

	assert(MDOC_BLOCK == bl->type && MDOC_Bl == bl->tok);
	assert(bl->args);

	for (i = 0; i < (int)bl->args->argc; i++) 
		switch (bl->args->argv[i].arg) {
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(bl->args->argv[i].arg);
		default:
			break;
		}

	abort();
	/* NOTREACHED */
}


/* FIXME: put in utility file for front-ends. */
static int
a2width(const char *p)
{
	int		 i, len;

	if (0 == (len = (int)strlen(p)))
		return(0);
	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p) + 2);

	return(len + 2);
}


/* FIXME: parts should be in a utility file for front-ends. */
d904 4
a907 4
	struct tm	*tm;
	struct htmlpair	 tag;
	struct tag	*t;
	char		 b[BUFSIZ], os[BUFSIZ];
d909 1
a909 1
	tm = localtime(&m->date);
d911 1
a911 1
	if (0 == strftime(b, BUFSIZ - 1, "%B %e, %Y", tm))
d914 6
a919 1
	strlcpy(os, m->os, BUFSIZ);
d921 3
a923 9
	tag.key = ATTR_CLASS;
	tag.val = "foot";

	t = print_otag(h, TAG_DIV, 1, &tag);

	tag.key = ATTR_STYLE;
	tag.val = "width: 49%; display: "
		"inline-block; text-align: left;";
	print_otag(h, TAG_SPAN, 1, &tag);
d925 1
a925 1
	print_stagq(h, t);
d927 4
a930 5
	tag.key = ATTR_STYLE;
	tag.val = "width: 49%; display: "
		"inline-block; text-align: right;";
	print_otag(h, TAG_SPAN, 1, &tag);
	print_text(h, os);
a931 1

a934 1
/* FIXME: parts should be in a utility file for front-ends. */
d939 1
a939 1
	struct htmlpair	 tag;
a942 1
	assert(m->vol);
d946 3
a948 3
		strlcat(b, " (", BUFSIZ);
		strlcat(b, m->arch, BUFSIZ);
		strlcat(b, ")", BUFSIZ);
d951 2
a952 1
	snprintf(title, BUFSIZ - 1, "%s(%d)", m->title, m->msec);
d954 3
a956 2
	tag.key = ATTR_CLASS;
	tag.val = "body";
d958 6
a963 1
	t = print_otag(h, TAG_DIV, 1, &tag);
d965 3
a967 9
	tag.key = ATTR_CLASS;
	tag.val = "head";

	tt = print_otag(h, TAG_DIV, 1, &tag);

	tag.key = ATTR_STYLE;
	tag.val = "width: 32%; text-align: left; "
		"display: inline-block;";
	print_otag(h, TAG_SPAN, 1, &tag);
d971 3
a973 4
	tag.key = ATTR_STYLE;
	tag.val = "width: 32%; text-align: center; "
		"display: inline-block;";
	print_otag(h, TAG_SPAN, 1, &tag);
d977 3
a979 4
	tag.key = ATTR_STYLE;
	tag.val = "width: 32%; text-align: right; "
		"display: inline-block;";
	print_otag(h, TAG_SPAN, 1, &tag);
d991 2
a992 1
	struct htmlpair	tag[2];
d999 9
d1045 3
a1047 2
	struct htmlpair	 tag[2];
	int		 i;
d1082 11
d1107 4
a1110 2
	print_text(h, "\\-");
	h->flags |= HTML_NOSPACE;
a1120 3
	bufcat("clear: both;");
	bufcat("height: 1em;");

d1122 1
a1122 2
	tag.val = buf;

d1203 10
a1212 1
	struct htmlpair	tag[2];
d1217 1
a1217 2
	tag[1].val = "#"; /* TODO */

d1220 3
a1222 3
	n = n->child;
	print_text(h, n->string);
	if (NULL == (n = n->next))
d1228 1
a1228 1
	print_text(h, n->string);
d1423 1
a1423 1
			w = a2width(bl->args->argv[i].value[0]);
d1426 2
a1427 1
			o = a2offs(bl->args->argv[i].value[0]);
d1438 1
a1438 1
			w = a2width(bl->args->argv[wp].value[i]);
d1479 1
d1487 1
a1487 1
	if (MDOC_Enum != a2list(n))
d1501 1
d1509 1
a1509 1
	if (MDOC_Enum != a2list(n))
d1525 1
a1525 1
		type = a2list(n->parent->parent);
d1527 1
a1527 1
		type = a2list(n->parent->parent->parent);
d1684 9
a1692 1
	struct htmlpair	tag[2];
d1695 1
a1695 1
	tag[0].val = "#"; /* XXX */
d1752 2
a1753 1
			o = a2offs(bl->args->argv[i].value[0]);
d1843 220
@


1.39
log
@Headers and footers in -Thtml.  Various minor additions.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.38 2009/09/20 17:48:13 kristaps Exp $ */
d997 1
a997 1
	struct htmlpair	 tag[2];
d1006 1
a1006 1
	(void)strlcpy(os, m->os, BUFSIZ);
d1008 2
a1009 4
	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 100%; margin-top: 1em;";
	tag[1].key = ATTR_CLASS;
	tag[1].val = "foot";
d1011 1
a1011 1
	t = print_otag(h, TAG_DIV, 2, tag);
d1013 4
a1016 7
	bufinit();
	bufcat("width: 50%;");
	bufcat("text-align: left;");
	bufcat("float: left;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = buf;
	print_otag(h, TAG_SPAN, 1, tag);
d1020 4
a1023 7
	bufinit();
	bufcat("width: 50%;");
	bufcat("text-align: right;");
	bufcat("float: left;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = buf;
	print_otag(h, TAG_SPAN, 1, tag);
d1035 1
a1035 1
	struct htmlpair	 tag[2];
d1043 3
a1045 3
		(void)strlcat(b, " (", BUFSIZ);
		(void)strlcat(b, m->arch, BUFSIZ);
		(void)strlcat(b, ")", BUFSIZ);
d1048 1
a1048 1
	(void)snprintf(title, BUFSIZ - 1, "%s(%d)", m->title, m->msec);
d1050 2
a1051 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = "body";
d1053 1
a1053 1
	t = print_otag(h, TAG_DIV, 1, tag);
d1055 2
a1056 4
	tag[0].key = ATTR_CLASS;
	tag[0].val = "head";
	tag[1].key = ATTR_STYLE;
	tag[1].val = "margin-bottom: 1em; clear: both;";
d1058 1
a1058 1
	tt = print_otag(h, TAG_DIV, 2, tag);
d1060 4
a1063 7
	bufinit();
	bufcat("width: 30%;");
	bufcat("text-align: left;");
	bufcat("float: left;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = buf;
	print_otag(h, TAG_SPAN, 1, tag);
d1067 4
a1070 7
	bufinit();
	bufcat("width: 30%;");
	bufcat("text-align: center;");
	bufcat("float: left;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = buf;
	print_otag(h, TAG_SPAN, 1, tag);
d1074 4
a1077 7
	bufinit();
	bufcat("width: 30%;");
	bufcat("text-align: right;");
	bufcat("float: left;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = buf;
	print_otag(h, TAG_SPAN, 1, tag);
a1078 1

d1106 4
d1111 1
a1111 1
		tag[1].val = "margin-top: 1em;";
@


1.38
log
@Bl -column in place for -Thtml.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.37 2009/09/20 17:24:57 kristaps Exp $ */
d165 1
d184 1
d194 1
d209 1
d213 2
d229 1
a229 1
	{NULL, NULL}, /* Ap */
d238 1
a238 1
	{NULL, NULL}, /* Bd */
d264 1
a264 1
	{NULL, NULL}, /* Pa */
d311 2
a312 2
	{NULL, NULL}, /* Qo */
	{NULL, NULL}, /* Qq */
d448 1
a448 1
	print_mdoc_node(m, n, h);
d506 10
d540 1
a540 1
		print_mdoc_node(m, n->child, h);
d548 1
a556 3

	if (n->next)
		print_mdoc_node(m, n->next, h);
d991 14
d1006 1
d1008 31
d1043 55
a1097 1
	struct htmlpair	 tag;
d1099 1
a1099 2
	tag.key = ATTR_CLASS;
	tag.val = "body";
a1100 1
	print_otag(h, TAG_DIV, 1, &tag);
d1120 10
a1129 1
		print_otag(h, TAG_DIV, 1, tag);
a1134 3
	if (n->parent->next && n->child)
		bufcat("margin-bottom: 1em;");

d1803 114
@


1.37
log
@Some extra html tags and near-complete Bl: -tag is hopeless (synonym for -hang, now) and -column is still pending.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.36 2009/09/20 13:43:31 kristaps Exp $ */
d1274 2
a1285 1

d1320 9
d1373 2
a1374 2
	int			 i, w, o, c;
	const struct mdoc_node	*bl;
d1385 1
d1390 1
d1397 10
@


1.36
log
@Fixed memory leak on close.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.35 2009/09/20 11:05:22 kristaps Exp $ */
d130 6
d137 1
d143 2
a144 1
	struct tagq	  stack;
d181 1
a182 2
static	int		  mdoc_list_pre(MDOC_ARGS, int);
static	int		  mdoc_listitem_pre(MDOC_ARGS);
d185 1
a185 1
static	int		  mdoc_tbl_block_pre(MDOC_ARGS, int, int, int);
d189 2
d192 1
d234 1
a234 1
	{mdoc_bl_pre, NULL}, /* Bl */
d276 2
a277 2
	{NULL, NULL}, /* Ao */
	{NULL, NULL}, /* Aq */
d393 3
a395 1
	SLIST_INIT(&h->stack);
d408 1
d413 9
a421 3
	while ( ! SLIST_EMPTY(&h->stack)) {
		tag = SLIST_FIRST(&h->stack);
		SLIST_REMOVE_HEAD(&h->stack, entry);
d506 1
a506 1
	t = SLIST_FIRST(&h->stack);
d751 1
a751 1
		SLIST_INSERT_HEAD(&h->stack, t, entry);
d860 2
a861 2
	while ( ! SLIST_EMPTY(&h->stack)) {
		tag = SLIST_FIRST(&h->stack);
d863 1
a863 1
		SLIST_REMOVE_HEAD(&h->stack, entry);
d876 2
a877 2
	while ( ! SLIST_EMPTY(&h->stack)) {
		tag = SLIST_FIRST(&h->stack);
d881 1
a881 1
		SLIST_REMOVE_HEAD(&h->stack, entry);
d917 42
d1269 1
a1269 1
mdoc_tbl_block_pre(MDOC_ARGS, int w, int o, int c)
d1273 10
a1282 1
	buffmt("margin-left: %dem; clear: both;", w + o);
d1284 2
a1285 1
	if ( ! c)
a1298 2
	struct htmlpair	 tag;
	int		 i;
d1300 1
a1300 15
	switch (t) {
	case (MDOC_Tag):
		i = 1;
		tag.key = ATTR_STYLE;
		tag.val = buf;
		bufcat("clear: right;");
		bufcat("float: left;");
		bufcat("width: 100%%;");
		break;
	default:
		i = 0;
		break;
	}

	print_otag(h, TAG_DIV, i, &tag);
d1310 2
a1311 1
	int		 i;
d1314 1
a1314 1
	case (MDOC_Hang):
d1316 4
a1319 4
	case (MDOC_Tag):
		i = 1;
		tag.key = ATTR_STYLE;
		tag.val = buf;
d1324 3
d1328 24
a1352 1
		i = 0;
a1355 1
	print_otag(h, TAG_DIV, i, &tag);
d1386 22
a1407 3
	if (0 == w)
		w = 10;
	
d1420 1
a1420 1
	return(mdoc_tbl_block_pre(m, n, h, w, o, c));
a1423 1
/* ARGSUSED */
d1425 1
a1425 1
mdoc_listitem_pre(MDOC_ARGS)
d1427 1
a1427 5
	int			 i, w, o, c;
	const struct mdoc_node	*bl;
	struct htmlpair	 	 tag;

	/* FIXME: fmt_vspace() equivalent. */
d1431 2
d1434 6
a1439 27
	bl = n->parent->parent;
	assert(bl);

	w = o = c = 0;

	for (i = 0; i < (int)bl->args->argc; i++) 
		if (MDOC_Width == bl->args->argv[i].arg) {
			assert(bl->args->argv[i].sz);
			w = a2width(bl->args->argv[i].value[0]);
		} else if (MDOC_Offset == bl->args->argv[i].arg) {
			assert(bl->args->argv[i].sz);
			o = a2offs(bl->args->argv[i].value[0]);
		} else if (MDOC_Compact == bl->args->argv[i].arg) 
			c = 1;

	if (o && w) 
		buffmt("margin-left: %dem; padding-left: %dem;", o, w);
	else if (w) 
		buffmt("padding-left: %dem;", w > 4 ? w - 4 : w);
	else if (o) 
		buffmt("margin-left: %dem;", o);
	
	if ( ! c)
		bufcat("padding-top: 1em;");

	tag.key = ATTR_STYLE;
	tag.val = buf;
a1440 1
	print_otag(h, TAG_LI, 1, &tag);
d1445 2
a1446 3
/* ARGSUSED */
static int
mdoc_list_pre(MDOC_ARGS, int type)
d1448 1
a1448 20

	switch (type) {
	case (MDOC_Enum):
		print_otag(h, TAG_OL, 0, NULL);
		break;
	case (MDOC_Bullet):
		print_otag(h, TAG_UL, 0, NULL);
		break;
	default:
		break;
	}

	return(1);
}


static int
mdoc_bl_pre(MDOC_ARGS)
{
	int		i, len, type;
d1451 3
a1453 1
		return(1);
d1455 4
a1458 33
	assert(n->args);
	len = (int)n->args->argc;

	for (i = 0; i < len; i++) 
		switch ((type = n->args->argv[i].arg)) {
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			return(mdoc_list_pre(m, n, h, type));
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(1); 
		default:
			break;
		}

	abort();
	/* NOTREACHED */
d1465 1
a1465 2
	int		 	 i, len, type;
	const struct mdoc_node	*bl;
d1468 1
a1468 1
		bl = n->parent->parent;
d1470 1
a1470 32
		bl = n->parent->parent->parent;

	assert(bl->args);
	len = (int)bl->args->argc;

	for (i = 0; i < len; i++) 
		switch ((type = bl->args->argv[i].arg)) {
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			return(mdoc_tbl_pre(m, n, h, type));
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			return(mdoc_listitem_pre(m, n, h));
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(0);
		default:
			break;
		}
d1472 1
a1472 2
	abort();
	/* NOTREACHED */
a1611 1
	bufcat("margin-bottom: 0px;");
d1637 26
@


1.35
log
@Considerable, wide-ranging improvements to the -Thtml output mode (most especially proper tagging and using `em' instead of `px').
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.34 2009/09/17 23:35:41 kristaps Exp $ */
d405 3
@


1.34
log
@Consider html fixes, most importantly -tag and -hang (breaks in IE6, apparently).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.33 2009/09/17 13:17:30 kristaps Exp $ */
d208 2
a209 2
extern	size_t	  strlcpy(char *, const char *, size_t);
extern	size_t	  strlcat(char *, const char *, size_t);
d335 5
d486 2
d506 2
d865 1
d893 1
d931 1
a931 1
mdoc_ss_pre(MDOC_ARGS)
d935 18
d954 41
a994 1
	tag[0].val = "ssec";
d996 2
d999 1
a999 1
	tag[1].val = "margin-left: -20px;";
d1001 2
a1002 4
	if (MDOC_BODY == n->type)
		print_otag(h, TAG_DIV, 1, &tag);
	if (MDOC_HEAD == n->type)
		print_otag(h, TAG_SPAN, 1, &tag);
d1029 3
d1033 1
a1033 1
	tag.val = "clear: both;";
d1035 1
a1035 2
	print_otag(h, TAG_BR, 1, &tag);
	print_otag(h, TAG_BR, 1, &tag);
d1044 4
d1049 5
a1053 2
	if (MDOC_BODY == n->type)
		print_text(h, "\\(en");
d1062 4
d1067 5
a1071 4
	if (MDOC_BODY == n->type) {
		print_text(h, "\\(lB");
		h->flags |= HTML_NOSPACE;
	}
d1091 1
a1091 1
	struct htmlpair	class;
d1094 5
a1098 2
		if (SEC_SYNOPSIS == n->sec)
			print_otag(h, TAG_BR, 0, NULL);
d1100 2
a1101 2
	class.key = ATTR_CLASS;
	class.val = "name";
d1103 1
a1103 1
	print_otag(h, TAG_SPAN, 1, &class);
a1112 17
mdoc_sh_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	tag.key = ATTR_CLASS;
	tag.val = "sec";

	if (MDOC_BODY == n->type)
		print_otag(h, TAG_DIV, 1, &tag);
	if (MDOC_HEAD == n->type)
		print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static int
d1115 1
a1115 1
	struct htmlpair	tag;
d1117 4
a1120 2
	tag.key = ATTR_HREF;
	tag.val = "#"; /* TODO */
d1122 1
a1122 1
	print_otag(h, TAG_A, 1, &tag);
d1149 1
d1163 1
d1169 1
d1194 4
d1203 1
a1207 3
	char		 buf[BUFSIZ];

	buf[BUFSIZ - 1] = 0;
d1209 1
a1209 2
	snprintf(buf, BUFSIZ - 1, "margin-left: %dpx; "
			"clear: both;", w + o);
d1212 1
a1212 1
		(void)strlcat(buf, " padding-top: 1em;", BUFSIZ);
a1215 1

d1221 1
a1225 1
	char		 buf[BUFSIZ];
a1227 3
	buf[BUFSIZ - 1] = 0;
	i = 0;

d1230 1
a1230 4
		i++;
		(void)snprintf(buf, BUFSIZ - 1, 
				"clear: right; float: left; "
				"width: 100%%;");
d1233 3
d1238 1
d1247 1
d1249 1
a1249 1
mdoc_tbl_head_pre(MDOC_ARGS, int type, int w)
a1251 1
	char		 buf[BUFSIZ];
d1254 3
a1256 4
	buf[BUFSIZ - 1] = 0;
	i = 0;

	switch (type) {
d1258 1
a1258 5
		i++;
		(void)snprintf(buf, BUFSIZ - 1,  
				"clear: left; float: left; "
				"padding-right: 1em; "
				"margin-left: -%dpx;", w);
d1261 4
d1267 1
a1267 7
		i++;
		(void)snprintf(buf, BUFSIZ - 1, 
				"clear: left; float: left; "
				"margin-left: -%dpx; "
				"padding-right: 1em;", w);
		tag.key = ATTR_STYLE;
		tag.val = buf;
a1303 3

	w *= PX_MULT;
	o *= PX_MULT;
a1327 1
	char		 	 buf[BUFSIZ];
d1348 7
a1355 7
	o *= PX_MULT;
	w *= PX_MULT;

	buf[BUFSIZ - 1] = 0;

	snprintf(buf, BUFSIZ - 1, "margin-left: %dpx;", o);

d1357 1
a1357 1
		(void)strlcat(buf, " padding-top: 1em;", BUFSIZ);
d1608 1
a1608 2
	struct htmlpair	tag;
	char		buf[BUFSIZ];
d1613 2
a1614 2
	(void)snprintf(buf, BUFSIZ - 1, "margin-left: %dpx", 
			INDENT * PX_MULT);
d1616 4
a1619 2
	tag.key = ATTR_STYLE;
	tag.val = buf;
d1621 1
a1621 1
	print_otag(h, TAG_DIV, 1, &tag);
d1630 1
a1630 1
	struct htmlpair	tag;
d1632 4
a1635 2
	tag.key = ATTR_HREF;
	tag.val = "#";
d1637 1
a1637 1
	print_otag(h, TAG_A, 1, &tag);
@


1.33
log
@Hang lists in html (the hard one first).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.32 2009/09/17 08:21:42 kristaps Exp $ */
d35 1
d55 3
d101 3
d174 2
a175 1
static	int		  mdoc_list_pre(MDOC_ARGS);
d177 4
a180 1
static	int		  mdoc_hang_pre(MDOC_ARGS);
d184 3
d188 2
d194 1
a195 1
static	void		  mdoc_op_post(MDOC_ARGS);
d197 2
d200 2
d203 1
d220 2
a221 2
	{NULL, NULL}, /* D1 */
	{NULL, NULL}, /* Dl */
d235 1
a235 1
	{NULL, NULL}, /* Ex */
d278 1
a278 1
	{NULL, NULL}, /* Dq */
d281 1
a281 1
	{NULL, NULL}, /* Em */ 
d291 2
a292 2
	{NULL, NULL}, /* Po */
	{NULL, NULL}, /* Pq */
d300 2
a301 2
	{NULL, NULL}, /* So */
	{NULL, NULL}, /* Sq */
d303 1
a303 1
	{NULL, NULL}, /* Sx */
d430 1
a430 1
	meta0[1].val = "text/html; charest-utf-8";
d687 15
a701 1
		if ('\\' != *p) {
d703 1
a703 1
			continue;
a704 1
		print_escape(h, &p);
d922 7
d931 1
a931 1
		print_otag(h, TAG_DIV, 0, NULL);
d933 1
a933 1
		print_otag(h, TAG_H2, 0, NULL);
d958 1
d960 5
a964 2
	print_otag(h, TAG_BR, 0, NULL);
	print_otag(h, TAG_BR, 0, NULL);
d1029 4
d1035 1
a1035 1
		print_otag(h, TAG_DIV, 0, NULL);
d1037 1
a1037 1
		print_otag(h, TAG_H1, 0, NULL);
d1126 51
a1176 1
mdoc_hang_pre(MDOC_ARGS)
d1178 6
a1183 4
	int			 i, width, offs;
	struct htmlpair		 tag;
	char			 buf[BUFSIZ];
	const struct mdoc_node	*bl;
d1185 19
a1203 3
	if (MDOC_BODY == n->type) {
		print_otag(h, TAG_DIV, 0, NULL);
		return(1);
d1206 11
d1221 2
d1225 3
a1227 1
	for (width = i = 0; i < (int)bl->args->argc; i++) 
d1230 52
a1281 2
			width = a2width(bl->args->argv[i].value[0]);
			break;
d1284 6
a1289 3
			offs = a2offs(bl->args->argv[i].value[0]);
			break;
		}
d1291 1
a1291 2
	if (0 == width)
		width = 10;
d1293 1
a1293 1
	width *= 10;
d1295 2
a1296 6
	if (MDOC_BLOCK == n->type)
		snprintf(buf, BUFSIZ - 1, "margin-left: %dpx; "
				"clear: both;", width);
	else
		snprintf(buf, BUFSIZ - 1, "float: left; "
				"margin-left: -%dpx;", width);
d1301 1
a1301 2
	print_otag(h, TAG_DIV, 1, &tag);

d1306 1
d1308 1
a1308 1
mdoc_list_pre(MDOC_ARGS)
d1311 12
a1322 2
	/* TODO */
	return(0);
d1327 1
a1327 1
mdoc_it_pre(MDOC_ARGS)
d1329 1
a1329 2
	int		 	 i, len;
	const struct mdoc_node	*bl;
d1331 2
a1332 4
	if (MDOC_BLOCK == n->type)
		bl = n->parent->parent;
	else
		bl = n->parent->parent->parent;
d1334 2
a1335 2
	assert(bl->args);
	len = (int)bl->args->argc;
d1338 3
a1340 1
		switch (bl->args->argv[i].arg) {
d1342 4
d1349 1
a1349 1
		case (MDOC_Enum):
a1350 4
		case (MDOC_Hyphen):
			return(0); /* TODO */
		case (MDOC_Tag):
			return(0);
a1358 3
		case (MDOC_Hang):
			return(mdoc_hang_pre(m, n, h));
			/* FALLTHROUGH */
d1360 1
a1360 1
			return(0); /* TODO */
d1362 1
a1362 2
			abort();
			/* NOTREACHED */
d1371 1
a1371 1
mdoc_bl_pre(MDOC_ARGS)
d1373 2
a1374 1
	int		 i, len;
d1376 4
a1379 2
	if (MDOC_BLOCK != n->type)
		return(1);
d1381 2
a1382 2
	assert(n->args);
	len = (int)n->args->argc;
d1385 7
a1391 1
		switch (n->args->argv[i].arg) {
d1393 1
a1393 1
			/* FALLTHROUGH */
d1396 1
a1396 1
		case (MDOC_Enum):
a1397 4
		case (MDOC_Hyphen):
			return(mdoc_list_pre(m, n, h));
		case (MDOC_Tag):
			return(0);
a1405 2
		case (MDOC_Hang):
			return(1);
d1407 1
a1407 1
			return(0); /* TODO */
d1409 1
a1409 2
			abort();
			/* NOTREACHED */
d1415 161
@


1.32
log
@More html.
Initial html encodings in chars.in.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.31 2009/09/17 07:41:28 kristaps Exp $ */
d20 1
d24 1
d33 3
d50 4
d66 3
d84 1
a84 1
	{"title",	HTML_CLRLINE | HTML_NOSTACK}, /* TAG_TITLE */
d93 4
d107 4
a110 1
	"class"
d163 5
d169 1
d172 1
d174 1
d184 6
d203 1
a203 1
	{NULL, NULL}, /* Bl */
d205 1
a205 1
	{NULL, NULL}, /* It */
d252 1
a252 1
	{NULL, NULL}, /* Bsx */
d262 1
a262 1
	{NULL, NULL}, /* Fx */
d266 2
a267 2
	{NULL, NULL}, /* Nx */
	{NULL, NULL}, /* Ox */
d285 1
a285 1
	{NULL, NULL}, /* Ux */
d308 1
a308 1
	{NULL, NULL}, /* Dx */ 
d314 1
d331 1
d348 1
d365 1
d382 1
d398 1
d430 1
d441 1
d450 1
d493 1
d508 1
d519 1
d528 1
d544 1
d560 1
d822 48
d890 1
a890 1
		print_otag(h, TAG_P, 0, NULL);
d986 1
a986 1
		print_otag(h, TAG_P, 0, NULL);
a1028 1

d1041 187
@


1.31
log
@ascii_xxx -> chars_xxx (intended to hold more than just ascii encoding).
More html work.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.30 2009/09/16 22:17:27 kristaps Exp $ */
d24 1
d111 1
d139 2
a140 1
static	void		  print_encode(const char *);
d142 2
a280 1

a296 1

a312 1

d322 4
a328 1

a344 1

a359 1

a390 1

d398 1
a398 1
	print_encode(m->title);
a400 1

a408 1

a450 1

a464 1

d472 1
a472 1
	print_encode(m->title);
a474 1

d483 129
d614 1
a614 1
print_encode(const char *p)
d617 7
a623 1
	printf("%s", p); /* XXX */
d650 1
a650 1
		print_encode(p[i].val);
d725 1
a725 1
		print_encode(p);
@


1.30
log
@More updates to html.c.
Secretly enabled -Thtml in main.c (obviously not yet documented).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.29 2009/09/16 09:41:24 kristaps Exp $ */
d141 1
d145 1
d170 1
a170 1
	{NULL, NULL}, /* Ar */
d227 1
a227 1
	{NULL, NULL}, /* Ns */
d702 1
a702 1
		print_text(h, "--");
d790 24
@


1.29
log
@Made tree/term/out() functions return void.
Put err() functions back into front-ends (no use making it needlessly complex).
@
text
@d1 1
a1 1
/*	$Id: tree.c,v 1.14 2009/08/13 11:45:29 kristaps Exp $ */
d17 2
d42 2
d62 2
a63 1
#define	HTML_BLOCK	 (1 << 0)
d67 6
a72 6
	{"html",	HTML_BLOCK}, /* TAG_HTML */
	{"head",	HTML_BLOCK}, /* TAG_HEAD */
	{"body",	HTML_BLOCK}, /* TAG_BODY */
	{"meta",	HTML_BLOCK}, /* TAG_META */
	{"title",	HTML_BLOCK}, /* TAG_TITLE */
	{"div",		HTML_BLOCK}, /* TAG_DIV */
d75 1
a75 1
	{"p",		HTML_BLOCK}, /* TAG_P */
d77 3
a79 1
	{"link",	HTML_BLOCK}, /* TAG_LINK */
d98 7
d108 2
d127 1
d132 1
a132 1
static	void		  print_otag(struct html *, enum htmltag, 
d134 2
a139 1
static	void		  mdoc_root_post(MDOC_ARGS);
d141 1
d144 2
a145 1
static	void		  mdoc_nm_post(MDOC_ARGS);
a147 1
static	void		  mdoc_sh_post(MDOC_ARGS);
d149 1
a149 1
static	void		  mdoc_ss_post(MDOC_ARGS);
d156 2
a157 2
	{mdoc_sh_pre, mdoc_sh_post }, /* Sh */
	{mdoc_ss_pre, mdoc_ss_post }, /* Ss */ 
d177 1
a177 1
	{NULL, NULL}, /* Fl */
d184 2
a185 2
	{mdoc_nm_pre, mdoc_nm_post}, /* Nm */ 
	{NULL, NULL}, /* Op */
d192 1
a192 1
	{NULL, NULL}, /* Xr */
d275 1
a275 1
int
d279 1
d284 1
a284 1
	print_otag(h, TAG_HTML, 0, NULL);
d286 2
a287 1
	print_ctag(h, TAG_HTML);
a288 1
	return(1);
d292 1
a292 1
int
d296 1
d301 1
a301 1
	print_otag(h, TAG_HTML, 0, NULL);
d303 2
a304 1
	print_ctag(h, TAG_HTML);
a305 1
	return(1);
d312 4
d317 2
a318 1
	return(calloc(1, sizeof(struct html)));
d325 4
d330 6
a335 1
	free(p);
d342 1
d344 1
a344 1
	print_otag(h, TAG_HEAD, 0, NULL);
d346 4
a349 2
	print_ctag(h, TAG_HEAD);
	print_otag(h, TAG_BODY, 0, NULL);
d351 1
a351 1
	print_ctag(h, TAG_BODY);
d375 1
a375 1
	link[1].val = "style.css";
d387 1
a394 100
	print_ctag(h, TAG_TITLE);
}


static int
mdoc_root_pre(MDOC_ARGS)
{
	struct htmlpair	 div;

	div.key = ATTR_CLASS;
	div.val = "body";

	print_otag(h, TAG_DIV, 1, &div);
	return(1);
}


static void
mdoc_root_post(MDOC_ARGS)
{

	print_ctag(h, TAG_DIV);
}


static int
mdoc_ss_pre(MDOC_ARGS)
{

	if (MDOC_BODY == n->type)
		print_otag(h, TAG_P, 0, NULL);
	if (MDOC_HEAD == n->type)
		print_otag(h, TAG_H2, 0, NULL);
	return(1);
}


static void
mdoc_ss_post(MDOC_ARGS)
{

	if (MDOC_BODY == n->type)
		print_ctag(h, TAG_P);
	if (MDOC_HEAD == n->type)
		print_ctag(h, TAG_H2);
}


static int
mdoc_pp_pre(MDOC_ARGS)
{

	print_otag(h, TAG_P, 0, NULL);
	return(0);
}


static int
mdoc_nd_pre(MDOC_ARGS)
{

	if (MDOC_BODY == n->type)
		print_text(h, "--");
	return(1);
}


static int
mdoc_nm_pre(MDOC_ARGS)
{
	struct htmlpair	class;

	class.key = ATTR_CLASS;
	class.val = "name";

	print_otag(h, TAG_SPAN, 1, &class);
	if (NULL == n->child)
		print_text(h, m->name);

	return(1);
}


static void
mdoc_nm_post(MDOC_ARGS)
{

	print_ctag(h, TAG_SPAN);
}


static int
mdoc_sh_pre(MDOC_ARGS)
{

	if (MDOC_BODY == n->type)
		print_otag(h, TAG_P, 0, NULL);
	if (MDOC_HEAD == n->type)
		print_otag(h, TAG_H1, 0, NULL);
	return(1);
d398 1
d400 1
a400 1
mdoc_sh_post(MDOC_ARGS)
d403 1
a403 4
	if (MDOC_BODY == n->type)
		print_ctag(h, TAG_P);
	if (MDOC_HEAD == n->type)
		print_ctag(h, TAG_H1);
d411 1
d414 1
d432 2
a435 1
		mdoc_root_post(m, n, h);
d453 1
d455 1
a455 1
	print_otag(h, TAG_HEAD, 0, NULL);
d457 3
a459 2
	print_ctag(h, TAG_HEAD);
	print_otag(h, TAG_BODY, 0, NULL);
d461 1
a461 1
	print_ctag(h, TAG_BODY);
d465 1
a472 1
	print_ctag(h, TAG_TITLE);
d476 1
d480 2
d493 1
a493 1
static void
d498 9
d509 1
a509 1
		if ( ! (HTML_BLOCK & htmltags[tag].flags))
d522 4
d527 1
d537 1
a537 1
	if (HTML_BLOCK & htmltags[tag].flags)
d539 4
d579 1
d586 1
d588 1
d601 1
d606 182
@


1.28
log
@Purged all old files in favour of new design.  Selective reintegration.
@
text
@d1 638
@


1.27
log
@*** empty log message ***
@
text
@a0 1085
/* $Id: html.c,v 1.26 2008/12/10 17:40:56 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/param.h>
#include <sys/stat.h>

#include <assert.h>
#include <err.h>
#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include "html.h"
#include "ml.h"

/* TODO: allow head/tail-less invocations (just "div" start). */

struct	htmlnode {
	int		 tok;
	enum md_ns	 ns;
	int		 argc[ROFF_MAXLINEARG];
	char		*argv[ROFF_MAXLINEARG];
	struct htmlnode	*parent;
};

struct	htmlq {
	struct htmlnode	*last;
};


static	int		html_loadcss(struct md_mbuf *, 
				const char *);
static	int		html_alloc(void **);
static	void		html_free(void *);
static	ssize_t		html_endtag(struct ml_args *, 
				enum md_ns, int);
static	ssize_t		html_beginstring(struct ml_args *, 
				const char *, size_t);
static	ssize_t		html_endstring(struct ml_args *,
				const char *, size_t);
static	ssize_t		html_begintag(struct ml_args *, 
				enum md_ns, int,
				const int *, const char **);
static	int		html_begin(struct ml_args *,
				const struct tm *, 
				const char *, const char *, 
				enum roffmsec, enum roffvol);
static	int		html_end(struct ml_args *,
				const struct tm *, 
				const char *, const char *, 
				enum roffmsec, enum roffvol);
static	int		html_printargs(struct md_mbuf *, int, 
				const char *, const int *, 
				const char **, size_t *);
static	ssize_t		html_beginhttp(struct md_mbuf *, 
				const struct md_args *, 
				const char *, size_t);
static	ssize_t		html_endhttp(struct md_mbuf *, 
				const struct md_args *, 
				const char *, size_t);
static	int		html_blocktagname(struct md_mbuf *,
				const struct md_args *, int, 
				struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_blocktagargs(struct md_mbuf *,
				const struct md_args *, int,
				const int *, const char **, size_t *);
static	int		html_headtagname(struct md_mbuf *,
				const struct md_args *, int, 
				struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_headtagargs(struct md_mbuf *,
				const struct md_args *, int,
				const int *, const char **, size_t *);
static	int		html_bodytagname(struct md_mbuf *,
				const struct md_args *, 
				int, struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_bodytagargs(struct md_mbuf *,
				const struct md_args *, int,
				const int *, const char **, size_t *);
static	int		html_inlinetagname(struct md_mbuf *,
				const struct md_args *, int, size_t *);
static	int		html_inlinetagargs(struct md_mbuf *,
				const struct md_args *, int,
				const int *, const char **, size_t *);
static	int		html_Bl_bodytagname(struct md_mbuf *, 
				struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_It_blocktagname(struct md_mbuf *, 
				struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_It_headtagname(struct md_mbuf *, 
				struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_It_bodytagname(struct md_mbuf *, 
				struct htmlq *, const int *, 
				const char **, size_t *);
static	int		html_tputln(struct md_mbuf *, 
				enum ml_scope, int, enum html_tag);
static	int		html_aputln(struct md_mbuf *, enum ml_scope, 
				int, enum html_tag, 
				int, const struct html_pair *);


/* ARGSUSED */
static int
html_It_headtagname(struct md_mbuf *mbuf, struct htmlq *q, 
		const int *argc, const char **argv, size_t *res)
{
	struct htmlnode	*n;
	int		 i;
	struct html_pair attr[2];

	for (n = q->last; n; n = n->parent)
		if (n->tok == ROFF_Bl)
			break;

	assert(n);

	/* LINTED */
	for (i = 0; ROFF_ARGMAX != n->argc[i] &&
			i < ROFF_MAXLINEARG; i++) {
		switch (n->argc[i]) {
		case (ROFF_Ohang):
			return(html_stput(mbuf, HTML_TAG_DIV, res));
		case (ROFF_Tag):
			attr[0].attr = HTML_ATTR_VALIGN;
			attr[0].val = "top";
			attr[1].attr = HTML_ATTR_NOWRAP;
			attr[1].val = "true";
			return(html_saput(mbuf, HTML_TAG_TD, 
						res, 2, attr));
		case (ROFF_Column): 
			attr[0].attr = HTML_ATTR_VALIGN;
			attr[0].val = "top";
			return(html_saput(mbuf, HTML_TAG_TD, 
						res, 1, attr));
		default:
			break;
		}
	}

	return(0);
}


/* ARGSUSED */
static int
html_It_bodytagname(struct md_mbuf *mbuf, struct htmlq *q, 
		const int *argc, const char **argv, size_t *res)
{
	struct htmlnode	*n;
	int		 i;
	struct html_pair attr[1];

	for (n = q->last; n; n = n->parent)
		if (n->tok == ROFF_Bl)
			break;

	assert(n);

	/* LINTED */
	for (i = 0; ROFF_ARGMAX != n->argc[i] &&
			i < ROFF_MAXLINEARG; i++) {
		switch (n->argc[i]) {
		case (ROFF_Enum):
			/* FALLTHROUGH */
		case (ROFF_Bullet):
			/* FALLTHROUGH */
		case (ROFF_Dash):
			/* FALLTHROUGH */
		case (ROFF_Hyphen):
			/* FALLTHROUGH */
		case (ROFF_Item):
			/* FALLTHROUGH */
		case (ROFF_Diag):
			/* FALLTHROUGH */
		case (ROFF_Hang):
			/* FALLTHROUGH */
		case (ROFF_Ohang): 
			/* FALLTHROUGH */
		case (ROFF_Inset):
			return(html_stput(mbuf, HTML_TAG_DIV, res));
		case (ROFF_Tag):
			/* FALLTHROUGH */
		case (ROFF_Column): 
			attr[0].attr = HTML_ATTR_VALIGN;
			attr[0].val = "top";
			return(html_saput(mbuf, HTML_TAG_TD, 
						res, 1, attr));
		default:
			break;
		}
	}

	assert(i != ROFF_MAXLINEARG);
	return(0);
}


/* ARGSUSED */
static int
html_Bl_bodytagname(struct md_mbuf *mbuf, struct htmlq *q, 
		const int *argc, const char **argv, size_t *res)
{
	int		 i;

	for (i = 0; ROFF_ARGMAX != argc[i]
			&& i < ROFF_MAXLINEARG; i++) {
		switch (argc[i]) {
		case (ROFF_Enum):
			return(html_stput(mbuf, HTML_TAG_OL, res));
		case (ROFF_Bullet):
			/* FALLTHROUGH */
		case (ROFF_Dash):
			/* FALLTHROUGH */
		case (ROFF_Hyphen):
			/* FALLTHROUGH */
		case (ROFF_Item):
			/* FALLTHROUGH */
		case (ROFF_Diag):
			/* FALLTHROUGH */
		case (ROFF_Hang):
			/* FALLTHROUGH */
		case (ROFF_Ohang): 
			/* FALLTHROUGH */
		case (ROFF_Inset):
			return(html_stput(mbuf, HTML_TAG_UL, res));
		case (ROFF_Tag):
			/* FALLTHROUGH */
		case (ROFF_Column): 
			return(html_stput(mbuf, HTML_TAG_TABLE, res));
		default:
			break;
		}
	}

	assert(i != ROFF_MAXLINEARG);
	return(0);
}


/* ARGSUSED */
static int
html_It_blocktagname(struct md_mbuf *mbuf, struct htmlq *q, 
		const int *argc, const char **argv, size_t *res)
{
	struct htmlnode	*n;
	int		 i;

	for (n = q->last; n; n = n->parent)
		if (n->tok == ROFF_Bl)
			break;

	assert(n);

	/* LINTED */
	for (i = 0; ROFF_ARGMAX != n->argc[i] &&
			i < ROFF_MAXLINEARG; i++) {
		switch (n->argc[i]) {
		case (ROFF_Enum):
			/* FALLTHROUGH */
		case (ROFF_Bullet):
			/* FALLTHROUGH */
		case (ROFF_Dash):
			/* FALLTHROUGH */
		case (ROFF_Hyphen):
			/* FALLTHROUGH */
		case (ROFF_Item):
			/* FALLTHROUGH */
		case (ROFF_Diag):
			/* FALLTHROUGH */
		case (ROFF_Hang):
			/* FALLTHROUGH */
		case (ROFF_Ohang): 
			/* FALLTHROUGH */
		case (ROFF_Inset):
			return(html_stput(mbuf, HTML_TAG_LI, res));
		case (ROFF_Tag):
			/* FALLTHROUGH */
		case (ROFF_Column): 
			return(html_stput(mbuf, HTML_TAG_TR, res));
		default:
			break;
		}
	}

	assert(i != ROFF_MAXLINEARG);
	return(0);
}


static int
html_loadcss(struct md_mbuf *mbuf, const char *css)
{
	size_t		 res, bufsz;
	char		*buf;
	struct stat	 st;
	int		 fd, c;
	ssize_t		 ssz;

	c = 0;
	res = 0;
	buf = NULL;

	if (-1 == (fd = open(css, O_RDONLY, 0))) {
		warn("%s", css);
		return(0);
	} 
	
	if (-1 == fstat(fd, &st)) {
		warn("%s", css);
		goto out;
	}

	bufsz = MAX(st.st_blksize, BUFSIZ);
	if (NULL == (buf = malloc(bufsz))) {
		warn("malloc");
		goto out;
	}

	for (;;) {
		if (-1 == (ssz = read(fd, buf, bufsz))) {
			warn("%s", css);
			goto out;
		} else if (0 == ssz)
			break;
		if ( ! ml_nputs(mbuf, buf, (size_t)ssz, &res))
			goto out;
	}

	c = 1;

out:
	if (-1 == close(fd)) {
		warn("%s", css);
		c = 0;
	}

	if (buf)
		free(buf);

	return(c);
}


static int
html_tputln(struct md_mbuf *mbuf, enum ml_scope scope,
		int i, enum html_tag tag)
{

	if ( ! ml_putchars(mbuf, ' ', INDENT(i) * INDENT_SZ, NULL))
		return(0);
	if ( ! html_tput(mbuf, scope, tag, NULL))
		return(0);
	return(ml_nputs(mbuf, "\n", 1, NULL));
}


static int
html_aputln(struct md_mbuf *mbuf, enum ml_scope scope, int i, 
		enum html_tag tag, int sz, const struct html_pair *p)
{

	if ( ! ml_putchars(mbuf, ' ', INDENT(i) * INDENT_SZ, NULL))
		return(0);
	if ( ! html_aput(mbuf, scope, tag, NULL, sz, p))
		return(0);
	return(ml_nputs(mbuf, "\n", 1, NULL));
}


/* ARGSUSED */
static int 
html_begin(struct ml_args *p, const struct tm *tm, const char *os, 
		const char *name, enum roffmsec msec, enum roffvol vol)
{
	enum roffvol	 bvol;
	struct html_pair attr[4];
	char		 ts[32], title[64];
	int		 i;

	(void)snprintf(ts, sizeof(ts), "%s(%s)", 
			name, roff_msecname(msec));

	if (vol >= ROFF_ARCH_START) {
		switch (msec) {
		case(ROFF_MSEC_1):
			/* FALLTHROUGH */
		case(ROFF_MSEC_6):
			/* FALLTHROUGH */
		case(ROFF_MSEC_7):
			bvol = ROFF_VOL_URM;
			break;
		case(ROFF_MSEC_2):
			/* FALLTHROUGH */
		case(ROFF_MSEC_3):
			/* FALLTHROUGH */
		case(ROFF_MSEC_3p):
			/* FALLTHROUGH */
		case(ROFF_MSEC_4):
			/* FALLTHROUGH */
		case(ROFF_MSEC_5):
			bvol = ROFF_VOL_PRM;
			break;
		case(ROFF_MSEC_8):
			bvol = ROFF_VOL_PRM;
			break;
		case(ROFF_MSEC_9):
			bvol = ROFF_VOL_KM;
			break;
		case(ROFF_MSEC_UNASS):
			/* FALLTHROUGH */
		case(ROFF_MSEC_DRAFT):
			/* FALLTHROUGH */
		case(ROFF_MSEC_PAPER):
			bvol = ROFF_VOL_NONE;
			break;
		default:
			abort();
			/* NOTREACHED */
		}

		(void)snprintf(title, sizeof(title), "%s (%s)",
				roff_volname(bvol), roff_volname(vol));
	} else
		(void)snprintf(title, sizeof(title), "%s", roff_volname(vol));


	i = 0;

	if ( ! html_typeput(p->mbuf, HTML_TYPE_4_01_STRICT, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_OPEN, i, HTML_TAG_HTML))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_OPEN, i++, HTML_TAG_HEAD))
		return(0);

	attr[0].attr = HTML_ATTR_HTTP_EQUIV;
	attr[0].val = "content-type";
	attr[1].attr = HTML_ATTR_CONTENT;
	attr[1].val = "text/html;charset=utf-8";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_META, 2, attr))
		return(0);

	attr[0].attr = HTML_ATTR_NAME;
	attr[0].val = "resource-type";
	attr[1].attr = HTML_ATTR_CONTENT;
	attr[1].val = "document";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_META, 2, attr))
		return(0);

	if ( ! html_tputln(p->mbuf, ML_OPEN, i, HTML_TAG_TITLE))
		return(0);
	if ( ! ml_putstring(p->mbuf, ts, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_TITLE))
		return(0);

	if (HTML_CSS_EMBED & p->args->params.html.flags) {
		attr[0].attr = HTML_ATTR_TYPE;
		attr[0].val = "text/css";

		if ( ! html_aputln(p->mbuf, ML_OPEN, i, 
					HTML_TAG_STYLE, 1, attr))
			return(0);
		if ( ! html_commentput(p->mbuf, ML_OPEN, NULL))
			return(0);

		if ( ! html_loadcss(p->mbuf, p->args->params.html.css))
			return(0);

		if ( ! html_commentput(p->mbuf, ML_CLOSE, NULL))
			return(0);
		if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_STYLE))
			return(0);
	} else {
		attr[0].attr = HTML_ATTR_REL;
		attr[0].val = "stylesheet";
		attr[1].attr = HTML_ATTR_TYPE;
		attr[1].val = "text/css";
		attr[2].attr = HTML_ATTR_HREF;
		attr[2].val = p->args->params.html.css;

		if ( ! html_aputln(p->mbuf, ML_OPEN, i,
					HTML_TAG_LINK, 3, attr))
			return(0);
	}

	if ( ! html_tputln(p->mbuf, ML_CLOSE, --i, HTML_TAG_HEAD))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_OPEN, i, HTML_TAG_BODY))
		return(0);

	attr[0].attr = HTML_ATTR_CLASS;
	attr[0].val = "mdoc";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_DIV, 1, attr))
		return(0);

	attr[0].attr = HTML_ATTR_WIDTH;
	attr[0].val = "100%";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "header-table";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i++, HTML_TAG_TABLE, 2, attr))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_OPEN, i++, HTML_TAG_TR))
		return(0);

	attr[0].attr = HTML_ATTR_ALIGN;
	attr[0].val = "left";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "header-section";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
		return(0);
	if ( ! ml_putstring(p->mbuf, ts, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_TD))
		return(0);

	attr[0].attr = HTML_ATTR_ALIGN;
	attr[0].val = "center";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "header-volume";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
		return(0);
	if ( ! ml_putstring(p->mbuf, title, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_TD))
		return(0);

	attr[0].attr = HTML_ATTR_ALIGN;
	attr[0].val = "right";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "header-section";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
		return(0);
	if ( ! ml_putstring(p->mbuf, ts, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_TD))
		return(0);

	if ( ! html_tputln(p->mbuf, ML_CLOSE, --i, HTML_TAG_TR))
		return(0);
	return(html_tputln(p->mbuf, ML_CLOSE, --i, HTML_TAG_TABLE));
}


/* ARGSUSED */
static int 
html_end(struct ml_args *p, const struct tm *tm, const char *os, 
		const char *name, enum roffmsec msec, enum roffvol vol)
{
	struct html_pair attr[4];
	int		 i;
	char		 ts[64];

	if (0 == strftime(ts, sizeof(ts), "%B %d, %Y", tm)) {
		warn("strftime");
		return(0);
	}

	i = 0;

	attr[0].attr = HTML_ATTR_WIDTH;
	attr[0].val = "100%";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "header-footer";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i++, HTML_TAG_TABLE, 2, attr))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_OPEN, i++, HTML_TAG_TR))
		return(0);

	attr[0].attr = HTML_ATTR_ALIGN;
	attr[0].val = "left";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "footer-os";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
		return(0);
	if ( ! ml_putstring(p->mbuf, os, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_TD))
		return(0);

	attr[0].attr = HTML_ATTR_ALIGN;
	attr[0].val = "right";
	attr[1].attr = HTML_ATTR_CLASS;
	attr[1].val = "footer-date";

	if ( ! html_aputln(p->mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
		return(0);
	if ( ! ml_putstring(p->mbuf, ts, NULL))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, i, HTML_TAG_TD))
		return(0);

	if ( ! html_tputln(p->mbuf, ML_CLOSE, --i, HTML_TAG_TR))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, --i, HTML_TAG_TABLE))
		return(0);

	if ( ! html_tputln(p->mbuf, ML_CLOSE, 0, HTML_TAG_DIV))
		return(0);
	if ( ! html_tputln(p->mbuf, ML_CLOSE, 0, HTML_TAG_BODY))
		return(0);
	return(html_tputln(p->mbuf, ML_CLOSE, 0, HTML_TAG_HTML));
}


/* ARGSUSED */
static int
html_bodytagname(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, struct htmlq *q, 
		const int *argc, const char **argv, size_t *res)
{

	switch (tok) {
	case (ROFF_Bl):
		return(html_Bl_bodytagname(mbuf, q, argc, argv, res));
	case (ROFF_Fo):
		return(html_stput(mbuf, HTML_TAG_SPAN, res));
	case (ROFF_It):
		return(html_It_bodytagname(mbuf, q, argc, argv, res));
	case (ROFF_Oo):
		return(html_stput(mbuf, HTML_TAG_SPAN, res));
	default:
		break;
	}

	return(html_stput(mbuf, HTML_TAG_DIV, res));
}


/* ARGSUSED */
static int
html_headtagname(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, struct htmlq *q, 
		const int *argc, const char **argv, size_t *res)
{

	switch (tok) {
	case (ROFF_It):
		return(html_It_headtagname(mbuf, q, argc, argv, res));
	case (ROFF_Fo):
		/* FALLTHROUGH */
	case (ROFF_Oo):
		return(html_stput(mbuf, HTML_TAG_SPAN, res));
	case (ROFF_Sh):
		return(html_stput(mbuf, HTML_TAG_H1, res));
	case (ROFF_Ss):
		return(html_stput(mbuf, HTML_TAG_H2, res));
	default:
		break;
	}

	return(html_stput(mbuf, HTML_TAG_DIV, res));
}


/* ARGSUSED */
static int
html_blocktagname(struct md_mbuf *mbuf, const struct md_args *args, 
		int tok, struct htmlq *q, const int *argc, 
		const char **argv, size_t *res)
{

	switch (tok) {
	case (ROFF_Fo):
		/* FALLTHROUGH */
	case (ROFF_Oo):
		return(html_stput(mbuf, HTML_TAG_SPAN, res));
	case (ROFF_It):
		return(html_It_blocktagname(mbuf, q, argc, argv, res));
	default:
		break;
	}

	return(html_stput(mbuf, HTML_TAG_DIV, res));
}


/* ARGSUSED */
static int
html_printargs(struct md_mbuf *mbuf, int tok, const char *ns,
		const int *argc, const char **argv, size_t *res)
{

	/* FIXME: use API in ml.h. */

	if ( ! ml_puts(mbuf, " class=\"", res))
		return(0);
	if ( ! ml_puts(mbuf, ns, res))
		return(0);
	if ( ! ml_puts(mbuf, "-", res))
		return(0);
	if ( ! ml_puts(mbuf, toknames[tok], res))
		return(0);
	return(ml_puts(mbuf, "\"", res));
}


/* ARGSUSED */
static int
html_headtagargs(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, 
		const int *argc, const char **argv, size_t *res)
{

	return(html_printargs(mbuf, tok, "head", argc, argv, res));
}


/* ARGSUSED */
static int
html_bodytagargs(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, 
		const int *argc, const char **argv, size_t *res)
{

	return(html_printargs(mbuf, tok, "body", argc, argv, res));
}


/* ARGSUSED */
static int
html_blocktagargs(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, 
		const int *argc, const char **argv, size_t *res)
{

	return(html_printargs(mbuf, tok, "block", argc, argv, res));
}


/* ARGSUSED */
static int
html_inlinetagargs(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, 
		const int *argc, const char **argv, size_t *res)
{

	if ( ! html_printargs(mbuf, tok, "inline", argc, argv, res))
		return(0);

	switch (tok) {
	case (ROFF_Sh):

		/* FIXME: use API in ml.h. */

		assert(*argv);
		if ( ! ml_nputs(mbuf, " name=\"", 7, res))
			return(0);
		if ( ! ml_putstring(mbuf, *argv++, res))
			return(0);
		while (*argv) {
			if ( ! ml_putstring(mbuf, "_", res))
				return(0);
			if ( ! ml_putstring(mbuf, *argv++, res))
				return(0);
		}
		if ( ! ml_nputs(mbuf, "\"", 1, res))
			return(0);
		break;

	case (ROFF_Sx):

		/* FIXME: use API in ml.h. */

		assert(*argv);
		if ( ! ml_nputs(mbuf, " href=\"#", 8, res))
			return(0);
		if ( ! ml_putstring(mbuf, *argv++, res))
			return(0);
		while (*argv) {
			if ( ! ml_putstring(mbuf, "_", res))
				return(0);
			if ( ! ml_putstring(mbuf, *argv++, res))
				return(0);
		}
		if ( ! ml_nputs(mbuf, "\"", 1, res))
			return(0);

		break;
	default:
		break;
	}
	
	return(1);
}


/* ARGSUSED */
static int
html_inlinetagname(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, size_t *res)
{

	switch (tok) {
	case (ROFF_Dl):
		/* FALLTHROUGH */
	case (ROFF_D1):
		return(html_stput(mbuf, HTML_TAG_DIV, res));
	case (ROFF_Sh):
		return(html_stput(mbuf, HTML_TAG_A, res));
	case (ROFF_Pp):
		return(html_stput(mbuf, HTML_TAG_DIV, res));
	case (ROFF_Sx):
		return(html_stput(mbuf, HTML_TAG_A, res));
	default:
		break;
	}

	return(html_stput(mbuf, HTML_TAG_SPAN, res));
}


static ssize_t 
html_begintag(struct ml_args *p, enum md_ns ns, 
		int tok, const int *argc, const char **argv)
{
	size_t		 res;
	struct htmlq	*q;
	struct htmlnode	*node;
	int		 i;

	assert(ns != MD_NS_DEFAULT);
	res = 0;

	q = (struct htmlq *)p->data;

	if (NULL == (node = calloc(1, sizeof(struct htmlnode)))) {
		warn("calloc");
		return(-1);
	}

	node->parent = q->last;
	node->tok = tok;
	node->ns = ns;

	if (argc)  {
		/* TODO: argv. */

		assert(argv);
		/* LINTED */
		for (i = 0; ROFF_ARGMAX != argc[i]
				&& i < ROFF_MAXLINEARG; i++) 
			node->argc[i] = argc[i];
		assert(i != ROFF_MAXLINEARG);
	} 


	q->last = node;

	switch (ns) {
	case (MD_NS_BLOCK):
		if ( ! html_blocktagname(p->mbuf, p->args, tok, 
					q, argc, argv, &res))
			return(-1);
		if ( ! html_blocktagargs(p->mbuf, p->args, tok, 
					argc, argv, &res))
			return(-1);
		break;
	case (MD_NS_BODY):
		if ( ! html_bodytagname(p->mbuf, p->args, tok, 
					q, argc, argv, &res))
			return(-1);
		if ( ! html_bodytagargs(p->mbuf, p->args, tok, 
					argc, argv, &res))
			return(-1);
		break;
	case (MD_NS_HEAD):
		if ( ! html_headtagname(p->mbuf, p->args, tok, q,
					argc, argv, &res))
			return(-1);
		if ( ! html_headtagargs(p->mbuf, p->args, tok, 
					argc, argv, &res))
			return(-1);
		break;
	default:
		if ( ! html_inlinetagname(p->mbuf, p->args, tok, &res))
			return(-1);
		if ( ! html_inlinetagargs(p->mbuf, p->args, tok, 
					argc, argv, &res))
			return(-1);
		break;
	}

	return((ssize_t)res);
}


static ssize_t 
html_endtag(struct ml_args *p, enum md_ns ns, int tok)
{
	size_t		 res;
	struct htmlq	*q;
	struct htmlnode	*node;

	assert(ns != MD_NS_DEFAULT);
	res = 0;

	q = (struct htmlq *)p->data;
	node = q->last;

	switch (ns) {
	case (MD_NS_BLOCK):
		if ( ! html_blocktagname(p->mbuf, p->args, tok, 
					q, node->argc, 
					(const char **)node->argv, &res))
			return(-1);
		break;
	case (MD_NS_BODY):
		if ( ! html_bodytagname(p->mbuf, p->args, tok, 
					q, node->argc, 
					(const char **)node->argv, &res))
			return(-1);
		break;
	case (MD_NS_HEAD):
		if ( ! html_headtagname(p->mbuf, p->args, tok, 
					q, node->argc,
					(const char **)node->argv, &res))
			return(-1);
		break;
	default:
		if ( ! html_inlinetagname(p->mbuf, p->args, tok, &res))
			return(-1);
		break;
	}

	q->last = node->parent;

	free(node);

	return((ssize_t)res);
}


static int
html_alloc(void **p)
{

	if (NULL == (*p = calloc(1, sizeof(struct htmlq)))) {
		warn("calloc");
		return(0);
	}
	return(1);
}


static void
html_free(void *p)
{
	struct htmlq	*q;
	struct htmlnode	*n;

	assert(p);
	q = (struct htmlq *)p;

	/* LINTED */
	while ((n = q->last)) {
		q->last = n->parent;
		free(n);
	}

	free(q);
}


/* ARGSUSED */
static ssize_t 
html_beginhttp(struct md_mbuf *mbuf, 
		const struct md_args *args, 
		const char *buf, size_t sz)
{
	size_t		 res;
	struct html_pair pair;

	res = 0;
	pair.attr = HTML_ATTR_HREF;
	pair.val = (char *)buf;

	if ( ! html_aput(mbuf, ML_OPEN, HTML_TAG_A, &res, 1, &pair))
		return(-1);
	return((ssize_t)res);
}


/* ARGSUSED */
static ssize_t 
html_endhttp(struct md_mbuf *mbuf, 
		const struct md_args *args, 
		const char *buf, size_t sz)
{
	size_t		 res;

	res = 0;
	if ( ! html_tput(mbuf, ML_CLOSE, HTML_TAG_A, &res))
		return(-1);
	return((ssize_t)res);
}


/* ARGSUSED */
static ssize_t 
html_beginstring(struct ml_args *p, const char *buf, size_t sz)
{

	if (0 == strncmp(buf, "http://", 7))
		return(html_beginhttp(p->mbuf, p->args, buf, sz));

	return(0);
}


/* ARGSUSED */
static ssize_t 
html_endstring(struct ml_args *p, const char *buf, size_t sz)
{
	
	if (0 == strncmp(buf, "http://", 7))
		return(html_endhttp(p->mbuf, p->args, buf, sz));

	return(0);
}


int
md_line_html(void *data, char *buf)
{

	return(mlg_line((struct md_mlg *)data, buf));
}


int
md_exit_html(void *data, int flush)
{

	return(mlg_exit((struct md_mlg *)data, flush));
}


void *
md_init_html(const struct md_args *args,
		struct md_mbuf *mbuf, const struct md_rbuf *rbuf)
{
	struct ml_cbs	 cbs;

	cbs.ml_alloc = html_alloc;
	cbs.ml_free = html_free;
	cbs.ml_begintag = html_begintag;
	cbs.ml_endtag = html_endtag;
	cbs.ml_begin = html_begin;
	cbs.ml_end = html_end;
	cbs.ml_beginstring = html_beginstring;
	cbs.ml_endstring = html_endstring;

	return(mlg_alloc(args, rbuf, mbuf, &cbs));
}
@


1.26
log
@Prettier HTML.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.25 2008/12/10 17:31:57 kristaps Exp $ */
d825 4
@


1.25
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.24 2008/12/10 13:41:58 kristaps Exp $ */
d130 1
d145 6
a150 1
			/* FALLTHROUGH */
d152 4
a155 1
			return(html_stput(mbuf, HTML_TAG_TD, res));
d172 1
d205 4
a208 1
			return(html_stput(mbuf, HTML_TAG_TD, res));
@


1.24
log
@Sx to Sh anchors work.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.23 2008/12/10 12:09:47 kristaps Exp $ */
d52 1
a52 2
static	ssize_t		html_endtag(struct md_mbuf *, void *,
				const struct md_args *, 
d54 1
a54 2
static	ssize_t		html_beginstring(struct md_mbuf *, 
				const struct md_args *, 
d56 1
a56 2
static	ssize_t		html_beginhttp(struct md_mbuf *, 
				const struct md_args *, 
d58 2
a59 9
static	ssize_t		html_endstring(struct md_mbuf *, 
				const struct md_args *, 
				const char *, size_t);
static	ssize_t		html_endhttp(struct md_mbuf *, 
				const struct md_args *, 
				const char *, size_t);
static	ssize_t		html_begintag(struct md_mbuf *, void *,
				const struct md_args *, 
				enum md_ns, int, 
d61 5
a65 2
static	int		html_begin(struct md_mbuf *,
	       			const struct md_args *, 
d72 6
a77 5
static	int		html_end(struct md_mbuf *,
	       			const struct md_args *, 
				const struct tm *, 
				const char *, const char *, 
				enum roffmsec, enum roffvol);
d380 1
a380 2
html_begin(struct md_mbuf *mbuf, const struct md_args *args,
		const struct tm *tm, const char *os, 
d437 1
a437 1
	if ( ! html_typeput(mbuf, HTML_TYPE_4_01_STRICT, NULL))
d439 1
a439 1
	if ( ! html_tputln(mbuf, ML_OPEN, i, HTML_TAG_HTML))
d441 1
a441 1
	if ( ! html_tputln(mbuf, ML_OPEN, i++, HTML_TAG_HEAD))
d449 1
a449 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_META, 2, attr))
d457 1
a457 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_META, 2, attr))
d460 1
a460 1
	if ( ! html_tputln(mbuf, ML_OPEN, i, HTML_TAG_TITLE))
d462 1
a462 1
	if ( ! ml_putstring(mbuf, ts, NULL))
d464 1
a464 1
	if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_TITLE))
d467 1
a467 1
	if (HTML_CSS_EMBED & args->params.html.flags) {
d471 1
a471 1
		if ( ! html_aputln(mbuf, ML_OPEN, i, 
d474 1
a474 1
		if ( ! html_commentput(mbuf, ML_OPEN, NULL))
d477 1
a477 1
		if ( ! html_loadcss(mbuf, args->params.html.css))
d480 1
a480 1
		if ( ! html_commentput(mbuf, ML_CLOSE, NULL))
d482 1
a482 1
		if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_STYLE))
d490 1
a490 1
		attr[2].val = args->params.html.css;
d492 1
a492 1
		if ( ! html_aputln(mbuf, ML_OPEN, i,
d497 1
a497 1
	if ( ! html_tputln(mbuf, ML_CLOSE, --i, HTML_TAG_HEAD))
d499 1
a499 1
	if ( ! html_tputln(mbuf, ML_OPEN, i, HTML_TAG_BODY))
d505 1
a505 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_DIV, 1, attr))
d513 1
a513 1
	if ( ! html_aputln(mbuf, ML_OPEN, i++, HTML_TAG_TABLE, 2, attr))
d515 1
a515 1
	if ( ! html_tputln(mbuf, ML_OPEN, i++, HTML_TAG_TR))
d523 1
a523 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
d525 1
a525 1
	if ( ! ml_putstring(mbuf, ts, NULL))
d527 1
a527 1
	if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_TD))
d535 1
a535 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
d537 1
a537 1
	if ( ! ml_putstring(mbuf, title, NULL))
d539 1
a539 1
	if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_TD))
d547 1
a547 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
d549 1
a549 1
	if ( ! ml_putstring(mbuf, ts, NULL))
d551 1
a551 1
	if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_TD))
d554 1
a554 1
	if ( ! html_tputln(mbuf, ML_CLOSE, --i, HTML_TAG_TR))
d556 1
a556 1
	return(html_tputln(mbuf, ML_CLOSE, --i, HTML_TAG_TABLE));
d562 1
a562 2
html_end(struct md_mbuf *mbuf, const struct md_args *args,
		const struct tm *tm, const char *os, 
d581 1
a581 1
	if ( ! html_aputln(mbuf, ML_OPEN, i++, HTML_TAG_TABLE, 2, attr))
d583 1
a583 1
	if ( ! html_tputln(mbuf, ML_OPEN, i++, HTML_TAG_TR))
d591 1
a591 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
d593 1
a593 1
	if ( ! ml_putstring(mbuf, os, NULL))
d595 1
a595 1
	if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_TD))
d603 1
a603 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_TD, 2, attr))
d605 1
a605 1
	if ( ! ml_putstring(mbuf, ts, NULL))
d607 1
a607 1
	if ( ! html_tputln(mbuf, ML_CLOSE, i, HTML_TAG_TD))
d610 1
a610 1
	if ( ! html_tputln(mbuf, ML_CLOSE, --i, HTML_TAG_TR))
d612 1
a612 1
	if ( ! html_tputln(mbuf, ML_CLOSE, --i, HTML_TAG_TABLE))
d615 1
a615 1
	if ( ! html_tputln(mbuf, ML_CLOSE, 0, HTML_TAG_DIV))
d617 1
a617 1
	if ( ! html_tputln(mbuf, ML_CLOSE, 0, HTML_TAG_BODY))
d619 1
a619 1
	return(html_tputln(mbuf, ML_CLOSE, 0, HTML_TAG_HTML));
d827 1
a827 2
html_begintag(struct md_mbuf *mbuf, void *data,
		const struct md_args *args, enum md_ns ns, 
d838 1
a838 2
	assert(data);
	q = (struct htmlq *)data;
d865 1
a865 1
		if ( ! html_blocktagname(mbuf, args, tok, 
d868 1
a868 1
		if ( ! html_blocktagargs(mbuf, args, tok, 
d873 1
a873 1
		if ( ! html_bodytagname(mbuf, args, tok, 
d876 1
a876 1
		if ( ! html_bodytagargs(mbuf, args, tok, 
d881 1
a881 1
		if ( ! html_headtagname(mbuf, args, tok, q,
d884 1
a884 1
		if ( ! html_headtagargs(mbuf, args, tok, 
d889 1
a889 1
		if ( ! html_inlinetagname(mbuf, args, tok, &res))
d891 1
a891 1
		if ( ! html_inlinetagargs(mbuf, args, tok, 
d902 1
a902 2
html_endtag(struct md_mbuf *mbuf, void *data,
		const struct md_args *args, enum md_ns ns, int tok)
d911 1
a911 2
	assert(data);
	q = (struct htmlq *)data;
d916 1
a916 1
		if ( ! html_blocktagname(mbuf, args, tok, 
d922 1
a922 1
		if ( ! html_bodytagname(mbuf, args, tok, 
d928 1
a928 1
		if ( ! html_headtagname(mbuf, args, tok, 
d934 1
a934 1
		if ( ! html_inlinetagname(mbuf, args, tok, &res))
d1014 1
a1014 3
html_beginstring(struct md_mbuf *mbuf, 
		const struct md_args *args, 
		const char *buf, size_t sz)
d1018 1
a1018 1
		return(html_beginhttp(mbuf, args, buf, sz));
d1026 1
a1026 3
html_endstring(struct md_mbuf *mbuf, 
		const struct md_args *args, 
		const char *buf, size_t sz)
d1030 1
a1030 1
		return(html_endhttp(mbuf, args, buf, sz));
@


1.23
log
@Linted on NetBSD side.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.22 2008/12/10 12:05:33 kristaps Exp $ */
d767 19
d793 1
a793 1
		if ( ! ml_putstring(mbuf, *argv, res))
d795 6
d803 1
d820 2
@


1.22
log
@Versioning up.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.21 2008/12/10 10:43:57 kristaps Exp $ */
d962 1
d981 1
@


1.21
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.20 2008/12/10 00:58:15 kristaps Exp $ */
d79 5
a83 2
static	int		html_end(struct md_mbuf *, 
				const struct md_args *);
d390 1
a397 3
	(void)snprintf(ts, sizeof(ts), "%s",
			name, roff_volname(vol));

d399 36
d436 4
a439 1
	}
d482 1
a482 1
			return(NULL);
d488 1
a488 1
			return(NULL);
d517 2
d520 1
a520 1
	if ( ! html_aputln(mbuf, ML_OPEN, i++, HTML_TAG_TABLE, 1, attr))
d525 6
a530 1
	if ( ! html_tputln(mbuf, ML_OPEN, i, HTML_TAG_TD))
d537 8
a544 1
	if ( ! html_tputln(mbuf, ML_OPEN, i, HTML_TAG_TD))
a545 1
	/* TODO: middle. */
d551 2
d554 1
a554 1
	if ( ! html_aputln(mbuf, ML_OPEN, i, HTML_TAG_TD, 1, attr))
d569 3
a571 1
html_end(struct md_mbuf *mbuf, const struct md_args *args)
d573 49
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.19 2008/12/10 00:52:46 kristaps Exp $ */
d75 1
a75 1
				enum roffmsec, const char *);
d385 1
a385 1
		const char *name, enum roffmsec msec, const char *vol)
d388 1
a388 1
	char		 ts[32];
d394 8
@


1.19
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.18 2008/12/09 19:57:26 kristaps Exp $ */
d488 4
a491 1
	if ( ! html_tputln(mbuf, ML_OPEN, i, HTML_TAG_TD))
@


1.18
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.17 2008/12/09 17:09:12 kristaps Exp $ */
d30 1
a30 1
#include "private.h"
a32 22
#define	TAG_HTML	"<html>"
#define	TAG_HTML_END	"</html>"
#define	TAG_BODY	"<body>"
#define	TAG_BODY_END	"</body>"
#define	TAG_DIV_MDOC	"<div class=\"mdoc\">"
#define	TAG_DIV_END	"</div>"
#define	TAG_STYLE_CSS	"<style type=\"text/css\"><!--"
#define	TAG_STYLE_END	"--></style>"
#define	TAG_HEAD	"<head>"
#define	TAG_HEAD_END	"</head>"
#define	TAG_TITLE	"<title>"
#define	TAG_TITLE_END	"</title>"
#define	TAG_LINK_CSS	"<link rel=\"stylesheet\" " \
			"type=\"text/css\" href=\"%s\">"
#define	TAG_DOCTYPE	"<!DOCTYPE HTML PUBLIC " \
			"\"-//W3C//DTD HTML 4.01//EN\" " \
			"\"http://www.w3.org/TR/html4/strict.dtd\">"
#define	TAG_RESTYPE	"<meta name=\"resource-type\" " \
			"content=\"document\">"
#define	TAG_CONTTYPE	"<meta http-equiv=\"Content-Type\" " \
			"content=\"text/html;charset=utf-8\">"

a42 1

d48 2
a49 2
static	int		html_loadcss(struct md_mbuf *, const char *);

d119 5
d145 1
a145 1
			return(ml_nputs(mbuf, "div", 3, res));
d149 1
a149 1
			return(ml_nputs(mbuf, "td", 2, res));
d194 1
a194 1
			return(ml_nputs(mbuf, "div", 3, res));
d198 1
a198 1
			return(ml_nputs(mbuf, "td", 2, res));
d220 1
a220 1
			return(ml_nputs(mbuf, "ol", 2, res));
d236 1
a236 1
			return(ml_nputs(mbuf, "ul", 2, res));
d240 1
a240 1
			return(ml_nputs(mbuf, "table", 5, res));
d286 1
a286 1
			return(ml_nputs(mbuf, "li", 2, res));
d290 1
a290 1
			return(ml_nputs(mbuf, "tr", 2, res));
d356 2
a357 2
html_putline(struct md_mbuf *mbuf, size_t indent, 
		const char *p, size_t *res)
d360 1
a360 2
	/* FIXME: use INDENT macro for this. */
	if ( ! ml_putchars(mbuf, ' ', indent * 4, res))
d362 1
a362 1
	if ( ! ml_puts(mbuf, p, res))
d364 1
a364 1
	return(ml_nputs(mbuf, "\n", 1, res));
d369 2
a370 2
html_putlinestart(struct md_mbuf *mbuf, size_t indent,
		const char *p, size_t *res)
d373 1
a373 1
	if ( ! ml_putchars(mbuf, ' ', indent * 4, res))
d375 3
a377 1
	return(ml_puts(mbuf, p, res));
d385 1
a385 2
		const char *title, enum roffmsec section, 
		const char *vol)
d387 3
a389 2
	char		 mtitle[128], css[128];
	size_t		 i;
d391 2
a392 5
	(void)snprintf(mtitle, sizeof(mtitle), 
			"Manual Page for %s(%s)",
			title, roff_msecname(section));
	(void)snprintf(css, sizeof(css), 
			TAG_LINK_CSS, args->params.html.css);
d396 1
a396 1
	if ( ! html_putline(mbuf, i, TAG_DOCTYPE, NULL))
d398 1
a398 1
	if ( ! html_putline(mbuf, i, TAG_HTML, NULL))
d400 1
a400 1
	if ( ! html_putline(mbuf, i++, TAG_HEAD, NULL))
d402 7
a408 1
	if ( ! html_putline(mbuf, i, TAG_CONTTYPE, NULL))
d410 7
a416 1
	if ( ! html_putline(mbuf, i, TAG_RESTYPE, NULL))
d418 2
a419 1
	if ( ! html_putlinestart(mbuf, i, TAG_TITLE, NULL))
d421 1
a421 1
	if ( ! ml_putstring(mbuf, mtitle, NULL))
d423 1
a423 1
	if ( ! html_putline(mbuf, i, TAG_TITLE_END, NULL))
d427 5
a431 1
		if ( ! html_putline(mbuf, i, TAG_STYLE_CSS, NULL))
d433 3
d438 4
a441 1
		if ( ! html_putline(mbuf, i, TAG_STYLE_END, NULL))
d443 12
a454 2
	} else if ( ! html_putline(mbuf, i, css, NULL))
		return(0);
d456 1
a456 1
	if ( ! html_putline(mbuf, --i, TAG_HEAD_END, NULL))
d458 1
a458 1
	if ( ! html_putline(mbuf, i, TAG_BODY, NULL))
d460 5
a464 1
	if ( ! html_putline(mbuf, i, TAG_DIV_MDOC, NULL))
d466 5
a470 1
	if ( ! html_putline(mbuf, i++, "<table width=\"100%\">", NULL))
d472 1
a472 1
	if ( ! html_putline(mbuf, i++, "<tr>", NULL))
d474 2
a475 1
	if ( ! html_putline(mbuf, i++, "<td align=\"left\">", NULL))
d477 1
a477 1
	if ( ! ml_putstring(mbuf, title, NULL))
d479 1
a479 1
	if ( ! html_putline(mbuf, --i, "</td>", NULL))
d481 2
a482 1
	if ( ! html_putline(mbuf, i++, "<td align=\"center\">", NULL))
d484 2
a485 1
	if ( ! ml_putstring(mbuf, "Hello, world.", NULL))
d487 2
a488 1
	if ( ! html_putline(mbuf, --i, "</td>", NULL))
d490 1
a490 1
	if ( ! html_putline(mbuf, i++, "<td align=\"right\">", NULL))
d492 1
a492 1
	if ( ! ml_putstring(mbuf, title, NULL))
d494 2
a495 5
	if ( ! html_putline(mbuf, --i, "</td>", NULL))
		return(0);
	if ( ! html_putline(mbuf, --i, "</tr>", NULL))
		return(0);
	if ( ! html_putline(mbuf, --i, "</table>", NULL))
d497 1
a497 1
	return(1);
d506 1
a506 1
	if ( ! html_putline(mbuf, 0, TAG_DIV_END, NULL))
d508 1
a508 1
	if ( ! html_putline(mbuf, 0, TAG_BODY_END, NULL))
d510 1
a510 1
	return(html_putline(mbuf, 0, TAG_HTML_END, NULL));
d525 1
a525 1
		return(ml_nputs(mbuf, "span", 4, res));
d529 1
a529 1
		return(ml_nputs(mbuf, "span", 4, res));
d534 1
a534 1
	return(ml_puts(mbuf, "div", res));
d549 1
a549 1
		return(ml_nputs(mbuf, "span", 4, res));
d551 1
a551 1
		return(ml_nputs(mbuf, "span", 4, res));
d553 1
a553 1
		return(ml_nputs(mbuf, "h1", 2, res));
d555 1
a555 1
		return(ml_nputs(mbuf, "h2", 2, res));
d560 1
a560 1
	return(ml_nputs(mbuf, "div", 3, res));
d573 1
a573 1
		return(ml_nputs(mbuf, "span", 4, res));
d575 1
a575 1
		return(ml_nputs(mbuf, "span", 4, res));
d582 1
a582 1
	return(ml_puts(mbuf, "div", res));
d592 2
d651 3
d678 1
a678 1
		return(ml_nputs(mbuf, "div", 3, res));
d680 1
a680 1
		return(ml_nputs(mbuf, "a", 1, res));
d685 1
a685 1
	return(ml_puts(mbuf, "span", res));
d851 1
d854 2
d857 1
a857 3
	if ( ! ml_puts(mbuf, "<a href=\"", &res))
		return(-1);
	if (1 != ml_nputstring(mbuf, buf, sz, &res))
a858 3
	if ( ! ml_puts(mbuf, "\">", &res))
		return(-1);

d871 1
a871 2

	if ( ! ml_puts(mbuf, "</a>", &res))
a872 1

@


1.17
log
@Considerable clean-ups.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.16 2008/12/08 16:29:57 kristaps Exp $ */
d34 1
d36 1
d38 1
d373 25
d406 1
a406 1
	size_t		 res;
d414 1
a414 1
	res = 0;
d416 1
a416 5
	if ( ! ml_puts(mbuf, TAG_DOCTYPE, &res))
		return(0);
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
		return(0);
	if ( ! ml_puts(mbuf, TAG_HTML, &res))
d418 1
a418 1
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
d420 1
a420 1
	if ( ! ml_puts(mbuf, TAG_BODY, &res))
d422 1
a422 1
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
d424 1
a424 1
	if ( ! ml_puts(mbuf, TAG_CONTTYPE, &res))
d426 1
a426 1
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
d428 1
a428 1
	if ( ! ml_puts(mbuf, TAG_RESTYPE, &res))
d430 1
a430 9
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
		return(0);
	if ( ! ml_puts(mbuf, TAG_TITLE, &res))
		return(0);
	if ( ! ml_putstring(mbuf, mtitle, &res))
		return(0);
	if ( ! ml_puts(mbuf, TAG_TITLE_END, &res))
		return(0);
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
d434 1
a434 3
		if ( ! ml_puts(mbuf, TAG_STYLE_CSS, &res))
			return(0);
		if ( ! ml_puts(mbuf, "\n", &res))
d438 1
a438 1
		if ( ! ml_puts(mbuf, TAG_STYLE_END, &res))
d440 1
a440 1
	} else if ( ! ml_puts(mbuf, css, &res))
d443 11
a453 1
	if ( ! ml_puts(mbuf, "\n", &res))
d455 11
a465 2

	if ( ! ml_puts(mbuf, TAG_HEAD_END, &res))
d467 1
a467 1
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
d469 1
a469 1
	if ( ! ml_puts(mbuf, TAG_BODY, &res))
d471 1
a471 1
	if ( ! ml_nputs(mbuf, "\n", 1, &res))
d473 1
a473 1
	if ( ! ml_puts(mbuf, TAG_DIV_MDOC, &res))
d475 1
a475 1
	return(ml_nputs(mbuf, "\n", 1, &res));
d484 5
a488 1
	return(ml_puts(mbuf, "</div></body>\n</html>", NULL));
@


1.16
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.15 2008/12/08 12:46:28 kristaps Exp $ */
a29 1
#include "libmdocml.h"
d33 18
d377 1
a377 2
	const char	*preamble, *css, *trail;
	char		 buf[512];
d380 5
a384 17
	preamble =
	"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n"
	"    \"http://www.w3.org/TR/html4/strict.dtd\">\n"
	"<html>\n"
	"<head>\n"
	"    <meta http-equiv=\"Content-Type\"\n"
	"         content=\"text/html;charset=utf-8\">\n"
	"    <meta name=\"resource-type\" content=\"document\">\n"
	"    <title>Manual Page for %s(%s)</title>\n";

	css = 
	"    <link rel=\"stylesheet\" type=\"text/css\"\n"
	"         href=\"%s\">\n";
	trail = 
	"</head>\n"
	"<body>\n"
	"<div class=\"mdoc\">";
d388 27
a414 4
	(void)snprintf(buf, sizeof(buf) - 1,
			preamble, title, ml_section(section));

	if ( ! ml_puts(mbuf, buf, &res))
a416 1
	assert(args->params.html.css);
d418 3
a420 1
		if ( ! ml_puts(mbuf, "    <style type=\"text/css\"><!--\n", &res))
d424 1
a424 1
		if ( ! ml_puts(mbuf, "    --!></style>\n", &res))
d426 2
a427 6
	} else {
		(void)snprintf(buf, sizeof(buf) - 1, css, 
				args->params.html.css);
		if ( ! ml_puts(mbuf, buf, &res))
			return(0);
	}
d429 1
a429 1
	if ( ! ml_puts(mbuf, trail, &res))
d432 11
a442 1
	return(1);
@


1.15
log
@Added warnings for using macros in the wrong sections.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.14 2008/12/07 21:30:49 kristaps Exp $ */
a143 1

d153 1
a153 2
	abort();
	/* NOTREACHED */
d203 1
a203 4
	abort();
	/* NOTREACHED */

	return(1);
d245 1
a245 2
	abort();
	/* NOTREACHED */
d295 1
a295 2
	abort();
	/* NOTREACHED */
@


1.14
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.13 2008/12/06 21:10:31 kristaps Exp $ */
d78 1
a78 1
				const char *, const char *);
d364 1
a364 1
		const char *title, const char *section, 
d392 1
a392 1
			preamble, title, section);
@


1.13
log
@.St macros in place.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.12 2008/12/06 19:41:41 kristaps Exp $ */
d58 12
d142 3
a153 1
	assert(i != ROFF_MAXLINEARG);
a155 2

	return(1);
d754 64
d846 2
a850 1

@


1.12
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.11 2008/12/05 22:54:44 kristaps Exp $ */
d125 2
d160 2
d256 2
d558 1
d615 1
d732 1
@


1.11
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.10 2008/12/05 22:34:30 kristaps Exp $ */
d86 1
a86 1
static	int		html_blockbodytagname(struct md_mbuf *,
d90 1
a90 1
static	int		html_blockbodytagargs(struct md_mbuf *,
d412 1
a412 1
html_blockbodytagname(struct md_mbuf *mbuf, 
d420 2
d424 2
d444 4
d449 1
a449 1
		return(ml_puts(mbuf, "h1", res));
d451 1
a451 1
		return(ml_puts(mbuf, "h2", res));
d456 1
a456 1
	return(ml_puts(mbuf, "div", res));
d468 4
d513 1
a513 1
html_blockbodytagargs(struct md_mbuf *mbuf, 
d540 17
a556 1
	return(html_printargs(mbuf, tok, "inline", argc, argv, res));
d568 3
a570 1
		return(ml_puts(mbuf, "div", res));
d612 1
a612 2
	} else
		assert(NULL == argv);
d627 1
a627 1
		if ( ! html_blockbodytagname(mbuf, args, tok, 
d630 1
a630 1
		if ( ! html_blockbodytagargs(mbuf, args, tok, 
d678 1
a678 1
		if ( ! html_blockbodytagname(mbuf, args, tok, 
@


1.10
log
@Nm works properly, many other changes, etc.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.9 2008/12/05 19:45:15 kristaps Exp $ */
d118 1
a118 1
	int		 i, c;
d125 1
a125 1
	for (i = 0; ROFF_ARGMAX != (c = n->argc[i]) &&
d151 1
a151 1
	int		 i, c;
d158 1
a158 1
	for (i = 0; ROFF_ARGMAX != (c = n->argc[i]) &&
d201 1
a201 1
	int		 c, i;
d203 1
a203 1
	for (i = 0; ROFF_ARGMAX != (c = argc[i])
d245 1
a245 1
	int		 i, c;
d252 1
a252 1
	for (i = 0; ROFF_ARGMAX != (c = n->argc[i]) &&
d557 1
a557 1
	int		 i, c;
d578 1
a578 1
		for (i = 0; ROFF_ARGMAX != (c = argc[i]) 
@


1.9
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.8 2008/12/05 17:43:14 kristaps Exp $ */
d40 1
a40 1
	int		*argc[ROFF_MAXLINEARG];
d73 3
a75 1
				const struct md_args *, int, size_t *);
d79 5
a83 3
static	int		html_blockheadtagname(struct md_mbuf *,
				const struct md_args *, int, size_t *);
static	int		html_blockheadtagargs(struct md_mbuf *,
d87 3
a89 1
				const struct md_args *, int, size_t *);
d98 188
d369 1
a369 1
	"<div class=\"mdoc\">\n";
d413 2
a414 1
		const struct md_args *args, int tok, size_t *res)
d417 9
d432 3
a434 2
html_blockheadtagname(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, size_t *res)
d437 11
d454 3
a456 2
html_blocktagname(struct md_mbuf *mbuf, 
		const struct md_args *args, int tok, size_t *res)
d459 7
d490 1
a490 1
html_blockheadtagargs(struct md_mbuf *mbuf, 
d557 1
d574 12
d590 2
a591 1
		if ( ! html_blocktagname(mbuf, args, tok, &res))
d598 2
a599 1
		if ( ! html_blockbodytagname(mbuf, args, tok, &res))
d606 2
a607 1
		if ( ! html_blockheadtagname(mbuf, args, tok, &res))
d609 1
a609 1
		if ( ! html_blockheadtagargs(mbuf, args, tok, 
d639 1
d643 3
a645 1
		if ( ! html_blocktagname(mbuf, args, tok, &res))
d649 3
a651 1
		if ( ! html_blockbodytagname(mbuf, args, tok, &res))
d655 3
a657 1
		if ( ! html_blockheadtagname(mbuf, args, tok, &res))
a665 1
	node = q->last;
@


1.8
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.7 2008/12/05 11:28:16 kristaps Exp $ */
a35 1
/* FIXME: free htmlq. */
a50 3
static	void		htmlnode_free(struct htmlnode *);
static	void		htmlnode_free(struct htmlnode *);

d53 2
a210 5
	size_t		 res;

	res = 0;
	if ( ! ml_puts(mbuf, "</div></body>\n</html>", &res))
		return(0);
d212 1
a212 1
	return(1);
a225 2


d246 1
a250 1
	int		 i, c;
d260 1
a260 29
	if ( ! ml_puts(mbuf, "\"", res))
		return(0);

	if (NULL == argv || NULL == argc)
		return(1);
	assert(argv && argc);
	
	/* FIXME: ignores values. */

	for (i = 0; ROFF_ARGMAX != (c = argc[i]); i++) {
		if (argv[i])
			continue;
		if ( ! ml_puts(mbuf, " class=\"", res))
			return(0);
		if ( ! ml_puts(mbuf, ns, res))
			return(0);
		if ( ! ml_puts(mbuf, "-", res))
			return(0);
		if ( ! ml_puts(mbuf, toknames[tok], res))
			return(0);
		if ( ! ml_puts(mbuf, "-", res))
			return(0);
		if ( ! ml_puts(mbuf, tokargnames[c], res))
			return(0);
		if ( ! ml_puts(mbuf, "\"", res))
			return(0);
	}

	return(1);
d318 1
a318 1
		return(ml_puts(mbuf, "span", res));
d320 2
a321 1
	return(1);
d422 1
a422 1
	htmlnode_free(node);
d428 30
d478 1
a478 1
	struct htmlq	*q;
d480 6
a485 4
	if (NULL == (q = calloc(1, sizeof(struct htmlq)))) {
		warn("calloc");
		return(NULL);
	}
d487 1
a487 2
	return(mlg_alloc(args, q, rbuf, mbuf, html_begintag, 
				html_endtag, html_begin, html_end));
@


1.7
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.6 2008/12/04 23:10:51 kristaps Exp $ */
d35 3
d39 2
a40 1
	int		 type;
d52 3
d57 1
a57 1
static	ssize_t		html_endtag(struct md_mbuf *, 
d60 1
a60 1
static	ssize_t		html_begintag(struct md_mbuf *, 
d362 3
a364 3
html_begintag(struct md_mbuf *mbuf, const struct md_args *args, 
		enum md_ns ns, int tok, 
		const int *argc, const char **argv)
d367 2
d373 14
d423 2
a424 2
html_endtag(struct md_mbuf *mbuf, const struct md_args *args, 
		enum md_ns ns, int tok)
d427 2
d433 3
d455 5
d484 6
d491 1
a491 1
	return(mlg_alloc(args, rbuf, mbuf, html_begintag, 
@


1.6
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.5 2008/12/04 16:19:52 kristaps Exp $ */
d35 13
d62 3
d67 3
a69 3
static	ssize_t		html_blocktagname(struct md_mbuf *,
				const struct md_args *, int);
static	ssize_t		html_blocktagargs(struct md_mbuf *,
d71 4
a74 4
				const int *, const char **);
static	ssize_t		html_blockheadtagname(struct md_mbuf *,
				const struct md_args *, int);
static	ssize_t		html_blockheadtagargs(struct md_mbuf *,
d76 4
a79 4
				const int *, const char **);
static	ssize_t		html_blockbodytagname(struct md_mbuf *,
				const struct md_args *, int);
static	ssize_t		html_blockbodytagargs(struct md_mbuf *,
d81 4
a84 4
				const int *, const char **);
static	ssize_t		html_inlinetagname(struct md_mbuf *,
				const struct md_args *, int);
static	ssize_t		html_inlinetagargs(struct md_mbuf *,
d86 1
a86 1
				const int *, const char **);
d217 1
a217 1
static ssize_t
d219 1
a219 1
		const struct md_args *args, int tok)
a220 5
	size_t		 res;

	res = 0;
	if ( ! ml_puts(mbuf, "div", &res))
		return(-1);
d222 1
a222 1
	return((ssize_t)res);
d229 1
a229 1
static ssize_t
d231 1
a231 1
		const struct md_args *args, int tok)
a232 5
	size_t		 res;

	res = 0;
	if ( ! ml_puts(mbuf, "div", &res))
		return(-1);
d234 1
a234 1
	return((ssize_t)res);
d239 1
a239 1
static ssize_t
d241 1
a241 1
		const struct md_args *args, int tok)
a242 1
	size_t		 res;
d244 1
a244 5
	res = 0;
	if ( ! ml_puts(mbuf, "div", &res))
		return(-1);

	return((ssize_t)res);
d248 3
a250 4
/* ARGSUSED */
static ssize_t
html_blockheadtagargs(struct md_mbuf *mbuf, const struct md_args *args, 
		int tok, const int *argc, const char **argv)
d252 1
a252 1
	size_t		 res;
d254 5
a258 3
	res = 0;

	if ( ! ml_puts(mbuf, " class=\"head-", &res))
d260 1
a260 1
	if ( ! ml_puts(mbuf, toknames[tok], &res))
d262 1
a262 1
	if ( ! ml_puts(mbuf, "\"", &res))
d265 23
a287 3
	switch (tok) {
	default:
		break;
d290 1
a290 1
	return(0);
d295 4
a298 3
static ssize_t
html_blockbodytagargs(struct md_mbuf *mbuf, const struct md_args *args, 
		int tok, const int *argc, const char **argv)
a299 1
	size_t		 res;
d301 2
a302 1
	res = 0;
a303 6
	if ( ! ml_puts(mbuf, " class=\"body-", &res))
		return(0);
	if ( ! ml_puts(mbuf, toknames[tok], &res))
		return(0);
	if ( ! ml_puts(mbuf, "\"", &res))
		return(0);
d305 6
a310 4
	switch (tok) {
	default:
		break;
	}
d312 1
a312 1
	return(res);
d317 4
a320 3
static ssize_t
html_blocktagargs(struct md_mbuf *mbuf, const struct md_args *args, 
		int tok, const int *argc, const char **argv)
a321 1
	size_t		 res;
d323 1
a323 15
	res = 0;

	if ( ! ml_puts(mbuf, " class=\"block-", &res))
		return(0);
	if ( ! ml_puts(mbuf, toknames[tok], &res))
		return(0);
	if ( ! ml_puts(mbuf, "\"", &res))
		return(0);

	switch (tok) {
	default:
		break;
	}

	return(0);
d328 4
a331 3
static ssize_t
html_inlinetagargs(struct md_mbuf *mbuf, const struct md_args *args, 
		int tok, const int *argc, const char **argv)
a332 11
	size_t		 res;

	res = 0;

	if ( ! ml_puts(mbuf, " class=\"inline-", &res))
		return(0);
	if ( ! ml_puts(mbuf, toknames[tok], &res))
		return(0);
	if ( ! ml_puts(mbuf, "\"", &res))
		return(0);

d334 1
a334 6
	switch (tok) {
	default:
		break;
	}

	return(0);
d339 1
a339 1
static ssize_t
d341 1
a341 1
		const struct md_args *args, int tok)
a342 3
	size_t		 res;

	res = 0;
d346 1
a346 3
		if ( ! ml_puts(mbuf, "div", &res))
			return(-1);
		break;
d348 1
a348 3
		if ( ! ml_puts(mbuf, "span", &res))
			return(-1);
		break;
d350 1
a350 2

	return((ssize_t)res);
d359 1
d362 2
d366 6
a371 7
		if ( ! html_blocktagname(mbuf, args, tok))
			return(0);
		if (NULL == argc || NULL == argv)
			return(1);
		assert(argc && argv);
		return(html_blocktagargs(mbuf, args, 
					tok, argc, argv));
d373 6
a378 7
		if ( ! html_blockbodytagname(mbuf, args, tok))
			return(0);
		if (NULL == argc || NULL == argv)
			return(1);
		assert(argc && argv);
		return(html_blockbodytagargs(mbuf, args, 
					tok, argc, argv));
d380 6
a385 7
		if ( ! html_blockheadtagname(mbuf, args, tok))
			return(0);
		if (NULL == argc || NULL == argv)
			return(1);
		assert(argc && argv);
		return(html_blockheadtagargs(mbuf, args, 
					tok, argc, argv));
d387 5
d395 1
a395 6
	if ( ! html_inlinetagname(mbuf, args, tok))
		return(0);
	if (NULL == argc || NULL == argv)
		return(1);
	assert(argc && argv);
	return(html_inlinetagargs(mbuf, args, tok, argc, argv));
d403 1
d406 2
d410 3
a412 1
		return(html_blocktagname(mbuf, args, tok));
d414 3
a416 1
		return(html_blockbodytagname(mbuf, args, tok));
d418 3
a420 1
		return(html_blockheadtagname(mbuf, args, tok));
d422 2
d427 1
a427 1
	return(html_inlinetagname(mbuf, args, tok));
@


1.5
log
@Character-encoding tests.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.4 2008/12/04 11:25:29 kristaps Exp $ */
d383 3
d391 3
d399 3
d410 3
@


1.4
log
@More html-css.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.3 2008/12/03 21:27:56 kristaps Exp $ */
d166 1
a166 1
		if ( ! ml_puts(mbuf, "    <style><!--\n", &res))
@


1.3
log
@Initial html outputs working.
@
text
@d1 1
a1 1
/* $Id: html.c,v 1.2 2008/12/03 19:21:58 kristaps Exp $ */
d19 3
d23 2
d26 1
d28 1
d35 2
d44 5
a48 2
static	int		html_begin(struct md_mbuf *, 
				const struct md_args *);
d73 54
d129 4
a132 1
html_begin(struct md_mbuf *mbuf, const struct md_args *args)
d134 2
d138 18
d157 5
a161 3
	if ( ! ml_puts(mbuf, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD "
				"HTML 4.01//EN\" \"http://www.w3.org"
				"/TR/html4/strict.dtd\">\n", &res))
d163 17
a179 16
	if ( ! ml_puts(mbuf, "<html>\n", &res))
		return(0);
	if ( ! ml_puts(mbuf, "<head>\n", &res))
		return(0);
	if ( ! ml_puts(mbuf, " <title>Manual page</title>\n", &res))
		return(0);
	if ( ! ml_puts(mbuf, " <meta http-equiv=\"Content-Type\" "
				"content=\"text/html; "
				"charset=utf-8\">\n", &res))
		return(0);
	if ( ! ml_puts(mbuf, " <meta name=\"resource-type\" "
				"content=\"document\">\n", &res))
		return(0);
	if ( ! ml_puts(mbuf, "</head>\n", &res))
		return(0);
	if ( ! ml_puts(mbuf, "<body>", &res))
d193 1
a193 1
	if ( ! ml_puts(mbuf, "</body>\n</html>", &res))
d208 2
a209 11

	switch (tok) {
	case (ROFF_Sh):
		if ( ! ml_puts(mbuf, "blockquote", &res))
			return(-1);
		break;
	default:
		if ( ! ml_puts(mbuf, "div", &res))
			return(-1);
		break;
	}
d225 2
a226 15

	switch (tok) {
	case (ROFF_Sh):
		if ( ! ml_puts(mbuf, "h1", &res))
			return(-1);
		break;
	case (ROFF_Ss):
		if ( ! ml_puts(mbuf, "h2", &res))
			return(-1);
		break;
	default:
		if ( ! ml_puts(mbuf, "div", &res))
			return(-1);
		break;
	}
d240 2
a241 19

	switch (tok) {
	case (ROFF_Bd):
		if ( ! ml_puts(mbuf, "pre", &res))
			return(-1);
		break;
	case (ROFF_Bl):
		if ( ! ml_puts(mbuf, "ul", &res))
			return(-1);
		break;
	case (ROFF_It):
		if ( ! ml_puts(mbuf, "li", &res))
			return(-1);
		break;
	default:
		if ( ! ml_puts(mbuf, "div", &res))
			return(-1);
		break;
	}
d256 1
a256 1
	if ( ! ml_puts(mbuf, " class=\"head:", &res))
d281 1
a281 1
	if ( ! ml_puts(mbuf, " class=\"body:", &res))
d306 1
a306 1
	if ( ! ml_puts(mbuf, " class=\"block:", &res))
d331 1
a331 1
	if ( ! ml_puts(mbuf, " class=\"inline:", &res))
d358 4
@


1.2
log
@Major update.
@
text
@d1 1
a1 1
/* $Id: xml.c,v 1.10 2008/12/03 14:39:59 kristaps Exp $ */
d44 10
d61 1
d94 1
d108 1
d110 1
a110 1
html_blocktagname(struct md_mbuf *mbuf, 
d122 50
d190 51
a240 1
	return((size_t)res);
d249 10
d262 1
a262 1
		return(0);
d265 1
a265 1
	return(-1);
d274 11
d288 1
a288 1
		return(0);
d291 1
a291 1
	return(-1);
d295 1
a304 8
	case (ROFF_Sh):
		if ( ! ml_puts(mbuf, "h1", &res))
			return(-1);
		break;
	case (ROFF_Ss):
		if ( ! ml_puts(mbuf, "h2", &res))
			return(-1);
		break;
d322 2
a323 1
	if (MD_NS_BLOCK == ns) {
d328 12
d354 2
a355 1
	if (MD_NS_BLOCK == ns)
d357 7
@


1.1
log
@Abstract ml/mlg/html/xml.
@
text
@d1 1
a1 1
/* $Id: html4_strict.c,v 1.9 2008/11/29 14:14:21 kristaps Exp $ */
d21 1
d25 119
d147 74
d225 1
a225 1
	return(1);
a228 1
/* ARGSUSED */
d233 1
a233 1
	return(1);
a236 1
/* ARGSUSED */
d242 2
a243 1
	return(NULL);
d245 1
@
