head	1.34;
access;
symbols
	VERSION_1_9_5:1.34
	VERSION_1_8_5:1.34
	VERSION_1_8_1:1.34
	VERSION_1_7_16:1.34
	VERSION_1_7_15:1.34
	OPENBSD_CHECKIN:1.34
	VERSION_1_7_5:1.32
	VERSION_1_6_5:1.30
	VERSION_1_6_2:1.29
	VERSION_1_5_3:1.29
	VERSION_1_5_1:1.29
	VERSION_1_4_6:1.27
	VERSION_1_4_5:1.27
	VERSION_1_4_4:1.26
	VERSION_1_4_2:1.26
	VERSION_1_3_15:1.22
	VERSION_1_3_13:1.22
	VERSION_1_3_11:1.22
	VERSION_1_3_10:1.22
	VERSION_1_3_9:1.22
	VERSION_1_3_8:1.22
	VERSION_1_3_6:1.22
	VERSION_1_3_5:1.19
	VERSION_1_2_0:1.10
	VERSION_1_1_0:1.6;
locks; strict;
comment	@ * @;


1.34
date	2009.03.31.13.50.19;	author kristaps;	state dead;
branches;
next	1.33;

1.33
date	2009.03.27.13.44.24;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.23.14.22.11;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.21.13.47.02;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.03.20.19.56.25;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.14.05.36.07;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.03.13.07.46.10;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.03.09.13.17.49;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.06.14.13.47;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.05.13.12.12;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.03.02.17.14.46;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.02.12.09.32;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.27.10.55.16;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.27.08.20.15;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.26.16.08.11;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.25.12.32.50;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.24.14.52.55;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.24.13.46.54;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.24.11.43.13;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.23.15.34.53;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.23.12.45.19;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.21.21.00.06;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.20.23.35.36;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.20.22.55.46;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.20.13.49.36;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.17.16.15.27;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.16.12.23.25;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.16.11.50.54;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.14.11.58.24;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.06.15.49.44;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.29.18.08.44;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.28.00.34.20;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.17.17.18.38;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.15.03.13.01;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.34
log
@General clean-ups.
@
text
@@


1.33
log
@Fixes in going over all OpenBSD manuals.
@
text
@a0 320
/* $Id: strings.c,v 1.32 2009/03/23 14:22:11 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "libmdoc.h"

/*
 * Various string-literal operations:  converting scalars to and from
 * strings, etc.
 */

struct mdoc_secname {
	const char	*name;
	int		 flag;
#define	MSECNAME_META	(1 << 0)
};

/* Section names corresponding to mdoc_sec. */

static	const struct mdoc_secname secnames[] = {
	{ "PROLOGUE", MSECNAME_META },
	{ "BODY", MSECNAME_META },
	{ "NAME", 0 },
	{ "LIBRARY", 0 },
	{ "SYNOPSIS", 0 },
	{ "DESCRIPTION", 0 },
	{ "IMPLEMENTATION NOTES", 0 },
	{ "RETURN VALUES", 0 },
	{ "ENVIRONMENT", 0 },
	{ "FILES", 0 },
	{ "EXAMPLES", 0 },
	{ "DIAGNOSTICS", 0 },
	{ "COMPATIBILITY", 0 },
	{ "ERRORS", 0 },
	{ "SEE ALSO", 0 },
	{ "STANDARDS", 0 },
	{ "HISTORY", 0 },
	{ "AUTHORS", 0 },
	{ "CAVEATS", 0 },
	{ "BUGS", 0 },
	{ NULL, 0 }
};

#ifdef __linux__
extern	char		*strptime(const char *, const char *, struct tm *);
#endif


size_t
mdoc_isescape(const char *p)
{
	size_t		 c;
	
	if ('\\' != *p++)
		return(0);

	switch (*p) {
	case ('\\'):
		/* FALLTHROUGH */
	case ('\''):
		/* FALLTHROUGH */
	case ('`'):
		/* FALLTHROUGH */
	case ('q'):
		/* FALLTHROUGH */
	case ('-'):
		/* FALLTHROUGH */
	case ('%'):
		/* FALLTHROUGH */
	case ('0'):
		/* FALLTHROUGH */
	case (' '):
		/* FALLTHROUGH */
	case ('|'):
		/* FALLTHROUGH */
	case ('&'):
		/* FALLTHROUGH */
	case ('.'):
		/* FALLTHROUGH */
	case (':'):
		/* FALLTHROUGH */
	case ('e'):
		return(2);
	case ('*'):
		if (0 == *++p || ! isgraph((u_char)*p))
			return(0);
		switch (*p) {
		case ('('):
			if (0 == *++p || ! isgraph((u_char)*p))
				return(0);
			return(4);
		case ('['):
			for (c = 3, p++; *p && ']' != *p; p++, c++)
				if ( ! isgraph((u_char)*p))
					break;
			return(*p == ']' ? c : 0);
		default:
			break;
		}
		return(3);
	case ('('):
		if (0 == *++p || ! isgraph((u_char)*p))
			return(0);
		if (0 == *++p || ! isgraph((u_char)*p))
			return(0);
		return(4);
	case ('['):
		break;
	default:
		return(0);
	}

	for (c = 3, p++; *p && ']' != *p; p++, c++)
		if ( ! isgraph((u_char)*p))
			break;

	return(*p == ']' ? c : 0);
}


int
mdoc_iscdelim(char p)
{

	switch (p) {
	case('.'):
		/* FALLTHROUGH */
	case(','):
		/* FALLTHROUGH */
	case(';'):
		/* FALLTHROUGH */
	case(':'):
		/* FALLTHROUGH */
	case('?'):
		/* FALLTHROUGH */
	case('!'):
		/* FALLTHROUGH */
	case('('):
		/* FALLTHROUGH */
	case(')'):
		/* FALLTHROUGH */
	case('['):
		/* FALLTHROUGH */
	case(']'):
		/* FALLTHROUGH */
	case('{'):
		/* FALLTHROUGH */
	case('}'):
		return(1);
	default:
		break;
	}

	return(0);
}


int
mdoc_isdelim(const char *p)
{

	if (0 == *p)
		return(0);
	if (0 != *(p + 1))
		return(0);
	return(mdoc_iscdelim(*p));
}


enum mdoc_sec 
mdoc_atosec(const char *p)
{
	const struct mdoc_secname *n;
	int			   i;

	for (i = 0, n = secnames; n->name; n++, i++)
		if ( ! (n->flag & MSECNAME_META))
			if (xstrcmp(p, n->name))
				return((enum mdoc_sec)i);

	return(SEC_CUSTOM);
}


time_t
mdoc_atotime(const char *p)
{
	struct tm	 tm;
	char		*pp;

	(void)memset(&tm, 0, sizeof(struct tm));

	if (xstrcmp(p, "$Mdocdate$"))
		return(time(NULL));
	if ((pp = strptime(p, "$Mdocdate: %b %d %Y $", &tm)) && 0 == *pp)
		return(mktime(&tm));
	/* XXX - this matches "June 1999", which is wrong. */
	if ((pp = strptime(p, "%b %d %Y", &tm)) && 0 == *pp)
		return(mktime(&tm));
	if ((pp = strptime(p, "%b %d, %Y", &tm)) && 0 == *pp)
		return(mktime(&tm));

	return(0);
}


size_t
mdoc_macro2len(int macro)
{

	switch (macro) {
	case(MDOC_Ad):
		return(12);
	case(MDOC_Ao):
		return(12);
	case(MDOC_An):
		return(12);
	case(MDOC_Aq):
		return(12);
	case(MDOC_Ar):
		return(12);
	case(MDOC_Bo):
		return(12);
	case(MDOC_Bq):
		return(12);
	case(MDOC_Cd):
		return(12);
	case(MDOC_Cm):
		return(10);
	case(MDOC_Do):
		return(10);
	case(MDOC_Dq):
		return(12);
	case(MDOC_Dv):
		return(12);
	case(MDOC_Eo):
		return(12);
	case(MDOC_Em):
		return(10);
	case(MDOC_Er):
		return(12);
	case(MDOC_Ev):
		return(15);
	case(MDOC_Fa):
		return(12);
	case(MDOC_Fl):
		return(10);
	case(MDOC_Fo):
		return(16);
	case(MDOC_Fn):
		return(16);
	case(MDOC_Ic):
		return(10);
	case(MDOC_Li):
		return(16);
	case(MDOC_Ms):
		return(6);
	case(MDOC_Nm):
		return(10);
	case(MDOC_No):
		return(12);
	case(MDOC_Oo):
		return(10);
	case(MDOC_Op):
		return(14);
	case(MDOC_Pa):
		return(32);
	case(MDOC_Pf):
		return(12);
	case(MDOC_Po):
		return(12);
	case(MDOC_Pq):
		return(12);
	case(MDOC_Ql):
		return(16);
	case(MDOC_Qo):
		return(12);
	case(MDOC_So):
		return(12);
	case(MDOC_Sq):
		return(12);
	case(MDOC_Sy):
		return(6);
	case(MDOC_Sx):
		return(16);
	case(MDOC_Tn):
		return(10);
	case(MDOC_Va):
		return(12);
	case(MDOC_Vt):
		return(12);
	case(MDOC_Xr):
		return(10);
	default:
		break;
	};
	return(0);
}
@


1.32
log
@First addition of -man macro support.
Abstraction of mdoc.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.31 2009/03/21 13:47:02 kristaps Exp $ */
d92 2
@


1.31
log
@Freed more macros from zero-length restrictions.
Fixed `Fn' spacing.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.30 2009/03/20 19:56:25 kristaps Exp $ */
d27 1
a27 1
#include "private.h"
@


1.30
log
@Proper .Dl literalism.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.29 2009/03/14 05:36:07 kristaps Exp $ */
d90 2
@


1.29
log
@Bumped version.
Added \| (non-breaking space, like \&).
Fixed termsym (TERMSYM_ALL).
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.28 2009/03/13 07:46:10 kristaps Exp $ */
d98 2
@


1.28
log
@Added canonical mdoc.7.
Added \q macro.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.27 2009/03/09 13:17:49 kristaps Exp $ */
d92 2
@


1.27
log
@Easier integration into FreeBSD (sys/types.h, time.h, etc.).
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.26 2009/03/06 14:13:47 kristaps Exp $ */
d86 2
@


1.26
log
@Strings abstracted into dynamically-created C files.
Added -V option.
Deprecated README files.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.25 2009/03/05 13:12:12 kristaps Exp $ */
d19 2
a25 3
#ifndef __OpenBSD__
#include <time.h>
#endif
@


1.25
log
@Cleaned up ctype functions (netbsd).
Fixed .Ex/.Rv -std usage.
Made Ar provide default value.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.24 2009/03/02 17:14:46 kristaps Exp $ */
d28 2
d31 2
a32 1
 * Convert scalars to and from string format.
d35 31
a65 1
#include "private.h"
d186 2
d189 4
a192 31
	assert(p);
	if (0 == strcmp(p, "NAME"))
		return(SEC_NAME);
	else if (0 == strcmp(p, "RETURN VALUES"))
		return(SEC_RETURN_VALUES);
	else if (0 == strcmp(p, "SEE ALSO"))
		return(SEC_SEE_ALSO);
	else if (0 == strcmp(p, "SYNOPSIS"))
		return(SEC_SYNOPSIS);
	else if (0 == strcmp(p, "DESCRIPTION"))
		return(SEC_DESCRIPTION);
	else if (0 == strcmp(p, "ENVIRONMENT"))
		return(SEC_ENVIRONMENT);
	else if (0 == strcmp(p, "FILES"))
		return(SEC_FILES);
	else if (0 == strcmp(p, "EXAMPLES"))
		return(SEC_EXAMPLES);
	else if (0 == strcmp(p, "DIAGNOSTICS"))
		return(SEC_DIAGNOSTICS);
	else if (0 == strcmp(p, "ERRORS"))
		return(SEC_ERRORS);
	else if (0 == strcmp(p, "STANDARDS"))
		return(SEC_STANDARDS);
	else if (0 == strcmp(p, "HISTORY"))
		return(SEC_HISTORY);
	else if (0 == strcmp(p, "AUTHORS"))
		return(SEC_AUTHORS);
	else if (0 == strcmp(p, "CAVEATS"))
		return(SEC_CAVEATS);
	else if (0 == strcmp(p, "BUGS"))
		return(SEC_BUGS);
a219 541
enum mdoc_msec
mdoc_atomsec(const char *p)
{

	if (0 == strcmp(p, "1"))
		return(MSEC_1);
	else if (0 == strcmp(p, "2"))
		return(MSEC_2);
	else if (0 == strcmp(p, "3"))
		return(MSEC_3);
	else if (0 == strcmp(p, "3f"))
		return(MSEC_3f);
	else if (0 == strcmp(p, "3p"))
		return(MSEC_3p);
	else if (0 == strcmp(p, "4"))
		return(MSEC_4);
	else if (0 == strcmp(p, "5"))
		return(MSEC_5);
	else if (0 == strcmp(p, "6"))
		return(MSEC_6);
	else if (0 == strcmp(p, "7"))
		return(MSEC_7);
	else if (0 == strcmp(p, "8"))
		return(MSEC_8);
	else if (0 == strcmp(p, "9"))
		return(MSEC_9);
	else if (0 == strcmp(p, "X11"))
		return(MSEC_X11);
	else if (0 == strcmp(p, "X11R6"))
		return(MSEC_X11R6);
	else if (0 == strcmp(p, "local"))
		return(MSEC_local);
	else if (0 == strcmp(p, "n"))
		return(MSEC_n);
	else if (0 == strcmp(p, "unass"))
		return(MSEC_unass);
	else if (0 == strcmp(p, "draft"))
		return(MSEC_draft);
	else if (0 == strcmp(p, "paper"))
		return(MSEC_paper);

	return(MSEC_DEFAULT);
}


enum mdoc_vol
mdoc_atovol(const char *p)
{

	if (0 == strcmp(p, "AMD"))
		return(VOL_AMD);
	else if (0 == strcmp(p, "IND"))
		return(VOL_IND);
	else if (0 == strcmp(p, "KM"))
		return(VOL_KM);
	else if (0 == strcmp(p, "LOCAL"))
		return(VOL_LOCAL);
	else if (0 == strcmp(p, "PRM"))
		return(VOL_PRM);
	else if (0 == strcmp(p, "PS1"))
		return(VOL_PS1);
	else if (0 == strcmp(p, "SMM"))
		return(VOL_SMM);
	else if (0 == strcmp(p, "URM"))
		return(VOL_URM);
	else if (0 == strcmp(p, "USD"))
		return(VOL_USD);

	return(VOL_DEFAULT);
}


enum mdoc_arch
mdoc_atoarch(const char *p)
{

	if (0 == strcmp(p, "alpha"))
		return(ARCH_alpha);
	else if (0 == strcmp(p, "amd64"))
		return(ARCH_amd64);
	else if (0 == strcmp(p, "amiga"))
		return(ARCH_amiga);
	else if (0 == strcmp(p, "arc"))
		return(ARCH_arc);
	else if (0 == strcmp(p, "arm"))
		return(ARCH_arm);
	else if (0 == strcmp(p, "armish"))
		return(ARCH_armish);
	else if (0 == strcmp(p, "aviion"))
		return(ARCH_aviion);
	else if (0 == strcmp(p, "hp300"))
		return(ARCH_hp300);
	else if (0 == strcmp(p, "hppa"))
		return(ARCH_hppa);
	else if (0 == strcmp(p, "hppa64"))
		return(ARCH_hppa64);
	else if (0 == strcmp(p, "i386"))
		return(ARCH_i386);
	else if (0 == strcmp(p, "landisk"))
		return(ARCH_landisk);
	else if (0 == strcmp(p, "luna88k"))
		return(ARCH_luna88k);
	else if (0 == strcmp(p, "mac68k"))
		return(ARCH_mac68k);
	else if (0 == strcmp(p, "macppc"))
		return(ARCH_macppc);
	else if (0 == strcmp(p, "mvme68k"))
		return(ARCH_mvme68k);
	else if (0 == strcmp(p, "mvme88k"))
		return(ARCH_mvme88k);
	else if (0 == strcmp(p, "mvmeppc"))
		return(ARCH_mvmeppc);
	else if (0 == strcmp(p, "pmax"))
		return(ARCH_pmax);
	else if (0 == strcmp(p, "sgi"))
		return(ARCH_sgi);
	else if (0 == strcmp(p, "socppc"))
		return(ARCH_socppc);
	else if (0 == strcmp(p, "sparc"))
		return(ARCH_sparc);
	else if (0 == strcmp(p, "sparc64"))
		return(ARCH_sparc64);
	else if (0 == strcmp(p, "sun3"))
		return(ARCH_sun3);
	else if (0 == strcmp(p, "vax"))
		return(ARCH_vax);
	else if (0 == strcmp(p, "zaurus"))
		return(ARCH_zaurus);

	return(ARCH_DEFAULT);
}


enum mdoc_att
mdoc_atoatt(const char *p)
{

	assert(p);
	if (0 == strcmp(p, "v1"))
		return(ATT_v1);
	else if (0 == strcmp(p, "v2"))
		return(ATT_v2);
	else if (0 == strcmp(p, "v3"))
		return(ATT_v3);
	else if (0 == strcmp(p, "v4"))
		return(ATT_v4);
	else if (0 == strcmp(p, "v5"))
		return(ATT_v5);
	else if (0 == strcmp(p, "v6"))
		return(ATT_v6);
	else if (0 == strcmp(p, "v7"))
		return(ATT_v7);
	else if (0 == strcmp(p, "32v"))
		return(ATT_32v);
	else if (0 == strcmp(p, "V"))
		return(ATT_V);
	else if (0 == strcmp(p, "V.1"))
		return(ATT_V1);
	else if (0 == strcmp(p, "V.2"))
		return(ATT_V2);
	else if (0 == strcmp(p, "V.3"))
		return(ATT_V3);
	else if (0 == strcmp(p, "V.4"))
		return(ATT_V4);
	
	return(ATT_DEFAULT);
}


char *
mdoc_type2a(enum mdoc_type type)
{
	switch (type) {
	case (MDOC_ROOT):
		return("root");
	case (MDOC_BLOCK):
		return("block");
	case (MDOC_HEAD):
		return("block-head");
	case (MDOC_BODY):
		return("block-body");
	case (MDOC_TAIL):
		return("block-tail");
	case (MDOC_ELEM):
		return("elem");
	case (MDOC_TEXT):
		return("text");
	default:
		break;
	}

	abort();
	/* NOTREACHED */
}


const char *
mdoc_arch2a(enum mdoc_arch arch)
{

	switch (arch) {
	case (ARCH_alpha):
		return("Alpha");
	case (ARCH_amd64):
		return("AMD64");
	case (ARCH_amiga):
		return("Amiga");
	case (ARCH_arc):
		return("ARC");
	case (ARCH_arm):
		return("ARM");
	case (ARCH_armish):
		return("ARMISH");
	case (ARCH_aviion):
		return("AViiON");
	case (ARCH_hp300):
		return("HP300");
	case (ARCH_hppa):
		return("HPPA");
	case (ARCH_hppa64):
		return("HPPA64");
	case (ARCH_i386):
		return("i386");
	case (ARCH_landisk):
		return("LANDISK");
	case (ARCH_luna88k):
		return("Luna88k");
	case (ARCH_mac68k):
		return("Mac68k");
	case (ARCH_macppc):
		return("MacPPC");
	case (ARCH_mvme68k):
		return("MVME68k");
	case (ARCH_mvme88k):
		return("MVME88k");
	case (ARCH_mvmeppc):
		return("MVMEPPC");
	case (ARCH_pmax):
		return("PMAX");
	case (ARCH_sgi):
		return("SGI");
	case (ARCH_socppc):
		return("SOCPPC");
	case (ARCH_sparc):
		return("SPARC");
	case (ARCH_sparc64):
		return("SPARC64");
	case (ARCH_sun3):
		return("Sun3");
	case (ARCH_vax):
		return("VAX");
	case (ARCH_zaurus):
		return("Zaurus");
	case (ARCH_DEFAULT):
		return(NULL);
	default:
		break;
	}

	abort();
	/* NOTREACHED */
}


const char *
mdoc_vol2a(enum mdoc_vol vol)
{

	switch (vol) {
	case (VOL_AMD):
		return("Ancestral Manual Documents");
	case (VOL_IND):
		return("Manual Master Index");
	case (VOL_KM):
		return("Kernel Manual");
	case (VOL_LOCAL):
		return("Local Manual");
	case (VOL_PRM):
		return("Programmer's Manual");
	case (VOL_PS1):
		return("Programmer's Supplementary Documents");
	case (VOL_SMM):
		return("System Manager's Manual");
	case (VOL_URM):
		return("Reference Manual");
	case (VOL_USD):
		return("User's Supplementary Documents");
	case (VOL_DEFAULT):
		return(NULL);
	default:
		break;
	}

	abort();
	/* NOTREACHED */
}


const char *
mdoc_msec2a(enum mdoc_msec msec)
{

	switch (msec) {
	case(MSEC_1):
		return("1");
	case(MSEC_2):
		return("2");
	case(MSEC_3):
		return("3");
	case(MSEC_3f):
		return("3f");
	case(MSEC_3p):
		return("3p");
	case(MSEC_4):
		return("4");
	case(MSEC_5):
		return("5");
	case(MSEC_6):
		return("6");
	case(MSEC_7):
		return("7");
	case(MSEC_8):
		return("8");
	case(MSEC_9):
		return("9");
	case(MSEC_X11):
		return("X11");
	case(MSEC_X11R6):
		return("X11R6");
	case(MSEC_local):
		return("local");
	case(MSEC_n):
		return("n");
	case(MSEC_unass):
		/* FALLTHROUGH */
	case(MSEC_draft):
		return("draft");
	case(MSEC_paper):
		return("paper");
	case(MSEC_DEFAULT):
		return(NULL);
	default:
		break;
	}

	abort();
	/* NOTREACHED */
}


const char *
mdoc_st2a(int c)
{
	char		 *p;

	switch (c) {
	case(MDOC_p1003_1_88):
		p = "IEEE Std 1003.1-1988 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1_90):
		p = "IEEE Std 1003.1-1990 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1_96):
		p = "ISO/IEC 9945-1:1996 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1_2001):
		p = "IEEE Std 1003.1-2001 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1_2004):
		p = "IEEE Std 1003.1-2004 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1):
		p = "IEEE Std 1003.1 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1b):
		p = "IEEE Std 1003.1b (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1b_93):
		p = "IEEE Std 1003.1b-1993 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1c_95):
		p = "IEEE Std 1003.1c-1995 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_1g_2000):
		p = "IEEE Std 1003.1g-2000 (\\(lqPOSIX\\(rq)";
		break;
	case(MDOC_p1003_2_92):
		p = "IEEE Std 1003.2-1992 (\\(lqPOSIX.2\\(rq)";
		break;
	case(MDOC_p1387_2_95):
		p = "IEEE Std 1387.2-1995 (\\(lqPOSIX.7.2\\(rq)";
		break;
	case(MDOC_p1003_2):
		p = "IEEE Std 1003.2 (\\(lqPOSIX.2\\(rq)";
		break;
	case(MDOC_p1387_2):
		p = "IEEE Std 1387.2 (\\(lqPOSIX.7.2\\(rq)";
		break;
	case(MDOC_isoC_90):
		p = "ISO/IEC 9899:1990 (\\(lqISO C90\\(rq)";
		break;
	case(MDOC_isoC_amd1):
		p = "ISO/IEC 9899/AMD1:1995 (\\(lqISO C90\\(rq)";
		break;
	case(MDOC_isoC_tcor1):
		p = "ISO/IEC 9899/TCOR1:1994 (\\(lqISO C90\\(rq)";
		break;
	case(MDOC_isoC_tcor2):
		p = "ISO/IEC 9899/TCOR2:1995 (\\(lqISO C90\\(rq)";
		break;
	case(MDOC_isoC_99):
		p = "ISO/IEC 9899:1999 (\\(lqISO C99\\(rq)";
		break;
	case(MDOC_ansiC):
		p = "ANSI X3.159-1989 (\\(lqANSI C\\(rq)";
		break;
	case(MDOC_ansiC_89):
		p = "ANSI X3.159-1989 (\\(lqANSI C\\(rq)";
		break;
	case(MDOC_ansiC_99):
		p = "ANSI/ISO/IEC 9899-1999 (\\(lqANSI C99\\(rq)";
		break;
	case(MDOC_ieee754):
		p = "IEEE Std 754-1985";
		break;
	case(MDOC_iso8802_3):
		p = "ISO 8802-3: 1989";
		break;
	case(MDOC_xpg3):
		p = "X/Open Portability Guide Issue 3 "
			"(\\(lqXPG3\\(rq)";
		break;
	case(MDOC_xpg4):
		p = "X/Open Portability Guide Issue 4 "
			"(\\(lqXPG4\\(rq)";
		break;
	case(MDOC_xpg4_2):
		p = "X/Open Portability Guide Issue 4.2 "
			"(\\(lqXPG4.2\\(rq)";
		break;
	case(MDOC_xpg4_3):
		p = "X/Open Portability Guide Issue 4.3 "
			"(\\(lqXPG4.3\\(rq)";
		break;
	case(MDOC_xbd5):
		p = "X/Open System Interface Definitions Issue 5 "
			"(\\(lqXBD5\\(rq)";
		break;
	case(MDOC_xcu5):
		p = "X/Open Commands and Utilities Issue 5 "
			"(\\(lqXCU5\\(rq)";
		break;
	case(MDOC_xsh5):
		p = "X/Open System Interfaces and Headers Issue 5 "
			"(\\(lqXSH5\\(rq)";
		break;
	case(MDOC_xns5):
		p = "X/Open Networking Services Issue 5 "
			"(\\(lqXNS5\\(rq)";
		break;
	case(MDOC_xns5_2d2_0):
		p = "X/Open Networking Services Issue 5.2 Draft 2.0 "
			"(\\(lqXNS5.2D2.0\\(rq)";
		break;
	case(MDOC_xcurses4_2):
		p = "X/Open Curses Issue 4 Version 2 "
			"(\\(lqXCURSES4.2\\(rq)";
		break;
	case(MDOC_susv2):
		p = "Version 2 of the Single UNIX Specification";
		break;
	case(MDOC_susv3):
		p = "Version 3 of the Single UNIX Specification";
		break;
	case(MDOC_svid4):
		p = "System V Interface Definition, Fourth Edition "
			"(\\(lqSVID4\\(rq)";
		break;
	default:
		p = NULL;
		break;
	}

	return(p);
}


const char *
mdoc_att2a(enum mdoc_att c)
{
	char		*p;
	
	switch (c) {
	case(ATT_v1):
		p = "Version 1 AT&T UNIX";
		break;
	case(ATT_v2):
		p = "Version 2 AT&T UNIX";
		break;
	case(ATT_v3):
		p = "Version 3 AT&T UNIX";
		break;
	case(ATT_v4):
		p = "Version 4 AT&T UNIX";
		break;
	case(ATT_v5):
		p = "Version 5 AT&T UNIX";
		break;
	case(ATT_v6):
		p = "Version 6 AT&T UNIX";
		break;
	case(ATT_v7):
		p = "Version 7 AT&T UNIX";
		break;
	case(ATT_32v):
		p = "Version 32V AT&T UNIX";
		break;
	case(ATT_V):
		p = "AT&T System V UNIX";
		break;
	case(ATT_V1):
		p = "AT&T System V.1 UNIX";
		break;
	case(ATT_V2):
		p = "AT&T System V.2 UNIX";
		break;
	case(ATT_V3):
		p = "AT&T System V.3 UNIX";
		break;
	case(ATT_V4):
		p = "AT&T System V.4 UNIX";
		break;
	default:
		p = "AT&T UNIX";
		break;
	}

	return(p);
}


@


1.24
log
@Added new old escape sequence \*[nn].
Initial correct .Bd support (still only text in literal displays).
Symbols put into tables (character-encoding).
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.23 2009/03/02 12:09:32 kristaps Exp $ */
d65 1
a65 1
		if (0 == *++p || ! isgraph((int)*p))
d69 1
a69 1
			if (0 == *++p || ! isgraph((int)*p))
d74 1
a74 1
				if ( ! isgraph((int)*p))
d82 1
a82 1
		if (0 == *++p || ! isgraph((int)*p))
d84 1
a84 1
		if (0 == *++p || ! isgraph((int)*p))
d94 1
a94 1
		if ( ! isgraph((int)*p))
@


1.23
log
@Support for maxrmargin-breaking with TERMP_NOBREAK.
Tabs auto-converted to spaces.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.22 2009/02/27 10:55:16 kristaps Exp $ */
d72 5
@


1.22
log
@Slowly decoupling mdoc(3) from being OpenBSD-only.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.21 2009/02/27 08:20:15 kristaps Exp $ */
d361 2
d724 3
@


1.21
log
@More character-encoding.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.20 2009/02/26 16:08:11 kristaps Exp $ */
d475 1
a475 1
		return("OpenBSD Ancestral Manual Documents");
d477 1
a477 1
		return("OpenBSD Manual Master Index");
d479 1
a479 1
		return("OpenBSD Kernel Manual");
d481 1
a481 1
		return("OpenBSD Local Manual");
d483 1
a483 1
		return("OpenBSD Programmer's Manual");
d485 1
a485 1
		return("OpenBSD Programmer's Supplementary Documents");
d487 1
a487 1
		return("OpenBSD System Manager's Manual");
d489 1
a489 1
		return("OpenBSD Reference Manual");
d491 1
a491 1
		return("OpenBSD User's Supplementary Documents");
@


1.20
log
@Support for macro widths (/usr/share/tmac/mdoc/doc-common).
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.19 2009/02/25 12:32:50 kristaps Exp $ */
d64 12
@


1.19
log
@NetBSD Lintified.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.18 2009/02/24 14:52:55 kristaps Exp $ */
d407 1
a407 1
		return("AViion");
d729 94
@


1.18
log
@Added several more mdocterm outputs.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.17 2009/02/24 13:46:54 kristaps Exp $ */
d65 1
a65 1
		if (0 == *++p || ! isgraph(*p))
d67 1
a67 1
		if (0 == *++p || ! isgraph(*p))
d77 1
a77 1
		if ( ! isgraph(*p))
@


1.17
log
@Character-encoding checked for all text (arguments/values).
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.16 2009/02/24 11:43:13 kristaps Exp $ */
d542 187
@


1.16
log
@Escape-sequence validation in place (for nodes).
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.15 2009/02/23 15:34:53 kristaps Exp $ */
d58 2
d65 1
a65 1
		if (0 == *++p)
d67 1
a67 1
		if (0 == *++p)
d77 1
a77 1
		if (isspace(*p))
@


1.15
log
@Compiles fine on NetBSD now, too.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.14 2009/02/23 12:45:19 kristaps Exp $ */
d38 44
@


1.14
log
@More in-file documentation and Linux-isation.
Moved mdoc_macros table definition into macro.c, where it belongs.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.13 2009/02/21 21:00:06 kristaps Exp $ */
d24 1
a24 1
#ifdef __linux__
@


1.13
log
@Split mdocml -> mdocterm, mdoctree (new manuals, etc.).
Escape-recognition term.c.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.12 2009/02/20 23:35:36 kristaps Exp $ */
d24 1
a24 1
#ifndef __OpenBSD__
d28 4
@


1.12
log
@More flesh in terminal-encoder.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.11 2009/01/20 22:55:46 kristaps Exp $ */
d339 1
a339 1
char *
d407 1
a407 1
char *
d441 1
a441 1
char *
@


1.11
log
@Added regression tests (just for prologue, for now).
Minor fixes in parsing prologue.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.10 2009/01/20 13:49:36 kristaps Exp $ */
d337 155
@


1.10
log
@Lint- and NetBSD-compiler checks.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.9 2009/01/17 16:15:27 kristaps Exp $ */
d127 1
d131 3
a133 1
	if (0 == strptime(p, "%b %d %Y", &tm))
d135 4
a138 1
	if (0 == strptime(p, "%b %d, %Y", &tm))
@


1.9
log
@Documentation, more validations, cleaned up actions, added Nm action.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.8 2009/01/16 12:23:25 kristaps Exp $ */
d24 1
a24 1
#ifdef __linux__
@


1.8
log
@Clean-ups & documentation.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.7 2009/01/16 11:50:54 kristaps Exp $ */
d84 1
a84 1
mdoc_atosec(size_t sz, const char **p)
d87 2
a88 14
	assert(sz > 0);
	if (sz > 2)
		return(SEC_CUSTOM);
	if (sz == 2) {
		if (0 == strcmp(*p, "RETURN") &&
				0 == strcmp(*(p + 1), "VALUES"))
			return(SEC_RETURN_VALUES);
		if (0 == strcmp(*p, "SEE") &&
				0 == strcmp(*(p + 1), "ALSO"))
			return(SEC_SEE_ALSO);
		return(SEC_CUSTOM);
	}

	if (0 == strcmp(*p, "NAME"))
d90 5
a94 1
	else if (0 == strcmp(*p, "SYNOPSIS"))
d96 1
a96 1
	else if (0 == strcmp(*p, "DESCRIPTION"))
d98 1
a98 1
	else if (0 == strcmp(*p, "ENVIRONMENT"))
d100 1
a100 1
	else if (0 == strcmp(*p, "FILES"))
d102 1
a102 1
	else if (0 == strcmp(*p, "EXAMPLES"))
d104 1
a104 1
	else if (0 == strcmp(*p, "DIAGNOSTICS"))
d106 1
a106 1
	else if (0 == strcmp(*p, "ERRORS"))
d108 1
a108 1
	else if (0 == strcmp(*p, "STANDARDS"))
d110 1
a110 1
	else if (0 == strcmp(*p, "HISTORY"))
d112 1
a112 1
	else if (0 == strcmp(*p, "AUTHORS"))
d114 1
a114 1
	else if (0 == strcmp(*p, "CAVEATS"))
d116 1
a116 1
	else if (0 == strcmp(*p, "BUGS"))
@


1.7
log
@Finished re-fitting err/warn/msg routines.
Some minor bug-fixes.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.6 2009/01/14 11:58:24 kristaps Exp $ */
d138 1
a138 1
	if (strptime(p, "%b %d %Y", &tm))
d140 1
a140 1
	if (strptime(p, "%b %d, %Y", &tm))
d231 2
@


1.6
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.5 2009/01/06 15:49:44 kristaps Exp $ */
a38 2
	case('{'):
		/* FALLTHROUGH */
d59 2
@


1.5
log
@Memory leak, some mdoc(7) conformities.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.4 2008/12/29 18:08:44 kristaps Exp $ */
d310 27
@


1.4
log
@More macros.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.3 2008/12/28 00:34:20 kristaps Exp $ */
d136 2
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.2 2008/12/17 17:18:38 kristaps Exp $ */
d24 3
d30 4
d274 34
@


1.2
log
@Prologue Dd and Dt macros.
@
text
@d1 1
a1 1
/* $Id: strings.c,v 1.1 2008/12/15 03:13:01 kristaps Exp $ */
d28 1
a28 1
mdoc_isdelim(const char *p)
d31 1
a31 6
	if (0 == *p)
		return(0);
	if (0 != *(p + 1))
		return(0);

	switch (*p) {
d64 12
@


1.1
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: macro.c,v 1.3 2008/12/15 02:23:12 kristaps Exp $ */
d23 1
d68 192
@
