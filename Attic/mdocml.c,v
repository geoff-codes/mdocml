head	1.55;
access;
symbols
	VERSION_1_9_5:1.55
	VERSION_1_8_5:1.55
	VERSION_1_8_1:1.55
	VERSION_1_7_16:1.55
	VERSION_1_7_15:1.55
	OPENBSD_CHECKIN:1.55
	VERSION_1_6_5:1.55
	VERSION_1_5_1:1.55
	VERSION_1_3_15:1.55
	VERSION_1_3_6:1.55
	VERSION_1_2_0:1.50
	VERSION_1_1_0:1.43
	VERSION_1_0_2:1.19
	VERSION_1_0_1:1.17
	version_0_0:1.1.1.1
	version_0:1.1.1;
locks; strict;
comment	@ * @;


1.55
date	2009.02.21.21.00.06;	author kristaps;	state dead;
branches;
next	1.54;

1.54
date	2009.02.21.15.34.46;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.20.23.35.36;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.20.11.04.23;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.20.07.43.15;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.20.12.51.28;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.01.19.17.51.33;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.01.17.14.04.25;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.16.15.58.50;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.16.14.15.12;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.16.11.50.54;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.15.17.38.57;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.15.15.59.19;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.14.11.58.24;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.12.16.39.57;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.12.12.52.21;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.12.10.31.53;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.09.14.45.44;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.08.14.55.59;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.07.15.53.00;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.05.17.57.08;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.05.16.11.14;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.03.22.10.22;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.03.18.38.39;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.01.20.40.16;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.30.19.06.03;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.29.19.25.29;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.29.18.08.44;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.28.23.07.04;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.28.21.25.09;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.28.00.34.20;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.23.05.30.49;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.17.17.18.38;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.15.02.23.12;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.15.01.54.58;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.10.14.42.46;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.09.17.09.12;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.09.00.27.17;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.04.11.25.29;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.03.19.21.58;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.02.00.10.37;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.28.11.21.12;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.27.17.27.50;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.26.22.27.07;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.25.12.14.02;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.24.14.24.55;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.23.23.12.47;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.23.22.30.53;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.23.19.10.03;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.23.11.05.25;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.22.20.15.34;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.22.18.34.06;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.22.17.14.32;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.22.16.55.02;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.22.14.53.29;	author kristaps;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.11.22.14.53.29;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Split mdocml -> mdocterm, mdoctree (new manuals, etc.).
Escape-recognition term.c.
@
text
@@


1.54
log
@A few more macros in place.
@
text
@a0 385
	/* $Id: mdocml.c,v 1.53 2009/02/20 23:35:36 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/stat.h>
#include <sys/param.h>

#include <assert.h>
#include <fcntl.h>
#include <err.h>
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mdoc.h"

#define	MD_LINE_SZ	(256)		/* Max input line size. */

typedef	int		(*md_print)(const struct mdoc_node *,
				const struct mdoc_meta *);

struct	md_parse {
	int		  warn;		/* Warning flags. */
#define	MD_WARN_SYNTAX	 (1 << 0)	/* Show syntax warnings. */
#define	MD_WARN_COMPAT	 (1 << 1)	/* Show compat warnings. */
#define	MD_WARN_ALL	 (0x03)		/* Show all warnings. */
#define	MD_WARN_ERR	 (1 << 2)	/* Make warnings->errors. */
	int		  dbg;		/* Debug level. */
	struct mdoc	 *mdoc;		/* Active parser. */
	char		 *buf;		/* Input buffer. */
	u_long		  bufsz;	/* Input buffer size. */
	char		 *in;		/* Input file name. */
	int		  fdin;		/* Input file desc. */
	md_print	  fp;
};

extern	char	 	 *__progname;

static	void		  usage(void);

static	int		  parse_opts(struct md_parse *, int, char *[]);
static	int		  parse_subopts(struct md_parse *, char *);

static	int		  parse_begin(struct md_parse *);
static	int		  parse_leave(struct md_parse *, int);
static	int		  io_begin(struct md_parse *);
static	int		  io_leave(struct md_parse *, int);
static	int		  buf_begin(struct md_parse *);
static	int		  buf_leave(struct md_parse *, int);

static	void		  msg_msg(void *, int, int, const char *);
static	int		  msg_err(void *, int, int, const char *);
static	int		  msg_warn(void *, int, int, 
				enum mdoc_warn, const char *);

#ifdef __linux__
extern	int		  getsubopt(char **, char *const *, char **);
#endif

int
main(int argc, char *argv[])
{
	struct md_parse	 parser;

	(void)memset(&parser, 0, sizeof(struct md_parse));

	if ( ! parse_opts(&parser, argc, argv))
		return(EXIT_FAILURE);
	if ( ! io_begin(&parser))
		return(EXIT_FAILURE);

	return(EXIT_SUCCESS);
}


static int
io_leave(struct md_parse *p, int code)
{

	if (-1 == p->fdin || STDIN_FILENO == p->fdin)
		return(code);

	if (-1 == close(p->fdin)) {
		warn("%s", p->in);
		code = 0;
	}
	return(code);
}


static int
parse_subopts(struct md_parse *p, char *arg)
{
	char		*v;
	char		*toks[] = { "all", "compat", 
				"syntax", "error", NULL };

	/* 
	 * Future -Wxxx levels and so on should be here.  For now we
	 * only recognise syntax and compat warnings as categories,
	 * beyond the usually "all" and "error" (make warn error out).
	 */

	while (*arg) 
		switch (getsubopt(&arg, toks, &v)) {
		case (0):
			p->warn |= MD_WARN_ALL;
			break;
		case (1):
			p->warn |= MD_WARN_COMPAT;
			break;
		case (2):
			p->warn |= MD_WARN_SYNTAX;
			break;
		case (3):
			p->warn |= MD_WARN_ERR;
			break;
		default:
			usage();
			return(0);
		}

	return(1);
}


static int
parse_opts(struct md_parse *p, int argc, char *argv[])
{
	int		 c;

	extern char	*optarg;
	extern int	 optind;

	extern int termprint(const struct mdoc_node *, 
			const struct mdoc_meta *);
	extern int treeprint(const struct mdoc_node *, 
			const struct mdoc_meta *);

	p->in = "-";

	while (-1 != (c = getopt(argc, argv, "f:vW:")))
		switch (c) {
		case ('f'):
			if (0 == strcmp(optarg, "tree")) {
				p->fp = treeprint;
				break;
			} else if (0 == strcmp(optarg, "term")) {
				p->fp = termprint;
				break;
			}
			warnx("unknown filter: %s", optarg);
			return(0);
		case ('v'):
			p->dbg++;
			break;
		case ('W'):
			if ( ! parse_subopts(p, optarg))
				return(0);
			break;
		default:
			usage();
			return(0);
		}

	argv += optind;
	if (0 == (argc -= optind))
		return(1);

	p->in = *argv++;
	return(1);
}


static int
io_begin(struct md_parse *p)
{

	p->fdin = STDIN_FILENO;
	if (0 != strncmp(p->in, "-", 1))
		if (-1 == (p->fdin = open(p->in, O_RDONLY, 0))) {
			warn("%s", p->in);
			return(io_leave(p, 0));
		}

	return(io_leave(p, buf_begin(p)));
}


static int
buf_leave(struct md_parse *p, int code)
{

	if (p->buf)
		free(p->buf);
	return(code);
}


static int
buf_begin(struct md_parse *p)
{
	struct stat	 st;

	if (-1 == fstat(p->fdin, &st)) {
		warn("%s", p->in);
		return(0);
	} 

	/*
	 * Try to intuit the fastest way of sucking down buffered data
	 * by using either the block buffer size or the hard-coded one.
	 * This is inspired by bin/cat.c.
	 */

	p->bufsz = MAX(st.st_blksize, BUFSIZ);

	if (NULL == (p->buf = malloc(p->bufsz))) {
		warn("malloc");
		return(buf_leave(p, 0));
	}

	return(buf_leave(p, parse_begin(p)));
}


static int
parse_leave(struct md_parse *p, int code)
{
	md_print	 fp;

	if (NULL == p->mdoc)
		return(code);

	if ( ! mdoc_endparse(p->mdoc))
		code = 0;

	if (code && (fp = p->fp)) {
		if ( ! (*fp)(mdoc_node(p->mdoc), mdoc_meta(p->mdoc)))
			code = 0;
	}

	mdoc_free(p->mdoc);
	return(code);
}


static int
parse_begin(struct md_parse *p)
{
	ssize_t		 sz, i;
	size_t		 pos;
	char		 line[MD_LINE_SZ];
	struct mdoc_cb	 cb;
	int		 lnn;

	cb.mdoc_err = msg_err;
	cb.mdoc_warn = msg_warn;
	cb.mdoc_msg = msg_msg;

	if (NULL == (p->mdoc = mdoc_alloc(p, &cb)))
		return(parse_leave(p, 0));

	/*
	 * This is a little more complicated than fgets.  TODO: have
	 * some benchmarks that show it's faster (note that I want to
	 * check many, many manuals simultaneously, so speed is
	 * important).  Fill a buffer (sized to the block size) with a
	 * single read, then parse \n-terminated lines into a line
	 * buffer, which is passed to the parser.  Hard-code the line
	 * buffer to a particular size -- a reasonable assumption.
	 */

	for (lnn = 1, pos = 0; ; ) {
		if (-1 == (sz = read(p->fdin, p->buf, p->bufsz))) {
			warn("%s", p->in);
			return(parse_leave(p, 0));
		} else if (0 == sz) 
			break;

		for (i = 0; i < sz; i++) {
			if ('\n' != p->buf[i]) {
				if (pos < sizeof(line)) {
					line[(int)pos++] = p->buf[(int)i];
					continue;
				}
				warnx("%s: line %d too long", p->in, lnn);
				return(parse_leave(p, 0));
			}
	
			line[(int)pos] = 0;
			if ( ! mdoc_parseln(p->mdoc, lnn, line))
				return(parse_leave(p, 0));

			lnn++;
			pos = 0;
		}
	}

	return(parse_leave(p, 1));
}


static int
msg_err(void *arg, int line, int col, const char *msg)
{
	struct md_parse	 *p;

	p = (struct md_parse *)arg;

	warnx("%s:%d: error: %s (column %d)", 
			p->in, line, msg, col);
	return(0);
}


static void
msg_msg(void *arg, int line, int col, const char *msg)
{
	struct md_parse	 *p;

	p = (struct md_parse *)arg;

	if (0 == p->dbg)
		return;

	warnx("%s:%d: debug: %s (column %d)", 
			p->in, line, msg, col);
}


static int
msg_warn(void *arg, int line, int col, 
		enum mdoc_warn type, const char *msg)
{
	struct md_parse	 *p;

	p = (struct md_parse *)arg;

	switch (type) {
	case (WARN_COMPAT):
		if (p->warn & MD_WARN_COMPAT)
			break;
		return(1);
	case (WARN_SYNTAX):
		if (p->warn & MD_WARN_SYNTAX)
			break;
		return(1);
	}

	warnx("%s:%d: warning: %s (column %d)", 
			p->in, line, msg, col);

	if ( ! (p->warn & MD_WARN_ERR))
		return(1);

	warnx("%s: considering warnings as errors", __progname);
	return(0);
}


static void
usage(void)
{

	warnx("usage: %s [-ffilter] [-v] [-Wwarn...] [infile]", 
			__progname);
}

@


1.53
log
@More flesh in terminal-encoder.
@
text
@d1 1
a1 1
	/* $Id: mdocml.c,v 1.52 2009/02/20 11:04:23 kristaps Exp $ */
d35 3
d50 1
d151 5
d158 1
a158 1
	while (-1 != (c = getopt(argc, argv, "vW:")))
d160 10
d246 1
a246 4
	extern int termprint(const struct mdoc_node *, 
			const struct mdoc_meta *);
	/*extern int treeprint(const struct mdoc_node *, 
			const struct mdoc_meta *);*/
d254 4
a257 5
	/* TODO */
	if (code && ! termprint(mdoc_node(p->mdoc), mdoc_meta(p->mdoc)))
		code = 0;
	/*if (code && ! treeprint(mdoc_node(p->mdoc), mdoc_meta(p->mdoc)))
		code = 0;*/
d382 2
a383 1
	warnx("usage: %s [-v] [-Wwarn...] [infile]", __progname);
@


1.52
log
@Re-added tree.c (for now).
Added initial terminal-output filter (term.c).
@
text
@d1 1
a1 1
	/* $Id: mdocml.c,v 1.51 2009/02/20 07:43:15 kristaps Exp $ */
d229 2
d241 2
@


1.51
log
@Removed tree-writing capability (for now, only validates and exits).
@
text
@d1 1
a1 1
	/* $Id: mdocml.c,v 1.50 2009/01/20 12:51:28 kristaps Exp $ */
d227 2
a235 1
#if 0
d237 1
a237 2
	if (code && ! mdoc_write(p->out, mdoc_node(p->mdoc))) {
		warnx("%s: write error", p->out);
a238 2
	}
#endif
@


1.50
log
@Moved prologue-pruning into action.c.
Added line-arg softmax.
@
text
@d1 1
a1 1
	/* $Id: mdocml.c,v 1.49 2009/01/19 17:51:33 kristaps Exp $ */
a32 2
#define	xfprintf	(void)fprintf

a34 5
/* TODO: have a struct for each transformer. */

typedef	int		(*mdocprint)(const struct mdoc_node *);


d45 2
a46 3
	char		 *name;		/* Input file name. */
	int		  fd;		/* Input file desc. */
	mdocprint	  print;	/* Node-print function. */
d51 1
a51 1
extern	int		  treeprint(const struct mdoc_node *);
d53 2
a54 1
static	void		  usage(void);
a74 1
	int		 c;
a75 12
	char		*opts, *v, *filter;
#define ALL     	 0
#define COMPAT     	 1
#define SYNTAX     	 2
#define ERROR     	 3
	char		*toks[] = { "all", "compat", "syntax", 
				    "error", NULL };

	extern char	*optarg;
	extern int	 optind;

	filter = NULL;
d79 2
a80 46
	while (-1 != (c = getopt(argc, argv, "f:vW:")))
		switch (c) {
		case ('f'):
			filter = optarg;
			break;
		case ('v'):
			parser.dbg++;
			break;
		case ('W'):
			opts = optarg;
			while (*opts) 
				switch (getsubopt(&opts, toks, &v)) {
				case (ALL):
					parser.warn |= MD_WARN_ALL;
					break;
				case (COMPAT):
					parser.warn |= MD_WARN_COMPAT;
					break;
				case (SYNTAX):
					parser.warn |= MD_WARN_SYNTAX;
					break;
				case (ERROR):
					parser.warn |= MD_WARN_ERR;
					break;
				default:
					usage();
					return(1);
				}
			break;
		default:
			usage();
			return(1);
		}

	argv += optind;
	argc -= optind;

	parser.name = "-";
	if (1 == argc)
		parser.name = *argv++;

	if (filter) {
		if (0 == strcmp(filter, "tree"))
			parser.print = treeprint;
	}

d92 1
a92 1
	if (-1 == p->fd || STDIN_FILENO == p->fd)
d95 2
a96 2
	if (-1 == close(p->fd)) {
		warn("%s", p->name);
d104 69
d176 4
a179 4
	p->fd = STDIN_FILENO;
	if (0 != strncmp(p->name, "-", 1))
		if (-1 == (p->fd = open(p->name, O_RDONLY, 0))) {
			warn("%s", p->name);
d202 3
a204 3
	if (-1 == fstat(p->fd, &st)) {
		warn("%s", p->name);
		return(1);
d207 6
a226 1
	const struct mdoc_node *n;
d233 8
a240 2
	if (p->print && (n = mdoc_node(p->mdoc)))
		(*p->print)(n);
a242 1

d263 10
d274 2
a275 2
		if (-1 == (sz = read(p->fd, p->buf, p->bufsz))) {
			warn("%s", p->name);
d286 1
a286 2
				warnx("%s: line %d too long", 
						p->name, lnn);
d310 2
a311 2
	xfprintf(stderr, "%s:%d: error: %s (column %d)\n", 
			p->name, line, msg, col);
d326 2
a327 2
	xfprintf(stderr, "%s:%d: debug: %s (column %d)\n", 
			p->name, line, msg, col);
d350 2
a351 2
	xfprintf(stderr, "%s:%d: warning: %s (column %d)\n", 
			p->name, line, msg, col);
d356 1
a356 2
	xfprintf(stderr, "%s: considering warnings as errors\n", 
			__progname);
d365 1
a365 2
	xfprintf(stderr, "usage: %s [-v] [-Wwarn...] [-ffilter] "
			"[infile]\n", __progname);
@


1.49
log
@More correct validation.
Elision of prologue macros from main tree.
@
text
@d1 1
a1 1
	/* $Id: mdocml.c,v 1.48 2009/01/17 14:04:25 kristaps Exp $ */
d37 1
a37 13
/*
 * Put this into a mdoctrans.h, which has:
 *
 * struct mdoc_trans; (opaque)
 *
 * struct mdoc_trans *mdoc_trans_alloc(const char *filter);
 *
 * mdoc_trans_free(struct mdoc_trans *);
 *
 * int mdoc_trans_getopt(struct mdoc_trans *, char *);
 *
 * int mdoc_trans_print(struct mdoc_trans *, const struct mdoc_node *);
 */
@


1.48
log
@Separating output filters.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.47 2009/01/16 15:58:50 kristaps Exp $ */
d235 1
a235 1
	if (p->print && (n = mdoc_result(p->mdoc)))
@


1.47
log
@Initial separation of tree/mdocml.1.
Finished mdoc.3.
Broken build: mdocml.c.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.46 2009/01/16 14:15:12 kristaps Exp $ */
a33 2
#define	xprintf		(void)printf
#define	xvfprintf	(void)fvprintf
d37 16
d66 1
a66 1
	int		(*fp)(const struct mdoc_node *, const char *);
d71 1
a71 1
extern	int		 
d96 1
a96 1
	char		*opts, *v, *filter, *output;
d107 1
a107 1
	output = filter = NULL;
d111 1
a111 1
	while (-1 != (c = getopt(argc, argv, "f:vW:o:")))
a115 3
		case ('o'):
			output = optarg;
			break;
d152 5
d235 2
a236 2
	if (p->fp && (n = mdoc_result(p->mdoc)))
		(*p->fp)(n, NULL);
d355 1
a355 1
			"[-o outfile] [infile]\n", __progname);
@


1.46
log
@Boolean validation.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.45 2009/01/16 11:50:54 kristaps Exp $ */
d39 1
d41 12
a52 11
	int		 warn;		/* Warning flags. */
#define	MD_WARN_SYNTAX	(1 << 0)	/* Show syntax warnings. */
#define	MD_WARN_COMPAT	(1 << 1)	/* Show compat warnings. */
#define	MD_WARN_ALL	(0x03)		/* Show all warnings. */
#define	MD_WARN_ERR	(1 << 2)	/* Make warnings->errors. */
	int		 dbg;		/* Debug level. */
	struct mdoc	*mdoc;		/* Active parser. */
	char		*buf;		/* Input buffer. */
	u_long		 bufsz;		/* Input buffer size. */
	char		*name;		/* Input file name. */
	int		 fd;		/* Input file desc. */
d55 3
a57 1
extern	char	 	*__progname;
d59 1
a59 1
static	void		 usage(void);
d61 10
a70 10
static	int		 parse_begin(struct md_parse *);
static	int		 parse_leave(struct md_parse *, int);
static	int		 io_begin(struct md_parse *);
static	int		 io_leave(struct md_parse *, int);
static	int		 buf_begin(struct md_parse *);
static	int		 buf_leave(struct md_parse *, int);

static	void		 msg_msg(void *, int, int, const char *);
static	int		 msg_err(void *, int, int, const char *);
static	int		 msg_warn(void *, int, int, 
d74 1
a74 1
extern	int		 getsubopt(char **, char *const *, char **);
d82 1
a82 1
	char		*opts, *v;
d93 2
d97 1
a97 1
	while (-1 != (c = getopt(argc, argv, "vW:")))
d99 6
a208 73
/* TODO: remove this to a print-tree output filter. */
static void
print_node(const struct mdoc_node *n, int indent)
{
	const char	 *p, *t;
	int		  i, j;
	size_t		  argc, sz;
	char		**params;
	struct mdoc_arg	 *argv;

	argv = NULL;
	argc = sz = 0;
	params = NULL;

	t = mdoc_type2a(n->type);

	switch (n->type) {
	case (MDOC_TEXT):
		p = n->data.text.string;
		break;
	case (MDOC_BODY):
		p = mdoc_macronames[n->tok];
		break;
	case (MDOC_HEAD):
		p = mdoc_macronames[n->tok];
		break;
	case (MDOC_TAIL):
		p = mdoc_macronames[n->tok];
		break;
	case (MDOC_ELEM):
		p = mdoc_macronames[n->tok];
		argv = n->data.elem.argv;
		argc = n->data.elem.argc;
		break;
	case (MDOC_BLOCK):
		p = mdoc_macronames[n->tok];
		argv = n->data.block.argv;
		argc = n->data.block.argc;
		break;
	case (MDOC_ROOT):
		p = "root";
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	for (i = 0; i < indent; i++)
		xprintf("    ");
	xprintf("%s (%s)", p, t);

	for (i = 0; i < (int)argc; i++) {
		xprintf(" -%s", mdoc_argnames[argv[i].arg]);
		if (argv[i].sz > 0)
			xprintf(" [");
		for (j = 0; j < (int)argv[i].sz; j++)
			xprintf(" [%s]", argv[i].value[j]);
		if (argv[i].sz > 0)
			xprintf(" ]");
	}

	for (i = 0; i < (int)sz; i++)
		xprintf(" [%s]", params[i]);

	xprintf(" %d:%d\n", n->line, n->pos);

	if (n->child)
		print_node(n->child, indent + 1);
	if (n->next)
		print_node(n->next, indent);
}


d219 2
a220 2
	if ((n = mdoc_result(p->mdoc)))
		print_node(n, 0);
d338 2
a339 2
	xfprintf(stderr, "usage: %s [-v] [-Wwarn...] [infile]\n",
			__progname);
@


1.45
log
@Finished re-fitting err/warn/msg routines.
Some minor bug-fixes.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.44 2009/01/15 17:38:57 kristaps Exp $ */
d197 1
@


1.44
log
@Broken build (changing err/warn/msg function prototypes for clarity).
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.43 2009/01/15 15:59:19 kristaps Exp $ */
d342 1
a342 1
	xfprintf(stderr, "%s:%d: error: %s (column %d)", 
d358 1
a358 1
	xfprintf(stderr, "%s:%d: debug: %s (column %d)", 
@


1.43
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.42 2009/01/14 11:58:24 kristaps Exp $ */
d33 5
a37 1
#define	MD_LINE_SZ	(256)
d40 11
a50 9
	int		 warn;
#define	MD_WARN_ALL	(1 << 0)
#define	MD_WARN_ERR	(1 << 1)
	int		 dbg;
	struct mdoc	*mdoc;
	char		*buf;
	u_long		 bufsz;
	char		*name;
	int		 fd;
d53 2
a63 2
static	int		 msg_err(void *, int, int, enum mdoc_err);
static	int		 msg_warn(void *, int, int, enum mdoc_warn);
d65 3
d80 5
a84 2
#define ERROR     	 1
	char		*toks[] = { "all", "error", NULL };
d103 6
d207 1
a207 1
	argc = 0;
a208 1
	sz = 0;
a213 1
		assert(NULL == n->child);
d244 2
a245 2
		(void)printf("    ");
	(void)printf("%s (%s)", p, t);
d248 1
a248 1
		(void)printf(" -%s", mdoc_argnames[argv[i].arg]);
d250 1
a250 1
			(void)printf(" [");
d252 1
a252 1
			(void)printf(" [%s]", argv[i].value[j]);
d254 1
a254 1
			(void)printf(" ]");
d258 1
a258 1
		(void)printf(" [%s]", params[i]);
d260 1
a260 1
	(void)printf(" %d:%d\n", n->line, n->pos);
d293 1
a293 1
	char		 line[256], sv[256];
d314 1
a314 3
					sv[(int)pos] = p->buf[(int)i];
					line[(int)pos++] = 
						p->buf[(int)i];
d322 1
a322 1
			line[(int)pos] = sv[(int)pos] = 0;
d336 1
a336 1
msg_err(void *arg, int line, int col, enum mdoc_err type)
a337 1
	char		 *lit;
d342 2
a343 109
	lit = NULL;

	switch (type) {
	case (ERR_SYNTAX_NOTEXT):
		lit = "syntax: context-free text disallowed";
		break;
	case (ERR_SYNTAX_QUOTE):
		lit = "syntax: disallowed argument quotation";
		break;
	case (ERR_SYNTAX_UNQUOTE):
		lit = "syntax: unterminated quotation";
		break;
	case (ERR_SYNTAX_WS):
		lit = "syntax: whitespace in argument";
		break;
	case (ERR_SYNTAX_ARGFORM):
		lit = "syntax: macro arguments malformed";
		break;
	case (ERR_SYNTAX_NOPUNCT):
		lit = "syntax: macro doesn't understand punctuation";
		break;
	case (ERR_SYNTAX_ARG):
		lit = "syntax: unknown argument for macro";
		break;
	case (ERR_SCOPE_BREAK):
		lit = "scope: macro breaks prior scope";
		break;
	case (ERR_SCOPE_NOCTX):
		lit = "scope: closure macro has no context";
		break;
	case (ERR_SCOPE_NONEST):
		lit = "scope: macro may not be nested in the current context";
		break;
	case (ERR_MACRO_NOTSUP):
		lit = "macro not supported";
		break;
	case (ERR_MACRO_NOTCALL):
		lit = "macro not callable";
		break;
	case (ERR_SEC_PROLOGUE):
		lit = "macro cannot be called in the prologue";
		break;
	case (ERR_SEC_NPROLOGUE):
		lit = "macro called outside of prologue";
		break;
	case (ERR_ARGS_EQ0):
		lit = "macro expects zero arguments";
		break;
	case (ERR_ARGS_EQ1):
		lit = "macro expects one argument";
		break;
	case (ERR_ARGS_GE1):
		lit = "macro expects one or more arguments";
		break;
	case (ERR_ARGS_LE2):
		lit = "macro expects two or fewer arguments";
		break;
	case (ERR_ARGS_LE8):
		lit = "macro expects eight or fewer arguments";
		break;
	case (ERR_ARGS_MANY):
		lit = "macro has too many arguments";
		break;
	case (ERR_SEC_PROLOGUE_OO):
		lit = "prologue macro is out-of-order";
		break;
	case (ERR_SEC_PROLOGUE_REP):
		lit = "prologue macro repeated";
		break;
	case (ERR_SEC_NAME):
		lit = "`NAME' section must be first";
		break;
	case (ERR_SYNTAX_ARGVAL):
		lit = "syntax: expected value for macro argument";
		break;
	case (ERR_SYNTAX_ARGBAD):
		lit = "syntax: invalid value(s) for macro argument";
		break;
	case (ERR_SYNTAX_ARGMISS):
		lit = "syntax: missing required argument(s) for macro";
		break;
	case (ERR_SYNTAX_ARGMANY):
		lit = "syntax: too many values for macro argument";
		break;
	case (ERR_SYNTAX_CHILDBAD):
		lit = "syntax: invalid child for parent macro";
		break;
	case (ERR_SYNTAX_PARENTBAD):
		lit = "syntax: invalid parent for macro";
		break;
	case (ERR_SYNTAX_CHILDHEAD):
		lit = "syntax: expected only block-header section";
		break;
	case (ERR_SYNTAX_CHILDBODY):
		lit = "syntax: expected only a block-body section";
		break;
	case (ERR_SYNTAX_EMPTYHEAD):
		lit = "syntax: block-header section may not be empty";
		break;
	case (ERR_SYNTAX_EMPTYBODY):
		lit = "syntax: block-body section may not be empty";
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	(void)fprintf(stderr, "%s:%d: error: %s (column %d)\n", 
			p->name, line, lit, col);
d355 1
a355 1
	if (p->dbg < 2)
d358 1
a358 1
	(void)printf("%s:%d: %s (column %d)\n", 
d364 2
a365 1
msg_warn(void *arg, int line, int col, enum mdoc_warn type)
a366 1
	char		 *lit;
a367 1
	extern char	 *__progname;
d371 8
a378 1
	if ( ! (p->warn & MD_WARN_ALL))
a379 52

	lit = NULL;

	switch (type) {
	case (WARN_SYNTAX_WS_EOLN):
		lit = "syntax: whitespace at end-of-line";
		break;
	case (WARN_SYNTAX_QUOTED):
		lit = "syntax: quotation mark starting string";
		break;
	case (WARN_SYNTAX_MACLIKE):
		lit = "syntax: macro-like argument";
		break;
	case (WARN_SYNTAX_ARGLIKE):
		lit = "syntax: argument-like value";
		break;
	case (WARN_SYNTAX_EMPTYBODY):
		lit = "syntax: macro suggests non-empty block-body section";
		break;
	case (WARN_SYNTAX_EMPTYHEAD):
		lit = "syntax: macro suggests non-empty block-head section";
		break;
	case (WARN_SYNTAX_NOBODY):
		lit = "syntax: macro suggests empty block-body section";
		break;
	case (WARN_SEC_OO):
		lit = "section is out of conventional order";
		break;
	case (WARN_SEC_REP):
		lit = "section repeated";
		break;
	case (WARN_ARGS_GE1):
		lit = "macro suggests one or more arguments";
		break;
	case (WARN_ARGS_EQ0):
		lit = "macro suggests zero arguments";
		break;
	case (WARN_IGN_AFTER_BLK):
		lit = "ignore: macro ignored after block macro";
		break;
	case (WARN_IGN_OBSOLETE):
		lit = "ignore: macro is obsolete";
		break;
	case (WARN_IGN_BEFORE_BLK):
		lit = "ignore: macro before block macro ignored";
		break;
	case (WARN_COMPAT_TROFF):
		lit = "compat: macro behaves differently in troff and nroff";
		break;
	default:
		abort();
		/* NOTREACHED */
d382 2
d385 2
a386 2
	(void)fprintf(stderr, "%s:%d: warning: %s (column %d)\n", 
			p->name, line, lit, col);
d388 3
a390 7
	if (p->warn & MD_WARN_ERR) {
		(void)fprintf(stderr, "%s: considering warnings as "
				"errors\n", __progname);
		return(0);
	}

	return(1);
a396 1
	extern char	*__progname;
d398 1
a398 1
	(void)fprintf(stderr, "usage: %s [-v] [-Wwarn...] [infile]\n",
@


1.42
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.41 2009/01/12 16:39:57 kristaps Exp $ */
a44 2
	int		 lnn;
	char		*line;
d279 1
d288 1
a288 4
	p->lnn = 1;
	p->line = sv;

	for (pos = 0; ; ) {
d304 1
a304 1
						p->name, p->lnn);
d309 1
a309 1
			if ( ! mdoc_parseln(p->mdoc, p->lnn, line))
d312 1
a312 1
			p->lnn++;
@


1.41
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.40 2009/01/12 12:52:21 kristaps Exp $ */
d195 2
a196 1
	/* FIXME: put parts of this in util.c. */
a200 1
		t = "text";
a203 1
		t = "block-body";
a206 1
		t = "block-head";
a209 1
		t = "block-tail";
a212 1
		t = "element";
a217 1
		t = "block";
a222 1
		t = "root";
d235 1
a235 1
		if (j > 0)
d239 1
a239 1
		if (j > 0)
d358 1
a358 2
		/* Which scope is broken? */
		lit = "scope: macro breaks prior explicit scope";
@


1.40
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.39 2009/01/12 10:31:53 kristaps Exp $ */
d241 2
d244 3
a246 1
			(void)printf(" \"%s\"", argv[i].value[j]);
d250 1
a250 1
		(void)printf(" \"%s\"", params[i]);
@


1.39
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.38 2009/01/09 14:45:44 kristaps Exp $ */
d195 1
d203 1
a203 1
		p = mdoc_macronames[n->data.body.tok];
d207 1
a207 1
		p = mdoc_macronames[n->data.head.tok];
d211 1
a211 1
		p = mdoc_macronames[n->data.tail.tok];
d215 1
a215 1
		p = mdoc_macronames[n->data.elem.tok];
d221 1
a221 1
		p = mdoc_macronames[n->data.block.tok];
d423 3
d492 7
a498 1
		lit = "syntax: empty block-body section";
@


1.38
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.37 2009/01/08 14:55:59 kristaps Exp $ */
d247 1
a247 1
	(void)printf("\n");
a330 1
	int		  i;
d411 4
a414 1
		lit = "syntax: invalid value for macro argument";
d419 3
d439 2
a440 12
	(void)fprintf(stderr, "%s:%d: error: %s", p->name, p->lnn, lit);

	if (p->dbg < 1) {
		(void)fprintf(stderr, " (column %d)\n", col);
		return(0);
	} 

	(void)fprintf(stderr, "\nFrom: %s\n      ", p->line);
	for (i = 0; i < col; i++)
		(void)fprintf(stderr, " ");
	(void)fprintf(stderr, "^\n");

a448 1
	int		  i;
d455 2
a456 11
	(void)printf("%s:%d: %s", p->name, line, msg);

	if (p->dbg < 3) {
		(void)printf(" (column %d)\n", col);
		return;
	}

	(void)printf("\nFrom: %s\n      ", p->line);
	for (i = 0; i < col; i++)
		(void)printf(" ");
	(void)printf("^\n");
a464 1
	int		  i;
d520 2
a521 9
	(void)fprintf(stderr, "%s:%d: warning: %s", p->name, line, lit);

	if (p->dbg >= 1) {
		(void)fprintf(stderr, "\nFrom: %s\n      ", p->line);
		for (i = 0; i < col; i++)
			(void)fprintf(stderr, " ");
		(void)fprintf(stderr, "^\n");
	} else 
		(void)fprintf(stderr, " (column %d)\n", col);
@


1.37
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.36 2009/01/07 15:53:00 kristaps Exp $ */
d225 4
d269 2
d509 3
@


1.36
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.35 2009/01/05 17:57:08 kristaps Exp $ */
d60 1
a60 1
static	void		 msg_msg(void *, int, const char *);
d321 1
a321 1
msg_err(void *arg, int tok, int col, enum mdoc_err type)
d323 1
a323 1
	char		 *fmt, *lit;
d329 1
a329 1
	fmt = lit = NULL;
d345 1
a345 1
		fmt = "syntax: macro `%s' arguments malformed";
d348 1
a348 1
		fmt = "syntax: macro `%s' doesn't understand punctuation";
d351 1
a351 1
		fmt = "syntax: unknown argument for macro `%s'";
d355 1
a355 1
		fmt = "scope: macro `%s' breaks prior explicit scope";
d358 1
a358 1
		fmt = "scope: closure macro `%s' has no context";
d361 1
a361 1
		fmt = "scope: macro `%s' may not be nested in the current context";
d367 1
a367 1
		fmt = "macro `%s' not callable";
d370 1
a370 1
		fmt = "macro `%s' cannot be called in the prologue";
d373 1
a373 1
		fmt = "macro `%s' called outside of prologue";
d376 1
a376 1
		fmt = "macro `%s' expects zero arguments";
d379 1
a379 1
		fmt = "macro `%s' expects one argument";
d382 1
a382 1
		fmt = "macro `%s' expects one or more arguments";
d385 1
a385 1
		fmt = "macro `%s' expects two or fewer arguments";
d388 1
a388 1
		fmt = "macro `%s' expects eight or fewer arguments";
d391 1
a391 1
		fmt = "macro `%s' has too many arguments";
d394 1
a394 1
		fmt = "prologue macro `%s' is out-of-order";
d397 1
a397 1
		fmt = "prologue macro `%s' repeated";
d428 1
a428 7
	if (fmt) {
		(void)fprintf(stderr, "%s:%d: error: ",
				p->name, p->lnn);
		(void)fprintf(stderr, fmt, mdoc_macronames[tok]);
	} else
		(void)fprintf(stderr, "%s:%d: error: %s",
				p->name, p->lnn, lit);
d431 1
a431 2
		if (-1 != col)
			(void)fprintf(stderr, " (column %d)\n", col);
d433 1
a433 4
	} else if (-1 == col) {
		(void)fprintf(stderr, "\nFrom: %s\n", p->line);
		return(0);
	}
d445 1
a445 1
msg_msg(void *arg, int col, const char *msg)
d455 1
a455 1
	(void)printf("%s:%d: %s", p->name, p->lnn, msg);
d458 1
a458 5
		if (-1 != col)
			(void)printf(" (column %d)\n", col);
		return;
	} else if (-1 == col) {
		(void)printf("\nFrom %s\n", p->line);
d470 1
a470 1
msg_warn(void *arg, int tok, int col, enum mdoc_warn type)
d472 1
a472 1
	char		 *fmt, *lit;
d482 1
a482 1
	fmt = lit = NULL;
d504 1
a504 1
		fmt = "macro `%s' suggests one or more arguments";
d507 1
a507 1
		fmt = "macro `%s' suggests zero arguments";
d510 1
a510 1
		fmt = "ignore: macro `%s' ignored after block macro";
d513 1
a513 1
		fmt = "ignore: macro `%s' is obsolete";
d516 1
a516 1
		fmt = "ignore: macro before block macro `%s' ignored";
d519 1
a519 1
		fmt = "compat: macro `%s' behaves differently in troff and nroff";
a525 7
	if (fmt) {
		(void)fprintf(stderr, "%s:%d: warning: ",
				p->name, p->lnn);
		(void)fprintf(stderr, fmt, mdoc_macronames[tok]);
	} else
		(void)fprintf(stderr, "%s:%d: warning: %s",
				p->name, p->lnn, lit);
d527 3
a529 1
	if (col >= 0 && p->dbg >= 1) {
d534 1
a534 1
	} else if (col >= 0)
a535 2
	else 
		(void)fprintf(stderr, "\n");
@


1.35
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.34 2009/01/05 16:11:14 kristaps Exp $ */
a217 2
		params = n->data.elem.args;
		sz = n->data.elem.sz;
d257 8
a264 5
	if (p->mdoc) {
		if ((n = mdoc_result(p->mdoc)))
			print_node(n, 0);
		mdoc_free(p->mdoc);
	}
d308 1
a308 1
			if ( ! mdoc_parseln(p->mdoc, line))
d387 3
d441 1
a441 1
		(void)fprintf(stderr, "\nFrom: %s", p->line);
d548 1
a548 1
	if (p->dbg >= 1) {
d553 1
a553 1
	} else
d555 2
@


1.34
log
@Finished initial parse sequence.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.33 2009/01/03 22:10:22 kristaps Exp $ */
d331 3
d363 1
a363 1
		fmt = "macro `%s' not supported";
@


1.33
log
@Huge changes.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.32 2009/01/03 18:38:39 kristaps Exp $ */
d209 4
@


1.32
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.31 2009/01/01 20:40:16 kristaps Exp $ */
a209 1
		assert(NULL == n->child);
@


1.31
log
@Broke apart macro_prologuexxx into prologue.
Fixed validation for line-scoped.
Merged const_arg and const.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.30 2008/12/30 19:06:03 kristaps Exp $ */
d401 11
a411 2
	case (ERR_CHILD_HEAD):
		lit = "scope context expects block-header child";
d501 3
@


1.30
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.29 2008/12/29 19:25:29 kristaps Exp $ */
a207 2
		params = n->data.head.args;
		sz = n->data.head.sz;
d401 3
@


1.29
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.28 2008/12/29 18:08:44 kristaps Exp $ */
d503 3
@


1.28
log
@More macros.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.27 2008/12/28 23:07:04 kristaps Exp $ */
d373 3
@


1.27
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.26 2008/12/28 21:25:09 kristaps Exp $ */
d342 3
d370 3
d376 3
@


1.26
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.25 2008/12/28 00:34:20 kristaps Exp $ */
d494 3
@


1.25
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.24 2008/12/23 05:30:49 kristaps Exp $ */
d184 5
a188 4
	const char	*p, *t;
	int		 i, j;
	size_t		 argc;
	struct mdoc_arg	*argv;
d192 2
d208 2
d217 2
d241 3
d353 1
a353 1
		fmt = "scope: macro `%s' may not be nested";
@


1.24
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.23 2008/12/17 17:18:38 kristaps Exp $ */
d195 1
a195 1
		p = "<text>";
d329 1
a329 1
	case (ERR_SYNTAX_ARGS):
d332 1
a332 1
	case (ERR_SYNTAX_BADARG):
d342 3
d375 3
d460 3
d475 9
@


1.23
log
@Prologue Dd and Dt macros.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.22 2008/12/15 02:23:12 kristaps Exp $ */
d185 6
a190 1
	int		 i;
d210 2
d216 2
d226 9
a234 1
	(void)printf("%s (%s)\n", p, t);
d321 3
d332 3
d337 4
a340 1
		fmt = "macro `%s' breaks prior explicit scope";
d369 6
d457 3
@


1.22
log
@Linted.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.21 2008/12/15 01:54:58 kristaps Exp $ */
d268 3
a270 3
					/* LINTED */
					sv[pos] = p->buf[i];
					line[pos++] = p->buf[i];
d309 3
d322 6
d331 12
d357 5
a361 1
		(void)fprintf(stderr, " (column %d)\n", col);
d388 5
a392 1
		(void)printf(" (column %d)\n", col);
d425 3
@


1.21
log
@Purged all old files in favour of new design.  Selective reintegration.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.20 2008/12/10 14:42:46 kristaps Exp $ */
d210 3
@


1.20
log
@Made noop the default filter.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.19 2008/12/09 17:09:12 kristaps Exp $ */
d19 1
a20 1
#include <sys/stat.h>
d23 1
a24 1
#include <fcntl.h>
d31 1
a31 1
#include "libmdocml.h"
d33 1
a33 2
#define	BUFFER_IN_DEF	BUFSIZ	 /* See begin_bufs. */
#define	BUFFER_OUT_DEF	BUFSIZ	 /* See begin_bufs. */
d35 13
a47 5
#ifdef	DEBUG
#define	CSS		"mdocml.css"
#else
#define	CSS		"/usr/local/share/mdocml/mdocml.css"
#endif
d51 10
a60 8
static	int		 begin_io(const struct md_args *, 
				char *, char *);
static	int		 leave_io(const struct md_buf *, 
				const struct md_buf *, int);
static	int		 begin_bufs(const struct md_args *,
				struct md_buf *, struct md_buf *);
static int		 leave_bufs(const struct md_buf *, 
				const struct md_buf *, int);
d70 2
a71 2
	char		*out, *in, *opts, *v;
	struct md_args	 args;
d79 1
a79 3
	out = in = NULL;

	(void)memset(&args, 0, sizeof(struct md_args));
d81 1
a81 3
	args.type = MD_NOOP;

	while (-1 != (c = getopt(argc, argv, "c:ef:o:vW:")))
a82 23
		case ('c'):
			if (args.type != MD_HTML)
				errx(1, "-c only valid for -fhtml");
			args.params.html.css = optarg;
			break;
		case ('e'):
			if (args.type != MD_HTML)
				errx(1, "-e only valid for -fhtml");
			args.params.html.flags |= HTML_CSS_EMBED;
			break;
		case ('f'):
			if (0 == strcmp(optarg, "html"))
				args.type = MD_HTML;
			else if (0 == strcmp(optarg, "xml"))
				args.type = MD_XML;
			else if (0 == strcmp(optarg, "noop"))
				args.type = MD_NOOP;
			else
				errx(1, "invalid filter type");
			break;
		case ('o'):
			out = optarg;
			break;
d84 1
a84 1
			args.verbosity++;
d91 1
a91 1
					args.warnings |= MD_WARN_ALL;
d94 1
a94 1
					args.warnings |= MD_WARN_ERROR;
a105 4
	if (MD_HTML == args.type)
		if (NULL == args.params.html.css) 
			args.params.html.css = CSS;

d109 1
d111 4
a114 1
		in = *argv++;
d116 1
a116 1
	return(begin_io(&args, out ? out : "-", in ? in : "-"));
a119 4
/* 
 * Close out file descriptors opened in begin_io.  If the descriptor
 * refers to stdin/stdout, then do nothing.
 */
d121 1
a121 2
leave_io(const struct md_buf *out, 
		const struct md_buf *in, int c)
a122 2
	assert(out);
	assert(in);
d124 6
a129 4
	if (-1 != in->fd && -1 == close(in->fd)) {
		assert(in->name);
		warn("%s", in->name);
		c = 1;
d131 14
a144 9
	if (-1 != out->fd && STDOUT_FILENO != out->fd &&
			-1 == close(out->fd)) {
		assert(out->name);
		warn("%s", out->name);
		c = 1;
	}
	if (1 == c && STDOUT_FILENO != out->fd)
		if (-1 == unlink(out->name))
			warn("%s", out->name);
d146 1
a146 1
	return(c);
a149 4
/*
 * Open file descriptors or assign stdin/stdout, if dictated by the "-"
 * token instead of a filename.
 */
d151 1
a151 1
begin_io(const struct md_args *args, char *out, char *in)
a152 2
	struct md_buf	 fi;
	struct md_buf	 fo;
d154 4
a157 2
#define	FI_FL	O_RDONLY
#define	FO_FL	O_WRONLY|O_CREAT|O_TRUNC
a158 3
	assert(args);
	assert(out);
	assert(in);
d160 4
a163 2
	bzero(&fi, sizeof(struct md_buf));
	bzero(&fo, sizeof(struct md_buf));
d165 56
a220 2
	fi.fd = STDIN_FILENO;
	fo.fd = STDOUT_FILENO;
a221 2
	fi.name = in;
	fo.name = out;
d223 55
a277 5
	if (0 != strncmp(fi.name, "-", 1))
		if (-1 == (fi.fd = open(fi.name, FI_FL, 0))) {
			warn("%s", fi.name);
			return(leave_io(&fo, &fi, 1));
		}
d279 2
a280 4
	if (0 != strncmp(fo.name, "-", 1)) 
		if (-1 == (fo.fd = open(fo.name, FO_FL, 0644))) {
			warn("%s", fo.name);
			return(leave_io(&fo, &fi, 1));
d282 1
d284 1
a284 1
	return(leave_io(&fo, &fi, begin_bufs(args, &fo, &fi)));
a287 3
/*
 * Free buffers allocated in begin_bufs.
 */
d289 59
a347 2
leave_bufs(const struct md_buf *out, 
		const struct md_buf *in, int c)
d349 19
a367 7
	assert(out);
	assert(in);
	if (out->buf)
		free(out->buf);
	if (in->buf)
		free(in->buf);
	return(c);
a370 4
/*
 * Allocate buffers to the maximum of either the input file's blocksize
 * or BUFFER_IN_DEF/BUFFER_OUT_DEF, which should be around BUFSIZE.
 */
d372 1
a372 2
begin_bufs(const struct md_args *args, 
		struct md_buf *out, struct md_buf *in)
d374 4
a377 2
	struct stat	 stin, stout;
	int		 c;
d379 1
a379 3
	assert(args);
	assert(in);
	assert(out);
d381 1
a381 8
	if (-1 == fstat(in->fd, &stin)) {
		warn("%s", in->name);
		return(1);
	} else if (STDIN_FILENO != in->fd && 0 == stin.st_size) {
		warnx("%s: empty file", in->name);
		return(1);
	} else if (-1 == fstat(out->fd, &stout)) {
		warn("%s", out->name);
d383 16
d401 20
a420 9
	in->bufsz = MAX(stin.st_blksize, BUFFER_IN_DEF);
	out->bufsz = MAX(stout.st_blksize, BUFFER_OUT_DEF);

	if (NULL == (in->buf = malloc(in->bufsz))) {
		warn("malloc");
		return(leave_bufs(out, in, 1));
	} else if (NULL == (out->buf = malloc(out->bufsz))) {
		warn("malloc");
		return(leave_bufs(out, in, 1));
d423 1
a423 2
	c = md_run(args, out, in);
	return(leave_bufs(out, in, -1 == c ? 1 : 0));
d432 1
a432 2
	(void)fprintf(stderr, "usage: %s [-v] [-Wwarn...]  "
			"[-f filter] [-o outfile] [infile]\n", 
@


1.19
log
@Considerable clean-ups.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.18 2008/12/09 00:27:17 kristaps Exp $ */
d74 1
a74 1
	args.type = MD_XML;
d93 2
@


1.18
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.17 2008/12/04 11:25:29 kristaps Exp $ */
d53 4
d272 3
a274 2
	(void)printf("usage: %s [-v] [-Wwarn...]  [-f filter] "
			"[-o outfile] [infile]\n", __progname);
@


1.17
log
@More html-css.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.16 2008/12/03 19:21:58 kristaps Exp $ */
d57 1
a57 1
	char		*out, *in;
d59 3
d72 1
a72 1
	while (-1 != (c = getopt(argc, argv, "c:ef:o:vW")))
d99 13
a111 1
			args.warnings |= MD_WARN_ALL;
d268 2
a269 2
	(void)printf("usage: %s [-vW] [-f filter] [-o outfile] "
			"[infile]\n", __progname);
d271 1
@


1.16
log
@Major update.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.15 2008/12/02 00:10:37 kristaps Exp $ */
d36 6
d57 1
a57 1
	char		*out, *in, *filter;
d63 1
a63 1
	out = in = filter = NULL;
d66 4
a69 2
	
	while (-1 != (c = getopt(argc, argv, "f:o:vW")))
d71 10
d82 6
a87 1
			filter = optarg;
d103 4
a112 10
	if (filter) {
		if (0 == strcmp(filter, "html"))
			args.type = MD_HTML;
		else if (0 == strcmp(filter, "xml"))
			args.type = MD_XML;
		else
			errx(1, "invalid filter type");
	} else
		args.type = MD_XML;

@


1.15
log
@Improvements to the xml part.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.14 2008/11/28 11:21:12 kristaps Exp $ */
d51 1
a51 1
	char		*out, *in;
d57 1
a57 1
	out = in = NULL;
d61 1
a61 1
	while (-1 != (c = getopt(argc, argv, "o:vW")))
d63 3
d86 10
d236 2
a237 1
	(void)printf("usage: %s [-vW] [-o outfile] [infile]\n", __progname);
@


1.14
log
@Initial pushing to mbuf.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.13 2008/11/27 17:27:50 kristaps Exp $ */
d109 3
@


1.13
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.12 2008/11/26 22:27:07 kristaps Exp $ */
a82 2
	args.type = MD_DUMMY;

@


1.12
log
@Various fixes.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.11 2008/11/25 12:14:02 kristaps Exp $ */
d61 1
a61 1
	while (-1 != (c = getopt(argc, argv, "o:")))
d66 6
d222 1
a222 1
	(void)printf("usage: %s [-o outfile] [infile]\n", __progname);
@


1.11
log
@Single call-back for filters.
Removed verbose flag.
Added more macros and arguments.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.10 2008/11/24 14:24:55 kristaps Exp $ */
d187 1
a187 1
	} else if (0 == stin.st_size) {
@


1.10
log
@Split roff engine into roff.c.
Re-worked calling convention for md_*.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.9 2008/11/23 23:12:47 kristaps Exp $ */
d61 1
a61 1
	while (-1 != (c = getopt(argc, argv, "vo:")))
a65 3
		case ('v'):
			args.dbg++;
			break;
d216 1
a216 2
	(void)printf("usage: %s [-v] [-o outfile] [infile]\n", 
			__progname);
@


1.9
log
@Fixed clarity in libmdocml.c.
Fixed debugging messages.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.8 2008/11/23 22:30:53 kristaps Exp $ */
d58 2
d80 1
a80 1
	args.type = MD_HTML4_STRICT;
@


1.8
log
@Considerable improvements across the board.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.7 2008/11/23 19:10:03 kristaps Exp $ */
d33 2
a34 2
#define	BUFFER_IN_DEF	BUFSIZ
#define	BUFFER_OUT_DEF	BUFSIZ
d36 3
a38 2
static void		 usage(void);
static int		 begin_io(const struct md_args *, 
d40 1
a40 1
static int		 leave_io(const struct md_buf *, 
d42 1
a42 1
static int		 begin_bufs(const struct md_args *,
d59 1
a59 1
	while (-1 != (c = getopt(argc, argv, "o:")))
d64 3
a78 1
	args.dbg = MD_DBG_TREE;
d84 4
d111 4
d153 3
d170 4
d217 2
a218 1
	(void)printf("usage: %s [-o outfile] [infile]\n", __progname);
@


1.7
log
@Initial support for Sh.
Debugging things (will be changed out).
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.6 2008/11/23 11:05:25 kristaps Exp $ */
d170 3
@


1.6
log
@Initial foray into roff-parsing.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.5 2008/11/22 20:15:34 kristaps Exp $ */
d75 1
@


1.5
log
@Fuller seperation into mdocml/libmdocml.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.4 2008/11/22 18:34:06 kristaps Exp $ */
d74 1
a74 1
	args.type = MD_DUMMY;
@


1.4
log
@Putting md_run and friends into libmdocml (needs work to be useful).
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.3 2008/11/22 17:14:32 kristaps Exp $ */
d37 8
a44 6
static int		 begin_io(const char *, const char *);
static int		 leave_io(const struct md_mbuf *, 
				const struct md_rbuf *, int);
static int		 begin_bufs(struct md_mbuf *, struct md_rbuf *);
static int		 leave_bufs(const struct md_mbuf *, 
				const struct md_rbuf *, int);
d51 1
d74 3
a76 1
	return(begin_io(out ? out : "-", in ? in : "-"));
d81 2
a82 2
leave_io(const struct md_mbuf *out, 
		const struct md_rbuf *in, int c)
d104 1
a104 1
begin_io(const char *out, const char *in)
d106 2
a107 2
	struct md_rbuf	 fi;
	struct md_mbuf	 fo;
d112 1
d116 2
a117 2
	bzero(&fi, sizeof(struct md_rbuf));
	bzero(&fo, sizeof(struct md_mbuf));
d137 1
a137 1
	return(leave_io(&fo, &fi, begin_bufs(&fo, &fi)));
d142 2
a143 2
leave_bufs(const struct md_mbuf *out, 
		const struct md_rbuf *in, int c)
d156 2
a157 1
begin_bufs(struct md_mbuf *out, struct md_rbuf *in)
d160 1
d162 1
d185 2
a186 1
	return(leave_bufs(out, in, md_run(MD_DUMMY, out, in)));
@


1.3
log
@Consolidated structs (elim. ptr overhead).
Set meaningful buffer default sizes.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.2 2008/11/22 16:55:02 kristaps Exp $ */
a34 17
#define	BUFFER_LINE	BUFSIZ

struct md_rbuf {
	int		 fd;
	const char	*name;
	char		*buf;
	size_t		 bufsz;
	size_t		 line;
};

struct md_mbuf {
	int		 fd;
	const char	*name;
	char		*buf;
	size_t		 bufsz;
	size_t		 pos;
};
d37 6
a42 15

static int		 md_begin(const char *, const char *);
static int		 md_begin_io(const char *, const char *);
static int		 md_begin_bufs(struct md_mbuf *, struct md_rbuf *);
static int		 md_run(struct md_mbuf *, struct md_rbuf *);
static int		 md_line(struct md_mbuf *, const struct md_rbuf *,
				const char *, size_t);

static ssize_t		 md_buf_fill(struct md_rbuf *);
static int		 md_buf_flush(struct md_mbuf *);

static int		 md_buf_putchar(struct md_mbuf *, char);
static int		 md_buf_puts(struct md_mbuf *, 
				const char *, size_t);

d53 1
a53 1
	out = NULL;
d66 1
a66 4
	if (1 != (argc -= optind)) {
		usage();
		return(1);
	}
d68 2
a69 2
	argc--;
	in = *argv++;
d71 1
a71 1
	return(md_begin(out, in));
d76 2
a77 1
md_begin(const char *out, const char *in)
d79 1
a79 2
	char		 buf[MAXPATHLEN];

a80 2
	if (out)
		return(md_begin_io(out, in));
d82 11
a92 6
	if (strlcpy(buf, in, MAXPATHLEN) >= MAXPATHLEN)
		warnx("output filename too long");
	else if (strlcat(buf, ".html", MAXPATHLEN) >= MAXPATHLEN)
		warnx("output filename too long");
	else 
		return(md_begin_io(buf, in));
d94 1
a94 1
	return(1);
d99 1
a99 1
md_begin_io(const char *out, const char *in)
d101 5
a105 3
	int		 c;
	struct md_rbuf	 fin;
	struct md_mbuf	 fout;
d110 2
a111 1
	/* TODO: accept "-" as both input and output. */
d113 2
a114 1
	fin.name = in;
d116 2
a117 4
	if (-1 == (fin.fd = open(fin.name, O_RDONLY, 0))) {
		warn("%s", fin.name);
		return(1);
	}
d119 5
a123 1
	fout.name = out;
d125 5
a129 7
	fout.fd = open(fout.name, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (-1 == fout.fd) {
		warn("%s", fout.name);
		if (-1 == close(fin.fd))
			warn("%s", fin.name);
		return(1);
	}
d131 2
a132 1
	c = md_begin_bufs(&fout, &fin);
a133 8
	if (-1 == close(fin.fd)) {
		warn("%s", in);
		c = 1;
	}
	if (-1 == close(fout.fd)) {
		warn("%s", out);
		c = 1;
	}
d135 10
d150 1
a150 1
md_begin_bufs(struct md_mbuf *out, struct md_rbuf *in)
a152 1
	int		 c;
a165 1

d170 1
a170 1
		return(1);
d173 1
a173 2
		free(in->buf);
		return(1);
d176 1
a176 151
	c = md_run(out, in);

	free(in->buf);
	free(out->buf);

	return(c);
}


static ssize_t
md_buf_fill(struct md_rbuf *in)
{
	ssize_t		 ssz;

	assert(in);
	assert(in->buf);
	assert(in->bufsz > 0);
	assert(in->name);

	if (-1 == (ssz = read(in->fd, in->buf, in->bufsz))) 
		warn("%s", in->name);

	return(ssz);
}


static int
md_run(struct md_mbuf *out, struct md_rbuf *in)
{
	ssize_t		 sz, i;
	char		 line[BUFFER_LINE];
	size_t		 pos;

	assert(in);
	assert(out); 

	out->pos = 0;
	in->line = 1;

	/* LINTED */
	for (pos = 0; ; ) {
		if (-1 == (sz = md_buf_fill(in)))
			return(1);
		else if (0 == sz)
			break;

		for (i = 0; i < sz; i++) {
			if ('\n' == in->buf[i]) {
				if (md_line(out, in, line, pos))
					return(1);
				in->line++;
				pos = 0;
				continue;
			}

			if (pos < BUFFER_LINE) {
				/* LINTED */
				line[pos++] = in->buf[i];
				continue;
			}

			warnx("%s: line %zu too long",
					in->name, in->line);
			return(1);
		}
	}

	if (0 != pos && md_line(out, in, line, pos))
		return(1);

	return(md_buf_flush(out) ? 0 : 1);
}


static int
md_buf_flush(struct md_mbuf *buf)
{
	ssize_t		 sz;

	assert(buf);
	assert(buf->buf);
	assert(buf->name);

	if (0 == buf->pos)
		return(1);

	sz = write(buf->fd, buf->buf, buf->pos);

	if (-1 == sz) {
		warn("%s", buf->name);
		return(0);
	} else if ((size_t)sz != buf->pos) {
		warnx("%s: short write", buf->name);
		return(0);
	}

	buf->pos = 0;
	return(1);
}


static int
md_buf_putchar(struct md_mbuf *buf, char c)
{
	return(md_buf_puts(buf, &c, 1));
}


static int
md_buf_puts(struct md_mbuf *buf, const char *p, size_t sz)
{
	size_t		 ssz;

	assert(p);
	assert(buf);
	assert(buf->buf);

	while (buf->pos + sz > buf->bufsz) {
		ssz = buf->bufsz - buf->pos;
		(void)memcpy(buf->buf + buf->pos, p, ssz);
		p += ssz;
		sz -= ssz;
		buf->pos += ssz;

		if ( ! md_buf_flush(buf))
			return(0);
	}

	(void)memcpy(buf->buf + buf->pos, p, sz);
	buf->pos += sz;
	return(1);
}


static int
md_line(struct md_mbuf *out, const struct md_rbuf *in,
		const char *buf, size_t sz)
{

	/* FIXME: this is just a placeholder function. */

	assert(buf);
	assert(out);
	assert(in);

	if ( ! md_buf_puts(out, buf, sz))
		return(1);
	if ( ! md_buf_putchar(out, '\n'))
		return(1);

	return(0);
d185 1
a185 1
	(void)printf("usage: %s [-o outfile] infile\n", __progname);
@


1.2
log
@Buffering and line-buffering working and tested.
@
text
@d1 1
a1 1
/* $Id: mdocml.c,v 1.1.1.1 2008/11/22 14:53:29 kristaps Exp $ */
d33 5
a37 1
struct md_file {
a39 4
};

struct md_buf {
	struct md_file	*file;
d46 4
a49 1
	struct md_buf	*buf;
d57 3
a59 3
static int		 md_begin_bufs(struct md_file *, struct md_file *);
static int		 md_run(struct md_buf *, struct md_buf *);
static int		 md_line(struct md_mbuf *, const struct md_buf *,
d62 1
a62 1
static ssize_t		 md_buf_fill(struct md_buf *);
d128 2
a129 1
	struct md_file	 fin, fout;
d169 1
a169 1
md_begin_bufs(struct md_file *out, struct md_file *in)
a171 1
	struct md_buf	 inbuf, outbuf;
d178 1
a178 1
		warn("fstat: %s", in->name);
d181 1
a181 1
		warn("fstat: %s", out->name);
d185 3
a187 9
	inbuf.file = in;
	inbuf.line = 1;
	/*inbuf.bufsz = MAX(stin.st_blksize, BUFSIZ);*/
	inbuf.bufsz = 256;

	outbuf.file = out;
	outbuf.line = 1;
	/*outbuf.bufsz = MAX(stout.st_blksize, BUFSIZ);*/
	outbuf.bufsz = 256;
d189 1
a189 1
	if (NULL == (inbuf.buf = malloc(inbuf.bufsz))) {
d192 1
a192 1
	} else if (NULL == (outbuf.buf = malloc(outbuf.bufsz))) {
d194 1
a194 1
		free(inbuf.buf);
d198 1
a198 1
	c = md_run(&outbuf, &inbuf);
d200 2
a201 2
	free(inbuf.buf);
	free(outbuf.buf);
d208 1
a208 1
md_buf_fill(struct md_buf *in)
a212 1
	assert(in->file);
d215 1
a215 1
	assert(in->file->name);
d217 2
a218 5
	if (-1 == (ssz = read(in->file->fd, in->buf, in->bufsz))) 
		warn("%s", in->file->name);
	else
		(void)printf("%s: filled %zd bytes\n",
				in->file->name, ssz);
d225 1
a225 1
md_run(struct md_buf *out, struct md_buf *in)
a226 1
	struct md_mbuf	 mbuf;
d228 1
a228 1
	char		 line[BUFSIZ];
d234 2
a235 2
	mbuf.buf = out;
	mbuf.pos = 0;
d246 1
a246 1
				if (md_line(&mbuf, in, line, pos))
d253 1
a253 1
			if (pos < BUFSIZ) {
d260 1
a260 1
					in->file->name, in->line);
d265 1
a265 1
	if (0 != pos && md_line(&mbuf, in, line, pos))
d268 1
a268 1
	return(md_buf_flush(&mbuf) ? 0 : 1);
d279 1
a279 6
	assert(buf->buf->file);
	assert(buf->buf->buf);
	assert(buf->buf->file->name);

	(void)printf("%s: flushing %zu bytes\n",
			buf->buf->file->name, buf->pos);
d284 1
a284 1
	sz = write(buf->buf->file->fd, buf->buf->buf, buf->pos);
d287 1
a287 1
		warn("%s", buf->buf->file->name);
d290 1
a290 1
		warnx("%s: short write", buf->buf->file->name);
d315 3
a317 3
	while (buf->pos + sz > buf->buf->bufsz) {
		ssz = buf->buf->bufsz - buf->pos;
		(void)memcpy(buf->buf->buf + buf->pos, p, ssz);
d326 1
a326 1
	(void)memcpy(buf->buf->buf + buf->pos, p, sz);
d333 1
a333 1
md_line(struct md_mbuf *out, const struct md_buf *in,
d337 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* $Id$ */
d45 5
d56 1
a56 1
static int		 md_line(struct md_buf *, const struct md_buf *,
d60 5
d130 1
a130 3
	/* XXX: put an output file in TMPDIR and switch it out when the
	 * true file is ready to be written.
	 */
d141 1
a141 1
	fout.fd = open(fout.name, O_WRONLY | O_CREAT | O_EXCL, 0644);
d184 2
a185 1
	inbuf.bufsz = MAX(stin.st_blksize, BUFSIZ);
d189 2
a190 1
	outbuf.bufsz = MAX(stout.st_blksize, BUFSIZ);
d223 3
d234 1
d242 3
d254 1
a254 1
				if (md_line(out, in, line, pos))
d273 38
a310 2
	if (0 != pos)
		return(md_line(out, in, line, pos));
d312 30
a341 1
	return(0);
d346 1
a346 1
md_line(struct md_buf *out, const struct md_buf *in,
a348 1
	size_t		 i;
d354 4
a357 2
	for (i = 0; i < sz; i++) 
		(void)putchar(buf[i]);
a358 1
	(void)putchar('\n');
@


1.1.1.1
log
@Initial check-in of mdocml.
@
text
@@
