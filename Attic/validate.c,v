head	1.94;
access;
symbols
	VERSION_1_9_5:1.94
	VERSION_1_8_5:1.94
	VERSION_1_8_1:1.94
	VERSION_1_7_16:1.94
	VERSION_1_7_15:1.94
	OPENBSD_CHECKIN:1.94
	VERSION_1_6_5:1.88
	VERSION_1_6_2:1.86
	VERSION_1_5_3:1.85
	VERSION_1_5_1:1.83
	VERSION_1_4_6:1.77
	VERSION_1_4_5:1.77
	VERSION_1_4_4:1.76
	VERSION_1_4_2:1.74
	VERSION_1_3_15:1.65
	VERSION_1_3_13:1.65
	VERSION_1_3_11:1.65
	VERSION_1_3_10:1.64
	VERSION_1_3_9:1.63
	VERSION_1_3_8:1.63
	VERSION_1_3_6:1.63
	VERSION_1_3_5:1.60
	VERSION_1_2_0:1.44
	VERSION_1_1_0:1.29
	VERSION_1_0_2:1.7;
locks; strict;
comment	@ * @;


1.94
date	2009.03.25.15.17.50;	author kristaps;	state dead;
branches;
next	1.93;

1.93
date	2009.03.23.14.22.11;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.21.21.09.00;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.21.13.47.02;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.21.13.37.31;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.21.13.09.29;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2009.03.21.09.48.30;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.21.09.42.07;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2009.03.20.15.14.01;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.16.23.37.28;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.16.22.19.19;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.13.13.56.13;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2009.03.12.16.30.50;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.12.06.32.17;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2009.03.12.02.57.36;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2009.03.11.00.39.58;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2009.03.09.14.19.59;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2009.03.09.13.17.50;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2009.03.08.20.57.35;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2009.03.08.20.50.12;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2009.03.08.18.02.36;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.08.12.40.27;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.08.11.48.44;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.08.11.41.22;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.06.14.24.49;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.06.14.13.47;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.05.13.12.12;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.04.13.57.35;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.02.17.14.46;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.28.14.40.07;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.28.13.47.36;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.27.09.39.40;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.27.09.14.02;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2009.02.26.14.56.27;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.25.12.32.50;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2009.02.25.11.37.05;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.24.16.16.45;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.24.13.57.17;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2009.02.24.13.46.54;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2009.02.24.12.20.52;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.02.24.11.43.13;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.02.23.22.51.10;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.22.19.23.48;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.02.22.14.31.08;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.02.21.21.00.06;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.02.21.15.34.46;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.21.14.56.58;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.21.17.56.32;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.01.21.11.35.26;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.01.20.20.56.21;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.20.13.44.05;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.20.12.51.28;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.19.23.11.43;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.19.23.11.12;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.19.17.51.33;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.19.17.02.59;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.17.20.10.36;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.17.16.47.02;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.17.16.15.27;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.16.15.58.50;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.16.14.15.12;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.16.14.04.26;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.16.12.23.25;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.16.11.50.54;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.15.17.38.58;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.01.15.15.46.45;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.01.14.11.58.24;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.01.12.17.26.42;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.12.16.39.57;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.12.12.52.21;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.12.10.31.53;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.09.15.15.31;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.09.15.07.04;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.09.14.45.44;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.08.15.59.58;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.08.15.05.50;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.08.14.55.59;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.07.15.53.00;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.05.14.14.04;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.03.22.10.22;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.18.38.39;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.02.14.06.16;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.02.09.29.06;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.01.20.40.16;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.30.19.06.03;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.30.18.15.26;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.30.13.43.53;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.30.21.41.35;	author kristaps;	state dead;
branches;
next	1.6;

1.6
date	2008.11.30.20.53.34;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.30.20.00.08;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.30.18.50.44;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.30.12.41.45;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.29.16.11.42;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.29.14.14.21;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.94
log
@Added man validator, renamed mdoc validator.
@
text
@@


1.93
log
@First addition of -man macro support.
Abstraction of mdoc.
@
text
@a0 1396
/* $Id: validate.c,v 1.92 2009/03/21 21:09:00 kristaps Exp $ */
/*
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdlib.h>

#include "libmdoc.h"

/* FIXME: .Bl -diag can't have non-text children in HEAD. */
/* TODO: ignoring Pp (it's superfluous in some invocations). */

/*
 * Pre- and post-validate macros as they're parsed.  Pre-validation
 * occurs when the macro has been detected and its arguments parsed.
 * Post-validation occurs when all child macros have also been parsed.
 * In the ELEMENT case, this is simply the parameters of the macro; in
 * the BLOCK case, this is the HEAD, BODY, TAIL and so on.
 */

#define	PRE_ARGS	struct mdoc *mdoc, const struct mdoc_node *n
#define	POST_ARGS	struct mdoc *mdoc

enum	merr {
	EESCAPE,
	EPRINT,
	ENODATA,
	ENOPROLOGUE,
	ELINE,
	EATT,
	ENAME,
	ELISTTYPE,
	EDISPTYPE,
	EMULTIDISP,
	EMULTILIST,
	EARGREP,
	EBOOL,
	ENESTDISP
};

enum	mwarn {
	WESCAPE,
	WWRONGMSEC,
	WSECOOO,
	WSECREP,
	WBADSTAND,
	WNAMESECINC,
	WNOMULTILINE,
	WMULTILINE,
	WLINE,
	WNOLINE,
	WPROLOOO,
	WPROLREP,
	WARGVAL,
	WBADSEC,
	WBADMSEC
};

typedef	int	(*v_pre)(PRE_ARGS);
typedef	int	(*v_post)(POST_ARGS);

struct	valids {
	v_pre	*pre;
	v_post	*post;
};

/* Utility checks. */

static	int	pwarn(struct mdoc *, int, int, enum mwarn);
static	int	perr(struct mdoc *, int, int, enum merr);
static	int	check_parent(PRE_ARGS, int, enum mdoc_type);
static	int	check_msec(PRE_ARGS, ...);
static	int	check_sec(PRE_ARGS, ...);
static	int	check_stdarg(PRE_ARGS);
static	int	check_text(struct mdoc *, int, int, const char *);
static	int	check_argv(struct mdoc *, 
			const struct mdoc_node *,
			const struct mdoc_argv *);
static	int	check_args(struct mdoc *, 
			const struct mdoc_node *);
static	int	err_child_lt(struct mdoc *, const char *, int);
static	int	warn_child_lt(struct mdoc *, const char *, int);
static	int	err_child_gt(struct mdoc *, const char *, int);
static	int	warn_child_gt(struct mdoc *, const char *, int);
static	int	err_child_eq(struct mdoc *, const char *, int);
static	int	warn_child_eq(struct mdoc *, const char *, int);
static	inline int count_child(struct mdoc *);
static	inline int warn_count(struct mdoc *, const char *, 
			int, const char *, int);
static	inline int err_count(struct mdoc *, const char *, 
			int, const char *, int);
static	int	pre_an(PRE_ARGS);
static	int	pre_bd(PRE_ARGS);
static	int	pre_bl(PRE_ARGS);
static	int	pre_cd(PRE_ARGS);
static	int	pre_dd(PRE_ARGS);
static	int	pre_display(PRE_ARGS);
static	int	pre_dt(PRE_ARGS);
static	int	pre_er(PRE_ARGS);
static	int	pre_ex(PRE_ARGS);
static	int	pre_fd(PRE_ARGS);
static	int	pre_it(PRE_ARGS);
static	int	pre_lb(PRE_ARGS);
static	int	pre_os(PRE_ARGS);
static	int	pre_prologue(PRE_ARGS);
static	int	pre_rv(PRE_ARGS);
static	int	pre_sh(PRE_ARGS);
static	int	pre_ss(PRE_ARGS);
static	int	herr_ge1(POST_ARGS);
static	int	hwarn_le1(POST_ARGS);
static	int	herr_eq0(POST_ARGS);
static	int	eerr_eq0(POST_ARGS);
static	int	eerr_le2(POST_ARGS);
static	int	eerr_eq1(POST_ARGS);
static	int	eerr_ge1(POST_ARGS);
static	int	ewarn_eq0(POST_ARGS);
static	int	ewarn_eq1(POST_ARGS);
static	int	bwarn_ge1(POST_ARGS);
static	int	hwarn_eq1(POST_ARGS);
static	int	ewarn_ge1(POST_ARGS);
static	int	ebool(POST_ARGS);

static	int	post_an(POST_ARGS);
static	int	post_args(POST_ARGS);
static	int	post_at(POST_ARGS);
static	int	post_bf(POST_ARGS);
static	int	post_bl(POST_ARGS);
static	int	post_it(POST_ARGS);
static	int	post_nm(POST_ARGS);
static	int	post_root(POST_ARGS);
static	int	post_sh(POST_ARGS);
static	int	post_sh_body(POST_ARGS);
static	int	post_sh_head(POST_ARGS);
static	int	post_st(POST_ARGS);

#define	mwarn(m, t) nwarn((m), (m)->last, (t))
#define	merr(m, t) nerr((m), (m)->last, (t))
#define	nwarn(m, n, t) pwarn((m), (n)->line, (n)->pos, (t))
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))

static	v_pre	pres_an[] = { pre_an, NULL };
static	v_pre	pres_bd[] = { pre_display, pre_bd, NULL };
static	v_pre	pres_bl[] = { pre_bl, NULL };
static	v_pre	pres_cd[] = { pre_cd, NULL };
static	v_pre	pres_dd[] = { pre_prologue, pre_dd, NULL };
static	v_pre	pres_d1[] = { pre_display, NULL };
static	v_pre	pres_dt[] = { pre_prologue, pre_dt, NULL };
static	v_pre	pres_er[] = { pre_er, NULL };
static	v_pre	pres_ex[] = { pre_ex, NULL };
static	v_pre	pres_fd[] = { pre_fd, NULL };
static	v_pre	pres_it[] = { pre_it, NULL };
static	v_pre	pres_lb[] = { pre_lb, NULL };
static	v_pre	pres_os[] = { pre_prologue, pre_os, NULL };
static	v_pre	pres_rv[] = { pre_rv, NULL };
static	v_pre	pres_sh[] = { pre_sh, NULL };
static	v_pre	pres_ss[] = { pre_ss, NULL };
static	v_post	posts_bool[] = { eerr_eq1, ebool, NULL };
static	v_post	posts_bd[] = { herr_eq0, bwarn_ge1, NULL };
static	v_post	posts_text[] = { eerr_ge1, NULL };
static	v_post	posts_wtext[] = { ewarn_ge1, NULL };
static	v_post	posts_notext[] = { eerr_eq0, NULL };
static	v_post	posts_wline[] = { bwarn_ge1, herr_eq0, NULL };
static	v_post	posts_sh[] = { herr_ge1, bwarn_ge1, post_sh, NULL };
static	v_post	posts_bl[] = { herr_eq0, bwarn_ge1, post_bl, NULL };
static	v_post	posts_it[] = { post_it, NULL };
static	v_post	posts_in[] = { ewarn_eq1, NULL };
static	v_post	posts_ss[] = { herr_ge1, NULL };
static	v_post	posts_pf[] = { eerr_eq1, NULL };
static	v_post	posts_lb[] = { eerr_eq1, NULL };
static	v_post	posts_st[] = { eerr_eq1, post_st, NULL };
static	v_post	posts_pp[] = { ewarn_eq0, NULL };
static	v_post	posts_ex[] = { eerr_eq0, post_args, NULL };
static	v_post	posts_rv[] = { eerr_eq0, post_args, NULL };
static	v_post	posts_an[] = { post_an, NULL };
static	v_post	posts_at[] = { post_at, NULL };
static	v_post	posts_xr[] = { eerr_ge1, eerr_le2, NULL };
static	v_post	posts_nm[] = { post_nm, NULL };
static	v_post	posts_bf[] = { hwarn_le1, post_bf, NULL };
static	v_post	posts_fo[] = { hwarn_eq1, bwarn_ge1, NULL };

const	struct valids mdoc_valids[MDOC_MAX] = {
	{ NULL, NULL }, 			/* \" */
	{ pres_dd, posts_text },		/* Dd */
	{ pres_dt, NULL },			/* Dt */
	{ pres_os, NULL },			/* Os */
	{ pres_sh, posts_sh },			/* Sh */ 
	{ pres_ss, posts_ss },			/* Ss */ 
	{ NULL, posts_pp },			/* Pp */ 
	{ pres_d1, posts_wline },		/* D1 */
	{ pres_d1, posts_wline },		/* Dl */
	{ pres_bd, posts_bd },			/* Bd */
	{ NULL, NULL },				/* Ed */
	{ pres_bl, posts_bl },			/* Bl */ 
	{ NULL, NULL },				/* El */
	{ pres_it, posts_it },			/* It */
	{ NULL, posts_text },			/* Ad */ 
	{ pres_an, posts_an },			/* An */ 
	{ NULL, NULL },				/* Ar */
	{ pres_cd, posts_text },		/* Cd */ 
	{ NULL, NULL },				/* Cm */
	{ NULL, NULL },				/* Dv */ 
	{ pres_er, posts_text },		/* Er */ 
	{ NULL, NULL },				/* Ev */ 
	{ pres_ex, posts_ex },			/* Ex */ 
	{ NULL, NULL },				/* Fa */ 
	{ pres_fd, posts_wtext },		/* Fd */
	{ NULL, NULL },				/* Fl */
	{ NULL, posts_text },			/* Fn */ 
	{ NULL, posts_wtext },			/* Ft */ 
	{ NULL, posts_text },			/* Ic */ 
	{ NULL, posts_in },			/* In */ 
	{ NULL, NULL },				/* Li */
	{ NULL, posts_wtext },			/* Nd */
	{ NULL, posts_nm },			/* Nm */
	{ NULL, posts_wline },			/* Op */
	{ NULL, NULL },				/* Ot */
	{ NULL, NULL },				/* Pa */
	{ pres_rv, posts_rv },			/* Rv */
	{ NULL, posts_st },			/* St */ 
	{ NULL, NULL },				/* Va */
	{ NULL, posts_text },			/* Vt */ 
	{ NULL, posts_xr },			/* Xr */ 
	{ NULL, posts_text },			/* %A */
	{ NULL, posts_text },			/* %B */
	{ NULL, posts_text },			/* %D */
	{ NULL, posts_text },			/* %I */
	{ NULL, posts_text },			/* %J */
	{ NULL, posts_text },			/* %N */
	{ NULL, posts_text },			/* %O */
	{ NULL, posts_text },			/* %P */
	{ NULL, posts_text },			/* %R */
	{ NULL, posts_text },			/* %T */
	{ NULL, posts_text },			/* %V */
	{ NULL, NULL },				/* Ac */
	{ NULL, NULL },				/* Ao */
	{ NULL, posts_wline },			/* Aq */
	{ NULL, posts_at },			/* At */ 
	{ NULL, NULL },				/* Bc */
	{ NULL, posts_bf },			/* Bf */
	{ NULL, NULL },				/* Bo */
	{ NULL, posts_wline },			/* Bq */
	{ NULL, NULL },				/* Bsx */
	{ NULL, NULL },				/* Bx */
	{ NULL, posts_bool },			/* Db */
	{ NULL, NULL },				/* Dc */
	{ NULL, NULL },				/* Do */
	{ NULL, posts_wline },			/* Dq */
	{ NULL, NULL },				/* Ec */
	{ NULL, NULL },				/* Ef */ 
	{ NULL, NULL },				/* Em */ 
	{ NULL, NULL },				/* Eo */
	{ NULL, NULL },				/* Fx */
	{ NULL, posts_text },			/* Ms */ 
	{ NULL, posts_notext },			/* No */
	{ NULL, posts_notext },			/* Ns */
	{ NULL, NULL },				/* Nx */
	{ NULL, NULL },				/* Ox */
	{ NULL, NULL },				/* Pc */
	{ NULL, posts_pf },			/* Pf */
	{ NULL, NULL },				/* Po */
	{ NULL, posts_wline },			/* Pq */
	{ NULL, NULL },				/* Qc */
	{ NULL, posts_wline },			/* Ql */
	{ NULL, NULL },				/* Qo */
	{ NULL, posts_wline },			/* Qq */
	{ NULL, NULL },				/* Re */
	{ NULL, posts_wline },			/* Rs */
	{ NULL, NULL },				/* Sc */
	{ NULL, NULL },				/* So */
	{ NULL, posts_wline },			/* Sq */
	{ NULL, posts_bool },			/* Sm */ 
	{ NULL, posts_text },			/* Sx */
	{ NULL, posts_text },			/* Sy */
	{ NULL, posts_text },			/* Tn */
	{ NULL, NULL },				/* Ux */
	{ NULL, NULL },				/* Xc */
	{ NULL, NULL },				/* Xo */
	{ NULL, posts_fo },			/* Fo */ 
	{ NULL, NULL },				/* Fc */ 
	{ NULL, NULL },				/* Oo */
	{ NULL, NULL },				/* Oc */
	{ NULL, posts_wline },			/* Bk */
	{ NULL, NULL },				/* Ek */
	{ NULL, posts_notext },			/* Bt */
	{ NULL, NULL },				/* Hf */
	{ NULL, NULL },				/* Fr */
	{ NULL, posts_notext },			/* Ud */
	{ pres_lb, posts_lb },			/* Lb */
	{ NULL, NULL },				/* Ap */
	{ NULL, posts_pp },			/* Lp */ 
	{ NULL, posts_text },			/* Lk */ 
	{ NULL, posts_text },			/* Mt */ 
	{ NULL, posts_wline },			/* Brq */ 
	{ NULL, NULL },				/* Bro */ 
	{ NULL, NULL },				/* Brc */ 
	{ NULL, posts_text },			/* %C */
	{ NULL, NULL },				/* Es */
	{ NULL, NULL },				/* En */
	{ NULL, NULL },				/* Dx */
	{ NULL, posts_text },			/* %Q */
};


int
mdoc_valid_pre(struct mdoc *mdoc, 
		const struct mdoc_node *n)
{
	v_pre		*p;
	int		 line, pos;
	const char	*tp;

	if (MDOC_TEXT == n->type) {
		tp = n->string;
		line = n->line;
		pos = n->pos;
		return(check_text(mdoc, line, pos, tp));
	}

	if ( ! check_args(mdoc, n))
		return(0);
	if (NULL == mdoc_valids[n->tok].pre)
		return(1);
	for (p = mdoc_valids[n->tok].pre; *p; p++)
		if ( ! (*p)(mdoc, n)) 
			return(0);
	return(1);
}


int
mdoc_valid_post(struct mdoc *mdoc)
{
	v_post		*p;

	/*
	 * This check occurs after the macro's children have been filled
	 * in: postfix validation.  Since this happens when we're
	 * rewinding the scope tree, it's possible to have multiple
	 * invocations (as by design, for now), we set bit MDOC_VALID to
	 * indicate that we've validated.
	 */

	if (MDOC_VALID & mdoc->last->flags)
		return(1);
	mdoc->last->flags |= MDOC_VALID;

	if (MDOC_TEXT == mdoc->last->type)
		return(1);
	if (MDOC_ROOT == mdoc->last->type)
		return(post_root(mdoc));

	if (NULL == mdoc_valids[mdoc->last->tok].post)
		return(1);
	for (p = mdoc_valids[mdoc->last->tok].post; *p; p++)
		if ( ! (*p)(mdoc)) 
			return(0);

	return(1);
}


static int
perr(struct mdoc *m, int line, int pos, enum merr type)
{
	char		 *p;
	
	p = NULL;
	switch (type) {
	case (EESCAPE):
		p = "invalid escape sequence";
		break;
	case (EPRINT):
		p = "invalid character";
		break;
	case (ENESTDISP):
		p = "displays may not be nested";
		break;
	case (EBOOL):
		p = "expected boolean value";
		break;
	case (EARGREP):
		p = "argument repeated";
		break;
	case (EMULTIDISP):
		p = "multiple display types specified";
		break;
	case (EMULTILIST):
		p = "multiple list types specified";
		break;
	case (ELISTTYPE):
		p = "missing list type";
		break;
	case (EDISPTYPE):
		p = "missing display type";
		break;
	case (ELINE):
		p = "expected line arguments";
		break;
	case (ENOPROLOGUE):
		p = "document has no prologue";
		break;
	case (ENODATA):
		p = "document has no data";
		break;
	case (EATT):
		p = "expected valid AT&T symbol";
		break;
	case (ENAME):
		p = "default name not yet set";
		break;
	}
	assert(p);
	return(mdoc_perr(m, line, pos, p));
}


static int
pwarn(struct mdoc *m, int line, int pos, enum mwarn type)
{
	char		 *p;
	enum mdoc_warn	  c;

	c = WARN_SYNTAX;
	p = NULL;
	switch (type) {
	case (WBADMSEC):
		p = "inappropriate manual section";
		c = WARN_COMPAT;
		break;
	case (WBADSEC):
		p = "inappropriate document section";
		c = WARN_COMPAT;
		break;
	case (WARGVAL):
		p = "argument value suggested";
		c = WARN_COMPAT;
		break;
	case (WPROLREP):
		p = "prologue macros repeated";
		c = WARN_COMPAT;
		break;
	case (WPROLOOO):
		p = "prologue macros out-of-order";
		c = WARN_COMPAT;
		break;
	case (WESCAPE):
		p = "invalid escape sequence";
		break;
	case (WNOLINE):
		p = "suggested no line arguments";
		break;
	case (WLINE):
		p = "suggested line arguments";
		break;
	case (WMULTILINE):
		p = "suggested multi-line arguments";
		break;
	case (WNOMULTILINE):
		p = "suggested no multi-line arguments";
		break;
	case (WWRONGMSEC):
		p = "document section in wrong manual section";
		c = WARN_COMPAT;
		break;
	case (WSECOOO):
		p = "document section out of conventional order";
		break;
	case (WSECREP):
		p = "document section repeated";
		break;
	case (WBADSTAND):
		p = "unknown standard";
		break;
	case (WNAMESECINC):
		p = "NAME section contents incomplete/badly-ordered";
		break;
	}
	assert(p);
	return(mdoc_pwarn(m, line, pos, c, p));
}



static inline int
warn_count(struct mdoc *m, const char *k, 
		int want, const char *v, int has)
{

	return(mdoc_warn(m, WARN_SYNTAX, 
		"suggests %s %s %d (has %d)", v, k, want, has));
}


static inline int
err_count(struct mdoc *m, const char *k,
		int want, const char *v, int has)
{

	return(mdoc_err(m, 
		"requires %s %s %d (has %d)", v, k, want, has));
}


static inline int
count_child(struct mdoc *mdoc)
{
	int		  i;
	struct mdoc_node *n;

	for (i = 0, n = mdoc->last->child; n; n = n->next, i++)
		/* Do nothing */ ;

	return(i);
}


/*
 * Build these up with macros because they're basically the same check
 * for different inequalities.  Yes, this could be done with functions,
 * but this is reasonable for now.
 */

#define CHECK_CHILD_DEFN(lvl, name, ineq) 			\
static int 							\
lvl##_child_##name(struct mdoc *mdoc, const char *p, int sz) 	\
{ 								\
	int i; 							\
	if ((i = count_child(mdoc)) ineq sz) 			\
		return(1); 					\
	return(lvl##_count(mdoc, #ineq, sz, p, i)); 		\
}

#define CHECK_BODY_DEFN(name, lvl, func, num) 			\
static int 							\
b##lvl##_##name(POST_ARGS) 					\
{ 								\
	if (MDOC_BODY != mdoc->last->type) 			\
		return(1); 					\
	return(func(mdoc, "multi-line arguments", (num))); 	\
}

#define CHECK_ELEM_DEFN(name, lvl, func, num) 			\
static int							\
e##lvl##_##name(POST_ARGS) 					\
{ 								\
	assert(MDOC_ELEM == mdoc->last->type); 			\
	return(func(mdoc, "line arguments", (num))); 		\
}

#define CHECK_HEAD_DEFN(name, lvl, func, num)			\
static int 							\
h##lvl##_##name(POST_ARGS) 					\
{ 								\
	if (MDOC_HEAD != mdoc->last->type) 			\
		return(1); 					\
	return(func(mdoc, "line arguments", (num)));	 	\
}


CHECK_CHILD_DEFN(warn, gt, >)			/* warn_child_gt() */
CHECK_CHILD_DEFN(err, gt, >)			/* err_child_gt() */
CHECK_CHILD_DEFN(warn, eq, ==)			/* warn_child_eq() */
CHECK_CHILD_DEFN(err, eq, ==)			/* err_child_eq() */
CHECK_CHILD_DEFN(err, lt, <)			/* err_child_lt() */
CHECK_CHILD_DEFN(warn, lt, <)			/* warn_child_lt() */
CHECK_BODY_DEFN(ge1, warn, warn_child_gt, 0)	/* bwarn_ge1() */
CHECK_ELEM_DEFN(eq1, warn, warn_child_eq, 1)	/* ewarn_eq1() */
CHECK_ELEM_DEFN(eq0, warn, warn_child_eq, 0)	/* ewarn_eq0() */
CHECK_ELEM_DEFN(ge1, warn, warn_child_gt, 0)	/* ewarn_gt1() */
CHECK_ELEM_DEFN(eq1, err, err_child_eq, 1)	/* eerr_eq1() */
CHECK_ELEM_DEFN(le2, err, err_child_lt, 3)	/* eerr_le2() */
CHECK_ELEM_DEFN(eq0, err, err_child_eq, 0)	/* eerr_eq0() */
CHECK_ELEM_DEFN(ge1, err, err_child_gt, 0)	/* eerr_ge1() */
CHECK_HEAD_DEFN(eq0, err, err_child_eq, 0)	/* herr_eq0() */
CHECK_HEAD_DEFN(le1, warn, warn_child_lt, 2)	/* hwarn_le1() */
CHECK_HEAD_DEFN(ge1, err, err_child_gt, 0)	/* herr_ge1() */
CHECK_HEAD_DEFN(eq1, warn, warn_child_eq, 1)	/* hwarn_eq1() */


static int
check_stdarg(PRE_ARGS)
{

	if (n->args && 1 == n->args->argc)
		if (MDOC_Std == n->args->argv[0].arg)
			return(1);
	return(nwarn(mdoc, n, WARGVAL));
}


static int
check_sec(PRE_ARGS, ...)
{
	enum mdoc_sec	 sec;
	va_list		 ap;

	va_start(ap, n);

	for (;;) {
		/* LINTED */
		sec = (enum mdoc_sec)va_arg(ap, int);
		if (SEC_CUSTOM == sec)
			break;
		if (sec != mdoc->lastsec)
			continue;
		va_end(ap);
		return(1);
	}

	va_end(ap);
	return(nwarn(mdoc, n, WBADSEC));
}


static int
check_msec(PRE_ARGS, ...)
{
	va_list		 ap;
	int		 msec;

	va_start(ap, n);
	for (;;) {
		/* LINTED */
		if (0 == (msec = va_arg(ap, int)))
			break;
		if (msec != mdoc->meta.msec)
			continue;
		va_end(ap);
		return(1);
	}

	va_end(ap);
	return(nwarn(mdoc, n, WBADMSEC));
}


static int
check_args(struct mdoc *m, const struct mdoc_node *n)
{
	int		 i;

	if (NULL == n->args)
		return(1);

	assert(n->args->argc);
	for (i = 0; i < (int)n->args->argc; i++)
		if ( ! check_argv(m, n, &n->args->argv[i]))
			return(0);

	return(1);
}


static int
check_argv(struct mdoc *m, const struct mdoc_node *n, 
		const struct mdoc_argv *v)
{
	int		 i;

	for (i = 0; i < (int)v->sz; i++)
		if ( ! check_text(m, v->line, v->pos, v->value[i]))
			return(0);

	if (MDOC_Std == v->arg) {
		/* `Nm' name must be set. */
		if (v->sz || m->meta.name)
			return(1);
		return(nerr(m, n, ENAME));
	}

	return(1);
}


static int
check_text(struct mdoc *mdoc, int line, int pos, const char *p)
{
	size_t		 c;

	/* FIXME: indicate deprecated escapes \*(xx and \*x. */

	for ( ; *p; p++) {
		if ('\t' == *p) {
			if ( ! (MDOC_LITERAL & mdoc->flags))
				return(perr(mdoc, line, pos, EPRINT));
		} else if ( ! isprint((u_char)*p))
			return(perr(mdoc, line, pos, EPRINT));

		if ('\\' != *p)
			continue;

		c = mdoc_isescape(p);
		if (c) {
			p += (int)c - 1;
			continue;
		}
		if ( ! (MDOC_IGN_ESCAPE & mdoc->pflags))
			return(perr(mdoc, line, pos, EESCAPE));
		if ( ! pwarn(mdoc, line, pos, WESCAPE))
			return(0);
	}

	return(1);
}




static int
check_parent(PRE_ARGS, int tok, enum mdoc_type t)
{

	assert(n->parent);
	if ((MDOC_ROOT == t || tok == n->parent->tok) &&
			(t == n->parent->type))
		return(1);

	return(mdoc_nerr(mdoc, n, "require parent %s",
		MDOC_ROOT == t ? "<root>" : mdoc_macronames[tok]));
}



static int
pre_display(PRE_ARGS)
{
	struct mdoc_node *node;

	/* Display elements (`Bd', `D1'...) cannot be nested. */

	if (MDOC_BLOCK != n->type)
		return(1);

	/* LINTED */
	for (node = mdoc->last->parent; node; node = node->parent) 
		if (MDOC_BLOCK == node->type)
			if (MDOC_Bd == node->tok)
				break;
	if (NULL == node)
		return(1);

	return(nerr(mdoc, n, ENESTDISP));
}


static int
pre_bl(PRE_ARGS)
{
	int		 i, type, width, offset;

	if (MDOC_BLOCK != n->type)
		return(1);
	if (NULL == n->args)
		return(nerr(mdoc, n, ELISTTYPE));

	/* Make sure that only one type of list is specified.  */

	type = offset = width = -1;

	/* LINTED */
	for (i = 0; i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Column):
			if (-1 == type) {
				type = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EMULTILIST));
		case (MDOC_Width):
			if (-1 == width) {
				width = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EARGREP));
		case (MDOC_Offset):
			if (-1 == offset) {
				offset = n->args->argv[i].arg;
				break;
			}
			return(nerr(mdoc, n, EARGREP));
		default:
			break;
		}

	if (-1 == type)
		return(nerr(mdoc, n, ELISTTYPE));

	switch (type) {
	case (MDOC_Column):
		/* FALLTHROUGH */
	case (MDOC_Diag):
		/* FALLTHROUGH */
	case (MDOC_Inset):
		/* FALLTHROUGH */
	case (MDOC_Item):
		if (-1 == width)
			break;
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX,
				"superfluous %s argument",
				mdoc_argnames[MDOC_Width]));
	case (MDOC_Tag):
		if (-1 != width)
			break;
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX, 
				"suggest %s argument", 
				mdoc_argnames[MDOC_Width]));
	default:
		break;
	}

	return(1);
}


static int
pre_bd(PRE_ARGS)
{
	int		 i, type, err;

	if (MDOC_BLOCK != n->type)
		return(1);
	if (NULL == n->args) 
		return(nerr(mdoc, n, EDISPTYPE));

	/* Make sure that only one type of display is specified.  */

	/* LINTED */
	for (i = 0, err = type = 0; ! err && 
			i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			/* FALLTHROUGH */
		case (MDOC_File):
			if (0 == type++) 
				break;
			return(nerr(mdoc, n, EMULTIDISP));
		default:
			break;
		}

	if (type)
		return(1);
	return(nerr(mdoc, n, EDISPTYPE));
}


static int
pre_ss(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, MDOC_Sh, MDOC_BODY));
}


static int
pre_sh(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, -1, MDOC_ROOT));
}


static int
pre_it(PRE_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);
	return(check_parent(mdoc, n, MDOC_Bl, MDOC_BODY));
}


static int
pre_an(PRE_ARGS)
{

	if (NULL == n->args || 1 == n->args->argc)
		return(1);
	return(mdoc_nerr(mdoc, n, "only one argument allowed"));
}


static int
pre_lb(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_LIBRARY, SEC_CUSTOM));
}


static int
pre_rv(PRE_ARGS)
{

	if ( ! check_msec(mdoc, n, 2, 3, 0))
		return(0);
	return(check_stdarg(mdoc, n));
}


static int
pre_ex(PRE_ARGS)
{

	if ( ! check_msec(mdoc, n, 1, 6, 8, 0))
		return(0);
	return(check_stdarg(mdoc, n));
}


static int
pre_er(PRE_ARGS)
{

	return(check_msec(mdoc, n, 2, 0));
}


static int
pre_cd(PRE_ARGS)
{

	return(check_msec(mdoc, n, 4, 0));
}


static int
pre_prologue(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_PROLOGUE, SEC_CUSTOM));
}


static int
pre_dt(PRE_ARGS)
{

	if (0 == mdoc->meta.date || mdoc->meta.os)
		if ( ! nwarn(mdoc, n, WPROLOOO))
			return(0);
	if (mdoc->meta.title)
		if ( ! nwarn(mdoc, n, WPROLREP))
			return(0);
	return(1);
}


static int
pre_os(PRE_ARGS)
{

	if (NULL == mdoc->meta.title || 0 == mdoc->meta.date)
		if ( ! nwarn(mdoc, n, WPROLOOO))
			return(0);
	if (mdoc->meta.os)
		if ( ! nwarn(mdoc, n, WPROLREP))
			return(0);
	return(1);
}


static int
pre_dd(PRE_ARGS)
{

	if (mdoc->meta.title || mdoc->meta.os)
		if ( ! nwarn(mdoc, n, WPROLOOO))
			return(0);
	if (mdoc->meta.date)
		if ( ! nwarn(mdoc, n, WPROLREP))
			return(0);
	return(1);
}


static int
post_bf(POST_ARGS)
{
	char		 *p;
	struct mdoc_node *head;

	if (MDOC_BLOCK != mdoc->last->type)
		return(1);

	head = mdoc->last->head;

	if (NULL == mdoc->last->args) {
		if (NULL == head->child || 
				MDOC_TEXT != head->child->type)
			return(mdoc_err(mdoc, "text argument expected"));

		p = head->child->string;
		if (xstrcmp(p, "Em"))
			return(1);
		else if (xstrcmp(p, "Li"))
			return(1);
		else if (xstrcmp(p, "Sm"))
			return(1);
		return(mdoc_nerr(mdoc, head->child, "invalid font"));
	}

	if (head->child)
		return(mdoc_err(mdoc, "one argument expected"));

	return(1);
}


static int
post_nm(POST_ARGS)
{

	if (mdoc->last->child)
		return(1);
	if (mdoc->meta.name)
		return(1);
	return(merr(mdoc, ENAME));
}


static int
post_at(POST_ARGS)
{

	if (NULL == mdoc->last->child)
		return(1);
	if (MDOC_TEXT != mdoc->last->child->type)
		return(merr(mdoc, EATT));
	if (mdoc_a2att(mdoc->last->child->string))
		return(1);
	return(merr(mdoc, EATT));
}


static int
post_an(POST_ARGS)
{

	if (mdoc->last->args) {
		if (NULL == mdoc->last->child)
			return(1);
		return(merr(mdoc, ELINE));
	}

	if (mdoc->last->child)
		return(1);
	return(merr(mdoc, ELINE));
}


static int
post_args(POST_ARGS)
{

	if (mdoc->last->args)
		return(1);
	return(merr(mdoc, ELINE));
}


static int
post_it(POST_ARGS)
{
	int		  type, i, cols;
	struct mdoc_node *n, *c;

	if (MDOC_BLOCK != mdoc->last->type)
		return(1);

	n = mdoc->last->parent->parent;
	if (NULL == n->args)
		return(merr(mdoc, ELISTTYPE));

	/* Some types require block-head, some not. */

	/* LINTED */
	for (cols = type = -1, i = 0; -1 == type && 
			i < (int)n->args->argc; i++)
		switch (n->args->argv[i].arg) {
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Item):
			type = n->args->argv[i].arg;
			break;
		case (MDOC_Column):
			type = n->args->argv[i].arg;
			cols = (int)n->args->argv[i].sz;
			break;
		default:
			break;
		}

	if (-1 == type)
		return(merr(mdoc, ELISTTYPE));

	switch (type) {
	case (MDOC_Tag):
		if (NULL == mdoc->last->head->child)
			if ( ! mwarn(mdoc, WLINE))
				return(0);
		break;
	case (MDOC_Hang):
		/* FALLTHROUGH */
	case (MDOC_Ohang):
		/* FALLTHROUGH */
	case (MDOC_Inset):
		/* FALLTHROUGH */
	case (MDOC_Diag):
		if (NULL == mdoc->last->head->child)
			if ( ! mwarn(mdoc, WLINE))
				return(0);
		if (NULL == mdoc->last->body->child)
			if ( ! mwarn(mdoc, WMULTILINE))
				return(0);
		break;
	case (MDOC_Bullet):
		/* FALLTHROUGH */
	case (MDOC_Dash):
		/* FALLTHROUGH */
	case (MDOC_Enum):
		/* FALLTHROUGH */
	case (MDOC_Hyphen):
		/* FALLTHROUGH */
	case (MDOC_Item):
		if (mdoc->last->head->child)
			if ( ! mwarn(mdoc, WNOLINE))
				return(0);
		if (NULL == mdoc->last->body->child)
			if ( ! mwarn(mdoc, WMULTILINE))
				return(0);
		break;
	case (MDOC_Column):
		if (NULL == mdoc->last->head->child)
			if ( ! mwarn(mdoc, WLINE))
				return(0);
		if (mdoc->last->body->child)
			if ( ! mwarn(mdoc, WNOMULTILINE))
				return(0);
		c = mdoc->last->child;
		for (i = 0; c && MDOC_HEAD == c->type; c = c->next)
			i++;
		if (i == cols)
			break;
		return(mdoc_err(mdoc, "column mismatch (have "
					"%d, want %d)", i, cols));
	default:
		break;
	}

	return(1);
}


static int
post_bl(POST_ARGS)
{
	struct mdoc_node	*n;

	if (MDOC_BODY != mdoc->last->type)
		return(1);
	if (NULL == mdoc->last->child)
		return(1);

	/* LINTED */
	for (n = mdoc->last->child; n; n = n->next) {
		if (MDOC_BLOCK == n->type) 
			if (MDOC_It == n->tok)
				continue;
		return(mdoc_nerr(mdoc, n, "bad child of parent %s",
				mdoc_macronames[mdoc->last->tok]));
	}

	return(1);
}


static int
ebool(struct mdoc *mdoc)
{
	struct mdoc_node *n;

	/* LINTED */
	for (n = mdoc->last->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			break;
		if (xstrcmp(n->string, "on"))
			continue;
		if (xstrcmp(n->string, "off"))
			continue;
		break;
	}

	if (NULL == n)
		return(1);
	return(nerr(mdoc, n, EBOOL));
}


static int
post_root(POST_ARGS)
{

	if (NULL == mdoc->first->child)
		return(merr(mdoc, ENODATA));
	if (SEC_PROLOGUE == mdoc->lastnamed)
		return(merr(mdoc, ENOPROLOGUE));

	if (MDOC_BLOCK != mdoc->first->child->type)
		return(merr(mdoc, ENODATA));
	if (MDOC_Sh != mdoc->first->child->tok)
		return(merr(mdoc, ENODATA));

	return(1);
}


static int
post_st(POST_ARGS)
{

	if (mdoc_a2st(mdoc->last->child->string))
		return(1);
	return(mwarn(mdoc, WBADSTAND));
}


static int
post_sh(POST_ARGS)
{

	if (MDOC_HEAD == mdoc->last->type)
		return(post_sh_head(mdoc));
	if (MDOC_BODY == mdoc->last->type)
		return(post_sh_body(mdoc));

	return(1);
}


static int
post_sh_body(POST_ARGS)
{
	struct mdoc_node *n;

	if (SEC_NAME != mdoc->lastnamed)
		return(1);

	/*
	 * Warn if the NAME section doesn't contain the `Nm' and `Nd'
	 * macros (can have multiple `Nm' and one `Nd').  Note that the
	 * children of the BODY declaration can also be "text".
	 */

	if (NULL == (n = mdoc->last->child))
		return(mwarn(mdoc, WNAMESECINC));

	for ( ; n && n->next; n = n->next) {
		if (MDOC_ELEM == n->type && MDOC_Nm == n->tok)
			continue;
		if (MDOC_TEXT == n->type)
			continue;
		if ( ! mwarn(mdoc, WNAMESECINC))
			return(0);
	}

	if (MDOC_ELEM == n->type && MDOC_Nd == n->tok)
		return(1);
	return(mwarn(mdoc, WNAMESECINC));
}


static int
post_sh_head(POST_ARGS)
{
	char		  buf[64];
	enum mdoc_sec	  sec;

	/*
	 * Process a new section.  Sections are either "named" or
	 * "custom"; custom sections are user-defined, while named ones
	 * usually follow a conventional order and may only appear in
	 * certain manual sections.
	 */

	assert(MDOC_Sh == mdoc->last->tok);

	(void)xstrlcpys(buf, mdoc->last->child, sizeof(buf));

	sec = mdoc_atosec(buf);

	/* The NAME section should always be first. */

	if (SEC_BODY == mdoc->lastnamed && SEC_NAME != sec)
		return(mwarn(mdoc, WSECOOO));
	if (SEC_CUSTOM == sec)
		return(1);

	/* Check for repeated or out-of-order sections. */

	if (sec == mdoc->lastnamed)
		return(mwarn(mdoc, WSECREP));
	if (sec < mdoc->lastnamed)
		return(mwarn(mdoc, WSECOOO));

	/* Check particular section/manual section conventions. */

	switch (sec) {
	case (SEC_LIBRARY):
		switch (mdoc->meta.msec) {
		case (2):
			/* FALLTHROUGH */
		case (3):
			break;
		default:
			return(mwarn(mdoc, WWRONGMSEC));
		}
		break;
	default:
		break;
	}

	return(1);
}


static int
pre_fd(PRE_ARGS)
{

	return(check_sec(mdoc, n, SEC_SYNOPSIS, SEC_CUSTOM));
}
@


1.92
log
@Fixes to dynamic addition of Bl width.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.91 2009/03/21 13:47:02 kristaps Exp $ */
d26 1
a26 1
#include "private.h"
@


1.91
log
@Freed more macros from zero-length restrictions.
Fixed `Fn' spacing.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.90 2009/03/21 13:37:31 kristaps Exp $ */
d842 2
a843 1
		return(mdoc_nerr(mdoc, n, "missing %s argument",
@


1.90
log
@More macros freed from unnecessary limitations on numargs.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.89 2009/03/21 13:09:29 kristaps Exp $ */
d223 1
a223 1
	{ NULL, posts_text },			/* Fa */ 
@


1.89
log
@`Em' accepts empty tokens.
Punctuation fully fixed (per-reserved-word).
Sm enabled.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.88 2009/03/21 09:48:30 kristaps Exp $ */
d219 1
a219 1
	{ NULL, posts_text },			/* Dv */ 
d221 1
a221 1
	{ NULL, posts_text },			/* Ev */ 
d230 1
a230 1
	{ NULL, posts_text },			/* Li */
d238 1
a238 1
	{ NULL, posts_text },			/* Va */
@


1.88
log
@Lint fixes.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.87 2009/03/21 09:42:07 kristaps Exp $ */
d268 1
a268 1
	{ NULL, posts_text },			/* Em */ 
@


1.87
log
@Added %Q macro.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.86 2009/03/20 15:14:01 kristaps Exp $ */
d710 2
a711 1
		if ((c = mdoc_isescape(p))) {
@


1.86
log
@Support for `Bd' of all types (see mdoc.7 for newline/tab rules).
Renamed term.c and terminal.c functions to be term_.
Some bugfixes to lists.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.85 2009/03/16 23:37:28 kristaps Exp $ */
d318 1
@


1.85
log
@Changed e-mail address to @@openbsd.
Cleaned up manual-page documentation.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.84 2009/03/16 22:19:19 kristaps Exp $ */
d43 1
d60 1
a196 1
static	v_post	posts_rs[] = { herr_eq0, bwarn_ge1, NULL };
a197 2
static	v_post	posts_bk[] = { herr_eq0, bwarn_ge1, NULL };
static	v_post	posts_fd[] = { ewarn_ge1, NULL };
d224 1
a224 1
	{ pres_fd, posts_fd },			/* Fd */
d285 1
a285 1
	{ NULL, posts_rs },			/* Rs */
d300 1
a300 1
	{ NULL, posts_bk },			/* Bk */
d386 3
d463 3
a697 1
	/* FIXME: don't allow tabs unless in literal mode. */
d700 4
a703 1
		if ('\t' != *p && ! isprint((u_char)*p))
d705 1
d708 1
d714 2
a715 4
			return(mdoc_perr(mdoc, line, pos, 
					"invalid escape sequence"));
		if ( ! mdoc_pwarn(mdoc, line, pos, WARN_SYNTAX,
					"invalid escape sequence"))
@


1.84
log
@Fixed mdoc_phrase escape handling.
Added MDOC_IGNDELIM (Pf, soon Li, etc.).
macro_constant_delimited ignargs -> argv.c parsing.
Renamed macro functions to correspond to ontologies.
`Fo' and `St' made callable (compat documented).
strings.sh deprecated (directly using CPP).
Abstracted ASCII translation into ascii.{c,in}.
ASCII table uses a self-reordering chained hashtable.
Removed old regressions.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.83 2009/03/13 13:56:13 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
d318 1
@


1.83
log
@Finished initial mdoc.7.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.82 2009/03/12 16:30:50 kristaps Exp $ */
d43 1
d85 2
a86 4
static	int	nwarn(struct mdoc *, 
			const struct mdoc_node *, enum mwarn);
static	int	nerr(struct mdoc *, 
			const struct mdoc_node *, enum merr);
d91 1
a91 2
static	int	check_text(struct mdoc *, 
			int, int, const char *);
d152 5
d316 2
d323 1
a323 1
		const struct mdoc_node *node)
d329 4
a332 4
	if (MDOC_TEXT == node->type) {
		tp = node->string;
		line = node->line;
		pos = node->pos;
d336 1
a336 1
	if ( ! check_args(mdoc, node))
d338 1
a338 1
	if (NULL == mdoc_valids[node->tok].pre)
d340 2
a341 2
	for (p = mdoc_valids[node->tok].pre; *p; p++)
		if ( ! (*p)(mdoc, node)) 
a378 1
#define	merr(m, t) nerr((m), (m)->last, (t))
d380 1
a380 1
nerr(struct mdoc *m, const struct mdoc_node *n, enum merr type)
a384 1

d386 3
a425 1

d427 1
a427 1
	return(mdoc_nerr(m, n, p));
a430 1
#define	mwarn(m, t) nwarn((m), (m)->last, (t))
d432 1
a432 1
nwarn(struct mdoc *m, const struct mdoc_node *n, enum mwarn type)
a438 1

d490 1
a490 1
	return(mdoc_nwarn(m, n, c, p));
d691 2
a692 1
	/* XXX - indicate deprecated escapes \*(xx and \*x. */
d695 2
a696 3
		if ( ! isprint((u_char)*p) && '\t' != *p)
			return(mdoc_perr(mdoc, line, pos,
				"invalid non-printing character"));
@


1.82
log
@Added -nested (doesn't do anything).
Added .%C.
.Cd is now callable.
Added .Rv -std.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.81 2009/03/12 06:32:17 kristaps Exp $ */
a182 1
static	v_post	posts_mt[] = { eerr_ge1, NULL };
a189 1
static	v_post	posts_lk[] = { eerr_ge1, NULL };
d305 4
a308 4
	{ NULL, NULL },				/* Lb */
	{ NULL, posts_pp },			/* Pp */ 
	{ NULL, posts_lk },			/* Lk */ 
	{ NULL, posts_mt },			/* Mt */ 
@


1.81
log
@Removed segfault with empty word.
Initial "full" -column support.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.80 2009/03/12 02:57:36 kristaps Exp $ */
d142 1
a145 1
static	int	post_ex(POST_ARGS);
d186 2
a187 1
static	v_post	posts_ex[] = { eerr_eq0, post_ex, NULL };
d236 1
a236 1
	{ pres_rv, posts_notext },		/* Rv */
d314 1
d674 1
a674 1
	if (MDOC_Std == v->arg && MDOC_Ex == n->tok) {
d1089 1
a1089 1
post_ex(POST_ARGS)
@


1.80
log
@Brq/Bro/Brc fixed up and pretty.
Cleaned up Aq/Sq use of escapes in term.c.
Added initial -column support.
Fixed argv returning ARGV_WORD and tokenising anyway.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.79 2009/03/11 00:39:58 kristaps Exp $ */
d1190 1
a1190 1
		c = mdoc->last->head;
d1195 2
a1196 4
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"column mismatch (have %d, want %d)", i, cols))
			return(0);
		break;
@


1.79
log
@Expanded perfect htab to use 27 * 26 * 3 space.
Added Brq, Bro and Brc macros.
Added lbrace and rbrace to special characters.
Fixed spacing in braces.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.78 2009/03/09 14:19:59 kristaps Exp $ */
d1190 2
a1191 2
		c = mdoc->last->head->child;
		for (i = 0; c; c = c->next)
@


1.78
log
@Added `Mt' and `Lk' macros (NetBSD).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.77 2009/03/09 13:17:50 kristaps Exp $ */
d310 3
@


1.77
log
@Easier integration into FreeBSD (sys/types.h, time.h, etc.).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.76 2009/03/08 20:57:35 kristaps Exp $ */
d140 1
d183 1
d190 1
d308 2
@


1.76
log
@Added `Lp' macro.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.75 2009/03/08 20:50:12 kristaps Exp $ */
d19 2
@


1.75
log
@Added .Ap.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.74 2009/03/08 18:02:36 kristaps Exp $ */
d302 1
@


1.74
log
@Updated manuals.
Added -fign-scope and -fign-escape.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.73 2009/03/08 12:40:27 kristaps Exp $ */
d301 1
@


1.73
log
@Memory fixes in new dynamic schema.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.72 2009/03/08 11:48:44 kristaps Exp $ */
d688 6
a693 1
		return(mdoc_perr(mdoc, line, pos, "invalid escape"));
@


1.72
log
@Printing invalid escape sequences.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.71 2009/03/08 11:41:22 kristaps Exp $ */
d641 1
d688 1
a688 2
		return(mdoc_perr(mdoc, line, pos, 
				"invalid escape sequence: %s", p));
d894 1
a894 1
	if (n->args && 1 >= n->args->argc)
@


1.71
log
@BROKEN CHECK-IN.  Wide-ranging updates.
Removed libmdoc internal argv limit (all dynamic).
Removed "data" union in mdoc_node (to be selectively re-added).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.70 2009/03/06 14:24:49 kristaps Exp $ */
d688 1
a688 1
				"invalid escape sequence"));
@


1.70
log
@Documented the strings script.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.69 2009/03/06 14:13:47 kristaps Exp $ */
d27 1
d40 32
a74 2
/* TODO: ignoring Pp (it's superfluous in some invocations). */

d82 4
a89 1

d94 3
a96 2
			const struct mdoc_arg *);

a102 3

/* Utility auxiliaries. */

a107 3

/* Specific pre-child-parse routines. */

a124 3

/* Specific post-child-parse routines. */

a128 1
static	int	eerr_le1(POST_ARGS);
a137 1

a150 2
/* Collections of pre-child-parse routines. */

a166 3

/* Collections of post-child-parse routines. */

d182 1
a182 1
static	v_post	posts_ex[] = { eerr_le1, post_ex, NULL };
a192 2
/* Per-macro pre- and post-child-check routine collections. */

d309 1
a309 3
	struct mdoc_arg	*argv;
	size_t		 argc;
	int		 line, pos, i, j;
d313 1
a313 1
		tp = node->data.text.string;
d319 2
a320 21
	if (MDOC_BLOCK == node->type || MDOC_ELEM == node->type) {
		argv = MDOC_BLOCK == node->type ?
			node->data.block.argv :
			node->data.elem.argv;
		argc = MDOC_BLOCK == node->type ?
			node->data.block.argc :
			node->data.elem.argc;

		for (i = 0; i < (int)argc; i++) {
			for (j = 0; j < (int)argv[i].sz; j++) {
				tp = argv[i].value[j];
				line = argv[i].line;
				pos = argv[i].pos;
				if ( ! check_text(mdoc, line, pos, tp))
					return(0);
			}
			if ( ! check_argv(mdoc, node, &argv[i]))
				return(0);
		}
	}

d362 117
d486 1
a486 2
				"suggests %s %s %d (has %d)", 
				v, k, want, has));
d495 2
a496 2
	return(mdoc_err(m, "requires %s %s %d (has %d)",
				v, k, want, has));
d535 1
a535 1
	return(func(mdoc, "multiline parameters", (num))); 	\
d543 1
a543 1
	return(func(mdoc, "line parameters", (num))); 		\
d552 1
a552 1
	return(func(mdoc, "line parameters", (num)));	 	\
a567 1
CHECK_ELEM_DEFN(le1, err, err_child_lt, 2)	/* eerr_le1() */
d580 4
a583 6
	if (MDOC_Std == n->data.elem.argv[0].arg && 
			1 == n->data.elem.argc)
		return(1);

	return(mdoc_nwarn(mdoc, n, WARN_COMPAT, 
				"one argument suggested"));
d596 1
d607 1
a607 2
	return(mdoc_nwarn(mdoc, n, WARN_COMPAT, 
		"inappropriate document section for macro"));
d619 1
d629 1
a629 2
	return(mdoc_nwarn(mdoc, n, WARN_COMPAT, 
		"inappropriate manual section for macro"));
a632 4
/*
 * Check over an argument.  When this has more stuff in it, make this
 * into a table-driven function; until then, a switch is fine.
 */
d634 18
a651 3
check_argv(struct mdoc *mdoc, 
		const struct mdoc_node *node,
		const struct mdoc_arg *argv)
d653 1
d655 3
d659 5
a663 22
	switch (argv->arg) {
	case (MDOC_Std):
		switch (node->tok) {
		case (MDOC_Ex):
			/*
			 * If the -std does not have an argument, then
			 * set it with the default name (if set).  This
			 * only happens with MDOC_Ex.
			 */
			if (1 == argv->sz)
				return(1);
			assert(0 == argv->sz);
			if (mdoc->meta.name)
				return(1);
			return(mdoc_nerr(mdoc, node, 
					"default name not yet set"));
		default:
			break;
		}
		break;
	default:
		break;
d680 1
a680 1
				"invalid non-printing characters"));
d730 1
a730 1
	return(mdoc_nerr(mdoc, n, "displays may not be nested"));
d737 1
a737 3
	int		 type, i, width, offset;
	struct mdoc_arg	*argv;
	size_t		 argc;
d741 2
a742 2

	argc = n->data.block.argc; 
d749 2
a750 4
	for (i = 0; i < (int)argc; i++) {
		argv = &n->data.block.argv[i];

		switch (argv->arg) {
d773 1
a773 1
				type = argv->arg;
d776 1
a776 2
			return(mdoc_perr(mdoc, argv->line, argv->pos, 
					"multiple types specified"));
d779 1
a779 1
				width = argv->arg;
d782 1
a782 3
			return(mdoc_perr(mdoc, argv->line, argv->pos, 
					"multiple -%s arguments",
					mdoc_argnames[MDOC_Width]));
d785 1
a785 1
				offset = argv->arg;
d788 1
a788 3
			return(mdoc_perr(mdoc, argv->line, argv->pos, 
					"multiple -%s arguments",
					mdoc_argnames[MDOC_Offset]));
a791 1
	}
d794 1
a794 1
		return(mdoc_err(mdoc, "no type specified"));
d807 1
a807 1
				"superfluous -%s argument",
d810 4
a813 5
		if (-1 == width && ! mdoc_nwarn(mdoc, n, WARN_SYNTAX, 
					"suggest -%s argument",
					mdoc_argnames[MDOC_Width]))
			return(0);
		break;
d825 1
a825 3
	int		 type, err, i;
	struct mdoc_arg	*argv;
	size_t		 argc;
d829 2
a830 2

	argc = n->data.block.argc;
d835 3
a837 4
	for (i = 0, err = type = 0; ! err && i < (int)argc; i++) {
		argv = &n->data.block.argv[i];

		switch (argv->arg) {
d849 1
a849 2
			return(mdoc_perr(mdoc, argv->line, argv->pos, 
					"multiple types specified"));
a852 1
	}
d856 1
a856 1
	return(mdoc_err(mdoc, "no type specified"));
d894 1
a894 1
	if (1 >= n->data.elem.argc)
d896 1
a896 1
	return(mdoc_nerr(mdoc, n, "one argument allowed"));
d957 1
a957 2
		if ( ! mdoc_nwarn(mdoc, n, WARN_COMPAT, 
					"out-of-order prologue"))
d960 1
a960 2
		if ( ! mdoc_nwarn(mdoc, n, WARN_COMPAT, 
					"prologue re-invoked"))
d971 1
a971 2
		if ( ! mdoc_nwarn(mdoc, n, WARN_COMPAT, 
					"out-of-order prologue"))
d974 1
a974 2
		if ( ! mdoc_nwarn(mdoc, n, WARN_COMPAT, 
					"prologue re-invoked"))
d985 1
a985 2
		if ( ! mdoc_nwarn(mdoc, n, WARN_COMPAT,
					"out-of-order prologue"))
d988 1
a988 2
		if ( ! mdoc_nwarn(mdoc, n, WARN_COMPAT,
					"prologue re-invoked"))
d1003 1
a1003 1
	head = mdoc->last->data.block.head;
d1005 4
a1008 3
	if (0 == mdoc->last->data.block.argc) {
		if (NULL == head->child)
			return(mdoc_err(mdoc, "argument expected"));
d1010 1
a1010 1
		p = head->child->data.text.string;
d1021 1
a1021 1
		return(mdoc_err(mdoc, "argument expected"));
d1023 1
a1023 3
	if (1 == mdoc->last->data.block.argc)
		return(1);
	return(mdoc_err(mdoc, "argument expected"));
d1035 1
a1035 1
	return(mdoc_err(mdoc, "not yet invoked with name"));
d1045 3
a1047 1
	if (mdoc_a2att(mdoc->last->child->data.text.string))
d1049 1
a1049 1
	return(mdoc_err(mdoc, "require valid AT&T symbol"));
d1057 1
a1057 1
	if (0 != mdoc->last->data.elem.argc) {
d1060 1
a1060 1
		return(mdoc_err(mdoc, "argument(s) expected"));
d1065 1
a1065 1
	return(mdoc_err(mdoc, "argument(s) expected"));
d1073 3
a1075 13
	if (0 == mdoc->last->data.elem.argc) {
		if (mdoc->last->child)
			return(1);
		return(mdoc_err(mdoc, "argument(s) expected"));
	}
	if (mdoc->last->child)
		return(mdoc_err(mdoc, "argument(s) expected"));
	if (1 != mdoc->last->data.elem.argc)
		return(mdoc_err(mdoc, "argument(s) expected"));
	if (MDOC_Std != mdoc->last->data.elem.argv[0].arg)
		return(mdoc_err(mdoc, "argument(s) expected"));

	return(1);
d1082 2
a1083 7
	int		  type, sv, i;
#define	TYPE_NONE	 (0)
#define	TYPE_BODY	 (1)
#define	TYPE_HEAD	 (2)
#define	TYPE_OHEAD	 (3)
	size_t		  argc;
	struct mdoc_node *n;
d1089 2
a1091 4
	argc = n->data.block.argc;
	type = TYPE_NONE;
	sv = -1;
	
d1095 3
a1097 2
	for (i = 0; TYPE_NONE == type && i < (int)argc; i++)
		switch (n->data.block.argv[i].arg) {
d1107 1
a1107 3
			type = TYPE_HEAD;
			sv = n->data.block.argv[i].arg;
			break;
d1117 1
a1117 2
			type = TYPE_BODY;
			sv = n->data.block.argv[i].arg;
d1120 2
a1121 2
			type = TYPE_OHEAD;
			sv = n->data.block.argv[i].arg;
d1127 2
a1128 1
	assert(TYPE_NONE != type);
d1130 15
a1144 6
	n = mdoc->last->data.block.head;

	if (TYPE_HEAD == type) {
		if (NULL == n->child)
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"argument(s) suggested"))
d1146 2
a1147 5

		n = mdoc->last->data.block.body;
		if (NULL == n->child)
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"multiline body suggested"))
d1149 12
a1160 5

	} else if (TYPE_BODY == type) {
		if (n->child)
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"no argument suggested"))
d1162 2
a1163 5
	
		n = mdoc->last->data.block.body;
		if (NULL == n->child)
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"multiline body suggested"))
d1165 4
a1168 4
	} else {
		if (NULL == n->child)
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"argument(s) suggested"))
d1170 2
a1171 5
	
		n = mdoc->last->data.block.body;
		if (n->child)
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, 
					"no multiline body suggested"))
d1173 11
d1186 1
a1186 17
	if (MDOC_Column != sv)
		return(1);

	argc = mdoc->last->parent->parent->data.block.argv->sz;
	n = mdoc->last->data.block.head->child;

	for (i = 0; n; n = n->next)
		i++;

	if (i == (int)argc)
		return(1);

	return(mdoc_err(mdoc, "need %zu columns (have %d)", argc, i));
#undef	TYPE_NONE
#undef	TYPE_BODY
#undef	TYPE_HEAD
#undef	TYPE_OHEAD
d1197 1
a1197 1
	if (NULL == (mdoc->last->child))
a1199 5
	/*
	 * Only allow `It' macros to be the immediate descendants of the
	 * `Bl' list. 
	 */

a1204 1

d1222 1
a1222 1
		if (xstrcmp(n->data.text.string, "on"))
d1224 1
a1224 1
		if (xstrcmp(n->data.text.string, "off"))
d1231 1
a1231 1
	return(mdoc_nerr(mdoc, n, "expected boolean"));
d1240 1
a1240 1
		return(mdoc_err(mdoc, "document lacks data"));
d1242 1
a1242 1
		return(mdoc_err(mdoc, "document lacks prologue"));
d1245 1
a1245 2
		return(mdoc_err(mdoc, "lacking post-prologue %s", 
					mdoc_macronames[MDOC_Sh]));
d1247 1
a1247 2
		return(mdoc_err(mdoc, "lacking post-prologue %s", 
					mdoc_macronames[MDOC_Sh]));
d1257 1
a1257 1
	if (mdoc_a2st(mdoc->last->child->data.text.string))
d1259 1
a1259 2

	return(mdoc_warn(mdoc, WARN_SYNTAX, "invalid standard"));
d1291 1
a1291 4
		return(mdoc_warn(mdoc, WARN_SYNTAX, 
					"section should have %s and %s",
					mdoc_macronames[MDOC_Nm],
					mdoc_macronames[MDOC_Nd]));
d1298 1
a1298 3
		if ( ! (mdoc_nwarn(mdoc, n, WARN_SYNTAX, 
					"section should have %s first",
					mdoc_macronames[MDOC_Nm])))
d1304 1
a1304 4

	return(mdoc_warn(mdoc, WARN_SYNTAX, 
				"section should have %s last",
				mdoc_macronames[MDOC_Nd]));
d1330 1
a1330 2
		return(mdoc_warn(mdoc, WARN_SYNTAX, 
				"section NAME should be first"));
d1337 1
a1337 2
		return(mdoc_warn(mdoc, WARN_SYNTAX, 
				"section repeated"));
d1339 1
a1339 2
		return(mdoc_warn(mdoc, WARN_SYNTAX, 
				"section out of conventional order"));
d1351 1
a1351 2
			return(mdoc_warn(mdoc, WARN_COMPAT,
				"section in wrong manual section"));
@


1.69
log
@Strings abstracted into dynamically-created C files.
Added -V option.
Deprecated README files.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.68 2009/03/05 13:12:12 kristaps Exp $ */
d487 2
a488 1
		if (SEC_CUSTOM == (sec = va_arg(ap, enum mdoc_sed)))
@


1.68
log
@Cleaned up ctype functions (netbsd).
Fixed .Ex/.Rv -std usage.
Made Ar provide default value.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.67 2009/03/04 13:57:35 kristaps Exp $ */
d21 1
d52 2
a53 1
static	int	check_msec(PRE_ARGS, int, enum mdoc_msec *);
d79 1
a79 3
static	int	pre_display(PRE_ARGS);
static	int	pre_sh(PRE_ARGS);
static	int	pre_ss(PRE_ARGS);
a81 1
static	int	pre_it(PRE_ARGS);
d83 3
d88 5
d94 2
a95 5
static	int	pre_an(PRE_ARGS);
static	int	pre_st(PRE_ARGS);
static	int	pre_prologue(PRE_ARGS);
static	int	pre_prologue(PRE_ARGS);
static	int	pre_prologue(PRE_ARGS);
d114 3
a116 4
static	int	post_sh(POST_ARGS);
static	int	post_sh_body(POST_ARGS);
static	int	post_sh_head(POST_ARGS);
static	int	post_fd(POST_ARGS);
d118 1
a119 4
static	int	post_ex(POST_ARGS);
static	int	post_an(POST_ARGS);
static	int	post_at(POST_ARGS);
static	int	post_xr(POST_ARGS);
a120 1
static	int	post_bf(POST_ARGS);
d122 4
d129 1
a129 2
static	v_pre	pres_prologue[] = { pre_prologue, NULL };
static	v_pre	pres_d1[] = { pre_display, NULL };
a131 3
static	v_pre	pres_it[] = { pre_it, NULL };
static	v_pre	pres_ss[] = { pre_ss, NULL };
static	v_pre	pres_sh[] = { pre_sh, NULL };
d133 3
d138 4
d143 2
a144 2
static	v_pre	pres_an[] = { pre_an, NULL };
static	v_pre	pres_st[] = { pre_st, NULL };
d160 2
d166 1
a166 1
static	v_post	posts_xr[] = { eerr_ge1, eerr_le2, post_xr, NULL };
d172 1
a172 1
static	v_post	posts_fd[] = { ewarn_ge1, post_fd, NULL };
d178 3
a180 3
	{ pres_prologue, posts_text },		/* Dd */
	{ pres_prologue, NULL },		/* Dt */
	{ pres_prologue, NULL },		/* Os */
d201 1
a201 1
	{ NULL, posts_fd },			/* Fd */
d214 1
a214 1
	{ pres_st, posts_notext },		/* St */ 
d283 1
d479 24
a502 1
check_msec(PRE_ARGS, int sz, enum mdoc_msec *msecs)
d504 2
a505 1
	int		 i;
d507 11
a517 3
	for (i = 0; i < sz; i++)
		if (msecs[i] == mdoc->meta.msec)
			return(1);
d519 1
a519 1
				"invalid manual section"));
d799 1
a799 1
pre_st(PRE_ARGS)
d802 1
a802 1
	if (1 == n->data.elem.argc)
d804 1
a804 1
	return(mdoc_nerr(mdoc, n, "one argument required"));
d809 1
a809 1
pre_an(PRE_ARGS)
d812 1
a812 3
	if (1 >= n->data.elem.argc)
		return(1);
	return(mdoc_nerr(mdoc, n, "one argument allowed"));
a818 1
	enum mdoc_msec msecs[] = { MSEC_2, MSEC_3 };
d820 1
a820 1
	if ( ! check_msec(mdoc, n, 2, msecs))
a828 1
	enum mdoc_msec msecs[] = { MSEC_1, MSEC_6, MSEC_8 };
d830 1
a830 1
	if ( ! check_msec(mdoc, n, 3, msecs))
a838 1
	enum mdoc_msec msecs[] = { MSEC_2 };
d840 1
a840 1
	return(check_msec(mdoc, n, 1, msecs));
a846 1
	enum mdoc_msec msecs[] = { MSEC_4 };
d848 1
a848 1
	return(check_msec(mdoc, n, 1, msecs));
d856 2
a857 2
	if (SEC_PROLOGUE != mdoc->lastnamed)
		return(mdoc_nerr(mdoc, n, "prologue only"));
a858 1
	/* Check for ordering. */
d860 30
a889 17
	switch (n->tok) {
	case (MDOC_Os):
		if (mdoc->meta.title && mdoc->meta.date)
			break;
		return(mdoc_nerr(mdoc, n, "prologue out-of-order"));
	case (MDOC_Dt):
		if (NULL == mdoc->meta.title && mdoc->meta.date)
			break;
		return(mdoc_nerr(mdoc, n, "prologue out-of-order"));
	case (MDOC_Dd):
		if (NULL == mdoc->meta.title && 0 == mdoc->meta.date)
			break;
		return(mdoc_nerr(mdoc, n, "prologue out-of-order"));
	default:
		abort();
		/* NOTREACHED */
	}
a890 1
	/* Check for repetition. */
d892 3
a894 17
	switch (n->tok) {
	case (MDOC_Os):
		if (NULL == mdoc->meta.os)
			return(1);
		break;
	case (MDOC_Dd):
		if (0 == mdoc->meta.date)
			return(1);
		break;
	case (MDOC_Dt):
		if (NULL == mdoc->meta.title)
			return(1);
		break;
	default:
		abort();
		/* NOTREACHED */
	}
d896 9
a904 1
	return(mdoc_nerr(mdoc, n, "prologue repetition"));
a954 13
post_xr(POST_ARGS)
{
	struct mdoc_node *n;

	if (NULL == (n = mdoc->last->child->next))
		return(1);
	if (MSEC_DEFAULT != mdoc_atomsec(n->data.text.string))
		return(1);
	return(mdoc_nerr(mdoc, n, "invalid manual section"));
}


static int
d960 1
a960 1
	if (ATT_DEFAULT != mdoc_atoatt(mdoc->last->child->data.text.string))
d962 1
a962 1
	return(mdoc_err(mdoc, "require valid symbol"));
d1191 11
d1260 7
d1269 1
a1269 2
	if ( ! xstrlcats(buf, mdoc->last->child, sizeof(buf)))
		return(mdoc_err(mdoc, "argument too long"));
d1273 2
d1280 3
d1288 19
a1306 1
				"section out of order"));
d1313 1
a1313 1
post_fd(POST_ARGS)
d1316 1
a1316 4
	if (SEC_SYNOPSIS == mdoc->last->sec)
		return(1);
	return(mdoc_warn(mdoc, WARN_COMPAT, 
			"suggested only in section SYNOPSIS"));
@


1.67
log
@Considerably cleaned up list handling.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.66 2009/03/02 17:14:46 kristaps Exp $ */
d56 3
a303 2
			if (0 == argv[i].sz)
				continue;
d311 2
d482 39
d529 1
a529 1
		if ( ! isprint((int)*p) && '\t' != *p)
@


1.66
log
@Added new old escape sequence \*[nn].
Initial correct .Bd support (still only text in literal displays).
Symbols put into tables (character-encoding).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.65 2009/02/28 14:40:07 kristaps Exp $ */
d25 2
@


1.65
log
@Added support for traditional `Ds' width.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.64 2009/02/28 13:47:36 kristaps Exp $ */
d487 1
a487 1
					"invalid characters"));
@


1.64
log
@Added support for dynamic -width detection for -tag lists.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.63 2009/02/27 09:39:40 kristaps Exp $ */
d494 2
a495 2
		return(mdoc_perr(mdoc, line, pos,
					"invalid escape sequence"));
@


1.63
log
@Lintified sources.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.62 2009/02/27 09:14:02 kristaps Exp $ */
d39 1
a39 3
/* FIXME: some sections should only occur in specific msecs. */
/* FIXME: ignoring Pp. */
/* FIXME: math symbols. */
d627 5
a631 5
		if (-1 != width)
			break;
		return(mdoc_nwarn(mdoc, n, WARN_SYNTAX,
				"suggest -%s argument",
				mdoc_argnames[MDOC_Width]));
a706 2
	/* TODO: children too big for -width? */

d1055 7
d1068 3
a1070 1
		break;
d1073 1
a1073 4
	if (NULL == n)
		return(1);

	return(mdoc_nerr(mdoc, n, "bad child of parent list"));
@


1.62
log
@Character-encoding stuff documented, expanded.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.61 2009/02/26 14:56:27 kristaps Exp $ */
d55 1
a55 1
			size_t, size_t, const char *);
d281 2
a282 1
	size_t		 argc, i, j, line, pos;
d300 1
a300 1
		for (i = 0; i < argc; i++) {
d303 1
a303 1
			for (j = 0; j < argv[i].sz; j++) {
d480 1
a480 1
check_text(struct mdoc *mdoc, size_t line, size_t pos, const char *p)
d493 1
a493 1
			p += (c - 1);
@


1.61
log
@Lists (scoped elements) now put delims in-scope.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.60 2009/02/25 12:32:50 kristaps Exp $ */
d483 2
@


1.60
log
@NetBSD Lintified.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.59 2009/02/25 11:37:05 kristaps Exp $ */
d543 1
a543 1
	int		 type, i;
d554 2
d557 1
a557 1
	for (i = 0, type = 0; i < (int)argc; i++) {
d582 2
a583 1
			if (0 == type++)
d585 1
d588 16
d609 27
a635 3
	if (type)
		return(1);
	return(mdoc_err(mdoc, "no type specified"));
a705 1
	/* TODO: -width attribute must be specified for -tag. */
@


1.59
log
@All "low-hanging" macros implemented in term.c.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.58 2009/02/24 16:16:45 kristaps Exp $ */
d484 1
a484 1
		if ( ! isprint(*p) && '\t' != *p)
d543 1
a543 1
	int		 type, err, i;
d555 1
a555 1
	for (i = 0, type = err = 0; i < (int)argc; i++) {
@


1.58
log
@Raft of mdocterm callbacks in place.
Fixed Fo/Fc handling in validate/mdocterm.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.57 2009/02/24 13:57:17 kristaps Exp $ */
d58 1
d93 1
a93 1
static	int	herr_le1(POST_ARGS);
d157 1
a157 1
static	v_post	posts_bf[] = { herr_le1, post_bf, NULL };
d436 1
d447 1
a447 1
CHECK_HEAD_DEFN(le1, err, err_child_lt, 2)	/* herr_le1() */
@


1.57
log
@Added Fd section validation.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.56 2009/02/24 13:46:54 kristaps Exp $ */
d102 1
d158 1
a158 1
static	v_post	posts_fo[] = { bwarn_ge1, NULL };
d359 2
a360 2
				"suggests %s %d %s (has %d)", 
				v, want, k, has));
d369 2
a370 2
	return(mdoc_err(m, "requires %s %d %s (has %d)",
				v, want, k, has));
d426 1
a426 1
	return(func(mdoc, "multiline parameters", (num))); 	\
d447 1
@


1.56
log
@Character-encoding checked for all text (arguments/values).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.55 2009/02/24 12:20:52 kristaps Exp $ */
a41 1
/* FIXME: .Fd only in synopsis section. */
d108 1
d159 1
d188 1
a188 1
	{ NULL, posts_wtext },			/* Fd */
d273 79
d1149 2
a1150 48
int
mdoc_valid_pre(struct mdoc *mdoc, 
		const struct mdoc_node *node)
{
	v_pre		*p;
	struct mdoc_arg	*argv;
	size_t		 argc, i, j, line, pos;
	const char	*tp;

	if (MDOC_TEXT == node->type) {
		tp = node->data.text.string;
		line = node->line;
		pos = node->pos;
		return(check_text(mdoc, line, pos, tp));
	}

	if (MDOC_BLOCK == node->type || MDOC_ELEM == node->type) {
		argv = MDOC_BLOCK == node->type ?
			node->data.block.argv :
			node->data.elem.argv;
		argc = MDOC_BLOCK == node->type ?
			node->data.block.argc :
			node->data.elem.argc;

		for (i = 0; i < argc; i++) {
			if (0 == argv[i].sz)
				continue;
			for (j = 0; j < argv[i].sz; j++) {
				tp = argv[i].value[j];
				line = argv[i].line;
				pos = argv[i].pos;
				if ( ! check_text(mdoc, line, pos, tp))
					return(0);
			}
		}
	}

	if (NULL == mdoc_valids[node->tok].pre)
		return(1);
	for (p = mdoc_valids[node->tok].pre; *p; p++)
		if ( ! (*p)(mdoc, node)) 
			return(0);
	return(1);
}


int
mdoc_valid_post(struct mdoc *mdoc)
a1151 13
	v_post		*p;

	/*
	 * This check occurs after the macro's children have been filled
	 * in: postfix validation.  Since this happens when we're
	 * rewinding the scope tree, it's possible to have multiple
	 * invocations (as by design, for now), we set bit MDOC_VALID to
	 * indicate that we've validated.
	 */

	if (MDOC_VALID & mdoc->last->flags)
		return(1);
	mdoc->last->flags |= MDOC_VALID;
d1153 1
a1153 1
	if (MDOC_TEXT == mdoc->last->type)
d1155 2
a1156 10
	if (MDOC_ROOT == mdoc->last->type)
		return(post_root(mdoc));

	if (NULL == mdoc_valids[mdoc->last->tok].post)
		return(1);
	for (p = mdoc_valids[mdoc->last->tok].post; *p; p++)
		if ( ! (*p)(mdoc)) 
			return(0);

	return(1);
a1157 1

@


1.55
log
@Added character-encoding checks.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.54 2009/02/24 11:43:13 kristaps Exp $ */
d20 1
d400 3
d410 1
a410 1
				"invalid escape sequence"));
@


1.54
log
@Escape-sequence validation in place (for nodes).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.53 2009/02/23 22:51:10 kristaps Exp $ */
d32 5
a36 2
typedef	int	(*v_pre)(struct mdoc *, struct mdoc_node *);
typedef	int	(*v_post)(struct mdoc *);
d50 7
a56 5
static	int	check_parent(struct mdoc *, struct mdoc_node *, 
			int, enum mdoc_type);
static	int	check_msec(struct mdoc *, struct mdoc_node *, 
			int, enum mdoc_msec *);
static	int	check_stdarg(struct mdoc *, struct mdoc_node *);
d73 15
a87 15
static	int	pre_display(struct mdoc *, struct mdoc_node *);
static	int	pre_sh(struct mdoc *, struct mdoc_node *);
static	int	pre_ss(struct mdoc *, struct mdoc_node *);
static	int	pre_bd(struct mdoc *, struct mdoc_node *);
static	int	pre_bl(struct mdoc *, struct mdoc_node *);
static	int	pre_it(struct mdoc *, struct mdoc_node *);
static	int	pre_cd(struct mdoc *, struct mdoc_node *);
static	int	pre_er(struct mdoc *, struct mdoc_node *);
static	int	pre_ex(struct mdoc *, struct mdoc_node *);
static	int	pre_rv(struct mdoc *, struct mdoc_node *);
static	int	pre_an(struct mdoc *, struct mdoc_node *);
static	int	pre_st(struct mdoc *, struct mdoc_node *);
static	int	pre_prologue(struct mdoc *, struct mdoc_node *);
static	int	pre_prologue(struct mdoc *, struct mdoc_node *);
static	int	pre_prologue(struct mdoc *, struct mdoc_node *);
d91 26
a116 26
static	int	herr_ge1(struct mdoc *);
static	int	herr_le1(struct mdoc *);
static	int	herr_eq0(struct mdoc *);
static	int	eerr_eq0(struct mdoc *);
static	int	eerr_le1(struct mdoc *);
static	int	eerr_le2(struct mdoc *);
static	int	eerr_eq1(struct mdoc *);
static	int	eerr_ge1(struct mdoc *);
static	int	ewarn_eq0(struct mdoc *);
static	int	ewarn_eq1(struct mdoc *);
static	int	bwarn_ge1(struct mdoc *);
static	int	ewarn_ge1(struct mdoc *);
static	int	ebool(struct mdoc *);
static	int	post_sh(struct mdoc *);
static	int	post_sh_body(struct mdoc *);
static	int	post_sh_head(struct mdoc *);
static	int	post_bl(struct mdoc *);
static	int	post_it(struct mdoc *);
static	int	post_ex(struct mdoc *);
static	int	post_an(struct mdoc *);
static	int	post_at(struct mdoc *);
static	int	post_xr(struct mdoc *);
static	int	post_nm(struct mdoc *);
static	int	post_bf(struct mdoc *);
static	int	post_root(struct mdoc *);
static	int	pre_text(struct mdoc *, const struct mdoc_node *);
d276 3
a278 2
	return(mdoc_warn(m, WARN_SYNTAX, "suggests %s %d %s "
				"(has %d)", v, want, k, has));
d323 1
a323 1
b##lvl##_##name(struct mdoc *mdoc) 				\
d332 1
a332 1
e##lvl##_##name(struct mdoc *mdoc) 				\
d340 1
a340 1
h##lvl##_##name(struct mdoc *mdoc) 				\
d368 1
a368 1
check_stdarg(struct mdoc *mdoc, struct mdoc_node *node)
d371 2
a372 2
	if (MDOC_Std == node->data.elem.argv[0].arg && 
			1 == node->data.elem.argc)
d375 1
a375 1
	return(mdoc_nwarn(mdoc, node, WARN_COMPAT, 
d381 1
a381 2
check_msec(struct mdoc *mdoc, struct mdoc_node *node, 
		int sz, enum mdoc_msec *msecs)
d388 22
a409 2
	return(mdoc_nwarn(mdoc, node, WARN_COMPAT, 
				"wrong manual section"));
d413 2
d416 1
a416 2
check_parent(struct mdoc *mdoc, struct mdoc_node *n, 
		int tok, enum mdoc_type t)
d431 1
a431 1
pre_display(struct mdoc *mdoc, struct mdoc_node *node)
d433 1
a433 1
	struct mdoc_node *n;
d437 1
a437 1
	if (MDOC_BLOCK != node->type)
d441 3
a443 3
	for (n = mdoc->last->parent; n; n = n->parent) 
		if (MDOC_BLOCK == n->type)
			if (MDOC_Bd == n->tok)
d445 1
a445 1
	if (NULL == n)
d448 1
a448 1
	return(mdoc_nerr(mdoc, node, "displays may not be nested"));
d453 1
a453 1
pre_bl(struct mdoc *mdoc, struct mdoc_node *node)
d459 1
a459 1
	if (MDOC_BLOCK != node->type)
d462 1
a462 1
	argc = node->data.block.argc; 
d468 1
a468 1
		argv = &node->data.block.argv[i];
d508 1
a508 1
pre_bd(struct mdoc *mdoc, struct mdoc_node *node)
d514 1
a514 1
	if (MDOC_BLOCK != node->type)
d517 1
a517 1
	argc = node->data.block.argc;
d523 1
a523 1
		argv = &node->data.block.argv[i];
d551 1
a551 1
pre_ss(struct mdoc *mdoc, struct mdoc_node *node)
d554 1
a554 1
	if (MDOC_BLOCK != node->type)
d556 1
a556 1
	return(check_parent(mdoc, node, MDOC_Sh, MDOC_BODY));
d561 1
a561 1
pre_sh(struct mdoc *mdoc, struct mdoc_node *node)
d564 1
a564 1
	if (MDOC_BLOCK != node->type)
d566 1
a566 1
	return(check_parent(mdoc, node, -1, MDOC_ROOT));
d571 1
a571 1
pre_it(struct mdoc *mdoc, struct mdoc_node *node)
d577 1
a577 1
	if (MDOC_BLOCK != node->type)
d579 1
a579 1
	return(check_parent(mdoc, node, MDOC_Bl, MDOC_BODY));
d584 1
a584 1
pre_st(struct mdoc *mdoc, struct mdoc_node *node)
d587 1
a587 1
	if (1 == node->data.elem.argc)
d589 1
a589 1
	return(mdoc_nerr(mdoc, node, "one argument required"));
d594 1
a594 1
pre_an(struct mdoc *mdoc, struct mdoc_node *node)
d597 1
a597 1
	if (1 >= node->data.elem.argc)
d599 1
a599 1
	return(mdoc_nerr(mdoc, node, "one argument allowed"));
d604 1
a604 1
pre_rv(struct mdoc *mdoc, struct mdoc_node *node)
d608 1
a608 1
	if ( ! check_msec(mdoc, node, 2, msecs))
d610 1
a610 1
	return(check_stdarg(mdoc, node));
d615 1
a615 1
pre_ex(struct mdoc *mdoc, struct mdoc_node *node)
d619 1
a619 1
	if ( ! check_msec(mdoc, node, 3, msecs))
d621 1
a621 1
	return(check_stdarg(mdoc, node));
d626 1
a626 1
pre_er(struct mdoc *mdoc, struct mdoc_node *node)
d630 1
a630 1
	return(check_msec(mdoc, node, 1, msecs));
d635 1
a635 1
pre_cd(struct mdoc *mdoc, struct mdoc_node *node)
d639 1
a639 1
	return(check_msec(mdoc, node, 1, msecs));
d644 1
a644 1
pre_prologue(struct mdoc *mdoc, struct mdoc_node *node)
d648 1
a648 1
		return(mdoc_nerr(mdoc, node, "prologue only"));
d652 1
a652 1
	switch (node->tok) {
d656 1
a656 2
		return(mdoc_nerr(mdoc, node, 
				"prologue out-of-order"));
d660 1
a660 2
		return(mdoc_nerr(mdoc, node, 
				"prologue out-of-order"));
d664 1
a664 2
		return(mdoc_nerr(mdoc, node, 
				"prologue out-of-order"));
d672 1
a672 1
	switch (node->tok) {
d690 1
a690 1
	return(mdoc_nerr(mdoc, node, "prologue repetition"));
d695 1
a695 1
post_bf(struct mdoc *mdoc)
d729 1
a729 1
post_nm(struct mdoc *mdoc)
d741 1
a741 1
post_xr(struct mdoc *mdoc)
d754 1
a754 1
post_at(struct mdoc *mdoc)
d766 1
a766 1
post_an(struct mdoc *mdoc)
d782 1
a782 1
post_ex(struct mdoc *mdoc)
d802 1
a802 1
post_it(struct mdoc *mdoc)
d919 1
a919 1
post_bl(struct mdoc *mdoc)
d964 1
a964 21
pre_text(struct mdoc *mdoc, const struct mdoc_node *n)
{
	size_t		 c;
	const char	*p;

	for (p = n->data.text.string; *p; p++) {
		if ('\\' != *p)
			continue;
		if ((c = mdoc_isescape(p))) {
			p += (c - 1);
			continue;
		}
		return(mdoc_nerr(mdoc, n, "bad escape sequence"));
	}

	return(1);
}


static int
post_root(struct mdoc *mdoc)
d984 1
a984 1
post_sh(struct mdoc *mdoc)
d997 1
a997 1
post_sh_body(struct mdoc *mdoc)
d1037 1
a1037 1
post_sh_head(struct mdoc *mdoc)
d1066 2
a1067 1
mdoc_valid_pre(struct mdoc *mdoc, struct mdoc_node *node)
d1070 3
d1074 27
a1100 3
	if (MDOC_TEXT == node->type)
		return(pre_text(mdoc, node));
	assert(MDOC_ROOT != node->type);
@


1.53
log
@Considerably cleaned up the validation code.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.52 2009/02/22 19:23:48 kristaps Exp $ */
a37 1
/* FIXME: valid character-escape checks. */
d111 1
d389 16
d941 20
d970 1
a970 1
		return(mdoc_err(mdoc, "lacking post-prologue `%s'", 
d973 1
a973 1
		return(mdoc_err(mdoc, "lacking post-prologue `%s'", 
d1008 2
a1009 2
		return(mdoc_warn(mdoc, WARN_COMPAT, "section NAME "
					"should contain %s and %s", 
d1018 2
a1019 3
		if ( ! (mdoc_nwarn(mdoc, n, WARN_COMPAT, "section "
					"NAME should contain %s as "
					"initial body child", 
d1027 2
a1028 2
	return(mdoc_warn(mdoc, WARN_COMPAT, "section NAME should "
				"contain %s as the last child",
d1041 2
a1042 2
	if ( ! xstrlcats(buf, mdoc->last->child, 64))
		return(mdoc_err(mdoc, "macro parameters too long"));
d1047 2
a1048 1
		return(mdoc_err(mdoc, "section NAME must be first"));
d1052 2
a1053 1
		return(mdoc_warn(mdoc, WARN_SYNTAX, "section repeated"));
d1055 2
a1056 1
		return(mdoc_warn(mdoc, WARN_SYNTAX, "section out of conventional order"));
d1068 1
a1068 1
		return(1);
d1085 8
@


1.52
log
@Fixed `.Pf' handling.
System now supports all mdocml manual pages.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.51 2009/02/22 14:31:08 kristaps Exp $ */
a36 1
/* FIXME: .Ef arguments */
d294 1
d299 5
a303 37
static int
warn_child_gt(struct mdoc *mdoc, const char *p, int sz)
{
	int		  i;

	if ((i = count_child(mdoc)) > sz)
		return(1);
	return(warn_count(mdoc, ">", sz, p, i));
}


static int
err_child_gt(struct mdoc *mdoc, const char *p, int sz)
{
	int		  i;

	if ((i = count_child(mdoc)) > sz)
		return(1);
	return(err_count(mdoc, ">", sz, p, i));
}


static int
warn_child_eq(struct mdoc *mdoc, const char *p, int sz)
{
	int		  i;

	if ((i = count_child(mdoc)) == sz)
		return(1);
	return(warn_count(mdoc, "==", sz, p, i));
}


static int
err_child_eq(struct mdoc *mdoc, const char *p, int sz)
{
	int		  i;
d305 34
a338 3
	if ((i = count_child(mdoc)) == sz)
		return(1);
	return(err_count(mdoc, "==", sz, p, i));
d342 17
a358 9
static int
err_child_lt(struct mdoc *mdoc, const char *p, int sz)
{
	int		  i;

	if ((i = count_child(mdoc)) < sz)
		return(1);
	return(err_count(mdoc, "<", sz, p, i));
}
d370 1
a370 2
				"macro suggests single `%s' argument",
				mdoc_argnames[MDOC_Std]));
d383 2
a384 131
	return(mdoc_nwarn(mdoc, node, WARN_COMPAT, "macro not "
				"appropriate for manual section"));
}


static int
check_parent(struct mdoc *mdoc, struct mdoc_node *n, 
		int tok, enum mdoc_type t)
{

	assert(n->parent);
	if ((MDOC_ROOT == t || tok == n->parent->tok) &&
			(t == n->parent->type))
		return(1);

	return(mdoc_nerr(mdoc, n, "require parent %s (have %s)", 
			MDOC_ROOT == t ? "<root>" :
			mdoc_macronames[tok],
			MDOC_ROOT == n->parent->type ? "<root>" :
			mdoc_macronames[n->parent->type]));
}


static int
bwarn_ge1(struct mdoc *mdoc)
{

	if (MDOC_BODY != mdoc->last->type)
		return(1);
	return(warn_child_gt(mdoc, "multi-line parameters", 0));
}


static int
ewarn_eq1(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(warn_child_eq(mdoc, "line parameters", 1));
}


static int
ewarn_eq0(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(warn_child_eq(mdoc, "line parameters", 0));
}


static int
ewarn_ge1(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(warn_child_gt(mdoc, "line parameters", 0));
}


static int
eerr_eq1(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(err_child_eq(mdoc, "line parameters", 1));
}


static int
eerr_le2(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(err_child_lt(mdoc, "line parameters", 3));
}


static int
eerr_le1(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(err_child_lt(mdoc, "line parameters", 2));
}


static int
eerr_eq0(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(err_child_eq(mdoc, "line parameters", 0));
}


static int
eerr_ge1(struct mdoc *mdoc)
{

	assert(MDOC_ELEM == mdoc->last->type);
	return(err_child_gt(mdoc, "line parameters", 0));
}


static int
herr_eq0(struct mdoc *mdoc)
{

	if (MDOC_HEAD != mdoc->last->type)
		return(1);
	return(err_child_eq(mdoc, "line parameters", 0));
}


static int
herr_le1(struct mdoc *mdoc)
{
	if (MDOC_HEAD != mdoc->last->type)
		return(1);
	return(err_child_lt(mdoc, "line parameters", 2));
}


static int
herr_ge1(struct mdoc *mdoc)
{

	if (MDOC_HEAD != mdoc->last->type)
		return(1);
	return(err_child_gt(mdoc, "line parameters", 0));
d393 2
a397 1
	assert(mdoc->last);
d405 1
d413 1
a413 1
	int		 type, err;
d415 1
a415 1
	size_t		 i, argc;
a418 1
	assert(MDOC_Bl == node->tok);
a419 1
	argv = NULL;
d422 2
d425 3
a427 3
	for (i = type = err = 0; i < argc; i++) {
		argv = &node->data.block.argv[(int)i];
		assert(argv);
d450 4
a453 4
			if (type)
				err++;
			type++;
			break;
d458 4
a461 7
	if (0 == type)
		return(mdoc_err(mdoc, "no list type specified"));
	if (0 == err)
		return(1);
	assert(argv);
	return(mdoc_perr(mdoc, argv->line, 
			argv->pos, "only one list type possible"));
d468 1
a468 1
	int		 type, err;
d470 1
a470 1
	size_t		 i, argc;
a473 1
	assert(MDOC_Bd == node->tok);
a474 1
	argv = NULL;
d477 2
d480 3
a482 3
	for (err = i = type = 0; 0 == err && i < argc; i++) {
		argv = &node->data.block.argv[(int)i];
		assert(argv);
d493 4
a496 4
			if (type)
				err++;
			type++;
			break;
d501 4
a504 7
	if (0 == type)
		return(mdoc_err(mdoc, "no display type specified"));
	if (0 == err)
		return(1);
	assert(argv);
	return(mdoc_perr(mdoc, argv->line, 
			argv->pos, "only one display type possible"));
d529 13
a544 2
	assert(MDOC_ELEM == node->type);
	assert(MDOC_St == node->tok);
d547 1
a547 1
	return(mdoc_nerr(mdoc, node, "macro must have one argument"));
a554 2
	assert(MDOC_ELEM == node->type);
	assert(MDOC_An == node->tok);
d557 1
a557 1
	return(mdoc_nerr(mdoc, node, "macro may only have one argument"));
d564 1
a564 4
	enum mdoc_msec	 msecs[2];

	assert(MDOC_ELEM == node->type);
	assert(MDOC_Rv == node->tok);
a565 2
	msecs[0] = MSEC_2;
	msecs[1] = MSEC_3;
d575 1
a575 4
	enum mdoc_msec	 msecs[3];

	assert(MDOC_ELEM == node->type);
	assert(MDOC_Ex == node->tok);
a576 3
	msecs[0] = MSEC_1;
	msecs[1] = MSEC_6;
	msecs[2] = MSEC_8;
d586 1
a586 1
	enum mdoc_msec	 msecs[1];
a587 1
	msecs[0] = MSEC_2;
d595 1
a595 1
	enum mdoc_msec	 msecs[1];
a596 1
	msecs[0] = MSEC_4;
a601 13
pre_it(struct mdoc *mdoc, struct mdoc_node *node)
{

	/* TODO: -width attribute must be specified for -tag. */
	/* TODO: children too big for -width? */

	if (MDOC_BLOCK != node->type)
		return(1);
	return(check_parent(mdoc, node, MDOC_Bl, MDOC_BODY));
}


static int
d606 1
a606 2
		return(mdoc_nerr(mdoc, node, "macro may only be invoked in the prologue"));
	assert(MDOC_ELEM == node->type);
d614 2
a615 1
		return(mdoc_nerr(mdoc, node, "prologue macro out-of-order"));
d619 2
a620 1
		return(mdoc_nerr(mdoc, node, "prologue macro out-of-order"));
d624 2
a625 1
		return(mdoc_nerr(mdoc, node, "prologue macro out-of-order"));
d651 1
a651 1
	return(mdoc_nerr(mdoc, node, "prologue macro repeated"));
d663 1
a663 1
	assert(MDOC_Bf == mdoc->last->tok);
a664 1
	assert(head);
d667 11
a677 12
		if (head->child) {
			assert(MDOC_TEXT == head->child->type);
			p = head->child->data.text.string;
			if (xstrcmp(p, "Em"))
				return(1);
			else if (xstrcmp(p, "Li"))
				return(1);
			else if (xstrcmp(p, "Sm"))
				return(1);
			return(mdoc_nerr(mdoc, head->child, "invalid font mode"));
		}
		return(mdoc_err(mdoc, "macro expects an argument or parameter"));
d679 1
d681 2
a682 1
		return(mdoc_err(mdoc, "macro expects an argument or parameter"));
d685 1
a685 1
	return(mdoc_err(mdoc, "macro expects an argument or parameter"));
a692 2
	assert(MDOC_ELEM == mdoc->last->type);
	assert(MDOC_Nm == mdoc->last->tok);
d697 1
a697 2
	return(mdoc_err(mdoc, "macro `%s' has not been invoked with a name",
				mdoc_macronames[MDOC_Nm]));
a705 5
	assert(MDOC_ELEM == mdoc->last->type);
	assert(MDOC_Xr == mdoc->last->tok);
	assert(mdoc->last->child);
	assert(MDOC_TEXT == mdoc->last->child->type);

a707 1
	assert(MDOC_TEXT == n->type);
a717 3
	assert(MDOC_ELEM == mdoc->last->type);
	assert(MDOC_At == mdoc->last->tok);

a719 2
	assert(MDOC_TEXT == mdoc->last->child->type);

d722 1
a722 1
	return(mdoc_err(mdoc, "macro expects a valid AT&T version symbol"));
a729 3
	assert(MDOC_ELEM == mdoc->last->type);
	assert(MDOC_An == mdoc->last->tok);

d733 1
a733 1
		return(mdoc_err(mdoc, "macro expects either argument or parameters"));
d738 1
a738 1
	return(mdoc_err(mdoc, "macro expects either argument or parameters"));
a745 3
	assert(MDOC_ELEM == mdoc->last->type);
	assert(MDOC_Ex == mdoc->last->tok);

d749 1
a749 2
		return(mdoc_err(mdoc, "macro expects `%s' or a single child",
					mdoc_argnames[MDOC_Std]));
d752 1
a752 2
		return(mdoc_err(mdoc, "macro expects `%s' or a single child",
					mdoc_argnames[MDOC_Std]));
d754 1
a754 2
		return(mdoc_err(mdoc, "macro expects `%s' or a single child",
					mdoc_argnames[MDOC_Std]));
d756 2
a757 2
		return(mdoc_err(mdoc, "macro expects `%s' or a single child",
					mdoc_argnames[MDOC_Std]));
a761 1
/* Warn if `Bl' type-specific syntax isn't reflected in items. */
d765 1
a765 1
	int		  type, sv;
d770 1
a770 1
	size_t		  i, argc;
d776 1
a776 9
	assert(MDOC_It == mdoc->last->tok);

	n = mdoc->last->parent;
	assert(n);
	assert(MDOC_Bl == n->tok);

	n = n->parent;
	assert(MDOC_BLOCK == n->type);
	assert(MDOC_Bl == n->tok);
d785 2
a786 2
	for (i = 0; TYPE_NONE == type && i < argc; i++)
		switch (n->data.block.argv[(int)i].arg) {
d797 1
a797 1
			sv = n->data.block.argv[(int)i].arg;
d809 1
a809 1
			sv = n->data.block.argv[(int)i].arg;
d813 1
a813 1
			sv = n->data.block.argv[(int)i].arg;
a821 1
	assert(n);
d825 2
a826 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests line parameters"))
a829 1
		assert(n);
d831 2
a832 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests body children"))
d837 2
a838 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests no line parameters"))
a841 1
		assert(n);
d843 2
a844 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests body children"))
d848 2
a849 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests line parameters"))
a852 1
		assert(n);
d854 2
a855 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests no body children"))
a861 2
	/* Make sure the number of columns is sane. */

d868 1
a868 1
	if (i == argc)
d870 2
a871 1
	return(mdoc_err(mdoc, "expected %zu list columns, have %zu", argc, i));
d882 1
a882 1
	struct mdoc_node *n;
a885 1
	assert(MDOC_Bl == mdoc->last->tok);
d894 1
d897 2
a898 1
	return(mdoc_nerr(mdoc, n, "invalid child of parent macro `Bl'"));
a906 1
	assert(MDOC_ELEM == mdoc->last->type);
d917 1
d920 1
a920 1
	return(mdoc_nerr(mdoc, n, "expected boolean value"));
d929 1
a929 1
		return(mdoc_err(mdoc, "document has no data"));
d931 2
a932 1
		return(mdoc_err(mdoc, "document has incomplete prologue"));
d934 2
a935 1
		return(mdoc_err(mdoc, "document expects `%s' macro after prologue", mdoc_macronames[MDOC_Sh]));
d937 3
a939 1
		return(mdoc_err(mdoc, "document expects `%s' macro after prologue", mdoc_macronames[MDOC_Sh]));
d952 1
a961 2
	assert(MDOC_Sh == mdoc->last->tok);
	assert(MDOC_BODY == mdoc->last->type);
@


1.51
log
@Cleaned up validation source a bit.
Fixed `Nm' and `Nd' detection.
Added a few more terminal outputs.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.50 2009/02/21 21:00:06 kristaps Exp $ */
d143 1
d235 1
a235 1
	{ NULL, NULL },				/* Pf */
@


1.50
log
@Split mdocml -> mdocterm, mdoctree (new manuals, etc.).
Escape-recognition term.c.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.49 2009/02/21 15:34:46 kristaps Exp $ */
d37 1
d39 2
a40 2
/* FIXME: valid character-escape checks!!!! */
/* FIXME: make sure required sections are included (NAME, ...). */
d49 1
a49 1
static	int	pre_check_parent(struct mdoc *, struct mdoc_node *, 
d51 1
a51 1
static	int	pre_check_msecs(struct mdoc *, struct mdoc_node *, 
d53 14
a66 7
static	int	pre_check_stdarg(struct mdoc *, struct mdoc_node *);
static	int	post_check_children_count(struct mdoc *);
static	int	post_check_children_lt(struct mdoc *, const char *, int);
static	int	post_check_children_gt(struct mdoc *, const char *, int);
static	int	post_check_children_wgt(struct mdoc *, const char *, int);
static	int	post_check_children_eq(struct mdoc *, const char *, int);
static	int	post_check_children_weq(struct mdoc *, const char *, int);
d157 106
a262 107
	{ NULL, NULL }, /* \" */
	{ pres_prologue, posts_text }, /* Dd */
	{ pres_prologue, NULL }, /* Dt */
	{ pres_prologue, NULL }, /* Os */
	{ pres_sh, posts_sh }, /* Sh */ 
	{ pres_ss, posts_ss }, /* Ss */ 
	{ NULL, posts_pp }, /* Pp */ 
	{ pres_d1, posts_wline }, /* D1 */
	{ pres_d1, posts_wline }, /* Dl */
	{ pres_bd, posts_bd }, /* Bd */
	{ NULL, NULL }, /* Ed */
	{ pres_bl, posts_bl }, /* Bl */ 
	{ NULL, NULL }, /* El */
	{ pres_it, posts_it }, /* It */
	{ NULL, posts_text }, /* Ad */ 
	{ pres_an, posts_an }, /* An */ 
	{ NULL, NULL }, /* Ar */
	{ pres_cd, posts_text }, /* Cd */ 
	{ NULL, NULL }, /* Cm */
	{ NULL, posts_text }, /* Dv */ 
	{ pres_er, posts_text }, /* Er */ 
	{ NULL, posts_text }, /* Ev */ 
	{ pres_ex, posts_ex }, /* Ex */ 
	{ NULL, posts_text }, /* Fa */ 
	/* FIXME: only in SYNOPSIS section. */
	{ NULL, posts_wtext }, /* Fd */
	{ NULL, NULL }, /* Fl */
	{ NULL, posts_text }, /* Fn */ 
	{ NULL, posts_wtext }, /* Ft */ 
	{ NULL, posts_text }, /* Ic */ 
	{ NULL, posts_in }, /* In */ 
	{ NULL, posts_text }, /* Li */
	{ NULL, posts_wtext }, /* Nd */
	{ NULL, posts_nm }, /* Nm */
	{ NULL, posts_wline }, /* Op */
	{ NULL, NULL }, /* Ot */
	{ NULL, NULL }, /* Pa */
	{ pres_rv, posts_notext }, /* Rv */
	{ pres_st, posts_notext }, /* St */ 
	{ NULL, posts_text }, /* Va */
	{ NULL, posts_text }, /* Vt */ 
	{ NULL, posts_xr }, /* Xr */ 
	{ NULL, posts_text }, /* %A */
	{ NULL, posts_text }, /* %B */
	{ NULL, posts_text }, /* %D */
	{ NULL, posts_text }, /* %I */
	{ NULL, posts_text }, /* %J */
	{ NULL, posts_text }, /* %N */
	{ NULL, posts_text }, /* %O */
	{ NULL, posts_text }, /* %P */
	{ NULL, posts_text }, /* %R */
	{ NULL, posts_text }, /* %T */
	{ NULL, posts_text }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ NULL, NULL }, /* Ao */
	{ NULL, posts_wline }, /* Aq */
	{ NULL, posts_at }, /* At */ 
	{ NULL, NULL }, /* Bc */
	{ NULL, posts_bf }, /* Bf */
	{ NULL, NULL }, /* Bo */
	{ NULL, posts_wline }, /* Bq */
	{ NULL, NULL }, /* Bsx */
	{ NULL, NULL }, /* Bx */
	{ NULL, posts_bool }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ NULL, NULL }, /* Do */
	{ NULL, posts_wline }, /* Dq */
	{ NULL, NULL }, /* Ec */
	{ NULL, NULL }, /* Ef */ /* -symbolic, etc. */
	{ NULL, posts_text }, /* Em */ 
	{ NULL, NULL }, /* Eo */
	{ NULL, NULL }, /* Fx */
	{ NULL, posts_text }, /* Ms */ 
	{ NULL, posts_notext }, /* No */
	{ NULL, posts_notext }, /* Ns */
	{ NULL, NULL }, /* Nx */
	{ NULL, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, NULL }, /* Pf */
	{ NULL, NULL }, /* Po */
	{ NULL, posts_wline }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ NULL, posts_wline }, /* Ql */
	{ NULL, NULL }, /* Qo */
	{ NULL, posts_wline }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ NULL, posts_rs }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ NULL, NULL }, /* So */
	{ NULL, posts_wline }, /* Sq */
	{ NULL, posts_bool }, /* Sm */ 
	{ NULL, posts_text }, /* Sx */
	{ NULL, posts_text }, /* Sy */
	{ NULL, posts_text }, /* Tn */
	{ NULL, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ NULL, posts_fo }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
	{ NULL, NULL }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ NULL, posts_bk }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ NULL, posts_notext }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ NULL, NULL }, /* Fr */
	{ NULL, posts_notext }, /* Ud */
d266 22
a287 2
static int
post_check_children_count(struct mdoc *mdoc)
d289 1
a290 1
	int		  i;
d299 1
a299 1
post_check_children_wgt(struct mdoc *mdoc, const char *p, int sz)
d303 1
a303 1
	if ((i = post_check_children_count(mdoc)) > sz)
d305 1
a305 2
	return(mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests more "
				"than %d %s (has %d)", sz, p, i));
d310 1
a310 1
post_check_children_gt(struct mdoc *mdoc, const char *p, int sz)
d314 1
a314 1
	if ((i = post_check_children_count(mdoc)) > sz)
d316 1
a316 2
	return(mdoc_err(mdoc, "macro requires more than %d "
				"%s (has %d)", sz, p, i));
d321 1
a321 1
post_check_children_weq(struct mdoc *mdoc, const char *p, int sz)
d325 1
a325 1
	if ((i = post_check_children_count(mdoc)) == sz)
d327 1
a327 2
	return(mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests %d "
				"%s (has %d)", sz, p, i));
d332 1
a332 1
post_check_children_eq(struct mdoc *mdoc, const char *p, int sz)
d336 1
a336 1
	if ((i = post_check_children_count(mdoc)) == sz)
d338 1
a338 2
	return(mdoc_err(mdoc, "macro requires %d %s "
				"(have %d)", sz, p, i));
d343 1
a343 1
post_check_children_lt(struct mdoc *mdoc, const char *p, int sz)
d347 1
a347 1
	if ((i = post_check_children_count(mdoc)) < sz)
d349 1
a349 2
	return(mdoc_err(mdoc, "macro requires less than %d "
				"%s (have %d)", sz, p, i));
d354 1
a354 1
pre_check_stdarg(struct mdoc *mdoc, struct mdoc_node *node)
d357 2
a358 2
	if (1 == node->data.elem.argc &&
			MDOC_Std == node->data.elem.argv[0].arg)
d360 1
d368 1
a368 1
pre_check_msecs(struct mdoc *mdoc, struct mdoc_node *node, 
d382 2
a383 2
pre_check_parent(struct mdoc *mdoc, struct mdoc_node *node, 
		int tok, enum mdoc_type type)
d386 10
a395 9
	if (type != node->parent->type) 
		return(mdoc_nerr(mdoc, node, "invalid macro parent class %s, expected %s", 
					mdoc_type2a(node->parent->type),
					mdoc_type2a(type)));
	if (MDOC_ROOT != type && tok != node->parent->tok)
		return(mdoc_nerr(mdoc, node, "invalid macro parent `%s', expected `%s'", 
					mdoc_macronames[node->parent->tok],
					mdoc_macronames[tok]));
	return(1);
d405 1
a405 1
	return(post_check_children_wgt(mdoc, "body children", 0));
d414 1
a414 1
	return(post_check_children_weq(mdoc, "parameters", 1));
d423 1
a423 1
	return(post_check_children_weq(mdoc, "parameters", 0));
d432 1
a432 1
	return(post_check_children_wgt(mdoc, "parameters", 0));
d441 1
a441 1
	return(post_check_children_eq(mdoc, "parameters", 1));
d450 1
a450 1
	return(post_check_children_lt(mdoc, "parameters", 3));
d459 1
a459 1
	return(post_check_children_lt(mdoc, "parameters", 2));
d468 1
a468 1
	return(post_check_children_eq(mdoc, "parameters", 0));
d477 1
a477 1
	return(post_check_children_gt(mdoc, "parameters", 0));
d487 1
a487 1
	return(post_check_children_eq(mdoc, "parameters", 0));
d496 1
a496 1
	return(post_check_children_lt(mdoc, "parameters", 2));
d506 1
a506 1
	return(post_check_children_gt(mdoc, "parameters", 0));
d640 1
a640 1
	return(pre_check_parent(mdoc, node, MDOC_Sh, MDOC_BODY));
d650 1
a650 1
	return(pre_check_parent(mdoc, node, -1, MDOC_ROOT));
d688 1
a688 1
	if ( ! pre_check_msecs(mdoc, node, 2, msecs))
d690 1
a690 1
	return(pre_check_stdarg(mdoc, node));
d705 1
a705 1
	if ( ! pre_check_msecs(mdoc, node, 3, msecs))
d707 1
a707 1
	return(pre_check_stdarg(mdoc, node));
d717 1
a717 1
	return(pre_check_msecs(mdoc, node, 1, msecs));
d727 1
a727 1
	return(pre_check_msecs(mdoc, node, 1, msecs));
d740 1
a740 1
	return(pre_check_parent(mdoc, node, MDOC_Bl, MDOC_BODY));
d1129 1
d1133 6
d1140 18
a1157 8
		return(mdoc_err(mdoc, "section NAME must contain %s as the first body child", mdoc_macronames[MDOC_Nm]));
	if (MDOC_ELEM != n->type || MDOC_Nm != n->tok)
		return(mdoc_err(mdoc, "section NAME must contain %s as the first body child", mdoc_macronames[MDOC_Nm]));
	if (NULL == (n = n->next))
		return(mdoc_err(mdoc, "section NAME must contain %s as the second body child", mdoc_macronames[MDOC_Nd]));
	if (MDOC_ELEM != n->type || MDOC_Nd != n->tok)
		return(mdoc_err(mdoc, "section NAME must contain %s as the second body child", mdoc_macronames[MDOC_Nd]));
	if (NULL == (n = n->next))
d1160 3
a1162 2
	return(mdoc_warn(mdoc, WARN_SYNTAX, "section NAME usually limited to %s and %s body children",
				mdoc_macronames[MDOC_Nm], mdoc_macronames[MDOC_Nd]));
@


1.49
log
@A few more macros in place.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.48 2009/02/21 14:56:58 kristaps Exp $ */
d38 1
a38 1
/* FIXME: valid character-escape checks. */
@


1.48
log
@Initial list support (not nested, yet).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.47 2009/01/21 17:56:32 kristaps Exp $ */
d712 1
@


1.47
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.46 2009/01/21 11:35:26 kristaps Exp $ */
d711 2
@


1.46
log
@More validation on prologue/first NAME section.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.45 2009/01/20 20:56:21 kristaps Exp $ */
a152 1
	/* FIXME: NAME section internal ordering. */
d907 1
d954 3
a956 1
			/* FALLTHROUGH */
d958 1
a958 1
			type = TYPE_BODY;
d967 3
a970 2
		n = mdoc->last->data.block.head;
		assert(n);
d981 20
a1000 1
		return(1);
d1003 1
a1003 17
	assert(TYPE_BODY == type);
	assert(mdoc->last->data.block.head);

	n = mdoc->last->data.block.head;
	assert(n);
	if (n->child)
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests no line parameters"))
			return(0);

	n = mdoc->last->data.block.body;
	assert(n);
	if (NULL == n->child)
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests body children"))
			return(0);

	assert(-1 != sv);
	if (MDOC_Column != sv) 
d1020 1
@


1.45
log
@In-progress migration to ARGV separation.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.44 2009/01/20 13:44:05 kristaps Exp $ */
d94 2
d722 1
a722 1
	if (SEC_PROLOGUE != mdoc->sec_lastn)
d1065 1
a1065 1
	if (NULL == mdoc->last->child)
d1067 1
a1067 5
	if (NULL == mdoc->meta.title)
		return(mdoc_err(mdoc, "document has incomplete prologue"));
	if (NULL == mdoc->meta.os)
		return(mdoc_err(mdoc, "document has incomplete prologue"));
	if (0 == mdoc->meta.date)
d1069 4
a1076 1
/* Warn if conventional sections are out of order. */
d1080 37
a1119 2
	if (MDOC_HEAD != mdoc->last->type)
		return(1);
d1125 5
a1129 1
	if (SEC_CUSTOM == (sec = mdoc_atosec(buf)))
d1131 1
a1131 3
	if (sec > mdoc->sec_lastn)
		return(1);
	if (sec == mdoc->sec_lastn)
d1133 4
a1136 1
	return(mdoc_warn(mdoc, WARN_SYNTAX, "section out of conventional order"));
@


1.44
log
@Re-merged old port-building routines.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.43 2009/01/20 12:51:28 kristaps Exp $ */
d140 3
d234 1
a234 1
	{ NULL, NULL }, /* Rs */
d245 1
a245 1
	{ NULL, NULL }, /* Fo */ 
d249 1
a249 1
	{ NULL, NULL }, /* Bk */
@


1.43
log
@Moved prologue-pruning into action.c.
Added line-arg softmax.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.42 2009/01/19 23:11:43 kristaps Exp $ */
d24 8
@


1.42
log
@Removed FIXME for Bf.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.41 2009/01/19 23:11:12 kristaps Exp $ */
a29 1
/* FIXME: make sure prologue is complete. */
a73 1
static	int	hwarn_ge1(struct mdoc *);
a82 1
static	int	berr_eq0(struct mdoc *);
d119 1
a119 1
static	v_post	posts_wline[] = { hwarn_ge1, berr_eq0, NULL };
a125 1
static	v_post	posts_d1[] = { herr_ge1, NULL };
d144 2
a145 2
	{ pres_d1, posts_d1 }, /* D1 */
	{ pres_d1, posts_d1 }, /* Dl */
a363 10
berr_eq0(struct mdoc *mdoc)
{

	if (MDOC_BODY != mdoc->last->type)
		return(1);
	return(post_check_children_eq(mdoc, "body children", 0));
}


static int
a455 10
hwarn_ge1(struct mdoc *mdoc)
{

	if (MDOC_HEAD != mdoc->last->type)
		return(1);
	return(post_check_children_wgt(mdoc, "parameters", 0));
}


static int
@


1.41
log
@Bf macro properly supported.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.40 2009/01/19 17:51:33 kristaps Exp $ */
d199 1
a199 1
	{ NULL, posts_bf }, /* Bf */  /* FIXME */
@


1.40
log
@More correct validation.
Elision of prologue macros from main tree.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.39 2009/01/19 17:02:59 kristaps Exp $ */
d74 1
d96 1
d135 1
d199 1
a199 1
	{ NULL, NULL }, /* Bf */  /* FIXME */
d480 9
d782 34
@


1.39
log
@Removed unnecessary test cases (most were for visual).
Finally fixed scope-rewinding (MDOC_VALID).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.38 2009/01/17 20:10:36 kristaps Exp $ */
d47 5
a51 5
static	int	post_check_children_lt(struct mdoc *, int);
static	int	post_check_children_gt(struct mdoc *, int);
static	int	post_check_children_wgt(struct mdoc *, int);
static	int	post_check_children_eq(struct mdoc *, int);
static	int	post_check_children_weq(struct mdoc *, int);
d261 1
a261 1
post_check_children_wgt(struct mdoc *mdoc, int sz)
d268 1
a268 1
				"than %d parameters (has %d)", sz, i));
d273 1
a273 1
post_check_children_gt(struct mdoc *mdoc, int sz)
d280 1
a280 1
				"parameters (has %d)", sz, i));
d285 1
a285 1
post_check_children_weq(struct mdoc *mdoc, int sz)
d292 1
a292 1
				"parameters (has %d)", sz, i));
d297 1
a297 1
post_check_children_eq(struct mdoc *mdoc, int sz)
d303 2
a304 2
	return(mdoc_err(mdoc, "macro requires %d parameters "
				"(have %d)", sz, i));
d309 1
a309 1
post_check_children_lt(struct mdoc *mdoc, int sz)
d316 1
a316 1
				"parameters (have %d)", sz, i));
d370 1
a370 1
	return(post_check_children_eq(mdoc, 0));
d380 1
a380 1
	return(post_check_children_wgt(mdoc, 0));
d389 1
a389 1
	return(post_check_children_weq(mdoc, 1));
d398 1
a398 1
	return(post_check_children_weq(mdoc, 0));
d407 1
a407 1
	return(post_check_children_wgt(mdoc, 0));
d416 1
a416 1
	return(post_check_children_eq(mdoc, 1));
d425 1
a425 1
	return(post_check_children_lt(mdoc, 3));
d434 1
a434 1
	return(post_check_children_lt(mdoc, 2));
d443 1
a443 1
	return(post_check_children_eq(mdoc, 0));
d452 1
a452 1
	return(post_check_children_gt(mdoc, 0));
d462 1
a462 1
	return(post_check_children_eq(mdoc, 0));
d472 1
a472 1
	return(post_check_children_wgt(mdoc, 0));
d482 1
a482 1
	return(post_check_children_gt(mdoc, 0));
@


1.38
log
@Lint checks.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.37 2009/01/17 16:47:02 kristaps Exp $ */
d32 1
d49 1
d51 1
d82 1
d124 1
d163 1
a163 1
	{ NULL, NULL }, /* Fd */
d166 1
a166 1
	{ NULL, NULL }, /* Ft */ 
d168 1
a168 1
	{ NULL, posts_wtext }, /* In */ 
d196 1
a196 1
	{ NULL, NULL }, /* Bf */ 
d261 12
d280 13
a292 1
				"parameters (have %d)", sz, i));
d370 1
a370 3
	if (NULL == mdoc->last->child)
		return(1);
	return(mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests no body children"));
d380 10
a389 3
	if (mdoc->last->child)
		return(1);
	return(mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests one or more body children"));
d398 1
a398 4
	if (NULL == mdoc->last->child)
		return(1);
	return(mdoc_pwarn(mdoc, mdoc->last->child->line,
			mdoc->last->child->pos, WARN_SYNTAX, "macro suggests no parameters"));
d407 1
a407 3
	if (mdoc->last->child)
		return(1);
	return(mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests one or more parameters"));
d472 1
a472 3
	if (mdoc->last->child)
		return(1);
	return(mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests one or more parameters"));
d1033 1
a1033 1
		return(mdoc_err(mdoc, "document has no incomplete prologue"));
d1035 1
a1035 1
		return(mdoc_err(mdoc, "document has no incomplete prologue"));
d1037 1
a1037 1
		return(mdoc_err(mdoc, "document has no incomplete prologue"));
d1089 4
@


1.37
log
@Added tests to makefile.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.36 2009/01/17 16:15:27 kristaps Exp $ */
d468 1
d493 1
d551 1
d864 1
d868 1
d934 1
d940 1
a940 1
	sv = mdoc->last->parent->parent->data.block.argv->sz;
d946 1
a946 1
	if (i == (size_t)sv)
d948 1
a948 1
	return(mdoc_err(mdoc, "expected %d list columns, have %d", sv, (int)i));
d964 1
d983 1
@


1.36
log
@Documentation, more validations, cleaned up actions, added Nm action.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.35 2009/01/16 15:58:50 kristaps Exp $ */
a23 1

a26 1

d30 2
d38 2
d50 2
d68 15
a82 13
static	int	head_err_ge1(struct mdoc *);
static	int	head_warn_ge1(struct mdoc *);
static	int	head_err_eq0(struct mdoc *);
static	int	elem_err_eq0(struct mdoc *);
static	int	elem_err_le1(struct mdoc *);
static	int	elem_err_le2(struct mdoc *);
static	int	elem_err_eq1(struct mdoc *);
static	int	elem_err_ge1(struct mdoc *);
static	int	elem_warn_eq0(struct mdoc *);
static	int	body_warn_ge1(struct mdoc *);
static	int	body_err_eq0(struct mdoc *);
static	int	elem_warn_ge1(struct mdoc *);
static	int	elem_bool(struct mdoc *);
d90 4
d109 10
a118 10
static	v_post	posts_bool[] = { elem_err_eq1, elem_bool, NULL };
static	v_post	posts_bd[] = { head_err_eq0, body_warn_ge1, NULL };
static	v_post	posts_text[] = { elem_err_ge1, NULL };
static	v_post	posts_wtext[] = { elem_warn_ge1, NULL };
static	v_post	posts_notext[] = { elem_err_eq0, NULL };
static	v_post	posts_wline[] = { head_warn_ge1, body_err_eq0, NULL };
static	v_post	posts_sh[] = { head_err_ge1, 
			body_warn_ge1, post_sh, NULL };
static	v_post	posts_bl[] = { head_err_eq0, 
			body_warn_ge1, post_bl, NULL };
d120 4
a123 4
static	v_post	posts_ss[] = { head_err_ge1, NULL };
static	v_post	posts_pp[] = { elem_warn_eq0, NULL };
static	v_post	posts_d1[] = { head_err_ge1, NULL };
static	v_post	posts_ex[] = { elem_err_le1, post_ex, NULL };
d125 3
a127 3
static	v_post	posts_at[] = { elem_err_eq1, post_at, NULL };
static	v_post	posts_xr[] = { elem_err_ge1, elem_err_le2, 
			post_xr, NULL };
d129 1
d166 1
a166 2
	/* FIXME: check that name must be set/provided. */
	{ NULL, NULL }, /* Nm */
d313 2
a314 2
	return(mdoc_nwarn(mdoc, node, WARN_COMPAT,
				"macro is not appropriate for this manual section"));
d336 1
a336 1
body_err_eq0(struct mdoc *mdoc)
d348 1
a348 1
body_warn_ge1(struct mdoc *mdoc)
d360 1
a360 1
elem_warn_eq0(struct mdoc *mdoc)
d372 1
a372 1
elem_warn_ge1(struct mdoc *mdoc)
d383 1
a383 1
elem_err_eq1(struct mdoc *mdoc)
d392 1
a392 1
elem_err_le2(struct mdoc *mdoc)
d401 1
a401 1
elem_err_le1(struct mdoc *mdoc)
d410 1
a410 1
elem_err_eq0(struct mdoc *mdoc)
d419 1
a419 1
elem_err_ge1(struct mdoc *mdoc)
d428 1
a428 1
head_err_eq0(struct mdoc *mdoc)
d438 1
a438 1
head_warn_ge1(struct mdoc *mdoc)
d450 1
a450 1
head_err_ge1(struct mdoc *mdoc)
d740 15
d779 3
a781 1
	assert(mdoc->last->child);
a948 1
/* Make sure that only `It' macros are our body-children. */
d971 1
a971 1
elem_bool(struct mdoc *mdoc)
d987 17
a1003 1
	return(mdoc_nerr(mdoc, n, "expected boolean value [on/off]"));
a1035 2
	/* TODO: character-escape checks. */

d1056 2
a1057 4
	if (MDOC_ROOT == mdoc->last->type) {
		/* TODO: make sure prologue is complete. */
		return(1);
	}
@


1.35
log
@Initial separation of tree/mdocml.1.
Finished mdoc.3.
Broken build: mdocml.c.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.34 2009/01/16 14:15:12 kristaps Exp $ */
d29 4
d42 5
d57 1
d59 1
d69 1
d82 2
d95 1
d97 1
d115 3
a124 1
	/* FIXME: preceding Pp. */ 
a126 1
	/* FIXME: preceding Pp. */
a127 1
	/* FIXME: proceeding Pp */
a130 1
	 /* FIXME: preceding Pp. */
a132 1
	/* FIXME: preceding Pp. */
d160 2
a161 2
	{ NULL, posts_notext }, /* Rv */ /* FIXME: -std required */
	{ NULL, posts_notext }, /* St */ /* FIXME: arg required */
d164 1
a164 1
	{ NULL, NULL }, /* Xr */ /* FIXME: valid arguments */
d179 1
a179 1
	{ NULL, NULL }, /* At */ /* FIXME: valid arguments */
d195 1
a195 1
	{ NULL, posts_text }, /* Ms */ /* FIXME: which symbols? */
d203 1
a203 1
	{ NULL, posts_wline }, /* Pq */ /* FIXME: ignore following Sh/Ss */
d234 61
d377 10
a386 5
	if (NULL == mdoc->last->child)
		return(mdoc_err(mdoc, "macro expects one parameter"));
	if (mdoc->last->child->next)
		return(mdoc_err(mdoc, "macro expects one parameter"));
	return(1);
d395 1
a395 5
	if (NULL == mdoc->last->child)
		return(1);
	if (NULL == mdoc->last->child->next)
		return(1);
	return(mdoc_err(mdoc, "macro expects one or fewer parameters"));
d404 1
a404 3
	if (NULL == mdoc->last->child)
		return(1);
	return(mdoc_err(mdoc, "macro expects no parameters"));
d413 1
a413 3
	if (mdoc->last->child)
		return(1);
	return(mdoc_err(mdoc, "macro expects one or more parameters"));
d423 1
a423 4
	if (NULL == mdoc->last->child)
		return(1);
	return(mdoc_perr(mdoc, mdoc->last->child->line,
			mdoc->last->child->pos, "macro expects no parameters"));
d445 1
a445 3
	if (mdoc->last->child)
		return(1);
	return(mdoc_err(mdoc, "macro expects one or more parameters"));
d591 12
d605 1
d615 16
d636 1
d643 1
a643 14

	if (1 != node->data.elem.argc) {
		if ( ! mdoc_nwarn(mdoc, node, WARN_COMPAT, 
					"macro suggests `%s' argument",
					mdoc_argnames[MDOC_Std]))
			return(0);
		return(1);
	}
	if (MDOC_Std != node->data.elem.argv[0].arg)
		if ( ! mdoc_nwarn(mdoc, node, WARN_COMPAT, 
					"macro suggests `%s' argument",
					mdoc_argnames[MDOC_Std]))
			return(0);
	return(1);
d689 1
a689 1
		if (mdoc->meta.title[0] && mdoc->meta.date)
d693 1
a693 1
		if (0 == mdoc->meta.title[0] && mdoc->meta.date)
d697 1
a697 1
		if (0 == mdoc->meta.title[0] && 0 == mdoc->meta.date)
d709 1
a709 1
		if (0 == mdoc->meta.os[0])
d717 1
a717 1
		if (0 == mdoc->meta.title[0])
d730 34
d969 1
a970 3
	int		  i;
	struct mdoc_node *n;
	char		 *args[MDOC_LINEARG_MAX];
a973 1
	
d976 2
a977 2
	n = mdoc->last->child;
	assert(n);
d979 1
a979 9
	for (i = 0; n && i < MDOC_LINEARG_MAX; n = n->next, i++) {
		assert(MDOC_TEXT == n->type);
		assert(NULL == n->child);
		assert(n->data.text.string);
		args[i] = n->data.text.string;
	}

	sec = mdoc_atosec((size_t)i, (const char **)args);
	if (SEC_CUSTOM == sec)
a982 1

@


1.34
log
@Boolean validation.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.33 2009/01/16 14:04:26 kristaps Exp $ */
d48 1
d57 1
d68 2
d81 1
d97 2
d111 1
a111 1
	/* FIXME: proceeding... */
d123 1
a123 2
	/* FIXME: argument OR parameters. */
	{ NULL, NULL }, /* An */ 
d130 1
a130 1
	{ pres_ex, posts_notext }, /* Ex */ /* FIXME: -std required */
d132 2
a133 1
	{ NULL, NULL }, /* Fd */ /* FIXME: SYNOPSIS section. */
d141 2
a142 1
	{ NULL, NULL }, /* Nm */  /* FIXME: If name not set? */
d146 2
a147 2
	{ NULL, posts_notext }, /* Rv */ /* -std required */
	{ NULL, posts_notext }, /* St */ /* arg required */
d150 1
a150 1
	{ NULL, NULL }, /* Xr */ /* FIXME */
d165 1
a165 1
	{ NULL, NULL }, /* At */ /* FIXME */
d187 1
a187 1
	{ NULL, NULL }, /* Pf */ /* FIXME: 2 or more arguments */ /* First should be text. */
d238 1
a238 1
	if (type != mdoc->last->parent->type) 
d240 1
a240 1
					mdoc_type2a(mdoc->last->parent->type),
d242 1
a242 1
	if (MDOC_ROOT != type && tok == mdoc->last->parent->tok)
d244 1
a244 1
					mdoc_macronames[mdoc->last->parent->tok],
d311 13
d507 1
a507 1
	if (MDOC_BLOCK != mdoc->last->type)
a508 1
	assert(MDOC_Sh == mdoc->last->tok);
d517 1
a517 1
	if (MDOC_BLOCK != mdoc->last->type)
a518 1
	assert(MDOC_Sh == mdoc->last->tok);
d524 11
d539 2
d544 16
a559 1
	return(pre_check_msecs(mdoc, node, 3, msecs));
d587 1
a587 1
	if (MDOC_BLOCK != mdoc->last->type)
a588 1
	assert(MDOC_It == mdoc->last->tok);
d645 45
a797 1

@


1.33
log
@Added more validation (parents/msecs).
Initial function documentation for mdoc.3.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.32 2009/01/16 12:23:25 kristaps Exp $ */
d52 11
a62 9
static	int	headchild_err_ge1(struct mdoc *);
static	int	headchild_warn_ge1(struct mdoc *);
static	int	headchild_err_eq0(struct mdoc *);
static	int	elemchild_err_eq0(struct mdoc *);
static	int	elemchild_err_ge1(struct mdoc *);
static	int	elemchild_warn_eq0(struct mdoc *);
static	int	bodychild_warn_ge1(struct mdoc *);
static	int	bodychild_err_eq0(struct mdoc *);
static	int	elemchild_warn_ge1(struct mdoc *);
d78 10
a87 7
static	v_post	posts_bd[] = { headchild_err_eq0, bodychild_warn_ge1, NULL };
static	v_post	posts_text[] = { elemchild_err_ge1, NULL };
static	v_post	posts_wtext[] = { elemchild_warn_ge1, NULL };
static	v_post	posts_notext[] = { elemchild_err_eq0, NULL };
static	v_post	posts_wline[] = { headchild_warn_ge1, bodychild_err_eq0, NULL };
static	v_post	posts_sh[] = { headchild_err_ge1, bodychild_warn_ge1, post_sh, NULL };
static	v_post	posts_bl[] = { headchild_err_eq0, bodychild_warn_ge1, post_bl, NULL };
d89 3
a91 3
static	v_post	posts_ss[] = { headchild_err_ge1, NULL };
static	v_post	posts_pp[] = { elemchild_warn_eq0, NULL };
static	v_post	posts_d1[] = { headchild_err_ge1, NULL };
d164 1
a164 1
	{ NULL, NULL }, /* Db */ /* FIXME: boolean */
d191 1
a191 1
	{ NULL, NULL }, /* Sm */ /* FIXME: boolean */
d243 1
a243 1
bodychild_err_eq0(struct mdoc *mdoc)
d255 1
a255 1
bodychild_warn_ge1(struct mdoc *mdoc)
d267 1
a267 1
elemchild_warn_eq0(struct mdoc *mdoc)
d279 1
a279 1
elemchild_warn_ge1(struct mdoc *mdoc)
d290 14
a303 1
elemchild_err_eq0(struct mdoc *mdoc)
d314 1
a314 1
elemchild_err_ge1(struct mdoc *mdoc)
d325 1
a325 1
headchild_err_eq0(struct mdoc *mdoc)
d338 1
a338 1
headchild_warn_ge1(struct mdoc *mdoc)
d350 1
a350 1
headchild_err_ge1(struct mdoc *mdoc)
d736 21
@


1.32
log
@Clean-ups & documentation.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.31 2009/01/16 11:50:54 kristaps Exp $ */
d34 4
d40 2
d45 3
d70 5
d96 1
a96 2
	/* FIXME: can only be a child of root. */
	{ NULL, posts_sh }, /* Sh */ 
d98 1
a98 2
	/* FIXME: can only be a child of Sh. */
	{ NULL, posts_ss }, /* Ss */ 
d111 1
a111 1
	/* FIXME */
d114 1
a114 2

	{ NULL, posts_text }, /* Cd */ /* FIXME: section 4 only. */
d117 1
a117 1
	{ NULL, posts_text }, /* Er */ /* FIXME: section 2 only. */
d119 1
a119 1
	{ NULL, posts_notext }, /* Ex */ /* FIXME: sections 1,6,8 only. */ /* -std required */
d174 1
a174 1
	{ NULL, NULL }, /* Pf */ /* FIXME: 2 or more arguments */
d207 31
d465 54
d525 1
a525 7

	if (MDOC_BODY != mdoc->last->parent->type) 
		return(mdoc_nerr(mdoc, node, "invalid macro parent `%s'", mdoc_macronames[mdoc->last->parent->tok]));
	if (MDOC_Bl != mdoc->last->parent->tok)
		return(mdoc_nerr(mdoc, node, "invalid macro parent `%s'", mdoc_macronames[mdoc->last->parent->tok]));

	return(1);
d645 3
a647 4
		if (NULL == (n = mdoc->last->data.block.head)) {
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests line parameters"))
				return(0);
		} else if (NULL == n->child)
d651 3
a653 4
		if (NULL == (n = mdoc->last->data.block.body)) {
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests body children"))
				return(0);
		} else if (NULL == n->child)
d660 7
a666 5
	if (NULL == (n = mdoc->last->data.block.head)) {
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests line parameters"))
			return(0);
	} else if (NULL == n->child)
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX, "macro suggests line parameters"))
d669 3
a671 1
	if ((n = mdoc->last->data.block.body) && n->child)
d781 2
a782 1
	if (MDOC_ROOT == mdoc->last->type)
d784 1
@


1.31
log
@Finished re-fitting err/warn/msg routines.
Some minor bug-fixes.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.30 2009/01/15 17:38:58 kristaps Exp $ */
d309 2
a310 1
	for (n = mdoc->last; n; n = n->parent) 
@


1.30
log
@Broken build (changing err/warn/msg function prototypes for clarity).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.29 2009/01/15 15:46:45 kristaps Exp $ */
d203 1
a203 1
	return(mdoc_warn(mdoc, WARN_ARGS_EQ0));
d215 1
a215 1
	return(mdoc_warn(mdoc, WARN_ARGS_GE1));
d227 1
a227 1
			mdoc->last->child->pos, WARN_ARGS_EQ0));
d238 1
a238 1
	return(mdoc_warn(mdoc, WARN_ARGS_GE1));
d249 1
a249 1
	return(mdoc_err(mdoc, ERR_ARGS_EQ0));
d260 1
a260 1
	return(mdoc_err(mdoc, ERR_ARGS_GE1));
d273 1
a273 1
			mdoc->last->child->pos, ERR_ARGS_EQ0));
d285 1
a285 1
	return(mdoc_warn(mdoc, WARN_ARGS_GE1));
d297 1
a297 1
	return(mdoc_err(mdoc, ERR_ARGS_GE1));
d315 1
a315 1
	return(mdoc_nerr(mdoc, node, ERR_SCOPE_NONEST));
d367 1
a367 1
		return(mdoc_err(mdoc, ERR_SYNTAX_ARGMISS));
d372 1
a372 1
			argv->pos, ERR_SYNTAX_ARGBAD));
d412 1
a412 1
		return(mdoc_err(mdoc, ERR_SYNTAX_ARGMISS));
d417 1
a417 1
			argv->pos, ERR_SYNTAX_ARGBAD));
d430 1
a430 1
		return(mdoc_nerr(mdoc, node, ERR_SYNTAX_PARENTBAD));
d432 1
a432 1
		return(mdoc_nerr(mdoc, node, ERR_SYNTAX_PARENTBAD));
d443 1
a443 1
		return(mdoc_nerr(mdoc, node, ERR_SEC_NPROLOGUE));
d452 1
a452 1
		return(mdoc_nerr(mdoc, node, ERR_SEC_PROLOGUE_OO));
d456 1
a456 1
		return(mdoc_nerr(mdoc, node, ERR_SEC_PROLOGUE_OO));
d460 1
a460 1
		return(mdoc_nerr(mdoc, node, ERR_SEC_PROLOGUE_OO));
d486 1
a486 1
	return(mdoc_nerr(mdoc, node, ERR_SEC_PROLOGUE_REP));
d555 1
a555 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX_EMPTYHEAD))
d558 1
a558 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX_EMPTYHEAD))
d562 1
a562 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX_EMPTYBODY))
d565 1
a565 1
			if ( ! mdoc_warn(mdoc, WARN_SYNTAX_EMPTYBODY))
d572 1
a572 1
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX_EMPTYHEAD))
d575 1
a575 1
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX_EMPTYHEAD))
d579 1
a579 1
		if ( ! mdoc_warn(mdoc, WARN_SYNTAX_NOBODY))
d595 1
a595 1
	return(mdoc_err(mdoc, ERR_SYNTAX_ARGFORM));
d621 1
a621 1
	return(mdoc_nerr(mdoc, n, ERR_SYNTAX_CHILDBAD));
d656 2
a657 2
		return(mdoc_warn(mdoc, WARN_SEC_REP));
	return(mdoc_warn(mdoc, WARN_SEC_OO));
@


1.29
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.28 2009/01/14 11:58:24 kristaps Exp $ */
d315 1
a315 1
	return(mdoc_verr(mdoc, node, ERR_SCOPE_NONEST));
d430 1
a430 1
		return(mdoc_verr(mdoc, node, ERR_SYNTAX_PARENTBAD));
d432 1
a432 1
		return(mdoc_verr(mdoc, node, ERR_SYNTAX_PARENTBAD));
d443 1
a443 1
		return(mdoc_verr(mdoc, node, ERR_SEC_NPROLOGUE));
d452 1
a452 1
		return(mdoc_verr(mdoc, node, ERR_SEC_PROLOGUE_OO));
d456 1
a456 1
		return(mdoc_verr(mdoc, node, ERR_SEC_PROLOGUE_OO));
d460 1
a460 1
		return(mdoc_verr(mdoc, node, ERR_SEC_PROLOGUE_OO));
d486 1
a486 1
	return(mdoc_verr(mdoc, node, ERR_SEC_PROLOGUE_REP));
d621 1
a621 1
	return(mdoc_verr(mdoc, n, ERR_SYNTAX_CHILDBAD));
@


1.28
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.27 2009/01/12 17:26:42 kristaps Exp $ */
d398 2
@


1.27
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.26 2009/01/12 16:39:57 kristaps Exp $ */
d82 1
d85 1
@


1.26
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.25 2009/01/12 12:52:21 kristaps Exp $ */
d44 1
d50 1
a60 2
static	v_post	posts_bd[] = { headchild_err_eq0, 
			bodychild_warn_ge1, NULL };
d62 1
d66 3
a68 4
static	v_post	posts_sh[] = { headchild_err_ge1, 
			bodychild_warn_ge1, post_sh, NULL };
static	v_post	posts_bl[] = { headchild_err_eq0, 
			bodychild_warn_ge1, post_bl, NULL };
d117 1
a117 1
	{ NULL, posts_wtext }, /* Op */
d138 1
a138 1
	{ NULL, posts_wtext }, /* Aq */
d143 1
a143 1
	{ NULL, posts_wtext }, /* Bq */
d149 1
a149 1
	{ NULL, posts_wtext }, /* Dq */
d163 1
a163 1
	{ NULL, posts_wtext }, /* Pq */ /* FIXME: ignore following Sh/Ss */
d165 1
a165 1
	{ NULL, posts_wtext }, /* Ql */
d167 1
a167 1
	{ NULL, posts_wtext }, /* Qq */
d172 1
a172 1
	{ NULL, posts_wtext }, /* Sq */
d194 12
d276 12
@


1.25
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.24 2009/01/12 10:31:53 kristaps Exp $ */
d45 1
d49 1
d62 3
a71 1
static	v_post	posts_dd[] = { elemchild_err_ge1, NULL };
d77 1
a77 1
	{ pres_prologue, posts_dd }, /* Dd */
d80 7
a86 3
	{ NULL, posts_sh }, /* Sh */ /* FIXME: preceding Pp. */
	{ NULL, posts_ss }, /* Ss */ /* FIXME: preceding Pp. */
	{ NULL, posts_pp }, /* Pp */ /* FIXME: proceeding... */
d89 2
a90 1
	{ pres_bd, posts_bd }, /* Bd */ /* FIXME: preceding Pp. */
d92 2
a93 1
	{ pres_bl, posts_bl }, /* Bl */ /* FIXME: preceding Pp. */
d96 3
a98 2
	{ NULL, NULL }, /* Ad */ 
	{ NULL, NULL }, /* An */
d100 2
a101 1
	{ NULL, NULL }, /* Cd */
d103 6
a108 6
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
	{ NULL, NULL }, /* Ex */
	{ NULL, NULL }, /* Fa */ 
	{ NULL, NULL }, /* Fd */ 
d110 1
a110 1
	{ NULL, NULL }, /* Fn */ 
d112 6
a117 6
	{ NULL, NULL }, /* Ic */ 
	{ NULL, NULL }, /* In */ 
	{ NULL, NULL }, /* Li */
	{ NULL, NULL }, /* Nd */ 
	{ NULL, NULL }, /* Nm */ 
	{ NULL, NULL }, /* Op */
d120 16
a135 16
	{ NULL, NULL }, /* Rv */
	{ NULL, NULL }, /* St */
	{ NULL, NULL }, /* Va */
	{ NULL, NULL }, /* Vt */ 
	{ NULL, NULL }, /* Xr */
	{ NULL, NULL }, /* %A */
	{ NULL, NULL }, /* %B */
	{ NULL, NULL }, /* %D */
	{ NULL, NULL }, /* %I */
	{ NULL, NULL }, /* %J */
	{ NULL, NULL }, /* %N */
	{ NULL, NULL }, /* %O */
	{ NULL, NULL }, /* %P */
	{ NULL, NULL }, /* %R */
	{ NULL, NULL }, /* %T */
	{ NULL, NULL }, /* %V */
d138 1
a138 1
	{ NULL, NULL }, /* Aq */
d143 1
a143 1
	{ NULL, NULL }, /* Bq */
d146 1
a146 1
	{ NULL, NULL }, /* Db */
d149 1
a149 1
	{ NULL, NULL }, /* Dq */
d152 1
a152 1
	{ NULL, NULL }, /* Em */ 
d155 3
a157 3
	{ NULL, NULL }, /* Ms */
	{ NULL, NULL }, /* No */
	{ NULL, NULL }, /* Ns */
d161 1
a161 1
	{ NULL, NULL }, /* Pf */ /* 2 or more arguments */
d163 1
a163 1
	{ NULL, NULL }, /* Pq */ /* FIXME: ignore following Sh/Ss */
d165 1
a165 1
	{ NULL, NULL }, /* Ql */
d167 1
a167 1
	{ NULL, NULL }, /* Qq */
d172 5
a176 5
	{ NULL, NULL }, /* Sq */
	{ NULL, NULL }, /* Sm */
	{ NULL, NULL }, /* Sx */
	{ NULL, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
d186 1
a186 1
	{ NULL, NULL }, /* Bt */
d189 1
a189 1
	{ NULL, NULL }, /* Ud */
d218 22
d330 2
d488 2
d554 7
a560 2
	/* TODO: make sure columns are aligned. */
	assert(MDOC_Column != sv);
d562 6
a567 1
	return(1);
@


1.24
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.23 2009/01/09 15:15:31 kristaps Exp $ */
d38 1
d50 1
d56 1
d64 1
d85 1
a85 1
	{ NULL, NULL }, /* It */
d251 1
a251 1
			if (MDOC_Bd == n->data.block.tok)
d268 1
a268 1
	assert(MDOC_Bl == node->data.block.tok);
d323 1
a323 1
	assert(MDOC_Bd == node->data.block.tok);
d358 17
d384 1
a384 1
	switch (node->data.elem.tok) {
d404 1
a404 1
	switch (node->data.elem.tok) {
d426 102
d535 1
a535 1
	assert(MDOC_Bl == mdoc->last->data.body.tok);
d539 1
a539 1
			if (MDOC_It == n->data.block.tok)
d549 1
a549 4
/*
 * Warn if sections (those that are with a known title, such as NAME,
 * DESCRIPTION, and so forth) are out of the conventional order.
 */
d561 1
a561 1
	assert(MDOC_Sh == mdoc->last->data.head.tok);
a588 1
	int		 t;
d590 3
a592 14
	switch (node->type) {
	case (MDOC_BODY):
		t = node->data.body.tok;
		break;
	case (MDOC_ELEM):
		t = node->data.elem.tok;
		break;
	case (MDOC_BLOCK):
		t = node->data.block.tok;
		break;
	case (MDOC_HEAD):
		t = node->data.head.tok;
		break;
	default:
d594 1
a594 1
	}
d596 1
a596 1
	if (NULL == mdoc_valids[t].pre)
d598 1
a598 1
	for (p = mdoc_valids[t].pre; *p; p++)
a608 1
	int		 t;
d610 3
a612 14
	switch (mdoc->last->type) {
	case (MDOC_BODY):
		t = mdoc->last->data.body.tok;
		break;
	case (MDOC_ELEM):
		t = mdoc->last->data.elem.tok;
		break;
	case (MDOC_BLOCK):
		t = mdoc->last->data.block.tok;
		break;
	case (MDOC_HEAD):
		t = mdoc->last->data.head.tok;
		break;
	default:
a613 1
	}
d615 1
a615 1
	if (NULL == mdoc_valids[t].post)
d617 1
a617 1
	for (p = mdoc_valids[t].post; *p; p++)
@


1.23
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.22 2009/01/09 15:07:04 kristaps Exp $ */
d30 1
a30 1
	v_pre	 pre;
d36 2
d41 6
a46 4
static	int	post_headchild_err_ge1(struct mdoc *);
static	int	post_elemchild_err_ge1(struct mdoc *);
static	int	post_elemchild_warn_eq0(struct mdoc *);
static	int	post_bodychild_warn_ge1(struct mdoc *);
d48 1
d50 15
a64 6
static	v_post	posts_sh[] = { post_headchild_err_ge1, 
			post_bodychild_warn_ge1, post_sh, NULL };
static	v_post	posts_ss[] = { post_headchild_err_ge1, NULL };
static	v_post	posts_pp[] = { post_elemchild_warn_eq0, NULL };
static	v_post	posts_dd[] = { post_elemchild_err_ge1, NULL };
static	v_post	posts_display[] = { post_headchild_err_ge1, NULL };
d69 3
a71 3
	{ pre_prologue, posts_dd }, /* Dd */
	{ pre_prologue, NULL }, /* Dt */
	{ pre_prologue, NULL }, /* Os */
d75 3
a77 3
	{ pre_display, posts_display }, /* D1 */
	{ pre_display, posts_display }, /* Dl */
	{ pre_display, NULL }, /* Bd */ /* FIXME: preceding Pp. */
d79 1
a79 1
	{ NULL, NULL }, /* Bl */ /* FIXME: preceding Pp. */
d178 1
a178 1
post_bodychild_warn_ge1(struct mdoc *mdoc)
a184 1

d190 1
a190 1
post_elemchild_warn_eq0(struct mdoc *mdoc)
d196 2
a197 1
	return(mdoc_warn(mdoc, WARN_ARGS_EQ0));
d202 1
a202 1
post_elemchild_err_ge1(struct mdoc *mdoc)
d213 14
a226 1
post_headchild_err_ge1(struct mdoc *mdoc)
d242 3
d256 98
d405 21
d468 1
d490 4
a493 1
	return((*mdoc_valids[t].pre)(mdoc, node));
a521 1

@


1.22
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.21 2009/01/09 14:45:44 kristaps Exp $ */
d35 1
d50 1
d61 3
a63 3
	{ NULL, NULL }, /* D1 */
	{ NULL, NULL }, /* Dl */
	{ NULL, NULL }, /* Bd */ /* FIXME: preceding Pp. */
d211 15
@


1.21
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.20 2009/01/08 15:59:58 kristaps Exp $ */
d40 1
d46 2
d57 2
a58 2
	{ NULL, NULL }, /* Ss */ /* FIXME: preceding Pp. */
	{ NULL, NULL }, /* Pp */ 
d175 11
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.19 2009/01/08 15:05:50 kristaps Exp $ */
a34 1
static	int	pre_sh(struct mdoc *, struct mdoc_node *);
d39 1
a39 1
static	int	post_headchild_err_le8(struct mdoc *);
d41 1
d43 3
a45 3
static v_post	posts_sh[] = { post_headchild_err_ge1, 
			post_bodychild_warn_ge1, 
			post_headchild_err_le8, NULL };
d50 4
a53 4
	{ pre_prologue, NULL }, /* Dd */ /* TODO: pre: ordering, repetition */
	{ pre_prologue, NULL }, /* Dt */ /* TODO ... */
	{ pre_prologue, NULL }, /* Os */ /* TODO ... */
	{ pre_sh, posts_sh }, /* Sh */ /* FIXME: preceding Pp. */
d172 1
a172 1
post_headchild_err_ge1(struct mdoc *mdoc)
d175 1
a175 2
	if (MDOC_HEAD != mdoc->last->type)
		return(1);
d183 1
a183 1
post_headchild_err_le8(struct mdoc *mdoc)
a184 2
	int		  i;
	struct mdoc_node *n;
d188 1
a188 3
	for (i = 0, n = mdoc->last->child; n; n = n->next, i++)
		/* Do nothing. */ ;
	if (i <= 8)
d190 1
a190 1
	return(mdoc_err(mdoc, ERR_ARGS_LE8));
d246 4
d251 1
a251 1
pre_sh(struct mdoc *mdoc, struct mdoc_node *node)
d253 12
d266 16
a281 1
	return(1);
@


1.19
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.18 2009/01/08 14:55:59 kristaps Exp $ */
d36 3
d50 3
a52 3
	{ NULL, NULL }, /* Dd */ /* TODO: pre: ordering, repetition */
	{ NULL, NULL }, /* Dt */ /* TODO ... */
	{ NULL, NULL }, /* Os */ /* TODO ... */
d200 52
d266 1
a266 1
		t = mdoc->last->data.body.tok;
d269 1
a269 1
		t = mdoc->last->data.elem.tok;
d272 1
a272 1
		t = mdoc->last->data.block.tok;
d275 1
a275 1
		t = mdoc->last->data.head.tok;
@


1.18
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.17 2009/01/07 15:53:00 kristaps Exp $ */
d47 3
a49 3
	{ NULL, NULL }, /* Dd */ /* TODO */
	{ NULL, NULL }, /* Dt */ /* TODO */
	{ NULL, NULL }, /* Os */ /* TODO */
@


1.17
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.16 2009/01/05 14:14:04 kristaps Exp $ */
d25 2
a26 3
typedef	int	(*v_pre)(struct mdoc *, int, int, 
			int, const struct mdoc_arg *);
typedef	int	(*v_post)(struct mdoc *, int, int);
d35 4
a38 5
static	int	pre_sh(struct mdoc *, int, int, 
			int, const struct mdoc_arg *);
static	int	post_headchild_err_ge1(struct mdoc *, int, int);
static	int	post_headchild_err_le8(struct mdoc *, int, int);
static	int	post_bodychild_warn_ge1(struct mdoc *, int, int);
d156 1
a156 1
post_bodychild_warn_ge1(struct mdoc *mdoc, int tok, int pos)
d164 1
a164 1
	return(mdoc_warn(mdoc, tok, pos, WARN_ARGS_GE1));
d169 1
a169 1
post_headchild_err_ge1(struct mdoc *mdoc, int tok, int pos)
d176 1
a176 1
	return(mdoc_err(mdoc, tok, pos, ERR_ARGS_GE1));
d181 1
a181 1
post_headchild_err_le8(struct mdoc *mdoc, int tok, int pos)
d192 1
a192 1
	return(mdoc_err(mdoc, tok, pos, ERR_ARGS_LE8));
d197 1
a197 2
pre_sh(struct mdoc *mdoc, int tok, int pos,
		int argc, const struct mdoc_arg *argv)
d205 1
a205 2
mdoc_valid_pre(struct mdoc *mdoc, int tok, int pos, 
		int argc, const struct mdoc_arg *argv)
d207 18
d226 1
a226 1
	if (NULL == mdoc_valids[tok].pre)
d228 1
a228 1
	return((*mdoc_valids[tok].pre)(mdoc, tok, pos, argc, argv));
d233 1
a233 1
mdoc_valid_post(struct mdoc *mdoc, int pos)
d259 1
a259 1
		if ( ! (*p)(mdoc, t, pos)) 
@


1.16
log
@Actions and validations properly added.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.15 2009/01/03 22:10:22 kristaps Exp $ */
a23 1
/* FIXME: `.St' can only have one argument set. */
d25 1
a25 3
typedef int	(*v_args_sz)(struct mdoc *, int, int, int);
typedef int	(*v_args)(struct mdoc *, int, int, 
			int, const char *[],
d27 1
a27 1
typedef int	(*v_tree)(struct mdoc *, int, int);
d31 2
a32 4
	v_args_sz sz;
	v_args	  args;
	v_tree	  tree_pre;
	v_tree	  tree_post;
d36 1
a36 30
static	int	  assert_eq0(struct mdoc *, int, int, int);
static	int	  assert_le1(struct mdoc *, int, int, int);
static	int	  need_eq0(struct mdoc *, int, int, int);
static	int	  need_eq1(struct mdoc *, int, int, int);
static	int	  need_ge1(struct mdoc *, int, int, int);
static	int	  need_le2(struct mdoc *, int, int, int);
static	int	  want_eq0(struct mdoc *, int, int, int);
static	int	  want_ge1(struct mdoc *, int, int, int);

static	int	  tree_pre_ref(struct mdoc *, int, int);
static	int	  tree_pre_display(struct mdoc *, int, int);

static	int	  tree_post_onlyhead(struct mdoc *, int, int);
static	int	  tree_post_onlybody(struct mdoc *, int, int);
static	int	  tree_post_warnemptybody(struct mdoc *, int, int);

static	int	  args_bool(struct mdoc *, int, int, 
			int, const char *[], 
			int, const struct mdoc_arg *);
static	int	  args_sh(struct mdoc *, int, int, 
			int, const char *[], 
			int, const struct mdoc_arg *);
static	int	  args_an(struct mdoc *, int, int, 
			int, const char *[], 
			int, const struct mdoc_arg *);
static	int	  args_nopunct(struct mdoc *, int, int, 
			int, const char *[], 
			int, const struct mdoc_arg *);
static	int	  args_xr(struct mdoc *, int, int, 
			int, const char *[], 
d38 7
d48 106
a153 106
	{ NULL, NULL, NULL, NULL }, /* \" */
	{ NULL, NULL, NULL, NULL }, /* Dd */ /* TODO */
	{ NULL, NULL, NULL, NULL }, /* Dt */ /* TODO */
	{ NULL, NULL, NULL, NULL }, /* Os */ /* TODO */
	{ want_ge1, args_sh, NULL, NULL }, /* Sh */ /* FIXME: preceding Pp. */
	{ want_ge1, NULL, NULL, NULL }, /* Ss */ /* FIXME: preceding Pp. */
	{ want_eq0, NULL, NULL, NULL }, /* Pp */ 
	{ assert_eq0, NULL, tree_pre_display, tree_post_onlyhead }, /* D1 */
	{ assert_eq0, NULL, tree_pre_display, tree_post_onlyhead }, /* Dl */
	{ want_eq0, NULL, tree_pre_display, tree_post_warnemptybody }, /* Bd */ /* FIXME: preceding Pp. */
	{ assert_eq0, NULL, NULL, tree_post_onlybody }, /* Ed */
	{ want_eq0, NULL, NULL, NULL }, /* Bl */ /* FIXME: preceding Pp. */
	{ assert_eq0, NULL, NULL, tree_post_onlybody }, /* El */
	{ NULL, NULL, NULL, NULL }, /* It */
	{ need_ge1, NULL, NULL, NULL }, /* Ad */ 
	{ NULL, args_an, NULL, NULL }, /* An */
	{ NULL, NULL, NULL, NULL }, /* Ar */
	{ need_ge1, NULL, NULL, NULL }, /* Cd */
	{ NULL, NULL, NULL, NULL }, /* Cm */
	{ need_ge1, NULL, NULL, NULL }, /* Dv */ 
	{ need_ge1, NULL, NULL, NULL }, /* Er */ 
	{ need_ge1, NULL, NULL, NULL }, /* Ev */ 
	{ NULL, NULL, NULL, NULL }, /* Ex */
	{ need_ge1, NULL, NULL, NULL }, /* Fa */ 
	{ NULL, NULL, NULL, NULL }, /* Fd */ 
	{ NULL, NULL, NULL, NULL }, /* Fl */
	{ need_ge1, NULL, NULL, NULL }, /* Fn */ 
	{ want_ge1, NULL, NULL, NULL }, /* Ft */ 
	{ need_ge1, NULL, NULL, NULL }, /* Ic */ 
	{ need_eq1, NULL, NULL, NULL }, /* In */ 
	{ want_ge1, NULL, NULL, NULL }, /* Li */
	{ want_ge1, NULL, NULL, NULL }, /* Nd */ 
	{ NULL, NULL, NULL, NULL }, /* Nm */ 
	{ NULL, NULL, NULL, NULL }, /* Op */
	{ NULL, NULL, NULL, NULL }, /* Ot */
	{ want_ge1, NULL, NULL, NULL }, /* Pa */
	{ NULL, NULL, NULL, NULL }, /* Rv */
	{ NULL, NULL, NULL, NULL }, /* St */
	{ need_ge1, NULL, NULL, NULL }, /* Va */
	{ need_ge1, NULL, NULL, NULL }, /* Vt */ 
	{ need_le2, args_xr, NULL, NULL }, /* Xr */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %A */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %B */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %D */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %I */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %J */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %N */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %O */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %P */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %R */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %T */
	{ need_ge1, NULL, tree_pre_ref, NULL }, /* %V */
	{ NULL, NULL, NULL, NULL }, /* Ac */
	{ NULL, NULL, NULL, NULL }, /* Ao */
	{ NULL, NULL, NULL, NULL }, /* Aq */
	{ need_le2, args_nopunct, NULL, NULL }, /* At */ /* FIXME */
	{ NULL, NULL, NULL, NULL }, /* Bc */
	{ NULL, NULL, NULL, NULL }, /* Bf */ 
	{ NULL, NULL, NULL, NULL }, /* Bo */
	{ NULL, NULL, NULL, NULL }, /* Bq */
	{ assert_le1, NULL, NULL, NULL }, /* Bsx */
	{ assert_le1, NULL, NULL, NULL }, /* Bx */
	{ need_eq1, args_bool, NULL, NULL }, /* Db */
	{ NULL, NULL, NULL, NULL }, /* Dc */
	{ NULL, NULL, NULL, NULL }, /* Do */
	{ NULL, NULL, NULL, NULL }, /* Dq */
	{ NULL, NULL, NULL, NULL }, /* Ec */
	{ NULL, NULL, NULL, NULL }, /* Ef */ /* -symbolic, etc. */
	{ need_ge1, NULL, NULL, NULL }, /* Em */ 
	{ NULL, NULL, NULL, NULL }, /* Eo */
	{ assert_le1, NULL, NULL, NULL }, /* Fx */
	{ want_ge1, NULL, NULL, NULL }, /* Ms */
	{ NULL, NULL, NULL, NULL }, /* No */
	{ NULL, NULL, NULL, NULL }, /* Ns */
	{ assert_le1, NULL, NULL, NULL }, /* Nx */
	{ assert_le1, NULL, NULL, NULL }, /* Ox */
	{ NULL, NULL, NULL, NULL }, /* Pc */
	{ NULL, NULL, NULL, NULL }, /* Pf */ /* 2 or more arguments */
	{ NULL, NULL, NULL, NULL }, /* Po */
	{ NULL, NULL, NULL, NULL }, /* Pq */ /* FIXME: ignore following Sh/Ss */
	{ NULL, NULL, NULL, NULL }, /* Qc */
	{ NULL, NULL, NULL, NULL }, /* Ql */
	{ NULL, NULL, NULL, NULL }, /* Qo */
	{ NULL, NULL, NULL, NULL }, /* Qq */
	{ NULL, NULL, NULL, NULL }, /* Re */
	{ NULL, NULL, NULL, NULL }, /* Rs */
	{ NULL, NULL, NULL, NULL }, /* Sc */
	{ NULL, NULL, NULL, NULL }, /* So */
	{ NULL, NULL, NULL, NULL }, /* Sq */
	{ need_eq1, args_bool, NULL, NULL }, /* Sm */
	{ need_ge1, NULL, NULL, NULL }, /* Sx */
	{ need_ge1, NULL, NULL, NULL }, /* Sy */
	{ want_ge1, NULL, NULL, NULL }, /* Tn */
	{ assert_eq0, NULL, NULL, NULL }, /* Ux */
	{ NULL, NULL, NULL, NULL }, /* Xc */
	{ NULL, NULL, NULL, NULL }, /* Xo */
	{ NULL, NULL, NULL, NULL }, /* Fo */ 
	{ NULL, NULL, NULL, NULL }, /* Fc */ 
	{ NULL, NULL, NULL, NULL }, /* Oo */
	{ NULL, NULL, NULL, NULL }, /* Oc */
	{ NULL, NULL, NULL, NULL }, /* Bk */
	{ NULL, NULL, NULL, NULL }, /* Ek */
	{ need_eq0, NULL, NULL, NULL }, /* Bt */
	{ need_eq1, NULL, NULL, NULL }, /* Hf */
	{ NULL, NULL, NULL, NULL }, /* Fr */
	{ need_eq0, NULL, NULL, NULL }, /* Ud */
d158 1
a158 1
need_le2(struct mdoc *mdoc, int tok, int pos, int sz)
a159 4
	if (sz <= 2)
		return(1);
	return(mdoc_err(mdoc, tok, pos, ERR_ARGS_LE2));
}
d161 1
a161 5

static int
want_ge1(struct mdoc *mdoc, int tok, int pos, int sz)
{
	if (sz > 0)
d163 1
a163 8
	return(mdoc_warn(mdoc, tok, pos, WARN_ARGS_GE1));
}


static int
want_eq0(struct mdoc *mdoc, int tok, int pos, int sz)
{
	if (sz == 0)
a164 2
	return(mdoc_warn(mdoc, tok, pos, WARN_ARGS_EQ0));
}
d166 1
a166 16

static int
need_eq0(struct mdoc *mdoc, int tok, int pos, int sz)
{
	if (sz == 0)
		return(1);
	return(mdoc_err(mdoc, tok, pos, ERR_ARGS_EQ0));
}


static int
assert_le1(struct mdoc *mdoc, int tok, int pos, int sz)
{

	assert(sz <= 1);
	return(1);
d171 1
a171 1
assert_eq0(struct mdoc *mdoc, int tok, int pos, int sz)
d174 1
a174 9
	assert(sz == 0);
	return(1);
}


static int
need_eq1(struct mdoc *mdoc, int tok, int pos, int sz)
{
	if (sz == 1)
d176 1
a176 8
	return(mdoc_err(mdoc, tok, pos, ERR_ARGS_EQ1));
}


static int
need_ge1(struct mdoc *mdoc, int tok, int pos, int sz)
{
	if (sz > 0)
d183 1
a183 22
tree_post_onlybody(struct mdoc *mdoc, int tok, int pos)
{
	struct mdoc_node *n;

	assert(mdoc->last);
	n = mdoc->last;

	assert(MDOC_BLOCK == n->type);
	assert(n->child);

	if (MDOC_BODY == n->child->type) {
		if (n->child->child)
			return(1);
		return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_EMPTYBODY));
	}

	return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_CHILDBODY));
}


static int
tree_post_warnemptybody(struct mdoc *mdoc, int tok, int pos)
d185 1
d188 1
a188 11
	assert(mdoc->last);
	n = mdoc->last;

	assert(MDOC_BLOCK == n->type);
	assert(n->child);

	for (n = n->child; n; n = n->next)
		if (MDOC_BODY == n->type)
			break;

	if (n && n->child)
d190 3
a192 20
	return(mdoc_warn(mdoc, tok, pos, WARN_SYNTAX_EMPTYBODY));
}


static int
tree_post_onlyhead(struct mdoc *mdoc, int tok, int pos)
{
	struct mdoc_node *n;

	assert(mdoc->last);
	n = mdoc->last;

	assert(MDOC_BLOCK == n->type);
	assert(n->child);

	n = n->child;

	if (MDOC_HEAD != n->type) 
		return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_CHILDHEAD));
	if (n->child)
d194 1
a194 1
	return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_EMPTYHEAD));
d199 1
a199 2
args_an(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[],
a202 2
	if (0 != argc && 0 != sz) 
		return(mdoc_warn(mdoc, tok, pos, WARN_ARGS_EQ0));
d207 2
a208 21
static int
args_sh(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[],
		int argc, const struct mdoc_arg *argv)
{
	enum mdoc_sec	 sec;

	sec = mdoc_atosec((size_t)sz, args);
	if (SEC_CUSTOM != sec && sec < mdoc->sec_lastn)
		if ( ! mdoc_warn(mdoc, tok, pos, WARN_SEC_OO))
			return(0);
	if (SEC_BODY == mdoc->sec_last && SEC_NAME != sec)
		return(mdoc_err(mdoc, tok, pos, ERR_SEC_NAME));

	return(1);
}


static int
args_bool(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[],
a210 17
	int	 	 i;

	for (i = 0; i < sz; i++) {
		if (xstrcmp(args[i], "on"))
			continue;
		if (xstrcmp(args[i], "off"))
			continue;
		return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_ARGBAD));
	}
	return(1);
}


static int
tree_pre_ref(struct mdoc *mdoc, int tok, int pos)
{
	struct mdoc_node *n;
d212 1
a212 6
	assert(mdoc->last);
	for (n = mdoc->last ; n; n = n->parent) {
		if (MDOC_BLOCK != n->type)
			continue;
		if (MDOC_Rs != n->data.block.tok)
			break;
d214 1
a214 3
	}

	return(mdoc_err(mdoc, tok, pos, ERR_SCOPE_NOCTX));
d218 2
a219 4
static int
args_xr(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[],
		int argc, const struct mdoc_arg *argv)
d221 2
d224 14
a237 18
	if (1 == sz)
		return(1);
	if (0 == sz)
		return(mdoc_err(mdoc, tok, pos, ERR_ARGS_GE1));
	if (MSEC_DEFAULT == mdoc_atomsec(args[1]))
		return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_ARGFORM));
	return(1);
}


static int
args_nopunct(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[],
		int argc, const struct mdoc_arg *argv)
{
	int		 i;

	if (0 == sz)
a238 8

	i = 0;
	if (ATT_DEFAULT == mdoc_atoatt(args[i]))
		i++;
	for ( ; i < sz; i++) {
		if ( ! mdoc_isdelim(args[i]))
			continue;
		return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_NOPUNCT));
a239 12
	return(1);
}


static int
tree_pre_display(struct mdoc *mdoc, int tok, int pos)
{
	struct mdoc_node *node;

	assert(mdoc->last);

	/* Displays may not be nested in other displays. */
d241 1
a241 9
	/* LINTED */
	for (node = mdoc->last; node; node = node->parent) {
		if (node->type != MDOC_BLOCK)
			continue;
		if (node->data.block.tok != MDOC_Bd)
			continue;
		break;
	}
	if (NULL == node)
a242 2
	return(mdoc_err(mdoc, tok, pos, ERR_SCOPE_NONEST));
}
d244 3
a246 13

int
mdoc_valid_pre(struct mdoc *mdoc, int tok, int pos, 
		int argc, const struct mdoc_arg *argv)
{

	return(1);
}


int
mdoc_valid_post(struct mdoc *mdoc, int tok, int pos)
{
@


1.15
log
@Huge changes.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.14 2009/01/03 18:38:39 kristaps Exp $ */
a324 1
	printf("argc=%d, sz=%d\n", argc, sz);
a450 11
	assert(tok < MDOC_MAX);
	if (mdoc_valids[tok].sz) 
		if ( ! (*mdoc_valids[tok].sz)(mdoc, tok, pos, sz))
			return(0);
	if (mdoc_valids[tok].args) 
		if ( ! (*mdoc_valids[tok].args)(mdoc, tok, pos, 
					sz, args, argc, argv))
			return(0);
	if (mdoc_valids[tok].tree_pre) 
		if ( ! (*mdoc_valids[tok].tree_pre)(mdoc, tok, pos))
			return(0);
d456 1
a456 2
mdoc_valid_post(struct mdoc *mdoc, int tok, int pos,
		int argc, const struct mdoc_arg *argv)
a458 2
	if (mdoc_valids[tok].tree_post)
		return((*mdoc_valids[tok].tree_post)(mdoc, tok, pos));
@


1.14
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.13 2009/01/02 14:06:16 kristaps Exp $ */
d79 2
a80 2
	{ want_ge1, args_sh, NULL, NULL }, /* Sh */
	{ want_ge1, NULL, NULL, NULL }, /* Ss */ 
d84 1
a84 1
	{ want_eq0, NULL, tree_pre_display, tree_post_warnemptybody }, /* Bd */
d86 1
a86 1
	{ want_eq0, NULL, NULL, NULL }, /* Bl */
d130 1
a130 1
	{ need_le2, args_nopunct, NULL, NULL }, /* At */
d154 1
a154 1
	{ NULL, NULL, NULL, NULL }, /* Pq */
a448 1
		int sz, const char *args[], 
d468 2
a469 1
mdoc_valid_post(struct mdoc *mdoc, int tok, int pos)
@


1.13
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.12 2009/01/02 09:29:06 kristaps Exp $ */
d27 12
a38 3
typedef int	(*v_args)(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);
typedef int	(*v_post)(struct mdoc *, int, int);
a39 2
static	int	  need_head_child(struct mdoc *, int, int);
static	int	  no_head_child(struct mdoc *, int, int);
d50 2
a51 18
static	int	  args_ref(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);
static	int	  args_bool(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);
static	int	  args_Sh(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);
static	int	  args_blocknest(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);
static	int	  args_At(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);
static	int	  args_Xr(struct mdoc *, int, int, int, 
			const char *[], int, const struct mdoc_arg *);

struct	valids {
	v_args_sz sz;
	v_args	  args;
	v_post	  post;
};
d53 19
a72 4
/* 
 * FIXME: have arrays of function pointers in case we want multiple
 * check callbacks per macro.
 */
d75 106
a180 106
	{ NULL, NULL, NULL }, /* \" */
	{ NULL, NULL, NULL }, /* Dd */ /* TODO */
	{ NULL, NULL, NULL }, /* Dt */ /* TODO */
	{ NULL, NULL, NULL }, /* Os */ /* TODO */
	{ NULL, args_Sh, NULL }, /* Sh */
	{ NULL, NULL, NULL }, /* Ss */ 
	{ want_eq0, NULL, NULL }, /* Pp */ 
	{ NULL, args_blocknest, need_head_child }, /* D1 */
	{ NULL, args_blocknest, need_head_child }, /* Dl */
	{ NULL, args_blocknest, NULL }, /* Bd */
	{ NULL, NULL, no_head_child }, /* Ed */
	{ NULL, NULL, NULL }, /* Bl */
	{ NULL, NULL, no_head_child }, /* El */
	{ NULL, NULL, NULL }, /* It */
	{ need_ge1, NULL, NULL }, /* Ad */ 
	{ NULL, NULL, NULL }, /* An */  /* FIXME: no args & argv. */
	{ NULL, NULL, NULL }, /* Ar */
	{ need_ge1, NULL, NULL }, /* Cd */
	{ NULL, NULL, NULL }, /* Cm */
	{ need_ge1, NULL, NULL }, /* Dv */ 
	{ need_ge1, NULL, NULL }, /* Er */ 
	{ need_ge1, NULL, NULL }, /* Ev */ 
	{ NULL, NULL, NULL }, /* Ex */
	{ need_ge1, NULL, NULL }, /* Fa */ 
	{ NULL, NULL, NULL }, /* Fd */ 
	{ NULL, NULL, NULL }, /* Fl */
	{ need_ge1, NULL, NULL }, /* Fn */ 
	{ want_ge1, NULL, NULL }, /* Ft */ 
	{ need_ge1, NULL, NULL }, /* Ic */ 
	{ need_eq1, NULL, NULL }, /* In */ 
	{ want_ge1, NULL, NULL }, /* Li */
	{ want_ge1, NULL, NULL }, /* Nd */ 
	{ NULL, NULL, NULL }, /* Nm */ 
	{ NULL, NULL, NULL }, /* Op */
	{ NULL, NULL, NULL }, /* Ot */
	{ want_ge1, NULL, NULL }, /* Pa */
	{ NULL, NULL, NULL }, /* Rv */
	{ NULL, NULL, NULL }, /* St */
	{ need_ge1, NULL, NULL }, /* Va */
	{ need_ge1, NULL, NULL }, /* Vt */ 
	{ need_le2, args_Xr, NULL }, /* Xr */
	{ need_ge1, args_ref, NULL }, /* %A */
	{ need_ge1, args_ref, NULL }, /* %B */
	{ need_ge1, args_ref, NULL }, /* %D */
	{ need_ge1, args_ref, NULL }, /* %I */
	{ need_ge1, args_ref, NULL }, /* %J */
	{ need_ge1, args_ref, NULL }, /* %N */
	{ need_ge1, args_ref, NULL }, /* %O */
	{ need_ge1, args_ref, NULL }, /* %P */
	{ need_ge1, args_ref, NULL }, /* %R */
	{ need_ge1, args_ref, NULL }, /* %T */
	{ need_ge1, args_ref, NULL }, /* %V */
	{ NULL, NULL, NULL }, /* Ac */
	{ NULL, NULL, NULL }, /* Ao */
	{ NULL, NULL, NULL }, /* Aq */
	{ need_le2, args_At, NULL }, /* At */
	{ NULL, NULL, NULL }, /* Bc */
	{ NULL, NULL, NULL }, /* Bf */ 
	{ NULL, NULL, NULL }, /* Bo */
	{ NULL, NULL, NULL }, /* Bq */
	{ assert_le1, NULL, NULL }, /* Bsx */
	{ assert_le1, NULL, NULL }, /* Bx */
	{ need_eq1, args_bool, NULL }, /* Db */
	{ NULL, NULL, NULL }, /* Dc */
	{ NULL, NULL, NULL }, /* Do */
	{ NULL, NULL, NULL }, /* Dq */
	{ NULL, NULL, NULL }, /* Ec */
	{ NULL, NULL, NULL }, /* Ef */ /* -symbolic, etc. */
	{ need_ge1, NULL, NULL }, /* Em */ 
	{ NULL, NULL, NULL }, /* Eo */
	{ assert_le1, NULL, NULL }, /* Fx */
	{ want_ge1, NULL, NULL }, /* Ms */
	{ NULL, NULL, NULL }, /* No */
	{ NULL, NULL, NULL }, /* Ns */
	{ assert_le1, NULL, NULL }, /* Nx */
	{ assert_le1, NULL, NULL }, /* Ox */
	{ NULL, NULL, NULL }, /* Pc */
	{ NULL, NULL, NULL }, /* Pf */ /* 2 or more arguments */
	{ NULL, NULL, NULL }, /* Po */
	{ NULL, NULL, NULL }, /* Pq */
	{ NULL, NULL, NULL }, /* Qc */
	{ NULL, NULL, NULL }, /* Ql */
	{ NULL, NULL, NULL }, /* Qo */
	{ NULL, NULL, NULL }, /* Qq */
	{ NULL, NULL, NULL }, /* Re */
	{ NULL, NULL, NULL }, /* Rs */
	{ NULL, NULL, NULL }, /* Sc */
	{ NULL, NULL, NULL }, /* So */
	{ NULL, NULL, NULL }, /* Sq */
	{ need_eq1, args_bool, NULL }, /* Sm */
	{ need_ge1, NULL, NULL }, /* Sx */
	{ need_ge1, NULL, NULL }, /* Sy */
	{ want_ge1, NULL, NULL }, /* Tn */
	{ assert_eq0, NULL, NULL }, /* Ux */
	{ NULL, NULL, NULL }, /* Xc */
	{ NULL, NULL, NULL }, /* Xo */
	{ NULL, NULL, NULL }, /* Fo */ 
	{ NULL, NULL, NULL }, /* Fc */ 
	{ NULL, NULL, NULL }, /* Oo */
	{ NULL, NULL, NULL }, /* Oc */
	{ NULL, NULL, NULL }, /* Bk */
	{ NULL, NULL, NULL }, /* Ek */
	{ need_eq0, NULL, NULL }, /* Bt */
	{ need_eq1, NULL, NULL }, /* Hf */
	{ NULL, NULL, NULL }, /* Fr */
	{ need_eq0, NULL, NULL }, /* Ud */
d257 1
a257 1
no_head_child(struct mdoc *mdoc, int tok, int pos)
d259 32
d292 3
a294 2
	/* TODO */
	return(1);
d299 1
a299 1
need_head_child(struct mdoc *mdoc, int tok, int pos)
d312 1
a312 1
		return(mdoc_err(mdoc, tok, pos, ERR_CHILD_HEAD));
d315 14
a328 1
	return(mdoc_err(mdoc, tok, pos, ERR_CHILD_HEAD));
d333 2
a334 2
args_Sh(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[], 
d352 1
a352 1
		int sz, const char *args[], 
d355 1
d357 8
a364 6
	assert(1 == sz);
	if (xstrcmp(args[0], "on"))
		return(1);	
	if (xstrcmp(args[0], "off"))
		return(1);
	return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_ARGBAD));
d369 1
a369 3
args_ref(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[], 
		int argc, const struct mdoc_arg *argv)
d387 2
a388 2
args_Xr(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[], 
a395 1

d403 2
a404 2
args_At(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[], 
a414 1

d425 1
a425 3
args_blocknest(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[], 
		int argc, const struct mdoc_arg *argv)
a428 5
	/*
	 * We can't be nested within any other block displays (or really
	 * any other kind of display, although Bd is the only multi-line
	 * one that will show up). 
	 */
d431 2
d457 8
a464 5

	if (NULL == mdoc_valids[tok].args) 
		return(1);
	return((*mdoc_valids[tok].args)(mdoc, 
			tok, pos, sz, args, argc, argv));
d472 3
a474 3
	if (NULL == mdoc_valids[tok].post)
		return(1);
	return((*mdoc_valids[tok].post)(mdoc, tok, pos));
d476 1
@


1.12
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.11 2009/01/01 20:40:16 kristaps Exp $ */
d84 1
a84 1
	{ NULL, NULL, NULL }, /* An */ 
d136 1
a136 1
	{ NULL, NULL, NULL }, /* Ef */
d146 1
a146 1
	{ NULL, NULL, NULL }, /* Pf */
@


1.11
log
@Broke apart macro_prologuexxx into prologue.
Fixed validation for line-scoped.
Merged const_arg and const.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.10 2008/12/30 19:06:03 kristaps Exp $ */
d32 1
d63 5
d79 1
a79 1
	{ NULL, NULL, NULL }, /* Ed */
d81 1
a81 1
	{ NULL, NULL, NULL }, /* El */
d251 9
@


1.10
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.9 2008/12/30 18:15:26 kristaps Exp $ */
d24 1
d26 2
a27 2
typedef int	(*v_sz)(struct mdoc *, int, int, int);
typedef int	(*v_extra)(struct mdoc *, int, int, int, 
d29 1
d31 16
a46 9
static int	  assert_eq0(struct mdoc *, int, int, int);
static int	  assert_le1(struct mdoc *, int, int, int);
static int	  need_eq0(struct mdoc *, int, int, int);
static int	  need_eq1(struct mdoc *, int, int, int);
static int	  need_ge1(struct mdoc *, int, int, int);
static int	  need_le2(struct mdoc *, int, int, int);
static int	  want_eq0(struct mdoc *, int, int, int);
static int	  want_ge1(struct mdoc *, int, int, int);
static int	  v_Sh(struct mdoc *, int, int, int, 
d48 1
a48 1
static int	  v_Bd(struct mdoc *, int, int, int, 
d50 3
a52 1
static int	  v_At(struct mdoc *, int, int, int, 
d56 3
a58 2
	v_sz	  sz;
	v_extra	  extra;
d63 106
a168 106
	{ NULL, NULL }, /* \" */
	{ NULL, NULL }, /* Dd */
	{ NULL, NULL }, /* Dt */
	{ NULL, NULL }, /* Os */
	{ need_ge1, v_Sh }, /* Sh */
	{ need_ge1, NULL }, /* Ss */ 
	{ want_eq0, NULL }, /* Pp */ 
	{ NULL, NULL }, /* D1 */
	{ NULL, NULL }, /* Dl */
	{ NULL, v_Bd }, /* Bd */
	{ NULL, NULL }, /* Ed */
	{ NULL, NULL }, /* Bl */
	{ NULL, NULL }, /* El */
	{ NULL, NULL }, /* It */
	{ need_ge1, NULL }, /* Ad */ 
	{ NULL, NULL }, /* An */ 
	{ NULL, NULL }, /* Ar */
	{ need_ge1, NULL }, /* Cd */
	{ NULL, NULL }, /* Cm */
	{ need_ge1, NULL }, /* Dv */ 
	{ need_ge1, NULL }, /* Er */ 
	{ need_ge1, NULL }, /* Ev */ 
	{ NULL, NULL }, /* Ex */
	{ need_ge1, NULL }, /* Fa */ 
	{ NULL, NULL }, /* Fd */ 
	{ NULL, NULL }, /* Fl */
	{ need_ge1, NULL }, /* Fn */ 
	{ want_ge1, NULL }, /* Ft */ 
	{ need_ge1, NULL }, /* Ic */ 
	{ NULL, NULL }, /* In */ 
	{ want_ge1, NULL }, /* Li */
	{ want_ge1, NULL }, /* Nd */ 
	{ NULL, NULL }, /* Nm */ 
	{ NULL, NULL }, /* Op */
	{ NULL, NULL }, /* Ot */
	{ want_ge1, NULL }, /* Pa */
	{ NULL, NULL }, /* Rv */
	{ NULL, NULL }, /* St */
	{ need_ge1, NULL }, /* Va */
	{ need_ge1, NULL }, /* Vt */ 
	{ NULL, NULL }, /* Xr */
	{ NULL, NULL }, /* %A */
	{ NULL, NULL }, /* %B */
	{ NULL, NULL }, /* %D */
	{ NULL, NULL }, /* %I */
	{ NULL, NULL }, /* %J */
	{ NULL, NULL }, /* %N */
	{ NULL, NULL }, /* %O */
	{ NULL, NULL }, /* %P */
	{ NULL, NULL }, /* %R */
	{ NULL, NULL }, /* %T */
	{ NULL, NULL }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ NULL, NULL }, /* Ao */
	{ NULL, NULL }, /* Aq */
	{ need_le2, v_At }, /* At */
	{ NULL, NULL }, /* Bc */
	{ NULL, NULL }, /* Bf */ 
	{ NULL, NULL }, /* Bo */
	{ NULL, NULL }, /* Bq */
	{ assert_le1, NULL }, /* Bsx */
	{ assert_le1, NULL }, /* Bx */
	{ NULL, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ NULL, NULL }, /* Do */
	{ NULL, NULL }, /* Dq */
	{ NULL, NULL }, /* Ec */
	{ NULL, NULL }, /* Ef */
	{ need_ge1, NULL }, /* Em */ 
	{ NULL, NULL }, /* Eo */
	{ assert_le1, NULL }, /* Fx */
	{ want_ge1, NULL }, /* Ms */
	{ NULL, NULL }, /* No */
	{ NULL, NULL }, /* Ns */
	{ assert_le1, NULL }, /* Nx */
	{ assert_le1, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, NULL }, /* Pf */
	{ NULL, NULL }, /* Po */
	{ NULL, NULL }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ NULL, NULL }, /* Ql */
	{ NULL, NULL }, /* Qo */
	{ NULL, NULL }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ NULL, NULL }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ NULL, NULL }, /* So */
	{ NULL, NULL }, /* Sq */
	{ NULL, NULL }, /* Sm */
	{ need_ge1, NULL }, /* Sx */
	{ need_ge1, NULL }, /* Sy */
	{ want_ge1, NULL }, /* Tn */
	{ assert_eq0, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ NULL, NULL }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
	{ NULL, NULL }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ NULL, NULL }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ need_eq0, NULL }, /* Bt */
	{ need_eq1, NULL }, /* Hf */
	{ NULL, NULL }, /* Fr */
	{ need_eq0, NULL }, /* Ud */
d175 1
a175 1
	if (sz > 2)
d245 22
a266 1
v_Sh(struct mdoc *mdoc, int tok, int pos, 
d284 53
a336 1
v_At(struct mdoc *mdoc, int tok, int pos, 
d359 1
a359 1
v_Bd(struct mdoc *mdoc, int tok, int pos, 
d373 1
a373 1
	for (node = mdoc->last->parent ; node; node = node->parent) {
d387 1
a387 1
mdoc_valid(struct mdoc *mdoc, int tok, int pos, 
d397 1
a397 1
	if (NULL == mdoc_valids[tok].extra) 
d399 2
a400 2
	return(*mdoc_valids[tok].extra)(mdoc, 
			tok, pos, sz, args, argc, argv);
d403 9
@


1.9
log
@Validation fully works.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.8 2008/12/30 13:43:53 kristaps Exp $ */
d68 1
a68 1
	{ NULL, NULL }, /* Cd */
d77 1
a77 1
	{ NULL, NULL }, /* Fn */ 
@


1.8
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: macro.c,v 1.12 2008/12/29 19:25:29 kristaps Exp $ */
a19 1
#include <ctype.h>
a20 5
#include <stdio.h>
#include <string.h>
#ifdef	__linux__
#include <time.h>
#endif
a23 2
/* FIXME: maxlineargs should be per LINE, no per TOKEN. */
/* FIXME: prologue check should be in macro_call. */
d25 3
a27 1
#define	_CC(p)	((const char **)p)
d29 13
a41 8
static	int	  scope_rewind_exp(struct mdoc *, int, int, int);
static	int	  scope_rewind_imp(struct mdoc *, int, int);
static	int	  append_text(struct mdoc *, int, 
			int, int, char *[]);
static	int	  append_const(struct mdoc *, int, int, int, char *[]);
static	int	  append_constarg(struct mdoc *, int, int, 
			 int, const struct mdoc_arg *);
static	int	  append_scoped(struct mdoc *, int, int, int, 
d43 115
a157 1
static	int	  append_delims(struct mdoc *, int, int *, char *);
d161 1
a161 1
append_delims(struct mdoc *mdoc, int tok, int *pos, char *buf)
d163 1
a163 4
	int		 c, lastarg;
	char		*p;

	if (0 == buf[*pos])
d165 1
a165 16

	mdoc_msg(mdoc, *pos, "`%s' flushing punctuation",
			mdoc_macronames[tok]);

	for (;;) {
		lastarg = *pos;
		c = mdoc_args(mdoc, tok, pos, buf, 0, &p);
		if (ARGS_ERROR == c)
			return(0);
		else if (ARGS_EOLN == c)
			break;
		assert(mdoc_isdelim(p));
		mdoc_word_alloc(mdoc, lastarg, p);
	}

	return(1);
d170 1
a170 1
scope_rewind_imp(struct mdoc *mdoc, int ppos, int tok)
d172 1
a172 20
	struct mdoc_node *n;
	int		  t;

	n = mdoc->last ? mdoc->last->parent : NULL;

	/* LINTED */
	for ( ; n; n = n->parent) {
		if (MDOC_BLOCK != n->type) 
			continue;
		if (tok == (t = n->data.block.tok))
			break;
		if ( ! (MDOC_EXPLICIT & mdoc_macros[t].flags))
			continue;
		return(mdoc_err(mdoc, tok, ppos, ERR_SCOPE_BREAK));
	}

	if (n) {
		mdoc->last = n;
		mdoc_msg(mdoc, ppos, "scope: rewound implicit `%s'",
				mdoc_macronames[tok]);
d174 1
a174 5
	} 

	mdoc_msg(mdoc, ppos, "scope: new implicit `%s'", 
			mdoc_macronames[tok]);
	return(1);
d179 1
a179 1
scope_rewind_exp(struct mdoc *mdoc, int ppos, int tok, int dst)
d181 3
a183 20
	struct mdoc_node *n;

	assert(mdoc->last);

	/* LINTED */
	for (n = mdoc->last->parent; n; n = n->parent) {
		if (MDOC_BLOCK != n->type) 
			continue;
		if (dst == n->data.block.tok)
			break;
		return(mdoc_err(mdoc, tok, ppos, ERR_SCOPE_BREAK));
	}

	if (NULL == (mdoc->last = n))
		return(mdoc_err(mdoc, tok, ppos, ERR_SCOPE_NOCTX));

	mdoc_msg(mdoc, ppos, "scope: rewound explicit `%s' to `%s'",
			mdoc_macronames[tok], mdoc_macronames[dst]);

	return(1);
d188 1
a188 2
append_constarg(struct mdoc *mdoc, int tok, int pos, 
		int argc, const struct mdoc_arg *argv)
d190 3
a192 8

	switch (tok) {
	default:
		break;
	}

	mdoc_elem_alloc(mdoc, pos, tok, argc, argv, 0, NULL);
	return(1);
a195 4
/*
 * Append a node with implicit or explicit scoping ONLY.  ALL macros
 * with the implicit- or explicit-scope callback must be included here.
 */
d197 1
a197 3
append_scoped(struct mdoc *mdoc, int tok, int pos, 
		int sz, const char *args[], 
		int argc, const struct mdoc_arg *argv)
a198 28
	enum mdoc_sec	  sec;
	struct mdoc_node *node;

	switch (tok) {
	 /* ======= ADD MORE MACRO CHECKS BELOW. ======= */

	case (MDOC_Sh):
		/*
		 * Check rules for section ordering.  We can have
		 * "known" sections (like NAME and so on) and "custom"
		 * sections, which are unknown.  If we have a known
		 * section, we should fall within the conventional
		 * section order.
		 */
		if (0 == sz) 
			return(mdoc_err(mdoc, tok, pos, ERR_ARGS_GE1));

		sec = mdoc_atosec((size_t)sz, _CC(args));
		if (SEC_CUSTOM != sec && sec < mdoc->sec_lastn)
			if ( ! mdoc_warn(mdoc, tok, pos, WARN_SEC_OO))
				return(0);

		if (SEC_BODY == mdoc->sec_last && SEC_NAME != sec)
			return(mdoc_err(mdoc, tok, pos, ERR_SEC_NAME));
		if (SEC_CUSTOM != sec)
			mdoc->sec_lastn = sec;
		mdoc->sec_last = sec;
		break;
d200 1
a200 37
	case (MDOC_Ss):
		if (0 != sz) 
			break;
		return(mdoc_err(mdoc, tok, pos, ERR_ARGS_GE1));
	
	case (MDOC_Bd):
		/*
		 * We can't be nested within any other block displays
		 * (or really any other kind of display, although Bd is
		 * the only multi-line one that will show up). 
		 */
		assert(mdoc->last);
		node = mdoc->last->parent; 
		/* LINTED */
		for ( ; node; node = node->parent) {
			if (node->type != MDOC_BLOCK)
				continue;
			if (node->data.block.tok != MDOC_Bd)
				continue;
			break;
		}
		if (NULL == node)
			break;
		return(mdoc_err(mdoc, tok, pos, ERR_SCOPE_NONEST));

	case (MDOC_Bl):
		break;

	 /* ======= ADD MORE MACRO CHECKS ABOVE. ======= */
	default:
		abort();
		/* NOTREACHED */
	}

	mdoc_block_alloc(mdoc, pos, tok, (size_t)argc, argv);
	mdoc_head_alloc(mdoc, pos, tok, (size_t)sz, _CC(args));
	mdoc_body_alloc(mdoc, pos, tok);
d206 1
a206 2
append_const(struct mdoc *mdoc, int tok, 
		int pos, int sz, char *args[])
d209 1
a209 71
	switch (tok) {
	 /* ======= ADD MORE MACRO CHECKS BELOW. ======= */

	/* FIXME: this is the ugliest part of this page. */
	case (MDOC_At):
		/* This needs special handling. */
		if (0 == sz)
			break;
		else if (sz > 2)
			return(mdoc_err(mdoc, tok, pos, ERR_ARGS_LE2));

		if (ATT_DEFAULT != mdoc_atoatt(args[0])) {
			mdoc_elem_alloc(mdoc, pos, tok, 0, 
					NULL, 1, _CC(&args[0]));
		} else {
			mdoc_elem_alloc(mdoc, pos, tok, 
					0, NULL, 0, NULL);
			if (mdoc_isdelim(args[0]))
				return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_NOPUNCT));
			mdoc_word_alloc(mdoc, pos, args[0]);
		}

		if (1 == sz)
			return(1);
		if (mdoc_isdelim(args[1]))
			return(mdoc_err(mdoc, tok, pos, ERR_SYNTAX_NOPUNCT));
		mdoc_word_alloc(mdoc, pos, args[1]);
		return(1);

	case (MDOC_Nd):
		if (sz > 0)
			break;
		if ( ! mdoc_warn(mdoc, tok, pos, WARN_ARGS_GE1))
			return(0);
		break;
	
	case (MDOC_Hf):
		if (1 == sz)
			break;
		return(mdoc_err(mdoc, tok, pos, ERR_ARGS_EQ1));

	case (MDOC_Bx):
		/* FALLTHROUGH */
	case (MDOC_Bsx):
		/* FALLTHROUGH */
	case (MDOC_Os):
		/* FALLTHROUGH */
	case (MDOC_Fx):
		/* FALLTHROUGH */
	case (MDOC_Nx):
		assert(sz <= 1);
		break;

	case (MDOC_Ux):
		assert(0 == sz);
		break;

	case (MDOC_Bt):
		/* FALLTHROUGH */
	case (MDOC_Ud):
		if (0 == sz)
			break;
		return(mdoc_err(mdoc, tok, pos, ERR_ARGS_EQ0));

	 /* ======= ADD MORE MACRO CHECKS ABOVE. ======= */
	default:
		abort();
		/* NOTREACHED */
	}

	mdoc_elem_alloc(mdoc, pos, tok, 0, NULL, (size_t)sz, _CC(args));
d215 1
a215 2
append_text(struct mdoc *mdoc, int tok, 
		int pos, int sz, char *args[])
d217 3
a219 65

	switch (tok) {
	 /* ======= ADD MORE MACRO CHECKS BELOW. ======= */
	case (MDOC_Pp):
		if (0 == sz)
			break;
		if ( ! mdoc_warn(mdoc, tok, pos, WARN_ARGS_EQ0))
			return(0);
		break;

	case (MDOC_Ft):
		/* FALLTHROUGH */
	case (MDOC_Li):
		/* FALLTHROUGH */
	case (MDOC_Ms):
		/* FALLTHROUGH */
	case (MDOC_Pa):
		/* FALLTHROUGH */
	case (MDOC_Tn):
		if (0 < sz)
			break;
		if ( ! mdoc_warn(mdoc, tok, pos, WARN_ARGS_GE1))
			return(0);
		break;

	case (MDOC_Ar):
		/* FALLTHROUGH */
	case (MDOC_Cm):
		/* FALLTHROUGH */
	case (MDOC_Fl):
		/* These can have no arguments. */
		break;

	case (MDOC_Ad):
		/* FALLTHROUGH */
	case (MDOC_Em):
		/* FALLTHROUGH */
	case (MDOC_Er):
		/* FALLTHROUGH */
	case (MDOC_Ev):
		/* FALLTHROUGH */
	case (MDOC_Fa):
		/* FALLTHROUGH */
	case (MDOC_Dv):
		/* FALLTHROUGH */
	case (MDOC_Ic):
		/* FALLTHROUGH */
	case (MDOC_Sy):
		/* FALLTHROUGH */
	case (MDOC_Sx):
		/* FALLTHROUGH */
	case (MDOC_Va):
		/* FALLTHROUGH */
	case (MDOC_Vt):
		if (0 < sz) 
			break;
		return(mdoc_err(mdoc, tok, pos, ERR_ARGS_GE1));
	 /* ======= ADD MORE MACRO CHECKS ABOVE. ======= */
	default:
		abort();
		/* NOTREACHED */
	}

	mdoc_elem_alloc(mdoc, pos, tok, 0, NULL, (size_t)sz, _CC(args));
	return(1);
d223 2
a224 2
int
macro_text(MACRO_PROT_ARGS)
d226 3
a228 109
	int		  lastarg, lastpunct, c, j;
	char		 *args[MDOC_LINEARG_MAX];

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	/* Token pre-processing.  */

	switch (tok) {
	case (MDOC_Pp):
		/* `.Pp' ignored when following `.Sh' or `.Ss'. */
		assert(mdoc->last);
		if (MDOC_BODY != mdoc->last->type)
			break;
		switch (mdoc->last->data.body.tok) {
		case (MDOC_Ss):
			/* FALLTHROUGH */
		case (MDOC_Sh):
			if ( ! mdoc_warn(mdoc, tok, ppos, WARN_IGN_AFTER_BLK))
				return(0);
			return(1);
		default:
			break;
		}
		break;
	default:
		break;
	}

	/* Process line parameters. */

	j = 0;
	lastarg = ppos;
	lastpunct = 0;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	/* 
	 * Parse out the next argument, unquoted and unescaped.   If
	 * we're a word (which may be punctuation followed eventually by
	 * a real word), then fall into checking for callables.  If
	 * only punctuation remains and we're the first, then flush
	 * arguments, punctuation and exit; else, return to the caller.
	 */

	lastarg = *pos;

	switch (mdoc_args(mdoc, tok, pos, buf, ARGS_DELIM, &args[j])) {
	case (ARGS_ERROR):
		return(0);
	case (ARGS_WORD):
		break;
	case (ARGS_PUNCT):
		if ( ! lastpunct && ! append_text(mdoc, tok, ppos, j, args))
			return(0);
		if (ppos > 1)
			return(1);
		return(append_delims(mdoc, tok, pos, buf));
	case (ARGS_EOLN):
		if (lastpunct)
			return(1);
		return(append_text(mdoc, tok, ppos, j, args));
	default:
		abort();
		/* NOTREACHED */
	}

	/* 
	 * Command found.  First flush out arguments, then call the
	 * command.  If we're the line macro when it exits, flush
	 * terminal punctuation.
	 */

	if (MDOC_MAX != (c = mdoc_find(mdoc, args[j]))) {
		if ( ! lastpunct && ! append_text(mdoc, tok, ppos, j, args))
			return(0);
		if ( ! mdoc_macro(mdoc, c, lastarg, pos, buf))
			return(0);
		if (ppos > 1)
			return(1);
		return(append_delims(mdoc, tok, pos, buf));
	}

	/* Word/non-term-punctuation found. */

	if ( ! mdoc_isdelim(args[j])) {
		/* Words are appended to the array of arguments. */
		j++;
		lastpunct = 0;
		goto again;
	}

	/* 
	 * For punctuation, flush all collected words, then flush
	 * punctuation, then start collecting again.   Of course, this
	 * is non-terminal punctuation.
	 */

	if ( ! lastpunct && ! append_text(mdoc, tok, ppos, j, args))
		return(0);

	mdoc_word_alloc(mdoc, lastarg, args[j]);
	j = 0;
	lastpunct = 1;

	goto again;
	/* NOTREACHED */
d232 4
a235 2
int
macro_prologue_dtitle(MACRO_PROT_ARGS)
d237 1
a237 2
	int		  lastarg, j;
	char		 *args[MDOC_LINEARG_MAX];
d239 3
a241 21
	if (SEC_PROLOGUE != mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_NPROLOGUE));
	if (0 == mdoc->meta.date)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE_OO));
	if (mdoc->meta.title[0])
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE_REP));

	j = -1;
	lastarg = ppos;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	lastarg = *pos;

	switch (mdoc_args(mdoc, tok, pos, buf, 0, &args[++j])) {
	case (ARGS_EOLN):
		if (mdoc->meta.title)
			return(1);
		if ( ! mdoc_warn(mdoc, tok, ppos, WARN_ARGS_GE1))
d243 2
a244 8
		(void)xstrlcpy(mdoc->meta.title, 
				"UNTITLED", META_TITLE_SZ);
		return(1);
	case (ARGS_ERROR):
		return(0);
	default:
		break;
	}
d246 1
a246 26
	if (MDOC_MAX != mdoc_find(mdoc, args[j]) && ! mdoc_warn
			(mdoc, tok, lastarg, WARN_SYNTAX_MACLIKE))
		return(0);

	if (0 == j) {
		if (xstrlcpy(mdoc->meta.title, args[0], META_TITLE_SZ))
			goto again;
		return(mdoc_err(mdoc, tok, lastarg, ERR_SYNTAX_ARGFORM));

	} else if (1 == j) {
		mdoc->meta.msec = mdoc_atomsec(args[1]);
		if (MSEC_DEFAULT != mdoc->meta.msec)
			goto again;
		return(mdoc_err(mdoc, tok, -1, ERR_SYNTAX_ARGFORM));

	} else if (2 == j) {
		mdoc->meta.vol = mdoc_atovol(args[2]);
		if (VOL_DEFAULT != mdoc->meta.vol)
			goto again;
		mdoc->meta.arch = mdoc_atoarch(args[2]);
		if (ARCH_DEFAULT != mdoc->meta.arch)
			goto again;
		return(mdoc_err(mdoc, tok, lastarg, ERR_SYNTAX_ARGFORM));
	}

	return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));
d250 4
a253 2
int
macro_prologue_os(MACRO_PROT_ARGS)
d255 1
a255 2
	int		  lastarg, j;
	char		 *args[MDOC_LINEARG_MAX];
d257 1
a257 20
	if (SEC_PROLOGUE != mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_NPROLOGUE));
	if (0 == mdoc->meta.title[0])
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE_OO));
	if (mdoc->meta.os[0])
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE_REP));

	j = -1;
	lastarg = ppos;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	lastarg = *pos;

	switch (mdoc_args(mdoc, tok, pos, buf, 
				ARGS_QUOTED, &args[++j])) {
	case (ARGS_EOLN):
		mdoc->sec_lastn = mdoc->sec_last = SEC_BODY;
a258 10
	case (ARGS_ERROR):
		return(0);
	default:
		break;
	}
	
	if ( ! xstrlcat(mdoc->meta.os, args[j], sizeof(mdoc->meta.os)))
		return(mdoc_err(mdoc, tok, lastarg, ERR_SYNTAX_ARGFORM));
	if ( ! xstrlcat(mdoc->meta.os, " ", sizeof(mdoc->meta.os)))
		return(mdoc_err(mdoc, tok, lastarg, ERR_SYNTAX_ARGFORM));
d260 3
a262 3
	goto again;
	/* NOTREACHED */
}
d264 4
a267 35

int
macro_prologue_ddate(MACRO_PROT_ARGS)
{
	int		  lastarg, j;
	char		 *args[MDOC_LINEARG_MAX], date[64];

	if (SEC_PROLOGUE != mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_NPROLOGUE));
	if (mdoc->meta.title[0])
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE_OO));
	if (mdoc->meta.date)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE_REP));

	j = -1;
	date[0] = 0;
	lastarg = ppos;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	lastarg = *pos;
	switch (mdoc_args(mdoc, tok, pos, buf, 0, &args[++j])) {
	case (ARGS_EOLN):
		if (mdoc->meta.date)
			return(1);
		mdoc->meta.date = mdoc_atotime(date);
		if (mdoc->meta.date)
			return(1);
		return(mdoc_err(mdoc, tok, ppos, ERR_SYNTAX_ARGFORM));
	case (ARGS_ERROR):
		return(0);
	default:
		break;
d269 1
a269 22
	
	if (MDOC_MAX != mdoc_find(mdoc, args[j]) && ! mdoc_warn
			(mdoc, tok, lastarg, WARN_SYNTAX_MACLIKE))
		return(0);
	
	if (0 == j) {
		if (xstrcmp("$Mdocdate$", args[j])) {
			mdoc->meta.date = time(NULL);
			goto again;
		} else if (xstrcmp("$Mdocdate:", args[j])) 
			goto again;
	} else if (4 == j)
		if ( ! xstrcmp("$", args[j]))
			goto again;

	if ( ! xstrlcat(date, args[j], sizeof(date)))
		return(mdoc_err(mdoc, tok, lastarg, ERR_SYNTAX_ARGFORM));
	if ( ! xstrlcat(date, " ", sizeof(date)))
		return(mdoc_err(mdoc, tok, lastarg, ERR_SYNTAX_ARGFORM));

	goto again;
	/* NOTREACHED */
d273 4
a276 2
int
macro_scoped_explicit(MACRO_PROT_ARGS)
d278 1
a278 6
	int		  c, lastarg, j;
	struct mdoc_arg	  argv[MDOC_LINEARG_MAX];
	struct mdoc_node *n;

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));
d281 3
a283 3
	 * First close out the explicit scope.  The `end' tags (such as
	 * `.El' to `.Bl' don't cause anything to happen: we merely
	 * readjust our last parse point.
d285 1
d287 5
a291 43
	switch (tok) {
	case (MDOC_El):
		return(scope_rewind_exp(mdoc, ppos, tok, MDOC_Bl));
	case (MDOC_Ed):
		return(scope_rewind_exp(mdoc, ppos, tok, MDOC_Bd));
	default:
		break;
	}

	assert(MDOC_EXPLICIT & mdoc_macros[tok].flags);

	/* Token pre-processing. */

	switch (tok) {
	case (MDOC_Bl):
		/* FALLTHROUGH */
	case (MDOC_Bd):
		/* `.Pp' ignored when preceding `.Bl' or `.Bd'. */
		assert(mdoc->last);
		if (MDOC_ELEM != mdoc->last->type)
			break;
		if (MDOC_Pp != mdoc->last->data.elem.tok)
			break;
		if ( ! mdoc_warn(mdoc, tok, ppos, WARN_IGN_BEFORE_BLK))
			return(0);
		assert(mdoc->last->prev);
		n = mdoc->last;
		mdoc->last = mdoc->last->prev;
		mdoc->last->next = NULL;
		mdoc_node_free(n);
		break;
	default:
		break;
	}

	lastarg = *pos;

	for (j = 0; j < MDOC_LINEARG_MAX; j++) {
		lastarg = *pos;
		c = mdoc_argv(mdoc, tok, &argv[j], pos, buf);
		if (0 == c)
			break;
		else if (1 == c)
a292 63

		mdoc_argv_free(j, argv);
		return(0);
	}

	if (MDOC_LINEARG_MAX == j) {
		mdoc_argv_free(j, argv);
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));
	}

	c = append_scoped(mdoc, tok, ppos, 0, NULL, j, argv);
	mdoc_argv_free(j, argv);
	return(c);
}


/*
 * Implicity-scoped macros, like `.Ss', have a scope that terminates
 * with a subsequent call to the same macro.  Implicit macros cannot
 * break the scope of explicitly-scoped macros; however, they can break
 * the scope of other implicit macros (so `.Sh' can break `.Ss').  This
 * is ok with macros like `.It' because they exist only within an
 * explicit context.
 *
 * These macros put line arguments (which it's allowed to have) into the
 * HEAD section and open a BODY scope to be used until the macro scope
 * closes.
 */
int
macro_scoped_implicit(MACRO_PROT_ARGS)
{
	int		  lastarg, j;
	char		 *args[MDOC_LINEARG_MAX];
	struct mdoc_node *n;

	assert( ! (MDOC_EXPLICIT & mdoc_macros[tok].flags));

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	/* Token pre-processing. */

	switch (tok) {
	case (MDOC_Ss):
		/* FALLTHROUGH */
	case (MDOC_Sh):
		/* `.Pp' ignored when preceding `.Ss' or `.Sh'. */
		if (NULL == mdoc->last)
			break;
		if (MDOC_ELEM != mdoc->last->type)
			break;
		if (MDOC_Pp != mdoc->last->data.elem.tok)
			break;
		if ( ! mdoc_warn(mdoc, tok, ppos, WARN_IGN_BEFORE_BLK))
			return(0);
		assert(mdoc->last->prev);
		n = mdoc->last;
		mdoc_msg(mdoc, ppos, "removing prior `Pp' macro");
		mdoc->last = mdoc->last->prev;
		mdoc->last->next = NULL;
		mdoc_node_free(n);
		break;
	default:
d295 3
a297 37

	/* Rewind our scope. */

	if ( ! scope_rewind_imp(mdoc, ppos, tok))
		return(0);

	j = 0;
	lastarg = ppos;

	/*
	 * Process until we hit a line.  Note that current implicit
	 * macros don't have any arguments, so we don't need to do any
	 * argument processing.
	 */

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	lastarg = *pos;

	switch (mdoc_args(mdoc, tok, pos, buf, 0, &args[j])) {
	case (ARGS_ERROR):
		return(0);
	case (ARGS_EOLN):
		return(append_scoped(mdoc, tok, ppos, j, _CC(args), 0, NULL));
	default:
		break;
	}

	if (MDOC_MAX != mdoc_find(mdoc, args[j]))
		if ( ! mdoc_warn(mdoc, tok, lastarg, WARN_SYNTAX_MACLIKE))
			return(0);

	j++;
	goto again;
	/* NOTREACHED */
a300 5
/*
 * A line-scoped macro opens a scope for the contents of its line, which
 * are placed under the HEAD node.  Punctuation trailing the line is put
 * as a sibling to the HEAD node, under the BLOCK node.  
 */
d302 3
a304 1
macro_scoped_line(MACRO_PROT_ARGS)
a305 46
	int		  lastarg, c, j;
	char		  *p;
	struct mdoc_node  *n;

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	assert(1 == ppos);
	
	/* Token pre-processing.  */

	switch (tok) {
	case (MDOC_D1):
		/* FALLTHROUGH */
	case (MDOC_Dl):
		/* These can't be nested in a display block. */
		assert(mdoc->last);
		for (n = mdoc->last->parent ; n; n = n->parent)
			if (MDOC_BLOCK != n->type) 
				continue;
			else if (MDOC_Bd == n->data.block.tok)
				break;
		if (NULL == n)
			break;
		return(mdoc_err(mdoc, tok, ppos, ERR_SCOPE_NONEST));
	default:
		break;
	}

	/*
	 * All line-scoped macros have a HEAD and optionally a BODY
	 * section.  We open our scope here; when we exit this function,
	 * we'll rewind our scope appropriately.
	 */

	mdoc_block_alloc(mdoc, ppos, tok, 0, NULL);
	mdoc_head_alloc(mdoc, ppos, tok, 0, NULL);

	/* Process line parameters. */

	j = 0;
	lastarg = ppos;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));
d307 3
a309 10
	lastarg = *pos;
	c = mdoc_args(mdoc, tok, pos, buf, ARGS_DELIM, &p);

	switch (c) {
	case (ARGS_ERROR):
		return(0);
	case (ARGS_WORD):
		break;
	case (ARGS_PUNCT):
		if ( ! append_delims(mdoc, tok, pos, buf))
a310 7
		return(scope_rewind_imp(mdoc, ppos, tok));
	case (ARGS_EOLN):
		return(scope_rewind_imp(mdoc, ppos, tok));
	default:
		abort();
		/* NOTREACHED */
	}
d312 4
a315 91
	if (MDOC_MAX != (c = mdoc_find(mdoc, p))) {
		if ( ! mdoc_macro(mdoc, c, lastarg, pos, buf))
			return(0);
		if ( ! append_delims(mdoc, tok, pos, buf))
			return(0);
		return(scope_rewind_imp(mdoc, ppos, tok));
	}

	if (mdoc_isdelim(p))
		j = 0;

	mdoc_word_alloc(mdoc, lastarg, p);
	goto again;
	/* NOTREACHED */
}


/* 
 * Partial-line scope is identical to line scope (macro_scoped_line())
 * except that trailing punctuation is appended to the BLOCK, instead of
 * contained within the HEAD.
 */
int
macro_scoped_pline(MACRO_PROT_ARGS)
{
	int		  lastarg, c, j;
	char		  *p;

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	/* Token pre-processing.  */

	switch (tok) {
	case (MDOC_Ql):
		if ( ! mdoc_warn(mdoc, tok, ppos, WARN_COMPAT_TROFF))
			return(0);
		break;
	default:
		break;
	}

	mdoc_block_alloc(mdoc, ppos, tok, 0, NULL);
	mdoc_head_alloc(mdoc, ppos, tok, 0, NULL);

	/* Process line parameters. */

	j = 0;
	lastarg = ppos;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	lastarg = *pos;
	c = mdoc_args(mdoc, tok, pos, buf, ARGS_DELIM, &p);

	switch (c) {
	case (ARGS_ERROR):
		return(0);
	case (ARGS_WORD):
		break;
	case (ARGS_PUNCT):
		if ( ! scope_rewind_imp(mdoc, ppos, tok))
			return(0);
		if (ppos > 1)
			return(1);
		return(append_delims(mdoc, tok, pos, buf));
	case (ARGS_EOLN):
		return(scope_rewind_imp(mdoc, ppos, tok));
	default:
		abort();
		/* NOTREACHED */
	}

	if (MDOC_MAX != (c = mdoc_find(mdoc, p))) {
		if ( ! mdoc_macro(mdoc, c, lastarg, pos, buf))
			return(0);
		if ( ! scope_rewind_imp(mdoc, ppos, tok))
			return(0);
		if (ppos > 1)
			return(1);
		return(append_delims(mdoc, tok, pos, buf));
	}

	if (mdoc_isdelim(p))
		j = 0;

	mdoc_word_alloc(mdoc, lastarg, p);
	goto again;
	/* NOTREACHED */
a317 166

/*
 * A delimited-constant macro is similar to a general text macro: the
 * macro is followed by a 0 or 1 arguments (possibly-unspecified) then
 * terminating punctuation, other words, or another callable macro.
 */
int
macro_constant_delimited(MACRO_PROT_ARGS)
{
	int		  lastarg, flushed, c, maxargs;
	char		 *p;

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	/* Process line parameters. */

	lastarg = ppos;
	flushed = 0;

	/* Token pre-processing. */

	switch (tok) {
	case (MDOC_Ux):
		maxargs = 0;
		break;
	default:
		maxargs = 1;
		break;
	}

again:
	lastarg = *pos;

	switch (mdoc_args(mdoc, tok, pos, buf, ARGS_DELIM, &p)) {
	case (ARGS_ERROR):
		return(0);
	case (ARGS_WORD):
		break;
	case (ARGS_PUNCT):
		if ( ! flushed && ! append_const(mdoc, tok, ppos, 0, &p))
			return(0);
		if (ppos > 1)
			return(1);
		return(append_delims(mdoc, tok, pos, buf));
	case (ARGS_EOLN):
		if (flushed)
			return(1);
		return(append_const(mdoc, tok, ppos, 0, &p));
	default:
		abort();
		/* NOTREACHED */
	}

	/* Accepts no arguments: flush out symbol and continue. */

	if (0 == maxargs) {
		if ( ! append_const(mdoc, tok, ppos, 0, &p))
			return(0);
		flushed = 1;
	}

	if (MDOC_MAX != (c = mdoc_find(mdoc, p))) {
		if ( ! flushed && ! append_const(mdoc, tok, ppos, 0, &p))
			return(0);
		if ( ! mdoc_macro(mdoc, c, lastarg, pos, buf))
			return(0);
		if (ppos > 1)
			return(1);
		return(append_delims(mdoc, tok, pos, buf));
	}

	/* 
	 * We only accept one argument; subsequent tokens are considered
	 * as literal words (until a macro).
	 */

	if ( ! flushed && ! mdoc_isdelim(p)) {
	       if ( ! append_const(mdoc, tok, ppos, 1, &p))
			return(0);
		flushed = 1;
		goto again;
	} else if ( ! flushed) {
		if ( ! append_const(mdoc, tok, ppos, 0, &p))
			return(0);
		flushed = 1;
	}

	mdoc_word_alloc(mdoc, lastarg, p);
	goto again;
	/* NOTREACHED */
}


int
macro_constant(MACRO_PROT_ARGS)
{
	int		  lastarg, j;
	char		 *args[MDOC_LINEARG_MAX];

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	j = 0;
	lastarg = ppos;

again:
	if (j == MDOC_LINEARG_MAX)
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));

	lastarg = *pos;

	switch (mdoc_args(mdoc, tok, pos, buf, 0, &args[j])) {
	case (ARGS_ERROR):
		return(0);
	case (ARGS_WORD):
		break;
	case (ARGS_EOLN):
		return(append_const(mdoc, tok, ppos, j, args));
	default:
		abort();
		/* NOTREACHED */
	}

	if (MDOC_MAX != mdoc_find(mdoc, args[j])) 
		if ( ! mdoc_warn(mdoc, tok, lastarg, WARN_SYNTAX_MACLIKE))
			return(0);

	j++;
	goto again;
	/* NOTREACHED */
}


int
macro_constant_argv(MACRO_PROT_ARGS)
{
	int		  c, lastarg, j;
	struct mdoc_arg	  argv[MDOC_LINEARG_MAX];

	if (SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));

	lastarg = *pos;

	for (j = 0; j < MDOC_LINEARG_MAX; j++) {
		lastarg = *pos;
		c = mdoc_argv(mdoc, tok, &argv[j], pos, buf);
		if (0 == c)
			break;
		else if (1 == c)
			continue;

		mdoc_argv_free(j, argv);
		return(0);
	}

	if (MDOC_LINEARG_MAX == j) {
		mdoc_argv_free(j, argv);
		return(mdoc_err(mdoc, tok, lastarg, ERR_ARGS_MANY));
	}

	c = append_constarg(mdoc, tok, ppos, j, argv);
	mdoc_argv_free(j, argv);
	return(c);
}
@


1.7
log
@Preliminary xml output filter (validate-renamed) done.
@
text
@d1 1159
@


1.6
log
@Cleaned up presentation with mbuf_putstring & al.
@
text
@a0 470
/* $Id: validate.c,v 1.5 2008/11/30 20:00:08 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/param.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "libmdocml.h"
#include "private.h"

#define	INDENT		 4
#define	COLUMNS		 72

#ifdef	__linux__ /* FIXME */
#define	strlcat		 strncat
#endif

enum	md_tok {
	MD_BLKIN,
	MD_BLKOUT,
	MD_IN,
	MD_OUT,
	MD_TEXT
};

struct	md_valid {
	const struct md_args	*args;
	const struct md_rbuf	*rbuf;

	struct md_mbuf	*mbuf;
	struct rofftree	*tree;
	size_t		 indent;
	size_t		 pos;
	enum md_tok	 last;
	int		 flags;
#define	MD_LITERAL	(1 << 0) /* FIXME */
};

static	void		 roffmsg(void *arg, enum roffmsg, 
				const char *, const char *, char *);
static	int		 roffhead(void *);
static	int		 rofftail(void *);
static	int		 roffin(void *, int, int, int *, char **);
static	int		 roffdata(void *, int, char *);
static	int		 roffout(void *, int);
static	int		 roffblkin(void *, int, int *, char **);
static	int		 roffblkout(void *, int);
static	int		 roffspecial(void *, int);

static	int		 mbuf_newline(struct md_valid *);
static	int		 mbuf_indent(struct md_valid *);
static	int		 mbuf_data(struct md_valid *, int, char *);
static	int		 mbuf_putstring(struct md_valid *, 
				const char *);
static	int		 mbuf_nputstring(struct md_valid *, 
				const char *, size_t);


static int
mbuf_putstring(struct md_valid *p, const char *buf)
{

	return(mbuf_nputstring(p, buf, strlen(buf)));
}


static int
mbuf_nputstring(struct md_valid *p, const char *buf, size_t sz)
{

	p->pos += sz;
	return(md_buf_puts(p->mbuf, buf, sz));
}


static int
mbuf_indent(struct md_valid *p)
{
	size_t		 i;

	assert(p->pos == 0);

	/* LINTED */
	for (i = 0; i < MIN(p->indent, INDENT); i++)
		if ( ! md_buf_putstring(p->mbuf, "    "))
			return(0);

	p->pos += i * INDENT;
	return(1);
}


static int
mbuf_newline(struct md_valid *p)
{

	if ( ! md_buf_putchar(p->mbuf, '\n'))
		return(0);

	p->pos = 0;
	return(1);
}


static int
mbuf_data(struct md_valid *p, int space, char *buf)
{
	size_t		 sz;
	char		*bufp;

	assert(p->mbuf);
	assert(0 != p->indent);

	/* 
	 * FIXME: punctuation/no-space stuff shouldn't have a newline
	 * before it.
	 */

	if (MD_LITERAL & p->flags)
		return(mbuf_putstring(p, buf));

	while (*buf) {
		while (*buf && isspace(*buf))
			buf++;

		if (0 == *buf)
			break;

		bufp = buf;
		while (*buf && ! isspace(*buf))
			buf++;

		if (0 != *buf)
			*buf++ = 0;

		sz = strlen(bufp);

		if (0 == p->pos) {
			if ( ! mbuf_indent(p))
				return(0);
			if ( ! mbuf_nputstring(p, bufp, sz))
				return(0);
			if (p->indent * INDENT + sz >= COLUMNS) {
				if ( ! mbuf_newline(p))
					return(0);
				continue;
			}
			continue;
		}

		if (sz + p->pos >= COLUMNS) {
			if ( ! mbuf_newline(p))
				return(0);
			if ( ! mbuf_indent(p))
				return(0);
		} else if (space) 
			if ( ! mbuf_nputstring(p, " ", 1))
				return(0);

		if ( ! mbuf_nputstring(p, bufp, sz))
			return(0);
	}

	return(1);
}


int
md_line_valid(void *arg, char *buf)
{
	struct md_valid	*p;

	p = (struct md_valid *)arg;
	return(roff_engine(p->tree, buf));
}


int
md_exit_valid(void *data, int flush)
{
	int		 c;
	struct md_valid	*p;

	p = (struct md_valid *)data;
	c = roff_free(p->tree, flush);
	free(p);

	return(c);
}


void *
md_init_valid(const struct md_args *args,
		struct md_mbuf *mbuf, const struct md_rbuf *rbuf)
{
	struct roffcb	 cb;
	struct md_valid	*p;

	cb.roffhead = roffhead;
	cb.rofftail = rofftail;
	cb.roffin = roffin;
	cb.roffout = roffout;
	cb.roffblkin = roffblkin;
	cb.roffblkout = roffblkout;
	cb.roffspecial = roffspecial;
	cb.roffmsg = roffmsg;
	cb.roffdata = roffdata;

	if (NULL == (p = calloc(1, sizeof(struct md_valid))))
		err(1, "malloc");

	p->args = args;
	p->mbuf = mbuf;
	p->rbuf = rbuf;

	assert(mbuf);

	if (NULL == (p->tree = roff_alloc(&cb, p))) {
		free(p);
		return(NULL);
	}

	return(p);
}


/* ARGSUSED */
static int
roffhead(void *arg)
{
	struct md_valid	*p;

	assert(arg);
	p = (struct md_valid *)arg;

	if ( ! mbuf_putstring(p, "<?xml version=\"1.0\" "
				"encoding=\"UTF-8\"?>\n"))
		return(0);
	if ( ! mbuf_nputstring(p, "<mdoc>", 6))
		return(0);

	p->indent++;
	return(mbuf_newline(p));
}


static int
rofftail(void *arg)
{
	struct md_valid	*p;

	assert(arg);
	p = (struct md_valid *)arg;

	if (0 != p->pos && ! mbuf_newline(p))
		return(0);

	if ( ! mbuf_nputstring(p, "</mdoc>", 7))
		return(0);
	return(mbuf_newline(p));
}


/* ARGSUSED */
static int
roffspecial(void *arg, int tok)
{

	return(1);
}


static int
roffblkin(void *arg, int tok, int *argc, char **argv)
{
	struct md_valid	*p;
	int		 i;

	assert(arg);
	p = (struct md_valid *)arg;

	if (0 != p->pos) {
		if ( ! mbuf_newline(p))
			return(0);
		if ( ! mbuf_indent(p))
			return(0);
	} else if ( ! mbuf_indent(p))
		return(0);

	if ( ! mbuf_nputstring(p, "<", 1))
		return(0);
	if ( ! mbuf_putstring(p, toknames[tok]))
		return(0);

	for (i = 0; ROFF_ARGMAX != argc[i]; i++) {
		if ( ! mbuf_nputstring(p, " ", 1))
			return(0);
		if ( ! mbuf_putstring(p, tokargnames[argc[i]]))
			return(0);
		if ( ! mbuf_nputstring(p, "=\"", 2))
			return(0);
		if ( ! mbuf_putstring(p, argv[i] ? argv[i] : "true"))
			return(0);
		if ( ! mbuf_nputstring(p, "\"", 1))
			return(0);
	}

	if ( ! mbuf_nputstring(p, ">", 1))
		return(0);
	if ( ! mbuf_newline(p))
		return(0);

	p->indent++;
	return(1);
}


static int
roffblkout(void *arg, int tok)
{
	struct md_valid	*p;

	assert(arg);
	p = (struct md_valid *)arg;

	p->indent--;

	if (0 != p->pos) {
		if ( ! mbuf_newline(p))
			return(0);
		if ( ! mbuf_indent(p))
			return(0);
	} else if ( ! mbuf_indent(p))
		return(0);

	if ( ! mbuf_nputstring(p, "</", 2))
		return(0);
	if ( ! mbuf_putstring(p, toknames[tok]))
		return(0);
	if ( ! mbuf_nputstring(p, ">", 1))
		return(0);
	if ( ! mbuf_newline(p))
		return(0);

	return(1);
}


static int
roffin(void *arg, int tok, int space, int *argc, char **argv)
{
	struct md_valid	*p;
	int		 i;

	assert(arg);
	p = (struct md_valid *)arg;

	if (0 == p->pos && ! mbuf_indent(p))
		return(0);

	/* 
	 * FIXME: put into a buffer before writing (check line length).
	 */

	if (space && ! mbuf_nputstring(p, " ", 1))
		return(0);
	if ( ! mbuf_nputstring(p, "<", 1))
		return(0);
	if ( ! mbuf_putstring(p, toknames[tok]))
		return(0);

	for (i = 0; ROFF_ARGMAX != argc[i]; i++) {
		if ( ! mbuf_nputstring(p, " ", 1))
			return(0);
		if ( ! mbuf_putstring(p, tokargnames[argc[i]]))
			return(0);
		if ( ! mbuf_nputstring(p, "=\"", 2))
			return(0);
		if ( ! mbuf_putstring(p, argv[i] ? argv[i] : "true"))
			return(0);
		if ( ! mbuf_nputstring(p, "\"", 1))
			return(0);
	}

	return(mbuf_nputstring(p, ">", 1));
}


static int
roffout(void *arg, int tok)
{
	struct md_valid	*p;

	assert(arg);
	p = (struct md_valid *)arg;

	if (0 == p->pos && ! mbuf_indent(p))
		return(0);

	if ( ! mbuf_nputstring(p, "</", 2))
		return(0);
	if ( ! mbuf_putstring(p, toknames[tok]))
		return(0);
	return(mbuf_nputstring(p, ">", 1));
}


static void
roffmsg(void *arg, enum roffmsg lvl, 
		const char *buf, const char *pos, char *msg)
{
	char		*level;
	struct md_valid	*p;

	assert(arg);
	p = (struct md_valid *)arg;

	switch (lvl) {
	case (ROFF_WARN):
		if ( ! (MD_WARN_ALL & p->args->warnings))
			return;
		level = "warning";
		break;
	case (ROFF_ERROR):
		level = "error";
		break;
	default:
		abort();
	}
	
	if (pos)
		(void)fprintf(stderr, "%s:%zu: %s: %s (column %zu)\n", 
				p->rbuf->name, p->rbuf->line, level, 
				msg, pos - buf);
	else
		(void)fprintf(stderr, "%s: %s: %s\n", 
				p->rbuf->name, level, msg);

}


static int
roffdata(void *arg, int space, char *buf)
{
	struct md_valid	*p;

	assert(arg);
	p = (struct md_valid *)arg;
	return(mbuf_data(p, space, buf));
}
@


1.5
log
@Validate-cum-xmlprint now includes arguments.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.4 2008/11/30 18:50:44 kristaps Exp $ */
d32 1
d38 8
d49 1
a51 1

d54 1
a54 1

d56 1
a56 1
#define	MD_LITERAL	(1 << 0)
d63 1
a63 1
static	int		 roffin(void *, int, int *, char **);
d73 21
d134 5
d140 1
a140 1
		return(md_buf_putstring(p->mbuf, buf));
a155 2
		/* Process word. */

d161 1
a161 1
			if ( ! md_buf_putstring(p->mbuf, bufp))
d163 1
a163 2

			if (p->indent * INDENT + sz >= 72) {
a167 2

			p->pos += sz;
d171 1
a171 6
		/* 
		 * FIXME: punctuation shouldn't have a newline before
		 * it! 
		 */

		if (sz + p->pos >= 72) {
d177 1
a177 1
			if ( ! md_buf_putchar(p->mbuf, ' '))
d180 1
a180 1
		if ( ! md_buf_putstring(p->mbuf, bufp))
a181 2

		p->pos += sz + (size_t)(space ? 1 : 0);
d256 1
a256 1
	if ( ! md_buf_putstring(p->mbuf, "<?xml version=\"1.0\" "
d259 2
a261 2
	if ( ! md_buf_putstring(p->mbuf, "<mdoc>"))
		return(0);
a262 1

d277 4
a280 1
	return(md_buf_putstring(p->mbuf, "</mdoc>\n"));
d310 1
a310 1
	if ( ! md_buf_putchar(p->mbuf, '<'))
d312 1
a312 1
	if ( ! md_buf_putstring(p->mbuf, toknames[tok]))
d316 1
a316 1
		if ( ! md_buf_putchar(p->mbuf, ' '))
d318 1
a318 1
		if ( ! md_buf_putstring(p->mbuf, tokargnames[argc[i]]))
d320 1
a320 1
		if ( ! md_buf_putstring(p->mbuf, "=\""))
d322 1
a322 2
		if ( ! md_buf_putstring(p->mbuf, argv[i] ? 
					argv[i] : "true"))
d324 1
a324 1
		if ( ! md_buf_putstring(p->mbuf, "\""))
d328 1
a328 1
	if ( ! md_buf_putchar(p->mbuf, '>'))
d356 1
a356 1
	if ( ! md_buf_putstring(p->mbuf, "</"))
d358 1
a358 1
	if ( ! md_buf_putstring(p->mbuf, toknames[tok]))
d360 1
a360 1
	if ( ! md_buf_putstring(p->mbuf, ">"))
d370 1
a370 1
roffin(void *arg, int tok, int *argc, char **argv)
d381 3
a383 1
	/* FIXME: put into a buffer before writing (line length). */
d385 3
a387 3
	/* FIXME: not always with a space... */

	if ( ! md_buf_putstring(p->mbuf, " <"))
d389 1
a389 1
	if ( ! md_buf_putstring(p->mbuf, toknames[tok]))
d393 1
a393 1
		if ( ! md_buf_putchar(p->mbuf, ' '))
d395 1
a395 1
		if ( ! md_buf_putstring(p->mbuf, tokargnames[argc[i]]))
d397 1
a397 1
		if ( ! md_buf_putstring(p->mbuf, "=\""))
d399 1
a399 2
		if ( ! md_buf_putstring(p->mbuf, argv[i] ? 
					argv[i] : "true"))
d401 1
a401 1
		if ( ! md_buf_putstring(p->mbuf, "\""))
a402 4

		p->pos += strlen(toknames[tok]) + 4 +
			strlen(tokargnames[argc[i]]) +
			strlen(argv[i] ? argv[i] : "true");
d405 1
a405 6
	if ( ! md_buf_putstring(p->mbuf, ">"))
		return(0);

	p->pos += strlen(toknames[tok]) + 3;

	return(1);
d420 1
a420 1
	if ( ! md_buf_putstring(p->mbuf, "</"))
d422 1
a422 1
	if ( ! md_buf_putstring(p->mbuf, toknames[tok]))
d424 1
a424 6
	if ( ! md_buf_putstring(p->mbuf, ">"))
		return(0);

	p->pos += strlen(toknames[tok]) + 2;

	return(1);
a427 1

d452 3
a454 2
		(void)fprintf(stderr, "%s:%zu: %s: %s\n", 
				p->rbuf->name, p->rbuf->line, level, msg);
@


1.4
log
@Fixed spacing (almost there).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.3 2008/11/30 12:41:45 kristaps Exp $ */
d73 1
d141 5
d158 1
a158 1
		p->pos += sz + (space ? 1 : 0);
d259 1
d272 1
d289 15
d346 1
a346 1
roffin(void *arg, int tok, int *argcp, char **argvp)
d349 1
d357 2
d360 1
d365 19
@


1.3
log
@Backed out PUNCT changes (again).
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.2 2008/11/29 16:11:42 kristaps Exp $ */
d55 1
a55 1
static	int		 roffdata(void *, char *);
d63 1
a63 1
static	int		 mbuf_data(struct md_valid *, char *);
d95 1
a95 1
mbuf_data(struct md_valid *p, char *buf)
a96 1
	int		 space;
a99 2
	space = 1; /* FIXME */

d227 5
a231 1
	if ( ! md_buf_putstring(p->mbuf, "BEGIN"))
a233 2
	if ( ! mbuf_newline(p))
		return(0);
d235 1
a235 1
	return(1);
d249 1
a249 4

	if ( ! md_buf_putstring(p->mbuf, "END\n"))
		return(0);
	return(1);
d333 1
d406 1
a406 1
roffdata(void *arg, char *buf)
d412 1
a412 1
	return(mbuf_data(p, buf));
@


1.2
log
@Validation presentation (html-like).
Fixed newlining for data.
Moved roffhead/rofftail to roff_Os.
@
text
@d1 1
a1 1
/* $Id: validate.c,v 1.1 2008/11/29 14:14:21 kristaps Exp $ */
d97 1
d101 2
d139 1
a139 4
			if ( ! md_buf_putchar(p->mbuf, ' '))
				return(0);

			p->pos += sz + 1;
d148 3
a150 1
		}
a153 2
		if ( ! md_buf_putchar(p->mbuf, ' '))
			return(0);
d155 1
a155 1
		p->pos += sz + 1;
d337 1
a337 1
	if ( ! md_buf_putstring(p->mbuf, "<"))
d344 1
a344 1
	p->pos += strlen(toknames[tok]) + 2;
d365 1
a365 1
	if ( ! md_buf_putstring(p->mbuf, "> "))
d368 1
a368 1
	p->pos += strlen(toknames[tok]) + 3;
@


1.1
log
@Inclusion of "real" validation code.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.10 2008/11/27 17:27:50 kristaps Exp $ */
d31 2
d34 1
a34 1
#define	strlcat		strncat
d57 1
a57 1
static	int		 roffblkin(void *, int);
d71 1
a71 1
	assert(0 == p->pos);
d73 1
a73 1
	for (i = 0; i < MIN(p->indent, 4); i++)
d77 1
a77 1
	p->pos = i * 4;
a82 8
mbuf_atnewline(struct md_valid *p)
{

	return(p->pos == MIN(4, p->indent));
}


static int
a85 2
	if (mbuf_atnewline(p))
		return(1);
d90 1
a90 1
	return(mbuf_indent(p));
a105 8
	if (0 == p->pos)
		mbuf_indent(p);

	/*
	 * Indent if we're at the beginning of a line.  Don't indent
	 * more than 16 or so characters.
	 */

d123 4
a126 2
		
		if (sz + p->pos < 72) {
d130 5
a134 1
			/* FIXME: check punctuation. */
d138 1
d143 6
a148 2
		if ( ! mbuf_newline(p))
			return(0);
a151 3

		/* FIXME: check punctuation. */

d154 1
d225 10
d248 2
a249 2
	if (mbuf_atnewline(p))
		return(1);
d251 3
a253 1
	return(md_buf_putchar(p->mbuf, '\n'));
d266 1
a266 1
roffblkin(void *arg, int tok)
d273 2
a274 2
	if ( ! mbuf_atnewline(p)) {
		if ( ! md_buf_putchar(p->mbuf, '\n'))
a275 1
		p->pos = 0;
d278 2
a279 1
	}
d281 2
d285 3
a287 2

	if ( ! md_buf_putchar(p->mbuf, '\n'))
a289 1
	p->pos = 0;
d291 1
a291 2

	return(mbuf_indent(p));
d303 8
a310 1
	if ( ! md_buf_putchar(p->mbuf, '\n'))
d313 8
a320 2
	p->pos = 0;
	p->indent--;
d322 1
a322 1
	return(mbuf_indent(p));
d329 16
d353 16
@
