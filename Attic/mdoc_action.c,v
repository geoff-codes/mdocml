head	1.89;
access;
symbols
	VERSION_1_10_6:1.78
	VERSION_1_10_5:1.77
	VERSION_1_10_5_PREPDF:1.76
	VERSION_1_10_4:1.75
	VERSION_1_10_3:1.72
	VERSION_1_10_2:1.71
	VERSION_1_10_1:1.65
	VERSION_1_9_24:1.54
	VERSION_1_9_25:1.55
	VERSION_1_9_23:1.53
	VERSION_1_9_22:1.51
	VERSION_1_9_21:1.50
	VERSION_1_9_20:1.50
	VERSION_1_9_19:1.50
	VERSION_1_9_18:1.50
	VERSION_1_9_17:1.50
	VERSION_1_9_16:1.50
	VERSION_1_9_15:1.50
	VERSION_1_9_15-pre2:1.50
	VERSION_1_9_15-pre1:1.49
	VERSION_1_9_14:1.49
	VERSION_1_9_13:1.49
	VERSION_1_9_12:1.48
	VERSION_1_9_11:1.45
	VERSION_1_9_10:1.44
	VERSION_1_9_9:1.41
	VERSION_1_9_8:1.41
	VERSION_1_9_7:1.41
	VERSION_1_9_6:1.41
	VERSION_1_9_5:1.37
	VERSION_1_9_2:1.35
	VERSION_1_9_1:1.35
	VERSION_1_9_0:1.34
	VERSION_1_8_5:1.34
	VERSION_1_8_4:1.34
	VERSION_1_8_3:1.31
	VERSION_1_8_2:1.30
	VERSION_1_8_1:1.30
	VERSION_1_8_0:1.27
	VERSION_1_7_24:1.24
	VERSION_1_7_23:1.23
	VERSION_1_7_22:1.20
	VERSION_1_7_21:1.20
	VERSION_1_7_20:1.19
	VERSION_1_7_19:1.16
	VERSION_1_7_17:1.11
	VERSION_1_7_16:1.11
	VERSION_1_7_15:1.11
	VERSION_1_7_14:1.9
	VERSION_1_7_13:1.8
	VERSION_1_7_12:1.7
	OPENBSD_CHECKIN:1.7
	VERSION_1_7_10:1.5
	VERSION_1_7_5:1.1;
locks; strict;
comment	@ * @;


1.89
date	2010.11.30.13.04.14;	author kristaps;	state dead;
branches;
next	1.88;

1.88
date	2010.11.30.12.59.20;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2010.11.30.12.35.10;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2010.11.30.10.32.05;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2010.11.29.16.06.46;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2010.11.29.15.45.15;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2010.11.29.14.56.43;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2010.11.29.14.50.33;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2010.11.29.13.51.03;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2010.11.29.13.02.47;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2010.11.29.12.22.28;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.30.17.14.09;	author joerg;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.26.13.45.49;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.13.23.53.20;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.04.21.59.30;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.01.22.56.17;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.01.22.35.54;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.27.15.52.41;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.19.20.46.28;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.13.21.02.48;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.13.20.05.12;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2010.06.12.12.38.01;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2010.06.12.11.21.44;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.12.10.09.19;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.03.13.44.36;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.31.10.28.04;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.30.11.00.53;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.29.18.58.52;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2010.05.24.11.59.37;	author joerg;	state Exp;
branches;
next	1.60;

1.60
date	2010.05.17.23.57.06;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.15.16.24.38;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.14.16.02.29;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.14.15.26.39;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.12.08.41.17;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.08.07.30.19;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.06.11.33.00;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.05.09.03.12;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2010.03.31.07.13.53;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.01.17.14.29;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.11.02.06.22.45;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.31.06.10.58;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.30.18.50.11;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.29.04.34.38;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.26.10.36.46;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.26.04.09.45;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.24.05.52.13;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.22.17.54.24;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.25.13.03.25;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.24.15.08.41;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.24.15.01.06;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.24.13.03.32;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.16.20.49.06;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.16.14.40.56;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.20.13.22.48;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.26.10.29.39;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.07.25.16.03.03;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.24.13.18.15;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.07.21.15.53.31;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.17.10.56.57;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.16.13.17.51;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.15.15.53.57;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.12.20.50.08;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.12.20.30.35;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.12.20.24.24;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.07.11.47.17;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.06.13.04.52;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.06.11.14.03;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.06.09.21.24;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.25.08.42.06;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.22.12.38.07;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.22.12.04.05;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.06.18.20.46.19;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.17.14.14.51;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.17.14.10.09;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.17.14.08.47;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.17.10.53.32;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.16.19.45.51;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.12.12.52.51;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.12.09.18.00;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.10.20.18.43;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.06.09.48.35;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.06.08.53.12;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.04.03.11.08.39;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.04.02.16.37.40;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.04.02.06.51.44;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.31.13.50.19;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.25.15.36.05;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.89
log
@mdoc_action.c is no more.  Attic it and remove it from the Makefile.
Remove references to MDOC_ACTED (it was only assertions) and the pre-
and post-action functions.
@
text
@@


1.88
log
@Moved all prologue actions from mdoc_action.c into mdoc_validate.c.  The
file is now ready for removal.
@
text
@a0 214
/*	$Id: mdoc_action.c,v 1.87 2010/11/30 12:35:10 kristaps Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#ifndef	OSNAME
#include <sys/utsname.h>
#endif

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "libmdoc.h"
#include "libmandoc.h"

/* 
 * FIXME: this file is deprecated.  All future "actions" should be
 * pushed into mdoc_validate.c.
 */

#define	POST_ARGS struct mdoc *m, struct mdoc_node *n
#define	PRE_ARGS  struct mdoc *m, struct mdoc_node *n

struct	actions {
	int	(*pre)(PRE_ARGS);
	int	(*post)(POST_ARGS);
};

static	const struct actions mdoc_actions[MDOC_MAX] = {
	{ NULL, NULL }, /* Ap */
	{ NULL, NULL }, /* Dd */ 
	{ NULL, NULL }, /* Dt */ 
	{ NULL, NULL }, /* Os */ 
	{ NULL, NULL }, /* Sh */ 
	{ NULL, NULL }, /* Ss */ 
	{ NULL, NULL }, /* Pp */ 
	{ NULL, NULL }, /* D1 */
	{ NULL, NULL }, /* Dl */
	{ NULL, NULL }, /* Bd */ 
	{ NULL, NULL }, /* Ed */
	{ NULL, NULL }, /* Bl */ 
	{ NULL, NULL }, /* El */
	{ NULL, NULL }, /* It */
	{ NULL, NULL }, /* Ad */ 
	{ NULL, NULL }, /* An */
	{ NULL, NULL }, /* Ar */
	{ NULL, NULL }, /* Cd */
	{ NULL, NULL }, /* Cm */
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
	{ NULL, NULL }, /* Ex */
	{ NULL, NULL }, /* Fa */ 
	{ NULL, NULL }, /* Fd */ 
	{ NULL, NULL }, /* Fl */
	{ NULL, NULL }, /* Fn */ 
	{ NULL, NULL }, /* Ft */ 
	{ NULL, NULL }, /* Ic */ 
	{ NULL, NULL }, /* In */ 
	{ NULL, NULL }, /* Li */
	{ NULL, NULL }, /* Nd */ 
	{ NULL, NULL }, /* Nm */ 
	{ NULL, NULL }, /* Op */
	{ NULL, NULL }, /* Ot */
	{ NULL, NULL }, /* Pa */
	{ NULL, NULL }, /* Rv */
	{ NULL, NULL }, /* St */
	{ NULL, NULL }, /* Va */
	{ NULL, NULL }, /* Vt */ 
	{ NULL, NULL }, /* Xr */
	{ NULL, NULL }, /* %A */
	{ NULL, NULL }, /* %B */
	{ NULL, NULL }, /* %D */
	{ NULL, NULL }, /* %I */
	{ NULL, NULL }, /* %J */
	{ NULL, NULL }, /* %N */
	{ NULL, NULL }, /* %O */
	{ NULL, NULL }, /* %P */
	{ NULL, NULL }, /* %R */
	{ NULL, NULL }, /* %T */
	{ NULL, NULL }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ NULL, NULL }, /* Ao */
	{ NULL, NULL }, /* Aq */
	{ NULL, NULL }, /* At */ 
	{ NULL, NULL }, /* Bc */
	{ NULL, NULL }, /* Bf */ 
	{ NULL, NULL }, /* Bo */
	{ NULL, NULL }, /* Bq */
	{ NULL, NULL }, /* Bsx */
	{ NULL, NULL }, /* Bx */
	{ NULL, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ NULL, NULL }, /* Do */
	{ NULL, NULL }, /* Dq */
	{ NULL, NULL }, /* Ec */
	{ NULL, NULL }, /* Ef */
	{ NULL, NULL }, /* Em */ 
	{ NULL, NULL }, /* Eo */
	{ NULL, NULL }, /* Fx */
	{ NULL, NULL }, /* Ms */
	{ NULL, NULL }, /* No */
	{ NULL, NULL }, /* Ns */
	{ NULL, NULL }, /* Nx */
	{ NULL, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, NULL }, /* Pf */
	{ NULL, NULL }, /* Po */
	{ NULL, NULL }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ NULL, NULL }, /* Ql */
	{ NULL, NULL }, /* Qo */
	{ NULL, NULL }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ NULL, NULL }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ NULL, NULL }, /* So */
	{ NULL, NULL }, /* Sq */
	{ NULL, NULL }, /* Sm */
	{ NULL, NULL }, /* Sx */
	{ NULL, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
	{ NULL, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ NULL, NULL }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
	{ NULL, NULL }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ NULL, NULL }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ NULL, NULL }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ NULL, NULL }, /* Fr */
	{ NULL, NULL }, /* Ud */
	{ NULL, NULL }, /* Lb */
	{ NULL, NULL }, /* Lp */
	{ NULL, NULL }, /* Lk */
	{ NULL, NULL }, /* Mt */
	{ NULL, NULL }, /* Brq */
	{ NULL, NULL }, /* Bro */
	{ NULL, NULL }, /* Brc */
	{ NULL, NULL }, /* %C */
	{ NULL, NULL }, /* Es */
	{ NULL, NULL }, /* En */
	{ NULL, NULL }, /* Dx */
	{ NULL, NULL }, /* %Q */
	{ NULL, NULL }, /* br */
	{ NULL, NULL }, /* sp */
	{ NULL, NULL }, /* %U */
	{ NULL, NULL }, /* Ta */
};


int
mdoc_action_pre(struct mdoc *m, struct mdoc_node *n)
{

	switch (n->type) {
	case (MDOC_ROOT):
		/* FALLTHROUGH */
	case (MDOC_TEXT):
		return(1);
	default:
		break;
	}

	if (NULL == mdoc_actions[n->tok].pre)
		return(1);
	return((*mdoc_actions[n->tok].pre)(m, n));
}


int
mdoc_action_post(struct mdoc *m)
{

	if (MDOC_ACTED & m->last->flags)
		return(1);
	m->last->flags |= MDOC_ACTED;

	switch (m->last->type) {
	case (MDOC_TEXT):
		/* FALLTHROUGH */
	case (MDOC_ROOT):
		return(1);
	default:
		break;
	}

	if (NULL == mdoc_actions[m->last->tok].post)
		return(1);
	return((*mdoc_actions[m->last->tok].post)(m, m->last));
}

@


1.87
log
@Move post_bl() and subfunctions from mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.86 2010/11/30 10:32:05 kristaps Exp $ */
a34 1
#define	DATESIZ	  32
a47 9
static	int	  concat(struct mdoc *, char *,
			const struct mdoc_node *, size_t);

static	int	  post_dd(POST_ARGS);
static	int	  post_dt(POST_ARGS);
static	int	  post_os(POST_ARGS);
static	int	  post_prol(POST_ARGS);
static	int	  post_std(POST_ARGS);

d50 3
a52 3
	{ NULL, post_dd }, /* Dd */ 
	{ NULL, post_dt }, /* Dt */ 
	{ NULL, post_os }, /* Os */ 
d71 1
a71 1
	{ NULL, post_std }, /* Ex */
d85 1
a85 1
	{ NULL, post_std }, /* Rv */
a214 248

/*
 * Concatenate sibling nodes together.  All siblings must be of type
 * MDOC_TEXT or an assertion is raised.  Concatenation is separated by a
 * single whitespace.
 */
static int
concat(struct mdoc *m, char *p, const struct mdoc_node *n, size_t sz)
{

	assert(sz);
	p[0] = '\0';
	for ( ; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
		/*
		 * XXX: yes, these can technically be resized, but it's
		 * highly unlikely that we're going to get here, so let
		 * it slip for now.
		 */
		if (strlcat(p, n->string, sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
		if (NULL == n->next)
			continue;
		if (strlcat(p, " ", sz) >= sz) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
	}

	return(1);
}


/*
 * Macros accepting `-std' as an argument have the name of the current
 * document (`Nm') filled in as the argument if it's not provided.
 */
static int
post_std(POST_ARGS)
{
	struct mdoc_node *nn;

	if (n->child)
		return(1);
	if (NULL == m->meta.name)
		return(1);
	
	nn = n;
	m->next = MDOC_NEXT_CHILD;

	if ( ! mdoc_word_alloc(m, n->line, n->pos, m->meta.name))
		return(0);
	m->last = nn;
	return(1);
}

/*
 * Parse out the contents of `Dt'.  See in-line documentation for how we
 * handle the various fields of this macro.
 */
static int
post_dt(POST_ARGS)
{
	struct mdoc_node *nn;
	const char	 *cp;

	if (m->meta.title)
		free(m->meta.title);
	if (m->meta.vol)
		free(m->meta.vol);
	if (m->meta.arch)
		free(m->meta.arch);

	m->meta.title = m->meta.vol = m->meta.arch = NULL;
	/* Handles: `.Dt' 
	 *   --> title = unknown, volume = local, msec = 0, arch = NULL
	 */

	if (NULL == (nn = n->child)) {
		/* XXX: make these macro values. */
		/* FIXME: warn about missing values. */
		m->meta.title = mandoc_strdup("UNKNOWN");
		m->meta.vol = mandoc_strdup("LOCAL");
		m->meta.msec = mandoc_strdup("1");
		return(post_prol(m, n));
	}

	/* Handles: `.Dt TITLE' 
	 *   --> title = TITLE, volume = local, msec = 0, arch = NULL
	 */

	m->meta.title = mandoc_strdup
		('\0' == nn->string[0] ? "UNKNOWN" : nn->string);

	if (NULL == (nn = nn->next)) {
		/* FIXME: warn about missing msec. */
		/* XXX: make this a macro value. */
		m->meta.vol = mandoc_strdup("LOCAL");
		m->meta.msec = mandoc_strdup("1");
		return(post_prol(m, n));
	}

	/* Handles: `.Dt TITLE SEC'
	 *   --> title = TITLE, volume = SEC is msec ? 
	 *           format(msec) : SEC,
	 *       msec = SEC is msec ? atoi(msec) : 0,
	 *       arch = NULL
	 */

	cp = mdoc_a2msec(nn->string);
	if (cp) {
		m->meta.vol = mandoc_strdup(cp);
		m->meta.msec = mandoc_strdup(nn->string);
	} else if (mdoc_nmsg(m, n, MANDOCERR_BADMSEC)) {
		m->meta.vol = mandoc_strdup(nn->string);
		m->meta.msec = mandoc_strdup(nn->string);
	} else
		return(0);

	if (NULL == (nn = nn->next))
		return(post_prol(m, n));

	/* Handles: `.Dt TITLE SEC VOL'
	 *   --> title = TITLE, volume = VOL is vol ?
	 *       format(VOL) : 
	 *           VOL is arch ? format(arch) : 
	 *               VOL
	 */

	cp = mdoc_a2vol(nn->string);
	if (cp) {
		free(m->meta.vol);
		m->meta.vol = mandoc_strdup(cp);
	} else {
		/* FIXME: warn about bad arch. */
		cp = mdoc_a2arch(nn->string);
		if (NULL == cp) {
			free(m->meta.vol);
			m->meta.vol = mandoc_strdup(nn->string);
		} else 
			m->meta.arch = mandoc_strdup(cp);
	}	

	/* Ignore any subsequent parameters... */
	/* FIXME: warn about subsequent parameters. */

	return(post_prol(m, n));
}


/*
 * Set the operating system by way of the `Os' macro.  Note that if an
 * argument isn't provided and -DOSNAME="\"foo\"" is provided during
 * compilation, this value will be used instead of filling in "sysname
 * release" from uname().
 */
static int
post_os(POST_ARGS)
{
	char		  buf[BUFSIZ];
#ifndef OSNAME
	struct utsname	  utsname;
#endif

	if (m->meta.os)
		free(m->meta.os);

	if ( ! concat(m, buf, n->child, BUFSIZ))
		return(0);

	/* XXX: yes, these can all be dynamically-adjusted buffers, but
	 * it's really not worth the extra hackery.
	 */

	if ('\0' == buf[0]) {
#ifdef OSNAME
		if (strlcat(buf, OSNAME, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
#else /*!OSNAME */
		if (-1 == uname(&utsname))
			return(mdoc_nmsg(m, n, MANDOCERR_UTSNAME));

		if (strlcat(buf, utsname.sysname, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, " ", 64) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
		if (strlcat(buf, utsname.release, BUFSIZ) >= BUFSIZ) {
			mdoc_nmsg(m, n, MANDOCERR_MEM);
			return(0);
		}
#endif /*!OSNAME*/
	}

	m->meta.os = mandoc_strdup(buf);
	return(post_prol(m, n));
}

/*
 * Parse the date field in `Dd'.
 */
static int
post_dd(POST_ARGS)
{
	char		buf[DATESIZ];

	if (NULL == n->child) {
		m->meta.date = time(NULL);
		return(post_prol(m, n));
	}

	if ( ! concat(m, buf, n->child, DATESIZ))
		return(0);

	m->meta.date = mandoc_a2time
		(MTIME_MDOCDATE | MTIME_CANONICAL, buf);

	if (0 == m->meta.date) {
		if ( ! mdoc_nmsg(m, n, MANDOCERR_BADDATE))
			return(0);
		m->meta.date = time(NULL);
	}

	return(post_prol(m, n));
}


/*
 * Remove prologue macros from the document after they're processed.
 * The final document uses mdoc_meta for these values and discards the
 * originals.
 */
static int
post_prol(POST_ARGS)
{

	mdoc_node_delete(m, n);
	if (m->meta.title && m->meta.date && m->meta.os)
		m->flags |= MDOC_PBODY;
	return(1);
}
@


1.86
log
@Move -column list validation and normal-formisation from mdoc_action.c
into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.85 2010/11/29 16:06:46 kristaps Exp $ */
d35 1
a43 3
#define	NUMSIZ	  32
#define	DATESIZ	  32

a51 3
static	int	  post_bl(POST_ARGS);
static	int	  post_bl_tagwidth(POST_ARGS);
static	int	  post_bl_width(POST_ARGS);
d70 1
a70 1
	{ NULL, post_bl }, /* Bl */ 
a429 145

/*
 * Calculate the -width for a `Bl -tag' list if it hasn't been provided.
 * Uses the first head macro.  NOTE AGAIN: this is ONLY if the -width
 * argument has NOT been provided.  See post_bl_width() for converting
 * the -width string.
 */
static int
post_bl_tagwidth(POST_ARGS)
{
	struct mdoc_node *nn;
	size_t		  sz, ssz;
	int		  i;
	char		  buf[NUMSIZ];

	sz = 10;

	for (nn = n->body->child; nn; nn = nn->next) {
		if (MDOC_It != nn->tok)
			continue;

		assert(MDOC_BLOCK == nn->type);
		nn = nn->head->child;

		if (nn == NULL) {
			/* No -width for .Bl and first .It is emtpy */
			if ( ! mdoc_nmsg(m, n, MANDOCERR_NOWIDTHARG))
				return(0);
			break;
		}

		if (MDOC_TEXT == nn->type) {
			sz = strlen(nn->string) + 1;
			break;
		}

		if (0 != (ssz = mdoc_macro2len(nn->tok)))
			sz = ssz;
		else if ( ! mdoc_nmsg(m, n, MANDOCERR_NOWIDTHARG))
			return(0);

		break;
	} 

	/* Defaults to ten ens. */

	snprintf(buf, NUMSIZ, "%zun", sz);

	/*
	 * We have to dynamically add this to the macro's argument list.
	 * We're guaranteed that a MDOC_Width doesn't already exist.
	 */

	assert(n->args);
	i = (int)(n->args->argc)++;

	n->args->argv = mandoc_realloc(n->args->argv, 
			n->args->argc * sizeof(struct mdoc_argv));

	n->args->argv[i].arg = MDOC_Width;
	n->args->argv[i].line = n->line;
	n->args->argv[i].pos = n->pos;
	n->args->argv[i].sz = 1;
	n->args->argv[i].value = mandoc_malloc(sizeof(char *));
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->data.Bl->width = n->args->argv[i].value[0];
	return(1);
}


/*
 * Calculate the real width of a list from the -width string, which may
 * contain a macro (with a known default width), a literal string, or a
 * scaling width.
 */
static int
post_bl_width(POST_ARGS)
{
	size_t		  width;
	int		  i;
	enum mdoct	  tok;
	char		  buf[NUMSIZ];

	/*
	 * If the value to -width is a macro, then we re-write it to be
	 * the macro's width as set in share/tmac/mdoc/doc-common.
	 */

	if (0 == strcmp(n->data.Bl->width, "Ds"))
		width = 6;
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->data.Bl->width)))
		return(1);
	else if (0 == (width = mdoc_macro2len(tok))) 
		return(mdoc_nmsg(m, n, MANDOCERR_BADWIDTH));

	/* The value already exists: free and reallocate it. */

	assert(n->args);

	for (i = 0; i < (int)n->args->argc; i++) 
		if (MDOC_Width == n->args->argv[i].arg)
			break;

	assert(i < (int)n->args->argc);

	snprintf(buf, NUMSIZ, "%zun", width);
	free(n->args->argv[i].value[0]);
	n->args->argv[i].value[0] = mandoc_strdup(buf);

	/* Set our width! */
	n->data.Bl->width = n->args->argv[i].value[0];
	return(1);
}


static int
post_bl(POST_ARGS)
{

	if (MDOC_BLOCK != n->type)
		return(1);

	/*
	 * These are fairly complicated, so we've broken them into two
	 * functions.  post_bl_tagwidth() is called when a -tag is
	 * specified, but no -width (it must be guessed).  The second
	 * when a -width is specified (macro indicators must be
	 * rewritten into real lengths).
	 */

	if (LIST_tag == n->data.Bl->type && NULL == n->data.Bl->width) {
		if ( ! post_bl_tagwidth(m, n))
			return(0);
	} else if (NULL != n->data.Bl->width) {
		if ( ! post_bl_width(m, n))
			return(0);
	} else 
		return(1);

	assert(n->data.Bl->width);
	return(1);
}

@


1.85
log
@Migrate `Nm' and `Pa' handling from mdoc_action.c into mdoc_validate.c.

Document that `Pa' is replaced by a tilde, just like `Mt'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.84 2010/11/29 15:45:15 kristaps Exp $ */
a54 1
static	int	  post_bl_head(POST_ARGS);
a551 53
/*
 * Do processing for -column lists, which can have two distinct styles
 * of invocation.  Merge this two styles into a consistent form.
 */
/* ARGSUSED */
static int
post_bl_head(POST_ARGS)
{
	int			 i, c;
	struct mdoc_node	*np, *nn, *nnp;

	if (LIST_column != n->data.Bl->type)
		return(1);
	else if (NULL == n->child)
		return(1);

	np = n->parent;
	assert(np->args);

	for (c = 0; c < (int)np->args->argc; c++) 
		if (MDOC_Column == np->args->argv[c].arg)
			break;

	assert(c < (int)np->args->argc);
	assert(0 == np->args->argv[c].sz);

	/*
	 * Accomodate for new-style groff column syntax.  Shuffle the
	 * child nodes, all of which must be TEXT, as arguments for the
	 * column field.  Then, delete the head children.
	 */

	np->args->argv[c].sz = (size_t)n->nchild;
	np->args->argv[c].value = mandoc_malloc
		((size_t)n->nchild * sizeof(char *));

	n->data.Bl->ncols = np->args->argv[c].sz;
	n->data.Bl->cols = (const char **)np->args->argv[c].value;

	for (i = 0, nn = n->child; nn; i++) {
		np->args->argv[c].value[i] = nn->string;
		nn->string = NULL;
		nnp = nn;
		nn = nn->next;
		mdoc_node_delete(NULL, nnp);
	}

	n->nchild = 0;
	n->child = NULL;
	return(1);
}


a555 2
	if (MDOC_HEAD == n->type)
		return(post_bl_head(m, n));
@


1.84
log
@Remove left-over rsord[] in mdoc_actions.c.

Remove MANDOCERR_BADLIB (not used).

Moved `St' handling from mdoc_action.c into mdoc_validate.c.

Moved relevant MDOC_LITERAL macros (`Dl', `Bd' subtypes) from
mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.83 2010/11/29 14:56:43 kristaps Exp $ */
a59 1
static	int	  post_nm(POST_ARGS);
a60 1
static	int	  post_pa(POST_ARGS);
d97 1
a97 1
	{ NULL, post_nm }, /* Nm */ 
d100 1
a100 1
	{ NULL, post_pa }, /* Pa */
a288 18

/*
 * The `Nm' macro's first use sets the name of the document.  See also
 * post_std(), etc.
 */
static int
post_nm(POST_ARGS)
{
	char		 buf[BUFSIZ];

	if (m->meta.name)
		return(1);
	if ( ! concat(m, buf, n->child, BUFSIZ))
		return(0);
	m->meta.name = mandoc_strdup(buf);
	return(1);
}

a635 22

/*
 * The `Pa' macro defaults to a tilde if no value is provided as an
 * argument.
 */
static int
post_pa(POST_ARGS)
{
	struct mdoc_node *np;

	if (n->child)
		return(1);
	
	np = n;
	m->next = MDOC_NEXT_CHILD;
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "~"))
		return(0);
	m->last = np;
	return(1);
}


@


1.83
log
@Move `Lb' handling from mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.82 2010/11/29 14:50:33 kristaps Exp $ */
a58 1
static	int	  post_display(POST_ARGS);
a63 1
static	int	  post_st(POST_ARGS);
a65 3
static	int	  pre_bd(PRE_ARGS);
static	int	  pre_dl(PRE_ARGS);

d75 2
a76 2
	{ pre_dl, post_display }, /* Dl */
	{ pre_bd, post_display }, /* Bd */ 
d104 1
a104 1
	{ NULL, post_st }, /* St */
a190 19
#define	RSORD_MAX 14

static	const enum mdoct rsord[RSORD_MAX] = {
	MDOC__A,
	MDOC__T,
	MDOC__B,
	MDOC__I,
	MDOC__J,
	MDOC__R,
	MDOC__N,
	MDOC__V,
	MDOC__P,
	MDOC__Q,
	MDOC__D,
	MDOC__O,
	MDOC__C,
	MDOC__U
};

a309 21
 * Substitute the value of `St' for the corresponding formatted string.
 * We're guaranteed that this exists (it's been verified during the
 * validation phase).
 */
/* ARGSUSED */
static int
post_st(POST_ARGS)
{
	const char	*p;

	assert(MDOC_TEXT == n->child->type);
	p = mdoc_a2st(n->child->string);
	if (p != NULL) {
		free(n->child->string);
		n->child->string = mandoc_strdup(p);
	}
	return(1);
}


/*
a720 40


/*
 * Trigger a literal context.
 */
static int
pre_dl(PRE_ARGS)
{

	if (MDOC_BODY == n->type)
		m->flags |= MDOC_LITERAL;
	return(1);
}


static int
pre_bd(PRE_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);

	assert(n->data.Bd);
	if (DISP_literal == n->data.Bd->type)
		m->flags |= MDOC_LITERAL;
	if (DISP_unfilled == n->data.Bd->type)
		m->flags |= MDOC_LITERAL;

	return(1);
}


static int
post_display(POST_ARGS)
{

	if (MDOC_BODY == n->type)
		m->flags &= ~MDOC_LITERAL;
	return(1);
}
@


1.82
log
@Move `At' handling from mdoc_action.c into mdoc_validate.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.81 2010/11/29 13:51:03 kristaps Exp $ */
a60 1
static	int	  post_lb(POST_ARGS);
d178 1
a178 1
	{ NULL, post_lb }, /* Lb */
a332 33

/*
 * Look up the value of `Lb' for matching predefined strings.  If it has
 * one, then substitute the current value for the formatted value.  Note
 * that the lookup may fail (we can provide arbitrary strings).
 */
/* ARGSUSED */
static int
post_lb(POST_ARGS)
{
	const char	*p;
	char		*buf;
	size_t		 sz;

	assert(MDOC_TEXT == n->child->type);
	p = mdoc_a2lib(n->child->string);

	if (p) {
		free(n->child->string);
		n->child->string = mandoc_strdup(p);
		return(1);
	}

	sz = strlen(n->child->string) +
		2 + strlen("\\(lqlibrary\\(rq");
	buf = mandoc_malloc(sz);
	snprintf(buf, sz, "library \\(lq%s\\(rq", n->child->string);
	free(n->child->string);
	n->child->string = buf;
	return(1);
}


@


1.81
log
@Move `Sh' validation from mdoc_action.c. into mdoc_validate.c.
Surprisingly, both functions were doing pretty much the same thing.
Make sure that the changes incorporate the union of both.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.80 2010/11/29 13:02:47 kristaps Exp $ */
a53 1
static	int	  post_at(POST_ARGS);
d128 1
a128 1
	{ NULL, post_at }, /* At */ 
a388 41
 * Look up the standard string in a table.  We know that it exists from
 * the validation phase, so assert on failure.  If a standard key wasn't
 * supplied, supply the default ``AT&T UNIX''.
 */
static int
post_at(POST_ARGS)
{
	struct mdoc_node *nn;
	const char	 *p, *q;
	char		 *buf;
	size_t		  sz;

	if (n->child) {
		assert(MDOC_TEXT == n->child->type);
		p = mdoc_a2att(n->child->string);
		if (p) {
			free(n->child->string);
			n->child->string = mandoc_strdup(p);
		} else {
			p = "AT&T UNIX ";
			q = n->child->string;
			sz = strlen(p) + strlen(q) + 1;
			buf = mandoc_malloc(sz);
			strlcpy(buf, p, sz);
			strlcat(buf, q, sz);
			free(n->child->string);
			n->child->string = buf;
		}
		return(1);
	}

	nn = n;
	m->next = MDOC_NEXT_CHILD;
	if ( ! mdoc_word_alloc(m, nn->line, nn->pos, "AT&T UNIX"))
		return(0);
	m->last = nn;
	return(1);
}


/*
@


1.80
log
@Move `Mt', `Ar', and `Li' handling from mdoc_action.c into mdoc_validate.c.

Clarify that `Mt' gets a default `~' (as per groff 1.20) and document it
in mdoc.7.

Made `Lk' be removed in mdoc_macro.c if it has no arguments.  This fixes
segfaults in mdoc_{term,html}.c that nobody's managed to raise yet.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.79 2010/11/29 12:22:28 kristaps Exp $ */
a66 1
static	int	  post_sh(POST_ARGS);
d78 1
a78 1
	{ NULL, post_sh }, /* Sh */ 
a430 57
 * Mark the current section.  The ``named'' section (lastnamed) is set
 * whenever the current section isn't a custom section--we use this to
 * keep track of section ordering.  Also check that the section is
 * allowed within the document's manual section.
 */
static int
post_sh(POST_ARGS)
{
	enum mdoc_sec	 sec;
	char		 buf[BUFSIZ];

	if (MDOC_HEAD != n->type)
		return(1);

	if ( ! concat(m, buf, n->child, BUFSIZ))
		return(0);
	sec = mdoc_str2sec(buf);
	/*
	 * The first section should always make us move into a non-new
	 * state.
	 */
	if (SEC_NONE == m->lastnamed || SEC_CUSTOM != sec)
		m->lastnamed = sec;

	/*
	 * Switch the parser's SYNOPSIS mode, to be copied
	 * into individual nodes when creating them.
	 * Note that this mode can also be set and unset
	 * using the roff nS register.
	 */
	if (SEC_SYNOPSIS == sec)
		m->flags |= MDOC_SYNOPSIS;
	else
		m->flags &= ~MDOC_SYNOPSIS;

	/* Some sections only live in certain manual sections. */

	switch ((m->lastsec = sec)) {
	case (SEC_RETURN_VALUES):
		/* FALLTHROUGH */
	case (SEC_ERRORS):
		assert(m->meta.msec);
		if (*m->meta.msec == '2')
			break;
		if (*m->meta.msec == '3')
			break;
		if (*m->meta.msec == '9')
			break;
		return(mdoc_nmsg(m, n, MANDOCERR_SECMSEC));
	default:
		break;
	}
	return(1);
}


/*
@


1.79
log
@Migrate action for `Rs' into mdoc_validate.c.
Remove superfluous in-line order_rs function.
Merge `Rs' validations {BLOCK, BODY} -> {BODY}.
Make invalid children of `Rs' raise an error but otherwise be allowed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.78 2010/07/30 17:14:09 joerg Exp $ */
a53 1
static	int	  post_ar(POST_ARGS);
a62 1
static	int	  post_li(POST_ARGS);
d91 1
a91 1
	{ NULL, post_ar }, /* Ar */
d105 1
a105 1
	{ NULL, post_li }, /* Li */
a857 45
 * Empty `Li' macros get an empty string to make front-ends add an extra
 * space.
 */
static int
post_li(POST_ARGS)
{
	struct mdoc_node *np;

	if (n->child)
		return(1);
	
	np = n;
	m->next = MDOC_NEXT_CHILD;
	if ( ! mdoc_word_alloc(m, n->line, n->pos, ""))
		return(0);
	m->last = np;
	return(1);
}


/*
 * The `Ar' macro defaults to two strings "file ..." if no value is
 * provided as an argument.
 */
static int
post_ar(POST_ARGS)
{
	struct mdoc_node *np;

	if (n->child)
		return(1);
	
	np = n;
	m->next = MDOC_NEXT_CHILD;
	/* XXX: make into macro values. */
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "file"))
		return(0);
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "..."))
		return(0);
	m->last = np;
	return(1);
}


/*
@


1.78
log
@Don't crash for the following test case as reported by Jordan Gordeev:
.Bl -tag
.It
foo
...
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.77 2010/07/26 13:45:49 kristaps Exp $ */
a52 1
static	inline int order_rs(enum mdoct);
a68 1
static	int	  post_rs(POST_ARGS);
d162 1
a162 1
	{ NULL, post_rs }, /* Rs */
a986 64


static inline int
order_rs(enum mdoct t)
{
	int		i;

	for (i = 0; i < (int)RSORD_MAX; i++)
		if (rsord[i] == t)
			return(i);

	abort();
	/* NOTREACHED */
}


/* ARGSUSED */
static int
post_rs(POST_ARGS)
{
	struct mdoc_node	*nn, *next, *prev;
	int			 o;

	if (MDOC_BLOCK != n->type)
		return(1);

	assert(n->body->child);
	for (next = NULL, nn = n->body->child->next; nn; nn = next) {
		o = order_rs(nn->tok);

		/* Remove `nn' from the chain. */
		next = nn->next;
		if (next)
			next->prev = nn->prev;

		prev = nn->prev;
		if (prev)
			prev->next = nn->next;

		nn->prev = nn->next = NULL;

		/* 
		 * Scan back until we reach a node that's ordered before
		 * us, then set ourselves as being the next. 
		 */
		for ( ; prev; prev = prev->prev)
			if (order_rs(prev->tok) <= o)
				break;

		nn->prev = prev;
		if (prev) {
			if (prev->next)
				prev->next->prev = nn;
			nn->next = prev->next;
			prev->next = nn;
			continue;
		} 

		n->body->child->prev = nn;
		nn->next = n->body->child;
		n->body->child = nn;
	}
	return(1);
}
@


1.77
log
@Note that `Dd' can be empty.  This found following a thread on discuss@@
started by Sascha Wildner, 07/25/2010 06:30 AM.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.76 2010/07/13 23:53:20 schwarze Exp $ */
d663 7
@


1.76
log
@correct lots of copyright notices;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.75 2010/07/04 21:59:30 kristaps Exp $ */
d907 5
@


1.75
log
@Cache column sizes and char pointer into mdoc_bl.  Finally get rid of
the loops here and there to track down the MDOC_Column arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.74 2010/07/01 22:56:17 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.74
log
@Make struct_bl and struct_bd into pointers.  This removes the need to do
copying on internals after modification.  Even more importantly, if an
ENDBODY token is provided, it would have been impossible for post-change
copying of the data to take place in the BLOCK.  This allows it to
happen by dint of pointers.

Also did some bikeshedding in mdoc_term.c: checking against enum type
and explicitly casting to the "post" function to void.  This is for my
own readability.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.73 2010/07/01 22:35:54 schwarze Exp $ */
d785 3
@


1.73
log
@In the mdoc(7) parser, inspect roff registers early such that all parts
of the parser can use the resulting cues.  In particular, this allows
to use .nr nS to force SYNOPSIS-style .Nm indentation outside the
SYNOPSIS as needed by ifconfig(8).

To actually make this useable, .Pp must rewind .Nm, or the rest of the
section would end up indented.  Implement a quick hack for now,
a generic solution can be designed later.

ok kristaps@@ and tested by sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.72 2010/06/27 15:52:41 kristaps Exp $ */
d699 1
a699 1
	n->data.Bl.width = n->args->argv[i].value[0];
d722 1
a722 1
	if (0 == strcmp(n->data.Bl.width, "Ds"))
d724 1
a724 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(n->data.Bl.width)))
d744 1
a744 1
	n->data.Bl.width = n->args->argv[i].value[0];
d760 1
a760 1
	if (LIST_column != n->data.Bl.type)
a801 2
	struct mdoc_node *nn;
	const char	 *ww;
d816 1
a816 3
	ww = n->data.Bl.width;

	if (LIST_tag == n->data.Bl.type && NULL == n->data.Bl.width) {
d819 1
a819 1
	} else if (NULL != n->data.Bl.width) {
d825 1
a825 11
	assert(n->data.Bl.width);

	/* If it has changed, propogate new width to children. */

	if (ww == n->data.Bl.width)
		return(1);

	for (nn = n->child; nn; nn = nn->next)
		if (MDOC_Bl == nn->tok)
			nn->data.Bl.width = n->data.Bl.width;

d956 2
a957 1
	if (DISP_literal == n->data.Bd.type)
d959 1
a959 1
	if (DISP_unfilled == n->data.Bd.type)
@


1.72
log
@Downstream maintainers: this removes UGLY!  I don't want diverging
functionality and UGLY works quite well thanks to schwarze@@'s careful
attention.

This also backs out function-prototype changes for struct regset,
instead stuffing a pointer to the regset directly into struct
mdoc/man/roff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.71 2010/06/19 20:46:28 kristaps Exp $ */
d460 11
@


1.71
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.70 2010/06/13 21:02:48 kristaps Exp $ */
d35 5
@


1.70
log
@Allow -width for lists to be cached in mdoc_bl.  This requires some
trickery because widths may be on-the-fly recalculated.  I don't like
how these are split between mdoc_action.c and mdoc_validate.c, but for
the time being, it'll do.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.69 2010/06/13 20:05:12 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.69
log
@Small optimisations in mdoc_action list processing.  Cleanups making way
for "width" cached argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.68 2010/06/12 12:38:01 kristaps Exp $ */
d55 1
a55 2
static	int	  post_bl_width(struct mdoc *, 
			struct mdoc_node *, int);
d669 5
a673 3
	nn = n;
	assert(nn->args);
	i = (int)(nn->args->argc)++;
d675 6
a680 2
	nn->args->argv = mandoc_realloc(nn->args->argv, 
			nn->args->argc * sizeof(struct mdoc_argv));
d682 2
a683 6
	nn->args->argv[i].arg = MDOC_Width;
	nn->args->argv[i].line = n->line;
	nn->args->argv[i].pos = n->pos;
	nn->args->argv[i].sz = 1;
	nn->args->argv[i].value = mandoc_malloc(sizeof(char *));
	nn->args->argv[i].value[0] = mandoc_strdup(buf);
d694 1
a694 1
post_bl_width(struct mdoc *m, struct mdoc_node *n, int pos)
d697 1
a699 4
	char		 *p;

	assert(n->args);
	p = n->args->argv[pos].value[0];
d706 1
a706 1
	if (0 == strcmp(p, "Ds"))
d708 1
a708 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(p)))
d715 8
d724 5
a728 2
	free(n->args->argv[pos].value[0]);
	n->args->argv[pos].value[0] = mandoc_strdup(buf);
d786 2
a787 1
	int		  i, r, len, width;
d802 1
a802 12
	len = (int)(n->args ? n->args->argc : 0);

	width = -1;

	for (r = i = 0; i < len; i++) {
		if (MDOC_Tag == n->args->argv[i].arg)
			r |= 1 << 0;
		if (MDOC_Width == n->args->argv[i].arg) {
			width = i;
			r |= 1 << 1;
		}
	}
d804 1
a804 1
	if (r & (1 << 0) && ! (r & (1 << 1))) {
d807 2
a808 2
	} else if (r & (1 << 1))
		if ( ! post_bl_width(m, n, width))
d810 13
a841 1
	/* XXX: make into macro value. */
@


1.68
log
@Cached `Bl -offset' into mdoc_bl.  Removed erroneous "-offset defaults
to 6n if no value is specified" and added regression tests for `Bl'
testing against the empty -offset argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.67 2010/06/12 11:21:44 kristaps Exp $ */
d55 2
a56 1
static	int	  post_bl_width(POST_ARGS);
d635 1
a635 1
	size_t		  sz;
d639 1
a639 3
	/* Defaults to ten ens. */

	sz = 10; /* XXX: make this a macro value. */
d642 2
a643 3
		if (MDOC_It == nn->tok)
			break;
	}
a644 1
	if (nn) {
d647 2
a648 8
		if (MDOC_TEXT != nn->type) {
			sz = mdoc_macro2len(nn->tok);
			if (sz == 0) {
				if ( ! mdoc_nmsg(m, n, MANDOCERR_NOWIDTHARG))
					return(0);
				sz = 10;
			}
		} else
d650 9
d661 2
d693 1
a693 1
post_bl_width(POST_ARGS)
a695 1
	int		  i;
d700 2
a701 10
	if (NULL == n->args)
		return(1);

	for (i = 0; i < (int)n->args->argc; i++)
		if (MDOC_Width == n->args->argv[i].arg)
			break;

	if (i == (int)n->args->argc)
		return(1);
	p = n->args->argv[i].value[0];
d718 2
a719 2
	free(n->args->argv[i].value[0]);
	n->args->argv[i].value[0] = mandoc_strdup(buf);
d735 3
a737 1
	if (NULL == n->child)
d747 1
a747 2
	if (c == (int)np->args->argc)
		return(1);
d777 1
a777 1
	int		  i, r, len;
d794 2
d799 2
a800 1
		if (MDOC_Width == n->args->argv[i].arg)
d802 1
d809 1
a809 1
		if ( ! post_bl_width(m, n))
@


1.67
log
@Cache all of `Bd's resolved arguments into mdoc_bd, which is stashed in
the "data" union in mdoc_node.  Allows me to remove some ugly loops in
the front-end and duplicate tests in mdoc_action.c.  Add a regression
test to make sure we're not doing anything bad (more to come).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.66 2010/06/12 10:09:19 kristaps Exp $ */
a70 1
static	int	  pre_bl(PRE_ARGS);
a71 1
static	int	  pre_offset(PRE_ARGS);
d85 1
a85 1
	{ pre_bl, post_bl }, /* Bl */ 
a937 38
/* ARGSUSED */
static int
pre_offset(PRE_ARGS)
{
	int		 i;

	/* 
	 * Make sure that an empty offset produces an 8n length space as
	 * stipulated by mdoc.samples. 
	 */

	for (i = 0; n->args && i < (int)n->args->argc; i++) {
		if (MDOC_Offset != n->args->argv[i].arg) 
			continue;
		if (n->args->argv[i].sz)
			break;
		assert(1 == n->args->refcnt);
		/* If no value set, length of <string>. */
		n->args->argv[i].sz++;
		n->args->argv[i].value = mandoc_malloc(sizeof(char *));
		n->args->argv[i].value[0] = mandoc_strdup("8n");
		break;
	}

	return(1);
}


static int
pre_bl(PRE_ARGS)
{

	if (MDOC_BLOCK == n->type)
		return(pre_offset(m, n));
	return(1);
}


@


1.66
log
@Added enum mdoc_disp (similar to enum mdoc_list).  Display types are now
only calculated once in mdoc_validate.c.

Noted that `Bd -file xxx' is not supported:  it now raises a fatal
warning.  This is noted in mdoc.7.

Empty `Bd' now defaults to LIST_ragged, which is not quite what groff
does, but close enough (gross just throws away the `Bd' and gets upset
when it encounters an `Ed').
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.65 2010/06/03 13:44:36 kristaps Exp $ */
a981 2
	if (MDOC_BLOCK == n->type)
		return(pre_offset(m, n));
d985 1
a985 1
	if (DISP_literal == n->data.disp)
d987 1
a987 1
	if (DISP_unfilled == n->data.disp)
@


1.65
log
@Consolidated list processing to a single loop in mdoc_validate.c.  This
relieves having to repeat running over the argument list in
mdoc_action.c and mdoc_validate.c.

Default to LIST_item for type-less lists (groff technically doesn't do
this: it just ignores the `It' lines altogether).

Make MANDOC_LISTTYPE be a recoverable error.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.64 2010/05/31 10:28:04 kristaps Exp $ */
a980 1
	int		 i;
d987 4
a990 7
	/* Enter literal context if `Bd -literal' or `-unfilled'. */

	for (n = n->parent, i = 0; i < (int)n->args->argc; i++)
		if (MDOC_Literal == n->args->argv[i].arg)
			m->flags |= MDOC_LITERAL;
		else if (MDOC_Unfilled == n->args->argv[i].arg)
			m->flags |= MDOC_LITERAL;
@


1.64
log
@Remove enum mdocargerr from phrase() (unused).

Add `Ta' macro, which is basically a NULL case everywhere but in
mdoc_macro.c, where it closes out an existing `It' body scope and opens
a new one, then continues parsing as in phrase() (TODO: merge these
two?).

Fix where scope-breaking was silently just dying instead of printing an
error.

Fix where trailing `Ta' or tab weren't creating a new MDOC_BODY context.

We now support arbitrarily complex `It' contents for `Bl -column'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.63 2010/05/30 11:00:53 kristaps Exp $ */
d951 1
a951 2
	assert(n->args);
	for (i = 0; i < (int)n->args->argc; i++) {
a970 1
	int		 pos;
d972 3
a974 55
	if (MDOC_BLOCK != n->type) {
		assert(n->parent);
		assert(MDOC_BLOCK == n->parent->type);
		assert(MDOC_Bl == n->parent->tok);
		assert(LIST__NONE != n->parent->data.list);
		n->data.list = n->parent->data.list;
		return(1);
	}

	assert(LIST__NONE == n->data.list);

	for (pos = 0; pos < (int)n->args->argc; pos++) {
		switch (n->args->argv[pos].arg) {
		case (MDOC_Bullet):
			n->data.list = LIST_bullet;
			break;
		case (MDOC_Dash):
			n->data.list = LIST_dash;
			break;
		case (MDOC_Enum):
			n->data.list = LIST_enum;
			break;
		case (MDOC_Hyphen):
			n->data.list = LIST_hyphen;
			break;
		case (MDOC_Item):
			n->data.list = LIST_item;
			break;
		case (MDOC_Tag):
			n->data.list = LIST_tag;
			break;
		case (MDOC_Diag):
			n->data.list = LIST_diag;
			break;
		case (MDOC_Hang):
			n->data.list = LIST_hang;
			break;
		case (MDOC_Ohang):
			n->data.list = LIST_ohang;
			break;
		case (MDOC_Inset):
			n->data.list = LIST_inset;
			break;
		case (MDOC_Column):
			n->data.list = LIST_column;
			break;
		default:
			break;
		}
		if (LIST__NONE != n->data.list)
			break;
	}

	assert(LIST__NONE != n->data.list);
	return(pre_offset(m, n));
@


1.63
log
@Made `Dt' default to LOCAL and UNKNOWN instead of local and unknown (note case).

Have `Dt' default to UNKNOWN if it's an empty string.

Raise a warning if `Dt' title isn't capitalised.

Sync'd `Dt' documentation with reality.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.62 2010/05/29 18:58:52 kristaps Exp $ */
d197 1
@


1.62
log
@Moved printing of empty word [back] into mdoc_action.c so that it's not
mirrored across front-ends.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.61 2010/05/24 11:59:37 joerg Exp $ */
d502 2
a503 2
		m->meta.title = mandoc_strdup("unknown");
		m->meta.vol = mandoc_strdup("local");
d512 2
a513 1
	m->meta.title = mandoc_strdup(nn->string);
d518 1
a518 1
		m->meta.vol = mandoc_strdup("local");
@


1.61
log
@If a .Bl -tag lacks a -width, skip all non-It macros for the implicit
calculation. E.g. .Sm can occur as direct child of .Bl.

OK schwarze@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.60 2010/05/17 23:57:06 kristaps Exp $ */
d60 1
d106 1
a106 1
	{ NULL, NULL }, /* Li */
d841 21
@


1.60
log
@Increase performance by stashing the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can known whether to
dump list line arguments into the body (`Bl -column' overflowing).

Remove a2list() and arg_listtype() because of this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.59 2010/05/17 22:11:42 kristaps Exp $ */
d640 5
a644 1
	nn = n->body->child;
a647 1
		assert(MDOC_It == nn->tok);
@


1.59
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.58 2010/05/15 16:24:38 kristaps Exp $ */
d36 1
a36 1
#define	PRE_ARGS  struct mdoc *m, const struct mdoc_node *n
d219 1
a219 1
mdoc_action_pre(struct mdoc *m, const struct mdoc_node *n)
d945 1
d947 55
a1001 1
	return(MDOC_BLOCK == n->type ? pre_offset(m, n) : 1);
@


1.58
log
@LIBRARY can also occur in section 9.
All manual sections (unknown, 3p, 3f, etc.) correctly handled by -mdoc.
Useful warning printed if unknown manual section.
Checking for manual sections (e.g., LIBRARY) checks only first character, so 3p, 3f, etc. are free.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.57 2010/05/14 16:02:29 kristaps Exp $ */
d31 1
d273 9
a281 2
		if (strlcat(p, n->string, sz) >= sz)
			return(mdoc_nerr(m, n, ETOOLONG));
d284 4
a287 2
		if (strlcat(p, " ", sz) >= sz)
			return(mdoc_nerr(m, n, ETOOLONG));
d301 1
a301 1
	struct mdoc_node	*nn;
d305 2
d310 1
a310 1
	assert(m->meta.name);
d468 1
a468 1
		return(mdoc_nwarn(m, n, EWRONGMSEC));
d532 1
a532 1
	} else if (mdoc_nwarn(m, n, EBADMSEC)) {
d589 4
d595 4
a598 2
		if (strlcat(buf, OSNAME, BUFSIZ) >= BUFSIZ)
			return(mdoc_nerr(m, n, EUTSNAME));
d601 14
a614 7
			return(mdoc_nerr(m, n, EUTSNAME));
		if (strlcat(buf, utsname.sysname, BUFSIZ) >= BUFSIZ)
			return(mdoc_nerr(m, n, ETOOLONG));
		if (strlcat(buf, " ", 64) >= BUFSIZ)
			return(mdoc_nerr(m, n, ETOOLONG));
		if (strlcat(buf, utsname.release, BUFSIZ) >= BUFSIZ)
			return(mdoc_nerr(m, n, ETOOLONG));
d649 1
a649 1
				if ( ! mdoc_nwarn(m, n, ENOWIDTH))
a711 1
		/* XXX: make into a macro. */
d716 1
a716 1
		return(mdoc_nwarn(m, n, ENOWIDTH));
d875 1
a875 1
		if ( ! mdoc_nwarn(m, n, EBADDATE))
@


1.57
log
@"Warn on unknown argument for .At and print it like [new] groff." (patch by Joerg Sonnenberger, ed. Kristaps)
Keep short-log of commits in index.sgml.
Document compatibility with new/old groff in mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.56 2010/05/14 15:26:39 kristaps Exp $ */
d449 2
a450 6
		switch (m->meta.msec) {
		case (2):
			/* FALLTHROUGH */
		case (3):
			/* FALLTHROUGH */
		case (9):
d452 5
a456 4
		default:
			return(mdoc_nwarn(m, n, EBADSEC));
		}
		break;
a472 2
	char		 *ep;
	long		  lval;
a481 2
	m->meta.msec = 0;

d488 1
d491 1
d502 1
d505 1
a517 1
		/* FIXME: where is strtonum!? */
d519 2
a520 4
		lval = strtol(nn->string, &ep, 10);
		if (nn->string[0] != '\0' && *ep == '\0')
			m->meta.msec = (int)lval;
	} else 
d522 3
d541 1
@


1.56
log
@"Invalid standard argument should be a warning. Just leak it into the
output." (patch by Joerg Sonnenberger)
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.55 2010/05/12 08:41:17 kristaps Exp $ */
d385 4
a388 2
	struct mdoc_node	*nn;
	const char		*p;
d393 13
a405 3
		assert(p);
		free(n->child->string);
		n->child->string = mandoc_strdup(p);
@


1.55
log
@mdoc_atosec -> mdoc_str2sec (consistent with str2 being different from a2).
Changed ordering of sections (EXIT STATUS moved around), argued for by Ulrich Sporlein.
Fixed mdoc_str2sec not to use weird structure.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.54 2010/05/08 07:30:19 kristaps Exp $ */
d369 4
a372 3
	assert(p);
	free(n->child->string);
	n->child->string = mandoc_strdup(p);
@


1.54
log
@Lint fixes (type-safety for enums via -cefuh).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.53 2010/04/06 11:33:00 kristaps Exp $ */
d422 1
a422 1
	sec = mdoc_atosec(buf);
@


1.53
log
@Migrating mdoc_node_free() and mdoc_node_freelist() to use mdoc_node_delete(), which has a more intuitive interface and mirrors libman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.52 2010/04/05 09:03:12 kristaps Exp $ */
d47 1
a47 1
static	inline int order_rs(int);
d199 1
a199 1
static	const int rsord[RSORD_MAX] = {
d948 1
a948 1
order_rs(int t)
d952 1
a952 1
	for (i = 0; i < RSORD_MAX; i++)
@


1.52
log
@Fix issue of non-NAME sections triggering "no sections" error, reported by Christian Weisgerber, patched by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.51 2010/03/31 07:13:53 kristaps Exp $ */
d732 1
a732 1
		mdoc_node_free(nnp);
a856 19
	struct mdoc_node *np;

	if (n->parent->child == n)
		n->parent->child = n->prev;
	if (n->prev)
		n->prev->next = NULL;

	np = n;
	assert(NULL == n->next);

	if (n->prev) {
		m->last = n->prev;
		m->next = MDOC_NEXT_SIBLING;
	} else {
		m->last = n->parent;
		m->next = MDOC_NEXT_CHILD;
	}

	mdoc_node_freelist(np);
d858 1
a860 1

@


1.51
log
@Macro types enum-ated (enum mdoct) (for easier debugging in gdb of "tok" values).
Initial check-in of Ingo Schwarze's patch for Xo/Xc handling (in blocks ifdef'd "UGLY").
Put Oc-close-Op parts into UGLY ifdef blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.50 2010/01/01 17:14:29 kristaps Exp $ */
d423 5
a427 1
	if (SEC_CUSTOM != sec)
@


1.50
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.49 2009/11/02 06:22:45 kristaps Exp $ */
d650 2
a651 1
	int		  i, tok;
@


1.49
log
@Added mandoc_a2time() for proper date conversion.
Fitted TH and Dd handlers to use mandoc_a2time().
Documented date syntax for -man, fixed documentation for -mdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.48 2009/10/31 06:10:58 kristaps Exp $ */
d17 4
a48 4
#ifdef __linux__
extern	size_t	  strlcat(char *, const char *, size_t);
#endif

@


1.48
log
@Using perror() instead of fprintf for failure from library functions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.47 2009/10/30 18:50:11 kristaps Exp $ */
d821 1
a821 2
 * Parse the date field in `Dd', primarily through mdoc_atotime().
 * FIXME: push mdoc_atotime() into here.
d831 3
a833 1
	m->meta.date = mdoc_atotime(buf);
@


1.47
log
@Lint fixes.
Made realloc puke with fprintf.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.46 2009/10/29 04:34:38 kristaps Exp $ */
a21 1
#include <errno.h>
a505 1
		errno = 0;
@


1.46
log
@Clean-ups in mdoc_action (using libmandoc.h functions).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.45 2009/10/26 10:36:46 kristaps Exp $ */
d893 1
@


1.45
log
@Fix to segfault in ordering Rs blocks (d'oh!).
Version: 1.9.11.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.44 2009/10/26 04:09:45 kristaps Exp $ */
d29 1
d34 3
d42 2
a43 3
static	int	  concat(struct mdoc *, 
			const struct mdoc_node *, 
			char *, size_t);
d62 1
a67 1
static	int	  post_tilde(POST_ARGS);
d110 1
a110 1
	{ NULL, post_tilde }, /* Pa */
d260 5
d266 1
a266 2
concat(struct mdoc *m, const struct mdoc_node *n, 
		char *buf, size_t sz)
d269 2
d273 1
a273 1
		if (strlcat(buf, n->string, sz) >= sz)
d277 1
a277 1
		if (strlcat(buf, " ", sz) >= sz)
d285 4
a302 1

d307 4
d314 1
a314 1
	char		 buf[64];
d318 1
a318 3

	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d320 1
a320 3
	if (NULL == (m->meta.name = strdup(buf)))
		return(mdoc_nerr(m, n, EMALLOC));

d325 6
d340 2
a341 8
	if (NULL == p) {
		sz = strlen(n->child->string) +
			2 + strlen("\\(lqlibrary\\(rq");
		buf = malloc(sz);
		if (NULL == buf)
			return(mdoc_nerr(m, n, EMALLOC));
		(void)snprintf(buf, sz, "library \\(lq%s\\(rq", 
				n->child->string);
d343 1
a343 1
		n->child->string = buf;
d347 4
d352 1
a352 4
	n->child->string = strdup(p);
	if (NULL == n->child->string)
		return(mdoc_nerr(m, n, EMALLOC));

d357 6
d372 1
a372 4
	n->child->string = strdup(p);
	if (NULL == n->child->string)
		return(mdoc_nerr(m, n, EMALLOC));

d377 5
d393 1
a393 3
		n->child->string = strdup(p);
		if (NULL == n->child->string)
			return(mdoc_nerr(m, n, EMALLOC));
a398 1

a401 1

d406 6
d416 1
a416 7
	char		 buf[64];

	/*
	 * We keep track of the current section /and/ the "named"
	 * section, which is one of the conventional ones, in order to
	 * check ordering.
	 */
d421 1
a421 2
	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d423 2
a424 1
	if (SEC_CUSTOM != (sec = mdoc_atosec(buf)))
d427 2
d451 4
d478 3
a480 4
		if (NULL == (m->meta.title = strdup("unknown")))
			return(mdoc_nerr(m, n, EMALLOC));
		if (NULL == (m->meta.vol = strdup("local")))
			return(mdoc_nerr(m, n, EMALLOC));
d488 1
a488 2
	if (NULL == (m->meta.title = strdup(nn->string)))
		return(mdoc_nerr(m, n, EMALLOC));
d491 2
a492 2
		if (NULL == (m->meta.vol = strdup("local")))
			return(mdoc_nerr(m, n, EMALLOC));
d505 2
a506 2
		if (NULL == (m->meta.vol = strdup(cp)))
			return(mdoc_nerr(m, n, EMALLOC));
d511 2
a512 2
	} else if (NULL == (m->meta.vol = strdup(nn->string)))
		return(mdoc_nerr(m, n, EMALLOC));
d527 1
a527 2
		if (NULL == (m->meta.vol = strdup(cp)))
			return(mdoc_nerr(m, n, EMALLOC));
d532 3
a534 4
			if (NULL == (m->meta.vol = strdup(nn->string)))
				return(mdoc_nerr(m, n, EMALLOC));
		} else if (NULL == (m->meta.arch = strdup(cp)))
			return(mdoc_nerr(m, n, EMALLOC));
d538 1
d544 6
d553 2
a554 2
	char		  buf[64];
#ifndef	OSNAME
a557 6
	/*
	 * Setting OSNAME to be the name of the target operating system,
	 * e.g., "OpenBSD 4.4", will result in the compile-time constant
	 * by supplied instead of the value in uname().
	 */

d561 1
a561 2
	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d564 3
a566 3
	if (0 == buf[0]) {
#ifdef	OSNAME
		if (strlcat(buf, OSNAME, 64) >= 64)
d568 1
a568 1
#else
d571 1
a571 1
		if (strlcat(buf, utsname.sysname, 64) >= 64)
d573 1
a573 1
		if (strlcat(buf, " ", 64) >= 64)
d575 1
a575 1
		if (strlcat(buf, utsname.release, 64) >= 64)
d577 1
a577 1
#endif
d580 1
a580 3
	if (NULL == (m->meta.os = strdup(buf)))
		return(mdoc_nerr(m, n, EMALLOC));

d587 3
a589 1
 * Uses the first head macro.
d594 4
a597 3
	struct mdoc_node  *nn;
	int		   sz;
	char		   buf[32];
d599 1
a599 4
	/*
	 * Use the text width, if a text node, or the default macro
	 * width if a macro.
	 */
d601 1
d603 1
a607 5
	}

	sz = 10; /* Default size. */

	if (nn) {
d609 2
a610 1
			if (0 == (sz = (int)mdoc_macro2len(nn->tok)))
d613 2
d616 1
a616 1
			sz = (int)strlen(nn->string) + 1;
d619 1
a619 2
	if (-1 == snprintf(buf, sizeof(buf), "%dn", sz))
		return(mdoc_nerr(m, n, ENUMFMT));
d628 1
a628 1
	sz = (int)(nn->args->argc)++;
d630 1
a630 1
	nn->args->argv = realloc(nn->args->argv, 
d633 6
a638 14
	if (NULL == nn->args->argv)
		return(mdoc_nerr(m, n, EMALLOC));

	nn->args->argv[sz].arg = MDOC_Width;
	nn->args->argv[sz].line = n->line;
	nn->args->argv[sz].pos = n->pos;
	nn->args->argv[sz].sz = 1;
	nn->args->argv[sz].value = calloc(1, sizeof(char *));

	if (NULL == nn->args->argv[sz].value)
		return(mdoc_nerr(m, n, EMALLOC));
	if (NULL == (nn->args->argv[sz].value[0] = strdup(buf)))
		return(mdoc_nerr(m, n, EMALLOC));

d643 5
d653 1
a653 1
	char		  buf[32];
d673 1
d682 1
a682 3
	if (-1 == snprintf(buf, sizeof(buf), "%zun", width))
		return(mdoc_nerr(m, n, ENUMFMT));

d684 1
a684 4
	n->args->argv[i].value[0] = strdup(buf);
	if (NULL == n->args->argv[i].value[0])
		return(mdoc_nerr(m, n, EMALLOC));

d689 4
a709 2
	/* Only process -column. */

a711 1
	
d721 1
a721 1
	np->args->argv[c].value = malloc
a733 1

d776 4
d781 1
a781 1
post_tilde(POST_ARGS)
d790 1
a790 1

a793 1

d798 4
d812 1
a817 1

d822 4
d829 1
a829 1
	char		  buf[64];
d831 1
a831 2
	buf[0] = 0;
	if ( ! concat(m, n->child, buf, sizeof(buf)))
d834 2
a835 1
	if (0 == (m->meta.date = mdoc_atotime(buf))) {
d845 5
a854 2
	/* Remove prologue macros from AST.  */

d880 3
a910 4
		n->args->argv[i].value = 
		calloc(1, sizeof(char *));
		if (NULL == n->args->argv[i].value)
			return(mdoc_nerr(m, n, EMALLOC));
d912 2
a913 3
		n->args->argv[i].value[0] = strdup("8n");
		if (NULL == n->args->argv[i].value[0])
			return(mdoc_nerr(m, n, EMALLOC));
@


1.44
log
@Full `%U' support.
`Lk' display fixed.
Renamed arg2xxxx as a2xxxx for consistency.
Renamed print_foot to print_man_foot for consistency.
Removed default printing of `~' when `Lk' not provided (not sure where I got that from).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.43 2009/10/24 05:52:13 kristaps Exp $ */
d195 1
a195 1
#define	RSORD_MAX 13
d210 2
a211 1
	MDOC__C
@


1.43
log
@Added `%U' to -mdoc (doesn't render in a nice way yet).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.42 2009/10/22 17:54:24 kristaps Exp $ */
d17 1
d19 1
d26 1
d180 1
a180 1
	{ NULL, post_tilde }, /* Lk */
a776 1
	/* XXX: not documented for `Lk'. */
@


1.42
log
@Added ability to set OS name at compile-time with -DOSNAME="\"foo\"".
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.41 2009/09/25 13:03:25 kristaps Exp $ */
d189 1
@


1.41
log
@Lint check (noop).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.40 2009/09/24 15:08:41 kristaps Exp $ */
d523 1
d525 7
d541 4
d553 1
@


1.40
log
@Fixed segfault in `Rs' empty block.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.39 2009/09/24 15:01:06 kristaps Exp $ */
d937 1
@


1.39
log
@Added EBADCHILD error (bad child of parent context).
`Rs' post-checks that all children are proper bibliographic elements.
`Rs' correctly re-orders its children as per groff's output (including %C).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.38 2009/09/24 13:03:32 kristaps Exp $ */
d946 1
@


1.38
log
@-offset string can now be blank (supplied with 6n as stipulated by mdoc.samples).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.37 2009/09/16 20:49:06 kristaps Exp $ */
d35 9
d57 1
d154 1
a154 1
	{ NULL, NULL }, /* Rs */
d191 1
a191 2
static	int	  concat(struct mdoc *, const struct mdoc_node *, 
			char *, size_t);
d193 15
a207 3
#ifdef __linux__
extern	size_t	  strlcat(char *, const char *, size_t);
#endif
d923 60
@


1.37
log
@Lintifications.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.36 2009/09/16 14:40:56 kristaps Exp $ */
d54 1
d56 1
d70 1
a70 1
	{ NULL, post_bl }, /* Bl */ 
d830 41
d875 2
a881 5
	/* 
	 * TODO: `-offset' without an argument should be the width of
	 * the literal "<string>".
	 */

d884 1
a884 1
			break;
d886 1
a886 4
			break;

	if (i < (int)n->args->argc)
		m->flags |= MDOC_LITERAL;
@


1.36
log
@Lookup hashes are now static tables, ordered first-level by second character, then randomly along a chain.  Improves performance by a small fraction and considerably cleans up hash sources.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.35 2009/08/20 13:22:48 kristaps Exp $ */
d56 1
a56 1
const	struct actions mdoc_actions[MDOC_MAX] = {
@


1.35
log
@Updated manual structure in mdoc.7.
Synchronised mdoc.template and mdoc.7 manual structure.
`Rv' and `Ex' now accept multiple arguments (-std made standalone, terms as children).
`Rv' and `Ex' format correctly in -Tascii (plurals, commas, etc.).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.34 2009/07/26 10:29:39 kristaps Exp $ */
d620 1
a620 1
	else if (MDOC_MAX == (tok = mdoc_hash_find(m->htab, p)))
@


1.34
log
@Made out-of-order prologue macros not cause an error.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.33 2009/07/25 16:03:03 kristaps Exp $ */
d27 1
a28 1
#define	POST_ARGS struct mdoc *m
d74 1
a74 1
	{ NULL, NULL }, /* Cd */ /* FIXME: tabs are accepted! */
d225 1
a225 1
	return((*mdoc_actions[m->last->tok].post)(m));
d251 1
d253 1
a253 6
	/*
	 * If '-std' is invoked without an argument, fill it in with our
	 * name (if it's been set).
	 */

	if (NULL == m->last->args)
d255 3
a257 3
	if (m->last->args->argv[0].sz)
		return(1);

d259 3
a261 9

	m->last->args->argv[0].value = calloc(1, sizeof(char *));
	if (NULL == m->last->args->argv[0].value)
		return(mdoc_nerr(m, m->last, EMALLOC));

	m->last->args->argv[0].sz = 1;
	m->last->args->argv[0].value[0] = strdup(m->meta.name);
	if (NULL == m->last->args->argv[0].value[0])
		return(mdoc_nerr(m, m->last, EMALLOC));
d276 1
a276 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
a277 1

d279 1
a279 1
		return(mdoc_nerr(m, m->last, EMALLOC));
d292 2
a293 2
	assert(MDOC_TEXT == m->last->child->type);
	p = mdoc_a2lib(m->last->child->string);
d295 1
a295 1
		sz = strlen(m->last->child->string) +
d299 1
a299 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d301 3
a303 3
				m->last->child->string);
		free(m->last->child->string);
		m->last->child->string = buf;
d307 5
a311 4
	free(m->last->child->string);
	m->last->child->string = strdup(p);
	if (NULL == m->last->child->string)
		return(mdoc_nerr(m, m->last, EMALLOC));
d321 2
a322 2
	assert(MDOC_TEXT == m->last->child->type);
	p = mdoc_a2st(m->last->child->string);
d324 5
a328 4
	free(m->last->child->string);
	m->last->child->string = strdup(p);
	if (NULL == m->last->child->string)
		return(mdoc_nerr(m, m->last, EMALLOC));
d336 2
a337 2
	struct mdoc_node *n;
	const char	 *p;
d339 3
a341 3
	if (m->last->child) {
		assert(MDOC_TEXT == m->last->child->type);
		p = mdoc_a2att(m->last->child->string);
d343 4
a346 4
		free(m->last->child->string);
		m->last->child->string = strdup(p);
		if (NULL == m->last->child->string)
			return(mdoc_nerr(m, m->last, EMALLOC));
d350 1
a350 1
	n = m->last;
d353 1
a353 1
	if ( ! mdoc_word_alloc(m, n->line, n->pos, "AT&T UNIX"))
d355 1
a356 2
	m->last = n;
	m->next = MDOC_NEXT_SIBLING;
d373 1
a373 1
	if (MDOC_HEAD != m->last->type)
d377 1
a377 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
d394 1
a394 1
			return(mdoc_nwarn(m, m->last, EBADSEC));
d407 1
a407 1
	struct mdoc_node *n;
d426 1
a426 1
	if (NULL == (n = m->last->child)) {
d428 1
a428 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d430 2
a431 2
			return(mdoc_nerr(m, m->last, EMALLOC));
		return(post_prol(m));
d438 2
a439 2
	if (NULL == (m->meta.title = strdup(n->string)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d441 1
a441 1
	if (NULL == (n = n->next)) {
d443 2
a444 2
			return(mdoc_nerr(m, m->last, EMALLOC));
		return(post_prol(m));
d454 1
a454 1
	cp = mdoc_a2msec(n->string);
d457 1
a457 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d459 2
a460 2
		lval = strtol(n->string, &ep, 10);
		if (n->string[0] != '\0' && *ep == '\0')
d462 2
a463 2
	} else if (NULL == (m->meta.vol = strdup(n->string)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d465 2
a466 2
	if (NULL == (n = n->next))
		return(post_prol(m));
d475 1
a475 1
	cp = mdoc_a2vol(n->string);
d479 1
a479 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d481 1
a481 1
		cp = mdoc_a2arch(n->string);
d484 2
a485 2
			if (NULL == (m->meta.vol = strdup(n->string)))
				return(mdoc_nerr(m, m->last, EMALLOC));
d487 1
a487 1
			return(mdoc_nerr(m, m->last, EMALLOC));
d492 1
a492 1
	return(post_prol(m));
d506 1
a506 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
d511 1
a511 1
			return(mdoc_nerr(m, m->last, EUTSNAME));
d513 1
a513 1
			return(mdoc_nerr(m, m->last, ETOOLONG));
d515 1
a515 1
			return(mdoc_nerr(m, m->last, ETOOLONG));
d517 1
a517 1
			return(mdoc_nerr(m, m->last, ETOOLONG));
d521 1
a521 1
		return(mdoc_nerr(m, m->last, EMALLOC));
d523 1
a523 1
	return(post_prol(m));
d532 1
a532 1
post_bl_tagwidth(struct mdoc *m)
d534 1
a534 1
	struct mdoc_node  *n;
d543 5
a547 5
	n = m->last->body->child;
	if (n) {
		assert(MDOC_BLOCK == n->type);
		assert(MDOC_It == n->tok);
		n = n->head->child;
d552 4
a555 4
	if (n) {
		if (MDOC_TEXT != n->type) {
			if (0 == (sz = (int)mdoc_macro2len(n->tok)))
				if ( ! mdoc_nwarn(m, m->last, ENOWIDTH))
d558 1
a558 1
			sz = (int)strlen(n->string) + 1;
d562 1
a562 1
		return(mdoc_nerr(m, m->last, ENUMFMT));
d569 3
a571 3
	n = m->last;
	assert(n->args);
	sz = (int)(n->args->argc)++;
d573 2
a574 2
	n->args->argv = realloc(n->args->argv, 
			n->args->argc * sizeof(struct mdoc_argv));
d576 2
a577 2
	if (NULL == n->args->argv)
		return(mdoc_nerr(m, m->last, EMALLOC));
d579 5
a583 5
	n->args->argv[sz].arg = MDOC_Width;
	n->args->argv[sz].line = m->last->line;
	n->args->argv[sz].pos = m->last->pos;
	n->args->argv[sz].sz = 1;
	n->args->argv[sz].value = calloc(1, sizeof(char *));
d585 4
a588 4
	if (NULL == n->args->argv[sz].value)
		return(mdoc_nerr(m, m->last, EMALLOC));
	if (NULL == (n->args->argv[sz].value[0] = strdup(buf)))
		return(mdoc_nerr(m, m->last, EMALLOC));
d595 1
a595 1
post_bl_width(struct mdoc *m)
d602 1
a602 1
	if (NULL == m->last->args)
d605 2
a606 2
	for (i = 0; i < (int)m->last->args->argc; i++)
		if (MDOC_Width == m->last->args->argv[i].arg)
d609 1
a609 1
	if (i == (int)m->last->args->argc)
d611 1
a611 1
	p = m->last->args->argv[i].value[0];
d623 1
a623 1
		return(mdoc_nwarn(m, m->last, ENOWIDTH));
d628 1
a628 1
		return(mdoc_nerr(m, m->last, ENUMFMT));
d630 4
a633 4
	free(m->last->args->argv[i].value[0]);
	m->last->args->argv[i].value[0] = strdup(buf);
	if (NULL == m->last->args->argv[i].value[0])
		return(mdoc_nerr(m, m->last, EMALLOC));
d639 1
d644 1
a644 1
	struct mdoc_node	*n, *nn, *nnp;
d646 1
a646 1
	if (NULL == m->last->child)
d649 2
a650 2
	n = m->last->parent;
	assert(n->args);
d652 2
a653 2
	for (c = 0; c < (int)n->args->argc; c++) 
		if (MDOC_Column == n->args->argv[c].arg)
d658 1
a658 1
	if (c == (int)n->args->argc)
d661 1
a661 1
	assert(0 == n->args->argv[c].sz);
d669 3
a671 3
	n->args->argv[c].sz = (size_t)m->last->nchild;
	n->args->argv[c].value = malloc
		((size_t)m->last->nchild * sizeof(char *));
d673 2
a674 2
	for (i = 0, nn = m->last->child; nn; i++) {
		n->args->argv[c].value[i] = nn->string;
d681 2
a682 2
	m->last->nchild = 0;
	m->last->child = NULL;
d693 3
a695 3
	if (MDOC_HEAD == m->last->type)
		return(post_bl_head(m));
	if (MDOC_BLOCK != m->last->type)
d706 1
a706 1
	len = (int)(m->last->args ? m->last->args->argc : 0);
d709 1
a709 1
		if (MDOC_Tag == m->last->args->argv[i].arg)
d711 1
a711 1
		if (MDOC_Width == m->last->args->argv[i].arg)
d716 1
a716 1
		if ( ! post_bl_tagwidth(m))
d719 1
a719 1
		if ( ! post_bl_width(m))
d729 1
a729 1
	struct mdoc_node *n;
d731 1
a731 1
	if (m->last->child)
d734 1
a734 1
	n = m->last;
d738 1
a738 1
	if ( ! mdoc_word_alloc(m, m->last->line, m->last->pos, "~"))
d740 1
a741 2
	m->last = n;
	m->next = MDOC_NEXT_SIBLING;
d749 1
a749 1
	struct mdoc_node *n;
d751 1
a751 1
	if (m->last->child)
d754 1
a754 1
	n = m->last;
d756 1
a756 1
	if ( ! mdoc_word_alloc(m, m->last->line, m->last->pos, "file"))
d758 1
a758 2
	m->next = MDOC_NEXT_SIBLING;
	if ( ! mdoc_word_alloc(m, m->last->line, m->last->pos, "..."))
d760 1
a761 2
	m->last = n;
	m->next = MDOC_NEXT_SIBLING;
d772 1
a772 1
	if ( ! concat(m, m->last->child, buf, sizeof(buf)))
d776 1
a776 1
		if ( ! mdoc_nwarn(m, m->last, EBADDATE))
d781 1
a781 1
	return(post_prol(m));
d788 1
a788 1
	struct mdoc_node *n;
d790 1
a790 4
	/* 
	 * The end document shouldn't have the prologue macros as part
	 * of the syntax tree (they encompass only meta-data).  
	 */
d792 4
a795 4
	if (m->last->parent->child == m->last)
		m->last->parent->child = m->last->prev;
	if (m->last->prev)
		m->last->prev->next = NULL;
d797 2
a798 2
	n = m->last;
	assert(NULL == m->last->next);
d800 2
a801 2
	if (m->last->prev) {
		m->last = m->last->prev;
d804 1
a804 1
		m->last = m->last->parent;
d808 1
a808 1
	mdoc_node_freelist(n);
d812 1
a822 1

d859 1
a859 1
	if (MDOC_BODY == m->last->type)
@


1.33
log
@Patches and results of LLVM static analysis (thanks uqs@@sporlein.net).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.32 2009/07/24 13:18:15 kristaps Exp $ */
a532 1
	m->flags |= MDOC_PBODY;
d824 3
d837 1
@


1.32
log
@Added `St -ieee1275-94'.
Documented a future `Bd' fixme.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.31 2009/07/21 15:53:31 kristaps Exp $ */
a489 1
		n = n->next;
@


1.31
log
@Added default print of `~' with empty `Pa' (not documented with OpenBSD, but still applicable).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.30 2009/07/17 10:56:57 kristaps Exp $ */
d848 6
a853 1
	/* Enter literal context if `Bd -literal' or * -unfilled'. */
@


1.30
log
@Added `br' and `sp' macros (requested by joerg@@netbsd.org, jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.29 2009/07/16 13:17:51 kristaps Exp $ */
a44 1
static	int	  post_lk(POST_ARGS);
d51 1
d92 1
a92 1
	{ NULL, NULL }, /* Pa */
d165 1
a165 1
	{ NULL, post_lk }, /* Lk */
d738 1
a738 1
post_lk(POST_ARGS)
d748 1
a748 1
	/* XXX: this isn't documented anywhere! */
@


1.29
log
@Subtle fixes correcting vis count with erroneously-decorated whitespace.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.28 2009/07/15 15:53:57 kristaps Exp $ */
d175 2
@


1.28
log
@Removed assertion (disregarded blank literal lines).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.27 2009/07/12 20:50:08 kristaps Exp $ */
a300 5
	/* 
	 * FIXME: this must be broken apart into a series of TEXT nodes,
	 * each containing a single word. 
	 */

a328 5
	/* 
	 * FIXME: this must be broken apart into a series of TEXT nodes,
	 * each containing a single word. 
	 */

a345 5
	/* 
	 * FIXME: this must be broken apart into a series of TEXT nodes,
	 * each containing a single word. 
	 */

@


1.27
log
@Replacement of `Lb' in mdoc_action.c.
Added warning against bogus `Lb' (like groff does).
Added proper quotes around `Lb' in mdoc_term.c.
Moved mdoc_a2lib -> libmdoc (where it belongs).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.26 2009/07/12 20:30:35 kristaps Exp $ */
d301 5
d334 5
d356 5
@


1.26
log
@Moved mdoc_a2st() out of mdoc.h -> libmdoc.h (replacement in mdoc_action.c).
Made bad standards into an error (were a warning).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.25 2009/07/12 20:24:24 kristaps Exp $ */
d44 1
d163 1
a163 1
	{ NULL, NULL }, /* Lb */
d295 30
@


1.25
log
@Moved mdoc_a2att() into libmdoc (replacement happens in mdoc_action.c).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.24 2009/07/07 11:47:17 kristaps Exp $ */
d49 1
d93 1
a93 1
	{ NULL, NULL }, /* St */
d294 16
@


1.24
log
@Made `In' handling work in new-groff style (see mdoc.samples).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.23 2009/07/06 13:04:52 kristaps Exp $ */
a34 3
static	int	  concat(struct mdoc *, const struct mdoc_node *, 
			char *, size_t);

d36 1
d39 1
a40 1
static	int	  post_bl_tagwidth(POST_ARGS);
d110 1
a110 1
	{ NULL, NULL }, /* At */ 
d175 2
d179 1
a179 1
extern	size_t	strlcat(char *, const char *, size_t);
d293 29
d699 1
a699 2
	if ( ! mdoc_word_alloc(m, m->last->line,
				m->last->pos, "~"))
d718 1
a718 2
	if ( ! mdoc_word_alloc(m, m->last->line,
				m->last->pos, "file"))
d721 1
a721 2
	if ( ! mdoc_word_alloc(m, m->last->line, 
				m->last->pos, "..."))
@


1.23
log
@Consolidated all err/warnings into mdoc.c via libmdoc.h.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.22 2009/07/06 11:14:03 kristaps Exp $ */
d668 2
a669 1
	/* FIXME: this isn't documented anywhere! */
@


1.22
log
@Consolidated mdoc_action pwarn->perr.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.21 2009/07/06 09:21:24 kristaps Exp $ */
a26 10
enum	merr {
	EBADDATE,
	ENOWIDTH,
	EBADSEC,
	ETOOLONG,
	EMALLOC,
	EUTSNAME,
	ENUMFMT
};

a34 1
static	int	  perr(struct mdoc *, int, int, enum merr, int);
a55 4
#define	vwarn(m, t) perr((m), (m)->last->line, (m)->last->pos, (t), 0)
#define	verr(m, t) perr((m), (m)->last->line, (m)->last->pos, (t), 1)
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t), 1)

d233 1
a233 1
			return(nerr(m, n, ETOOLONG));
d237 1
a237 1
			return(nerr(m, n, ETOOLONG));
a244 39
perr(struct mdoc *m, int line, int pos, enum merr type, int iserr)
{
	char		*p;

	p = NULL;

	switch (type) {
	case (ENUMFMT):
		p = "bad number format";
		break;
	case (ETOOLONG):
		p = "argument text too long";
		break;
	case (EUTSNAME):
		p = "utsname";
		break;
	case (EMALLOC):
		p = "memory exhausted";
		break;
	case (EBADSEC):
		p = "inappropriate document section in manual section";
		break;
	case (ENOWIDTH):
		p = "cannot determine default width";
		break;
	case (EBADDATE):
		p = "malformed date syntax";
		break;
	}

	assert(p);
	if (iserr)
		return(mdoc_perr(m, line, pos, p));

	return(mdoc_pwarn(m, line, pos, p));
}


static int
d262 1
a262 1
		return(verr(m, EMALLOC));
d267 1
a267 1
		return(verr(m, EMALLOC));
d286 1
a286 1
		return(verr(m, EMALLOC));
d325 1
a325 1
			return(vwarn(m, EBADSEC));
d359 1
a359 1
			return(verr(m, EMALLOC));
d361 1
a361 1
			return(verr(m, EMALLOC));
d370 1
a370 1
		return(verr(m, EMALLOC));
d374 1
a374 1
			return(verr(m, EMALLOC));
d388 1
a388 1
			return(verr(m, EMALLOC));
d394 1
a394 1
		return(verr(m, EMALLOC));
d410 1
a410 1
			return(verr(m, EMALLOC));
d417 1
a417 1
				return(verr(m, EMALLOC));
d419 1
a419 1
			return(verr(m, EMALLOC));
d443 1
a443 1
			return(verr(m, EUTSNAME));
d445 1
a445 1
			return(verr(m, ETOOLONG));
d447 1
a447 1
			return(verr(m, ETOOLONG));
d449 1
a449 1
			return(verr(m, ETOOLONG));
d453 1
a453 1
		return(verr(m, EMALLOC));
d488 1
a488 1
				if ( ! vwarn(m, ENOWIDTH))
d495 1
a495 1
		return(verr(m, ENUMFMT));
d510 1
a510 1
		return(verr(m, EMALLOC));
d519 1
a519 1
		return(verr(m, EMALLOC));
d521 1
a521 1
		return(verr(m, EMALLOC));
d556 1
a556 1
		return(vwarn(m, ENOWIDTH));
d561 1
a561 1
		return(verr(m, ENUMFMT));
d566 1
a566 1
		return(verr(m, EMALLOC));
d713 1
a713 1
		if ( ! vwarn(m, EBADDATE))
@


1.21
log
@Initial removal of enum mdoc_warn from mdoc warnings (unnecessary complication).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.20 2009/06/25 08:42:06 kristaps Exp $ */
a26 6
enum	mwarn {
	WBADSEC,
	WNOWIDTH,
	WBADDATE
};

d28 3
d45 1
a45 2
static	int	  pwarn(struct mdoc *, int, int, enum mwarn);
static	int	  perr(struct mdoc *, int, int, enum merr);
d67 3
a69 3
#define	vwarn(m, t) pwarn((m), (m)->last->line, (m)->last->pos, (t))
#define	verr(m, t) perr((m), (m)->last->line, (m)->last->pos, (t))
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))
d260 1
a260 1
perr(struct mdoc *m, int line, int pos, enum merr type)
d265 1
d279 1
a279 15
	}
	assert(p);
	return(mdoc_perr(m, line, pos, p));
}


static int
pwarn(struct mdoc *m, int line, int pos, enum mwarn type)
{
	char		*p;

	p = NULL;

	switch (type) {
	case (WBADSEC):
d282 1
a282 1
	case (WNOWIDTH):
d285 1
a285 1
	case (WBADDATE):
d291 3
d379 1
a379 1
			return(vwarn(m, WBADSEC));
d542 1
a542 1
				if ( ! vwarn(m, WNOWIDTH))
d610 1
a610 1
		return(vwarn(m, WNOWIDTH));
d767 1
a767 1
		if ( ! vwarn(m, WBADDATE))
@


1.20
log
@Updating web-page to be a bit more compact.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.19 2009/06/22 12:38:07 kristaps Exp $ */
a291 1
	int		 c;
d294 1
a294 1
	c = WARN_SYNTAX;
a297 1
		c = WARN_COMPAT;
d306 1
d308 1
a308 1
	return(mdoc_pwarn(m, line, pos, c, p));
@


1.19
log
@Noted .Cd tabs-ok issue (will fix later).
Added single space to -diag lists.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.18 2009/06/22 12:04:05 kristaps Exp $ */
d36 1
d276 3
d512 1
a512 1
			return(mdoc_err(m, "utsname"));
@


1.18
log
@Added "Spacing" part of "Punctuation and Spacing" in mandoc.1 manual.
Fixed `Ds' meta-macro default width.
Fixed -width and -offset "indent", "indent-two", and "left" widths.
Fixed -width and -offset literal-word and numeric widths.
Fixed off-by-one errors in whitespace output (schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.17 2009/06/18 20:46:19 kristaps Exp $ */
d92 1
a92 1
	{ NULL, NULL }, /* Cd */
@


1.17
log
@Added nchild decrement in libman (not used, but better in than forgotten).
Added nchild to libmdoc, deprecated count() functions in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.16 2009/06/17 14:14:51 kristaps Exp $ */
d617 1
a617 1
		width = 8;
@


1.16
log
@Clean-up.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.15 2009/06/17 14:10:09 kristaps Exp $ */
d666 3
a668 5
	for (i = 0, nn = m->last->child; nn; nn = nn->next, i++)
		/* Count children. */;

	n->args->argv[c].sz = (size_t)i;
	n->args->argv[c].value = malloc((size_t)i * sizeof(char *));
d678 1
d680 1
@


1.15
log
@Lint fixes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.14 2009/06/17 14:08:47 kristaps Exp $ */
d822 2
a823 3
	if (MDOC_BODY != n->type)
		return(1);
	m->flags |= MDOC_LITERAL;
@


1.14
log
@`Bl -column' now correctly handles tail entries (Bl -column -more... arg0...).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.13 2009/06/17 10:53:32 kristaps Exp $ */
d669 2
a670 2
	n->args->argv[c].sz = i;
	n->args->argv[c].value = malloc(i * sizeof(char *));
@


1.13
log
@Section orders are more elegantly handled (MDOC_PBODY is a flag).
Cleaned up string->enum conversion for section lookup.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.12 2009/06/16 19:45:51 kristaps Exp $ */
d54 1
d638 48
d690 2
@


1.12
log
@Removed MDOC___: moved MDOC_Ap to its index (comments not passed into mdoc parser).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.11 2009/06/12 12:52:51 kristaps Exp $ */
a517 1
	m->lastnamed = m->lastsec = SEC_BODY;
d519 1
@


1.11
log
@Lint fixes (no effect).
Versioning up.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.10 2009/06/12 09:18:00 kristaps Exp $ */
d74 1
a74 1
	{ NULL, NULL }, /* \" */
a180 1
	{ NULL, NULL }, /* Ap */
@


1.10
log
@`Lk' is correctly handled as CALLABLE (note groff munges nested output).
`Mt' is now CALLABLE.
Fixed missing validate/action of zero-element, non-called inline elements.
Fixed missing validate/action of nested inline element re-calls.
Fixed bogus column argv index in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.9 2009/06/10 20:18:43 kristaps Exp $ */
d541 2
a542 1
	if ((n = m->last->body->child)) {
@


1.9
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.8 2009/04/12 19:45:26 kristaps Exp $ */
d59 1
d183 1
a183 1
	{ NULL, NULL }, /* Lk */
d673 21
@


1.8
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: mdoc_action.c,v 1.7 2009/04/06 09:48:35 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.7
log
@Removed forgotten printfs.
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.6 2009/04/06 08:53:12 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.6
log
@Fix bogus use of mdoc->last in action pre-handler (!!!!!).
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.5 2009/04/03 11:08:39 kristaps Exp $ */
a346 2
	printf("bar\n");

a350 2
	printf("foo\n");

a353 2
	printf("baz\n");

@


1.5
log
@Proper resetting of memory.
Array boundary fixed (-W).
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.4 2009/04/02 16:37:40 kristaps Exp $ */
d215 1
a215 1
	if (NULL == mdoc_actions[m->last->tok].pre)
d217 1
a217 1
	return((*mdoc_actions[m->last->tok].pre)(m, n));
d347 2
d352 3
d358 2
@


1.4
log
@Added -p1003.1-2008 specification.
Fixed invalid memory accesses (concat()).
Made -fign-macro be the default for libman.
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.3 2009/04/02 06:51:44 kristaps Exp $ */
d346 2
d371 2
d701 1
@


1.3
log
@mdoc_tokhash -> hash
Initial man hashtab (BROKEN).
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.2 2009/03/31 13:50:19 kristaps Exp $ */
a197 1
extern	size_t	strlcpy(char *, const char *, size_t);
d497 2
d505 1
a505 1
		if (strlcpy(buf, utsname.sysname, 64) >= 64)
@


1.2
log
@General clean-ups.
@
text
@d1 1
a1 1
/* $Id: mdoc_action.c,v 1.1 2009/03/25 15:36:05 kristaps Exp $ */
d612 1
a612 1
	else if (MDOC_MAX == (tok = mdoc_tokhash_find(m->htab, p)))
@


1.1
log
@Added man_action.c, renamed mdoc_action.c.
@
text
@d1 1
a1 1
/* $Id: action.c,v 1.51 2009/03/23 14:31:58 kristaps Exp $ */
a21 1
#include <err.h>
a28 6
/*
 * Actions are executed on macros after they've been post-validated: in
 * other words, a macro will not be "acted upon" until all of its
 * children have been filled in (post-fix order).
 */

d35 6
d50 3
d70 3
a72 1
#define	mwarn(m, t) pwarn((m), (m)->last->line, (m)->last->pos, (t))
d197 6
d209 1
a209 1
		break;
d211 2
a213 4
	default:
		if (NULL == mdoc_actions[m->last->tok].pre)
			break;
		return((*mdoc_actions[m->last->tok].pre)(m, n));
d215 4
a218 1
	return(1);
d232 1
a232 1
		break;
d234 2
a236 4
	default:
		if (NULL == mdoc_actions[m->last->tok].post)
			break;
		return((*mdoc_actions[m->last->tok].post)(m));
d238 22
d265 22
a293 1

a305 1

d329 1
a329 1
		err(1, "calloc");
d332 4
a335 1
	m->last->args->argv[0].value[0] = xstrdup(m->meta.name);
d347 4
a350 3

	(void)xstrlcpys(buf, m->last->child, sizeof(buf));
	m->meta.name = xstrdup(buf);
d370 2
a371 2

	(void)xstrlcpys(buf, m->last->child, sizeof(buf));
d387 1
a387 1
			return(mwarn(m, WBADSEC));
d420 4
a423 2
		m->meta.title = xstrdup("unknown");
		m->meta.vol = xstrdup("local");
d431 2
a432 1
	m->meta.title = xstrdup(n->string);
d435 2
a436 1
		m->meta.vol = xstrdup("local");
d449 2
a450 1
		m->meta.vol = xstrdup(cp);
d455 2
a456 2
	} else 
		m->meta.vol = xstrdup(n->string);
d471 2
a472 1
		m->meta.vol = xstrdup(cp);
d478 4
a481 3
			m->meta.vol = xstrdup(n->string);
		} else
			m->meta.arch = xstrdup(cp);
d498 2
a499 2

	(void)xstrlcpys(buf, m->last->child, sizeof(buf));
d504 6
a509 3
		(void)xstrlcpy(buf, utsname.sysname, sizeof(buf));
		(void)xstrlcat(buf, " ", sizeof(buf));
		(void)xstrlcat(buf, utsname.release, sizeof(buf));
d512 2
a513 1
	m->meta.os = xstrdup(buf);
d547 1
a547 1
				if ( ! mwarn(m, WNOWIDTH))
d553 2
a554 1
	(void)snprintf(buf, sizeof(buf), "%dn", sz);
d563 1
d565 1
a565 2
	sz = (int)(n->args->argc)++;
	n->args->argv = xrealloc(n->args->argv, 
d568 3
d576 1
d578 3
a580 2
		err(1, "calloc");
	n->args->argv[sz].value[0] = xstrdup(buf);
a602 1

d610 1
a610 1
	if (xstrcmp(p, "Ds"))
d615 1
a615 1
		return(mwarn(m, WNOWIDTH));
d619 2
a620 1
	(void)snprintf(buf, sizeof(buf), "%zun", width);
d623 3
a625 1
	m->last->args->argv[i].value[0] = xstrdup(buf);
d696 2
a697 1
	(void)xstrlcpys(buf, m->last->child, sizeof(buf));
d700 1
a700 1
		if ( ! mwarn(m, WBADDATE))
d759 1
a759 6
	/* 
	 * We ONLY enter a literal context if `Bd -literal' or `Bd
	 * -unfilled'.  
	 */

	n = n->parent;
d761 1
a761 1
	for (i = 0; i < (int)n->args->argc; i++)
@
