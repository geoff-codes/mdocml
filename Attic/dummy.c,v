head	1.11;
access;
symbols
	VERSION_1_9_5:1.11
	VERSION_1_8_5:1.11
	VERSION_1_8_1:1.11
	VERSION_1_7_16:1.11
	VERSION_1_7_15:1.11
	OPENBSD_CHECKIN:1.11
	VERSION_1_6_5:1.11
	VERSION_1_5_1:1.11
	VERSION_1_3_15:1.11
	VERSION_1_3_6:1.11
	VERSION_1_2_0:1.11
	VERSION_1_0_2:1.11;
locks; strict;
comment	@ * @;


1.11
date	2008.12.01.15.32.36;	author kristaps;	state dead;
branches;
next	1.10;

1.10
date	2008.11.27.17.27.50;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.27.16.54.58;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.27.14.02.41;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.26.16.50.34;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.25.16.49.57;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.25.12.14.02;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.24.18.32.39;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.24.14.24.55;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.24.08.50.33;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.23.16.53.18;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Considerably improved roff_text parser.
Consolidated noop roff macros.
@
text
@@


1.10
log
@*** empty log message ***
@
text
@a0 251
/* $Id: dummy.c,v 1.9 2008/11/27 16:54:58 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <assert.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "libmdocml.h"
#include "private.h"

#ifdef	__linux__
#define	strlcat		strncat
#endif

static	int		md_dummy_blk_in(const struct md_args *, int);
static	int		md_dummy_blk_out(const struct md_args *, int);
static 	int		md_dummy_text_in(const struct md_args *, int,
				int *, char **);
static	int		md_dummy_text_out(const struct md_args *, int);
static	int		md_dummy_special(int);
static	int		md_dummy_head(void);
static	int		md_dummy_tail(void);
static	void		md_dummy_msg(const struct md_args *, 
				enum roffmsg, const char *,
				const char *, const char *,
				int, char *);

static	void		dbg_prologue(const char *);
static	void		dbg_epilogue(void);

static	int		dbg_lvl = 0;
static	char		dbg_line[72];

struct	md_dummy {
	struct rofftree	*tree;
	struct roffcb	 cb;
};


int
md_line_dummy(void *arg, char *buf, size_t sz)
{
	struct md_dummy	*p;

	p = (struct md_dummy *)arg;
	return(roff_engine(p->tree, buf, sz));
}


int
md_exit_dummy(void *data, int flush)
{
	int		 c;
	struct md_dummy	*p;

	p = (struct md_dummy *)data;
	c = roff_free(p->tree, flush);
	free(p);

	return(c);
}


void *
md_init_dummy(const struct md_args *args,
		struct md_mbuf *mbuf, const struct md_rbuf *rbuf)
{
	struct md_dummy	*p;

	if (NULL == (p = malloc(sizeof(struct md_dummy)))) {
		warn("malloc");
		return(NULL);
	}

	p->cb.roffhead = md_dummy_head;
	p->cb.rofftail = md_dummy_tail;
	p->cb.roffin = md_dummy_text_in;
	p->cb.roffout = md_dummy_text_out;
	p->cb.roffblkin = md_dummy_blk_in;
	p->cb.roffblkout = md_dummy_blk_out;
	p->cb.roffspecial = md_dummy_special;
	p->cb.roffmsg = md_dummy_msg;

	p->tree = roff_alloc(args, mbuf, rbuf, &p->cb);

	if (NULL == p->tree) {
		free(p);
		return(NULL);
	}

	return(p);
}


static void
dbg_prologue(const char *p)
{
	int		 i;

	(void)snprintf(dbg_line, sizeof(dbg_line) - 1, "%6s", p);
	(void)strlcat(dbg_line, ": ", sizeof(dbg_line) - 1);
	/* LINTED */
	for (i = 0; i < dbg_lvl; i++)
		(void)strlcat(dbg_line, "    ", sizeof(dbg_line) - 1);
}


static void
dbg_epilogue(void)
{

	assert(0 != dbg_line[0]);
	(void)printf("%s\n", dbg_line);
}


static int
md_dummy_head(void)
{

	return(1);
}


static int
md_dummy_tail(void)
{

	return(1);
}


static int
md_dummy_special(int tok)
{

	dbg_prologue("noop");
	(void)strlcat(dbg_line, toknames[tok], sizeof(dbg_line) - 1);
	dbg_epilogue();

	return(1);
}


static int
md_dummy_blk_in(const struct md_args *args, int tok)
{

	if (args->verbosity < 1)
		return(1);

	dbg_prologue("blk");
	(void)strlcat(dbg_line, toknames[tok], sizeof(dbg_line) - 1);
	dbg_epilogue();

	dbg_lvl++;
	return(1);
}


static int
md_dummy_blk_out(const struct md_args *args, int tok)
{

	if (args->verbosity < 1)
		return(1);

	dbg_lvl--;
	return(1);
}


static int
md_dummy_text_in(const struct md_args *args, 
		int tok, int *argcp, char **argvp)
{

	if (args->verbosity < 1)
		return(1);

	dbg_prologue("text");
	(void)strlcat(dbg_line, toknames[tok], sizeof(dbg_line) - 1);
	(void)strlcat(dbg_line, " ", sizeof(dbg_line) - 1);
	while (ROFF_ARGMAX != *argcp) {
		(void)strlcat(dbg_line, "[", sizeof(dbg_line) - 1);
		(void)strlcat(dbg_line, tokargnames[*argcp], 
				sizeof(dbg_line) - 1);
		if (*argvp) {
			(void)strlcat(dbg_line, " [", 
					sizeof(dbg_line) - 1);
			(void)strlcat(dbg_line, *argvp,
					sizeof(dbg_line) - 1);
			(void)strlcat(dbg_line, "]", 
					sizeof(dbg_line) - 1);
		}
		(void)strlcat(dbg_line, "]", sizeof(dbg_line) - 1);
		argcp++;
		argvp++;
	}
	dbg_epilogue();
	return(1);
}


static int
md_dummy_text_out(const struct md_args *args, int tok)
{

	return(1);
}


static void
md_dummy_msg(const struct md_args *args, enum roffmsg lvl, 
		const char *buf, const char *pos, 
		const char *name, int line, char *msg)
{
	char		*p;

	switch (lvl) {
	case (ROFF_WARN):
		if ( ! (MD_WARN_ALL & args->warnings))
			return;
		p = "warning";
		break;
	case (ROFF_ERROR):
		p = "error";
		break;
	}

	assert(pos >= buf);
	(void)fprintf(stderr, "%s:%d: %s: %s\n", name, line, p, msg);
}

@


1.9
log
@Considerable fixes.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.8 2008/11/27 14:02:41 kristaps Exp $ */
d32 5
a36 4
static	int		md_dummy_blk_in(int);
static	int		md_dummy_blk_out(int);
static 	int		md_dummy_text_in(int, int *, char **);
static	int		md_dummy_text_out(int);
d163 1
a163 1
md_dummy_blk_in(int tok)
d166 3
d179 1
a179 1
md_dummy_blk_out(int tok)
d182 3
a189 1
/* ARGSUSED */
d191 2
a192 1
md_dummy_text_in(int tok, int *argcp, char **argvp)
d195 3
d223 1
a223 1
md_dummy_text_out(int tok)
d239 2
d251 1
@


1.8
log
@Added "special" macros.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.7 2008/11/26 16:50:34 kristaps Exp $ */
d39 4
d98 1
d218 21
@


1.7
log
@Added regression tests.
Considerable fixes... blah blah blah...
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.6 2008/11/25 16:49:57 kristaps Exp $ */
d36 3
d51 55
d129 28
a212 53


int
md_line_dummy(void *arg, char *buf, size_t sz)
{
	struct md_dummy	*p;

	p = (struct md_dummy *)arg;
	return(roff_engine(p->tree, buf, sz));
}


int
md_exit_dummy(void *data, int flush)
{
	int		 c;
	struct md_dummy	*p;

	p = (struct md_dummy *)data;
	c = roff_free(p->tree, flush);
	free(p);

	return(c);
}


void *
md_init_dummy(const struct md_args *args,
		struct md_mbuf *mbuf, const struct md_rbuf *rbuf)
{
	struct md_dummy	*p;

	if (NULL == (p = malloc(sizeof(struct md_dummy)))) {
		warn("malloc");
		return(NULL);
	}

	p->cb.roffhead = NULL;
	p->cb.rofftail = NULL;
	p->cb.roffin = md_dummy_text_in;
	p->cb.roffout = md_dummy_text_out;
	p->cb.roffblkin = md_dummy_blk_in;
	p->cb.roffblkout = md_dummy_blk_out;

	p->tree = roff_alloc(args, mbuf, rbuf, &p->cb);

	if (NULL == p->tree) {
		free(p);
		return(NULL);
	}

	return(p);
}
@


1.6
log
@Imported all macros from mdoc(7).
Put all names into roff.c with extern access from private.h.
Annotated list of changes that must occur for end-game (scope, nests, etc.).
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.5 2008/11/25 12:14:02 kristaps Exp $ */
d45 1
d164 8
a171 3
	p->tree = roff_alloc(args, mbuf, rbuf, 
			md_dummy_text_in, md_dummy_text_out, 
			md_dummy_blk_in, md_dummy_blk_out);
@


1.5
log
@Single call-back for filters.
Removed verbose flag.
Added more macros and arguments.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.4 2008/11/24 18:32:39 kristaps Exp $ */
d28 1
a28 1
#ifdef	__Linux__
d37 2
a38 1
static	void		dbg_indent(void);
d41 1
a46 3
static	const char *const toknames[ROFF_MAX] = ROFF_NAMES;


d48 1
a48 1
dbg_indent(void)
d50 1
a50 5
	char		buf[128];
	int		i;

	*buf = 0;
	assert(dbg_lvl >= 0);
d52 2
d56 3
a58 1
		(void)strlcat(buf, "  ", sizeof(buf) - 1);
d60 6
a65 1
	(void)printf("%s", buf);
d73 4
a76 2
	dbg_indent();
	(void)printf("%s\n", toknames[tok]);
a85 1
	assert(dbg_lvl > 0);
a86 2
	dbg_indent();
	(void)printf("%s\n", toknames[tok]);
d96 20
a115 2
	dbg_indent();
	(void)printf("%s\n", toknames[tok]);
a123 2
	dbg_indent();
	(void)printf("%s\n", toknames[tok]);
@


1.4
log
@Generic roff_layout for layout tokens.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.3 2008/11/24 14:24:55 kristaps Exp $ */
d28 8
d37 1
a37 9
static roffin		in[ROFF_MAX];
static roffout		out[ROFF_MAX];
static roffblkin	blkin[ROFF_MAX];
static roffblkout	blkout[ROFF_MAX];

static int		md_dummy_blk_in(int);
static int		md_dummy_blk_out(int);
static int		md_dummy_text_in(int, int *, char **);
static int		md_dummy_text_out(int);
d39 1
a39 3
static void		dbg_indent(void);

static int		dbg_lvl = 0;
d45 2
d56 2
d59 1
a59 1
		(void)strncat(buf, "  ", sizeof(buf) - 1);
d70 1
a70 1
	(void)printf("+++blk\n");
d83 1
a83 1
	(void)printf("---blk\n");
d88 1
d94 1
a94 1
	(void)printf("in: text\n");
d104 1
a104 1
	(void)printf("out: text\n");
a137 8
	int		 i;

	for (i = 0; i < ROFF_MAX; i++) {
		in[i] = md_dummy_text_in;
		out[i] = md_dummy_text_out;
		blkin[i] = md_dummy_blk_in;
		blkout[i] = md_dummy_blk_out;
	}
d144 3
a146 2
	p->tree = roff_alloc
		(args, mbuf, rbuf, in, out, blkin, blkout);
@


1.3
log
@Split roff engine into roff.c.
Re-worked calling convention for md_*.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.2 2008/11/24 08:50:33 kristaps Exp $ */
d21 1
d23 1
d29 14
d48 58
d135 8
d149 4
a152 1
	if (NULL == (p->tree = roff_alloc(args, mbuf, rbuf))) {
@


1.2
log
@Roff-line tokens parsed into char**.
@
text
@d1 1
a1 1
/* $Id: dummy.c,v 1.1 2008/11/23 16:53:18 kristaps Exp $ */
d20 1
d27 15
d43 16
a58 3
md_line_dummy(const struct md_args *args, 
		struct md_mbuf *out, const struct md_rbuf *in, 
		char *buf, size_t sz, void *data)
d60 1
d62 9
a70 10
	assert(buf);
	assert(out);
	assert(in);
	assert(args);
	assert(NULL == data);

	if ( ! md_buf_puts(out, buf, sz))
		return(0);
	if ( ! md_buf_putchar(out, '\n'))
		return(0);
d72 1
a72 1
	return(1);
@


1.1
log
@Segmentation into html and dummy parsers.
Initial recursive-descent parser in place for html/ml parser.
Parsing of title tags more-or-less in place.
@
text
@d1 1
a1 1
/* $Id: libmdocml.c,v 1.4 2008/11/23 11:05:25 kristaps Exp $ */
d29 1
a29 1
		const char *buf, size_t sz, void *data)
@
