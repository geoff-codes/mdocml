head	1.22;
access;
symbols
	VERSION_1_11_4:1.20
	VERSION_1_11_3:1.2
	VERSION_1_11_2:1.1;
locks; strict;
comment	@ * @;


1.22
date	2011.07.14.17.32.53;	author kristaps;	state dead;
branches;
next	1.21;

1.21
date	2011.07.12.15.26.35;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.12.10.03.02;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2011.07.11.21.56.06;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.11.09.36.15;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.10.13.03.31;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.01.13.46.39;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.01.12.02.44;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.01.10.46.32;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.01.10.17.24;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.01.09.11.35;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2011.06.25.13.19.25;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.22.10.36.36;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.22.09.10.36;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.22.09.00.14;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.21.23.37.27;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.21.14.16.05;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.21.13.54.05;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.21.13.13.15;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.21.13.05.14;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.15.02.47.17;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.13.00.42.26;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Apparently these weren't removed properly...
@
text
@@


1.21
log
@Re-ordered logic in makewhatis to iterate over the index file only once.
This is much more efficient.
@
text
@a0 1105
/*	$Id: makewhatis.c,v 1.20 2011/07/12 10:03:02 kristaps Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <sys/param.h>

#include <assert.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#ifdef __linux__
# include <db_185.h>
#else
# include <db.h>
#endif

#include "man.h"
#include "mdoc.h"
#include "mandoc.h"

#define	MANDOC_DB	 "mandoc.db"
#define	MANDOC_IDX	 "mandoc.index"
#define	MANDOC_BUFSZ	  BUFSIZ
#define	MANDOC_FLAGS	  O_CREAT|O_TRUNC|O_RDWR
#define	MANDOC_SLOP	  1024

/* Bit-fields.  See makewhatis.1. */

#define TYPE_NAME	  0x01
#define TYPE_FUNCTION	  0x02
#define TYPE_UTILITY	  0x04
#define TYPE_INCLUDES	  0x08
#define TYPE_VARIABLE	  0x10
#define TYPE_STANDARD	  0x20
#define TYPE_AUTHOR	  0x40
#define TYPE_CONFIG	  0x80
#define TYPE_DESC	  0x100
#define TYPE_XREF	  0x200
#define TYPE_PATH	  0x400
#define TYPE_ENV	  0x800
#define TYPE_ERR	  0x1000

/* Buffer for storing growable data. */

struct	buf {
	char		 *cp;
	size_t		  len;
	size_t		  size;
};

/* Operation we're going to perform. */

enum	op {
	OP_NEW = 0, /* new database */
	OP_UPDATE, /* update entries in existing database */
	OP_DELETE /* delete entries from existing database */
};

#define	MAN_ARGS	  DB *hash, \
			  struct buf *buf, \
			  struct buf *dbuf, \
			  const struct man_node *n
#define	MDOC_ARGS	  DB *hash, \
			  struct buf *buf, \
			  struct buf *dbuf, \
			  const struct mdoc_node *n, \
			  const struct mdoc_meta *m

static	void		  buf_appendmdoc(struct buf *, 
				const struct mdoc_node *, int);
static	void		  buf_append(struct buf *, const char *);
static	void		  buf_appendb(struct buf *, 
				const void *, size_t);
static	void		  dbt_put(DB *, const char *, DBT *, DBT *);
static	void		  hash_put(DB *, const struct buf *, int);
static	void		  hash_reset(DB **);
static	int		  pman_node(MAN_ARGS);
static	void		  pmdoc_node(MDOC_ARGS);
static	void		  pmdoc_An(MDOC_ARGS);
static	void		  pmdoc_Cd(MDOC_ARGS);
static	void		  pmdoc_Er(MDOC_ARGS);
static	void		  pmdoc_Ev(MDOC_ARGS);
static	void		  pmdoc_Fd(MDOC_ARGS);
static	void		  pmdoc_In(MDOC_ARGS);
static	void		  pmdoc_Fn(MDOC_ARGS);
static	void		  pmdoc_Fo(MDOC_ARGS);
static	void		  pmdoc_Nd(MDOC_ARGS);
static	void		  pmdoc_Nm(MDOC_ARGS);
static	void		  pmdoc_Pa(MDOC_ARGS);
static	void		  pmdoc_St(MDOC_ARGS);
static	void		  pmdoc_Vt(MDOC_ARGS);
static	void		  pmdoc_Xr(MDOC_ARGS);
static	void		  usage(void);

typedef	void		(*pmdoc_nf)(MDOC_ARGS);

static	const pmdoc_nf	  mdocs[MDOC_MAX] = {
	NULL, /* Ap */
	NULL, /* Dd */
	NULL, /* Dt */
	NULL, /* Os */
	NULL, /* Sh */ 
	NULL, /* Ss */ 
	NULL, /* Pp */ 
	NULL, /* D1 */
	NULL, /* Dl */
	NULL, /* Bd */
	NULL, /* Ed */
	NULL, /* Bl */ 
	NULL, /* El */
	NULL, /* It */
	NULL, /* Ad */ 
	pmdoc_An, /* An */ 
	NULL, /* Ar */
	pmdoc_Cd, /* Cd */ 
	NULL, /* Cm */
	NULL, /* Dv */ 
	pmdoc_Er, /* Er */ 
	pmdoc_Ev, /* Ev */ 
	NULL, /* Ex */ 
	NULL, /* Fa */ 
	pmdoc_Fd, /* Fd */
	NULL, /* Fl */
	pmdoc_Fn, /* Fn */ 
	NULL, /* Ft */ 
	NULL, /* Ic */ 
	pmdoc_In, /* In */ 
	NULL, /* Li */
	pmdoc_Nd, /* Nd */
	pmdoc_Nm, /* Nm */
	NULL, /* Op */
	NULL, /* Ot */
	pmdoc_Pa, /* Pa */
	NULL, /* Rv */
	pmdoc_St, /* St */ 
	pmdoc_Vt, /* Va */
	pmdoc_Vt, /* Vt */ 
	pmdoc_Xr, /* Xr */ 
	NULL, /* %A */
	NULL, /* %B */
	NULL, /* %D */
	NULL, /* %I */
	NULL, /* %J */
	NULL, /* %N */
	NULL, /* %O */
	NULL, /* %P */
	NULL, /* %R */
	NULL, /* %T */
	NULL, /* %V */
	NULL, /* Ac */
	NULL, /* Ao */
	NULL, /* Aq */
	NULL, /* At */ 
	NULL, /* Bc */
	NULL, /* Bf */
	NULL, /* Bo */
	NULL, /* Bq */
	NULL, /* Bsx */
	NULL, /* Bx */
	NULL, /* Db */
	NULL, /* Dc */
	NULL, /* Do */
	NULL, /* Dq */
	NULL, /* Ec */
	NULL, /* Ef */ 
	NULL, /* Em */ 
	NULL, /* Eo */
	NULL, /* Fx */
	NULL, /* Ms */ 
	NULL, /* No */
	NULL, /* Ns */
	NULL, /* Nx */
	NULL, /* Ox */
	NULL, /* Pc */
	NULL, /* Pf */
	NULL, /* Po */
	NULL, /* Pq */
	NULL, /* Qc */
	NULL, /* Ql */
	NULL, /* Qo */
	NULL, /* Qq */
	NULL, /* Re */
	NULL, /* Rs */
	NULL, /* Sc */
	NULL, /* So */
	NULL, /* Sq */
	NULL, /* Sm */ 
	NULL, /* Sx */
	NULL, /* Sy */
	NULL, /* Tn */
	NULL, /* Ux */
	NULL, /* Xc */
	NULL, /* Xo */
	pmdoc_Fo, /* Fo */ 
	NULL, /* Fc */ 
	NULL, /* Oo */
	NULL, /* Oc */
	NULL, /* Bk */
	NULL, /* Ek */
	NULL, /* Bt */
	NULL, /* Hf */
	NULL, /* Fr */
	NULL, /* Ud */
	NULL, /* Lb */
	NULL, /* Lp */ 
	NULL, /* Lk */ 
	NULL, /* Mt */ 
	NULL, /* Brq */ 
	NULL, /* Bro */ 
	NULL, /* Brc */ 
	NULL, /* %C */
	NULL, /* Es */
	NULL, /* En */
	NULL, /* Dx */
	NULL, /* %Q */
	NULL, /* br */
	NULL, /* sp */
	NULL, /* %U */
	NULL, /* Ta */
};

static	const char	 *progname;

int
main(int argc, char *argv[])
{
	struct mparse	*mp; /* parse sequence */
	struct mdoc	*mdoc; /* resulting mdoc */
	struct man	*man; /* resulting man */
	enum op		 op; /* current operation */
	char		*fn; /* current file being parsed */
	const char	*msec, /* manual section */
	      	 	*mtitle, /* manual title */
			*arch, /* manual architecture */
	      		*dir; /* result dir (default: cwd) */
	char		 ibuf[MAXPATHLEN], /* index fname */
			 fbuf[MAXPATHLEN],  /* btree fname */
			 vbuf[8]; /* stringified record number */
	int		 ch, seq, sseq, verb, i;
	DB		*idx, /* index database */
			*db, /* keyword database */
			*hash; /* temporary keyword hashtable */
	DBT		 key, val;
	enum mandoclevel ec; /* exit status */
	size_t		 sv;
	BTREEINFO	 info; /* btree configuration */
	recno_t		 rec,
			 maxrec; /* supremum of all records */
	recno_t		*recs; /* buffer of empty records */
	size_t		 recsz, /* buffer size of recs */
			 reccur; /* valid number of recs */
	struct buf	 buf, /* keyword buffer */
			 dbuf; /* description buffer */
	extern int	 optind;
	extern char	*optarg;

	progname = strrchr(argv[0], '/');
	if (progname == NULL)
		progname = argv[0];
	else
		++progname;

	dir = "";
	verb = 0;
	db = idx = NULL;
	mp = NULL;
	hash = NULL;
	recs = NULL;
	recsz = reccur = 0;
	maxrec = 0;
	op = OP_NEW;
	ec = MANDOCLEVEL_SYSERR;

	memset(&buf, 0, sizeof(struct buf));
	memset(&dbuf, 0, sizeof(struct buf));

	while (-1 != (ch = getopt(argc, argv, "d:ruv")))
		switch (ch) {
		case ('d'):
			dir = optarg;
			break;
		case ('r'):
			op = OP_DELETE;
			break;
		case ('u'):
			op = OP_UPDATE;
			break;
		case ('v'):
			verb++;
			break;
		default:
			usage();
			return((int)MANDOCLEVEL_BADARG);
		}

	argc -= optind;
	argv += optind;

	ibuf[0] = ibuf[MAXPATHLEN - 2] =
		fbuf[0] = fbuf[MAXPATHLEN - 2] = '\0';

	strlcat(fbuf, dir, MAXPATHLEN);
	strlcat(fbuf, MANDOC_DB, MAXPATHLEN);

	strlcat(ibuf, dir, MAXPATHLEN);
	strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);

	if ('\0' != fbuf[MAXPATHLEN - 2] ||
			'\0' != ibuf[MAXPATHLEN - 2]) {
		fprintf(stderr, "%s: Path too long\n", dir);
		goto out;
	}

	/*
	 * For the keyword database, open a BTREE database that allows
	 * duplicates.  
	 * For the index database, use a standard RECNO database type.
	 * Truncate the database if we're creating a new one.
	 */

	memset(&info, 0, sizeof(BTREEINFO));
	info.flags = R_DUP;

	if (OP_NEW == op) {
		db = dbopen(fbuf, MANDOC_FLAGS, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);
	} else {
		db = dbopen(fbuf, O_CREAT|O_RDWR, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, O_CREAT|O_RDWR, 0644, DB_RECNO, NULL);
	}

	if (NULL == db) {
		perror(fbuf);
		goto out;
	} else if (NULL == db) {
		perror(ibuf);
		goto out;
	}

	/*
	 * If we're going to delete or update a database, remove the
	 * entries now (both the index and all keywords pointing to it).
	 * This doesn't actually remove them: it only sets their record
	 * value lengths to zero.
	 * While doing so, add the empty records to a list we'll access
	 * later in re-adding entries to the database.
	 */

	if (OP_DELETE == op || OP_UPDATE == op) {
		seq = R_FIRST;
		while (0 == (ch = (*idx->seq)(idx, &key, &val, seq))) {
			seq = R_NEXT;
			maxrec = *(recno_t *)key.data;
			if (0 == val.size && OP_UPDATE == op) {
				if (reccur >= recsz) {
					recsz += MANDOC_SLOP;
					recs = mandoc_realloc
						(recs, recsz * sizeof(recno_t));
				}
				recs[(int)reccur] = maxrec;
				reccur++;
				continue;
			}

			fn = (char *)val.data;
			for (i = 0; i < argc; i++)
				if (0 == strcmp(fn, argv[i]))
					break;

			if (i == argc)
				continue;

			sseq = R_FIRST;
			while (0 == (ch = (*db->seq)(db, &key, &val, sseq))) {
				sseq = R_NEXT;
				assert(8 == val.size);
				if (maxrec != *(recno_t *)(val.data + 4))
					continue;
				if (verb > 1)
					printf("%s: Deleted keyword: %s\n", 
						fn, (char *)key.data);
				ch = (*db->del)(db, &key, R_CURSOR);
				if (ch < 0)
					break;
			}
			if (ch < 0) {
				perror(fbuf);
				exit((int)MANDOCLEVEL_SYSERR);
			}

			if (verb)
				printf("%s: Deleted index\n", fn);

			val.size = 0;
			ch = (*idx->put)(idx, &key, &val, R_CURSOR);
			if (ch < 0) {
				perror(ibuf);
				exit((int)MANDOCLEVEL_SYSERR);
			}

			if (OP_UPDATE == op) {
				if (reccur >= recsz) {
					recsz += MANDOC_SLOP;
					recs = mandoc_realloc
						(recs, recsz * sizeof(recno_t));
				}
				recs[(int)reccur] = maxrec;
				reccur++;
			}
		}
		maxrec++;
	}

	if (OP_DELETE == op) {
		ec = MANDOCLEVEL_OK;
		goto out;
	}

	/*
	 * Add records to the database.
	 * Try parsing each manual given on the command line.  
	 * If we fail, then emit an error and keep on going.  
	 * Take resulting trees and push them down into the database code.
	 * Use the auto-parser and don't report any errors.
	 */

	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);

	buf.size = dbuf.size = MANDOC_BUFSZ;
	buf.cp = mandoc_malloc(buf.size);
	dbuf.cp = mandoc_malloc(dbuf.size);

	for (rec = 0, i = 0; i < argc; i++) {
		fn = argv[i];
		if (OP_UPDATE == op) {
			if (reccur > 0) {
				--reccur;
				rec = recs[(int)reccur];
			} else if (maxrec > 0) {
				rec = maxrec;
				maxrec = 0;
			} else
				rec++;
		} else
			rec++;

		mparse_reset(mp);
		hash_reset(&hash);

		if (mparse_readfd(mp, -1, fn) >= MANDOCLEVEL_FATAL) {
			fprintf(stderr, "%s: Parse failure\n", fn);
			continue;
		}

		mparse_result(mp, &mdoc, &man);
		if (NULL == mdoc && NULL == man)
			continue;

		msec = NULL != mdoc ? 
			mdoc_meta(mdoc)->msec : man_meta(man)->msec;
		mtitle = NULL != mdoc ? 
			mdoc_meta(mdoc)->title : man_meta(man)->title;
		arch = NULL != mdoc ? mdoc_meta(mdoc)->arch : NULL;

		if (NULL == arch)
			arch = "";

		/* 
		 * The index record value consists of a nil-terminated
		 * filename, a nil-terminated manual section, and a
		 * nil-terminated description.  Since the description
		 * may not be set, we set a sentinel to see if we're
		 * going to write a nil byte in its place.
		 */

		dbuf.len = 0;
		buf_appendb(&dbuf, fn, strlen(fn) + 1);
		buf_appendb(&dbuf, msec, strlen(msec) + 1);
		buf_appendb(&dbuf, mtitle, strlen(mtitle) + 1);
		buf_appendb(&dbuf, arch, strlen(arch) + 1);

		sv = dbuf.len;

		/* Fix the record number in the btree value. */

		if (mdoc)
			pmdoc_node(hash, &buf, &dbuf,
				mdoc_node(mdoc), mdoc_meta(mdoc));
		else 
			pman_node(hash, &buf, &dbuf, man_node(man));

		/*
		 * Copy from the in-memory hashtable of pending keywords
		 * into the database.
		 */
		
		memset(vbuf, 0, sizeof(uint32_t));
		memcpy(vbuf + 4, &rec, sizeof(uint32_t));

		seq = R_FIRST;
		while (0 == (ch = (*hash->seq)(hash, &key, &val, seq))) {
			seq = R_NEXT;

			memcpy(vbuf, val.data, sizeof(uint32_t));
			val.size = sizeof(vbuf);
			val.data = vbuf;

			if (verb > 1)
				printf("%s: Added keyword: %s, 0x%x\n", 
					fn, (char *)key.data, 
					*(int *)val.data);
			dbt_put(db, fbuf, &key, &val);
		}
		if (ch < 0) {
			perror("hash");
			exit((int)MANDOCLEVEL_SYSERR);
		}
		
		/*
		 * Apply to the index.  If we haven't had a description
		 * set, put an empty one in now.
		 */

		if (dbuf.len == sv)
			buf_appendb(&dbuf, "", 1);

		key.data = &rec;
		key.size = sizeof(recno_t);

		val.data = dbuf.cp;
		val.size = dbuf.len;

		if (verb > 0)
			printf("%s: Added index\n", fn);

		dbt_put(idx, ibuf, &key, &val);
	}

	ec = MANDOCLEVEL_OK;
out:
	if (db)
		(*db->close)(db);
	if (idx)
		(*idx->close)(idx);
	if (hash)
		(*hash->close)(hash);
	if (mp)
		mparse_free(mp);

	free(buf.cp);
	free(dbuf.cp);
	free(recs);

	return((int)ec);
}

/*
 * Grow the buffer (if necessary) and copy in a binary string.
 */
static void
buf_appendb(struct buf *buf, const void *cp, size_t sz)
{

	/* Overshoot by MANDOC_BUFSZ. */

	while (buf->len + sz >= buf->size) {
		buf->size = buf->len + sz + MANDOC_BUFSZ;
		buf->cp = mandoc_realloc(buf->cp, buf->size);
	}

	memcpy(buf->cp + (int)buf->len, cp, sz);
	buf->len += sz;
}

/*
 * Append a nil-terminated string to the buffer.  
 * This can be invoked multiple times.  
 * The buffer string will be nil-terminated.
 * If invoked multiple times, a space is put between strings.
 */
static void
buf_append(struct buf *buf, const char *cp)
{
	size_t		 sz;

	if (0 == (sz = strlen(cp)))
		return;

	if (buf->len)
		buf->cp[(int)buf->len - 1] = ' ';

	buf_appendb(buf, cp, sz + 1);
}

/*
 * Recursively add all text from a given node.  
 * This is optimised for general mdoc nodes in this context, which do
 * not consist of subexpressions and having a recursive call for n->next
 * would be wasteful.
 * The "f" variable should be 0 unless called from pmdoc_Nd for the
 * description buffer, which does not start at the beginning of the
 * buffer.
 */
static void
buf_appendmdoc(struct buf *buf, const struct mdoc_node *n, int f)
{

	for ( ; n; n = n->next) {
		if (n->child)
			buf_appendmdoc(buf, n->child, f);

		if (MDOC_TEXT == n->type && f) {
			f = 0;
			buf_appendb(buf, n->string, 
					strlen(n->string) + 1);
		} else if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);

	}
}

/* ARGSUSED */
static void
pmdoc_An(MDOC_ARGS)
{
	
	if (SEC_AUTHORS != n->sec)
		return;

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_AUTHOR);
}

static void
hash_reset(DB **db)
{
	DB		*hash;

	if (NULL != (hash = *db))
		(*hash->close)(hash);

	*db = dbopen(NULL, MANDOC_FLAGS, 0644, DB_HASH, NULL);
	if (NULL == *db) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	}
}

/* ARGSUSED */
static void
pmdoc_Fd(MDOC_ARGS)
{
	const char	*start, *end;
	size_t		 sz;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == (n = n->child) || MDOC_TEXT != n->type)
		return;

	/*
	 * Only consider those `Fd' macro fields that begin with an
	 * "inclusion" token (versus, e.g., #define).
	 */
	if (strcmp("#include", n->string))
		return;

	if (NULL == (n = n->next) || MDOC_TEXT != n->type)
		return;

	/*
	 * Strip away the enclosing angle brackets and make sure we're
	 * not zero-length.
	 */

	start = n->string;
	if ('<' == *start || '"' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return;

	end = &start[(int)sz - 1];
	if ('>' == *end || '"' == *end)
		end--;

	assert(end >= start);

	buf_appendb(buf, start, (size_t)(end - start + 1));
	buf_appendb(buf, "", 1);

	hash_put(hash, buf, TYPE_INCLUDES);
}

/* ARGSUSED */
static void
pmdoc_Cd(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec)
		return;

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_CONFIG);
}

/* ARGSUSED */
static void
pmdoc_In(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	buf_append(buf, n->child->string);
	hash_put(hash, buf, TYPE_INCLUDES);
}

/* ARGSUSED */
static void
pmdoc_Fn(MDOC_ARGS)
{
	const char	*cp;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	/* .Fn "struct type *arg" "foo" */

	cp = strrchr(n->child->string, ' ');
	if (NULL == cp)
		cp = n->child->string;

	/* Strip away pointer symbol. */

	while ('*' == *cp)
		cp++;

	buf_append(buf, cp);
	hash_put(hash, buf, TYPE_FUNCTION);
}

/* ARGSUSED */
static void
pmdoc_St(MDOC_ARGS)
{
	
	if (SEC_STANDARDS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	buf_append(buf, n->child->string);
	hash_put(hash, buf, TYPE_STANDARD);
}

/* ARGSUSED */
static void
pmdoc_Xr(MDOC_ARGS)
{

	if (NULL == (n = n->child))
		return;

	buf_appendb(buf, n->string, strlen(n->string));

	if (NULL != (n = n->next)) {
		buf_appendb(buf, ".", 1);
		buf_appendb(buf, n->string, strlen(n->string) + 1);
	} else
		buf_appendb(buf, ".", 2);

	hash_put(hash, buf, TYPE_XREF);
}

/* ARGSUSED */
static void
pmdoc_Vt(MDOC_ARGS)
{
	const char	*start;
	size_t		 sz;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (MDOC_Vt == n->tok && MDOC_BODY != n->type)
		return;
	if (NULL == n->last || MDOC_TEXT != n->last->type)
		return;

	/*
	 * Strip away leading pointer symbol '*' and trailing ';'.
	 */

	start = n->last->string;

	while ('*' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return;

	if (';' == start[(int)sz - 1])
		sz--;

	if (0 == sz)
		return;

	buf_appendb(buf, start, sz);
	buf_appendb(buf, "", 1);
	hash_put(hash, buf, TYPE_VARIABLE);
}

/* ARGSUSED */
static void
pmdoc_Fo(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	buf_append(buf, n->child->string);
	hash_put(hash, buf, TYPE_FUNCTION);
}


/* ARGSUSED */
static void
pmdoc_Nd(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;

	buf_appendmdoc(dbuf, n->child, 1);
	buf_appendmdoc(buf, n->child, 0);

	hash_put(hash, buf, TYPE_DESC);
}

/* ARGSUSED */
static void
pmdoc_Er(MDOC_ARGS)
{

	if (SEC_ERRORS != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_ERR);
}

/* ARGSUSED */
static void
pmdoc_Ev(MDOC_ARGS)
{

	if (SEC_ENVIRONMENT != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_ENV);
}

/* ARGSUSED */
static void
pmdoc_Pa(MDOC_ARGS)
{

	if (SEC_FILES != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_PATH);
}

/* ARGSUSED */
static void
pmdoc_Nm(MDOC_ARGS)
{
	
	if (SEC_NAME == n->sec) {
		buf_appendmdoc(buf, n->child, 0);
		hash_put(hash, buf, TYPE_NAME);
		return;
	} else if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;

	if (NULL == n->child)
		buf_append(buf, m->name);

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_UTILITY);
}

static void
hash_put(DB *db, const struct buf *buf, int mask)
{
	DBT		 key, val;
	int		 rc;

	if (buf->len < 2)
		return;

	key.data = buf->cp;
	key.size = buf->len;

	if ((rc = (*db->get)(db, &key, &val, 0)) < 0) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	} else if (0 == rc)
		mask |= *(int *)val.data;

	val.data = &mask;
	val.size = sizeof(int); 

	if ((rc = (*db->put)(db, &key, &val, 0)) < 0) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	} 
}

static void
dbt_put(DB *db, const char *dbn, DBT *key, DBT *val)
{

	assert(key->size);
	assert(val->size);

	if (0 == (*db->put)(db, key, val, 0))
		return;
	
	perror(dbn);
	exit((int)MANDOCLEVEL_SYSERR);
	/* NOTREACHED */
}

/*
 * Call out to per-macro handlers after clearing the persistent database
 * key.  If the macro sets the database key, flush it to the database.
 */
static void
pmdoc_node(MDOC_ARGS)
{

	if (NULL == n)
		return;

	switch (n->type) {
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		/* FALLTHROUGH */
	case (MDOC_BLOCK):
		/* FALLTHROUGH */
	case (MDOC_ELEM):
		if (NULL == mdocs[n->tok])
			break;

		buf->len = 0;
		(*mdocs[n->tok])(hash, buf, dbuf, n, m);
		break;
	default:
		break;
	}

	pmdoc_node(hash, buf, dbuf, n->child, m);
	pmdoc_node(hash, buf, dbuf, n->next, m);
}

static int
pman_node(MAN_ARGS)
{
	const struct man_node *head, *body;
	const char	*start, *sv;
	size_t		 sz;

	if (NULL == n)
		return(0);

	/*
	 * We're only searching for one thing: the first text child in
	 * the BODY of a NAME section.  Since we don't keep track of
	 * sections in -man, run some hoops to find out whether we're in
	 * the correct section or not.
	 */

	if (MAN_BODY == n->type && MAN_SH == n->tok) {
		body = n;
		assert(body->parent);
		if (NULL != (head = body->parent->head) &&
				1 == head->nchild &&
				NULL != (head = (head->child)) &&
				MAN_TEXT == head->type &&
				0 == strcmp(head->string, "NAME") &&
				NULL != (body = body->child) &&
				MAN_TEXT == body->type) {

			assert(body->string);
			start = sv = body->string;

			/* 
			 * Go through a special heuristic dance here.
			 * This is why -man manuals are great!
			 * (I'm being sarcastic: my eyes are bleeding.)
			 * Conventionally, one or more manual names are
			 * comma-specified prior to a whitespace, then a
			 * dash, then a description.  Try to puzzle out
			 * the name parts here.
			 */

			for ( ;; ) {
				sz = strcspn(start, " ,");
				if ('\0' == start[(int)sz])
					break;

				buf->len = 0;
				buf_appendb(buf, start, sz);
				buf_appendb(buf, "", 1);

				hash_put(hash, buf, TYPE_NAME);

				if (' ' == start[(int)sz]) {
					start += (int)sz + 1;
					break;
				}

				assert(',' == start[(int)sz]);
				start += (int)sz + 1;
				while (' ' == *start)
					start++;
			}

			buf->len = 0;

			if (sv == start) {
				buf_append(buf, start);
				return(1);
			}

			while (' ' == *start)
				start++;

			if (0 == strncmp(start, "-", 1))
				start += 1;
			else if (0 == strncmp(start, "\\-", 2))
				start += 2;
			else if (0 == strncmp(start, "\\(en", 4))
				start += 4;
			else if (0 == strncmp(start, "\\(em", 4))
				start += 4;

			while (' ' == *start)
				start++;

			sz = strlen(start) + 1;
			buf_appendb(dbuf, start, sz);
			buf_appendb(buf, start, sz);

			hash_put(hash, buf, TYPE_DESC);
		}
	}

	if (pman_node(hash, buf, dbuf, n->child))
		return(1);
	if (pman_node(hash, buf, dbuf, n->next))
		return(1);

	return(0);
}

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-ruv] [-d path] [file...]\n", 
			progname);
}
@


1.20
log
@Fixed some uninitialised values found during lint check.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.19 2011/07/11 21:56:06 kristaps Exp $ */
d45 1
a96 2
static	void		  op_delete(const char *, int, DB *, 
				const char *, DB *, const char *);
d250 1
a250 1
	enum op		 op;
d259 1
a259 1
	int		 ch, seq, verb, i;
d264 1
a264 1
	enum mandoclevel ec;
d267 5
a271 4
	recno_t		 rec, /* current record number */
			 maxrec;
	recno_t		*recs;
	size_t		 recsz;
d289 1
a289 1
	recsz = 0;
d362 5
a366 2
	 * entries now.  This doesn't actually remove them; it only sets
	 * their record value lengths to zero.
d369 1
a369 16
	if (OP_DELETE == op || OP_UPDATE == op)
		for (i = 0; i < argc; i++)
			op_delete(argv[i], verb, idx, ibuf, db, fbuf);

	if (OP_DELETE == op) {
		ec = MANDOCLEVEL_OK;
		goto out;
	}

	/*
	 * Compile a list of all available "empty" records to use.  This
	 * keeps the size of the database small.
	 */

	if (OP_UPDATE == op) {
		i = 0;
d374 17
a390 1
			if (val.size > 0)
d392 37
a428 4
			if ((size_t)i >= recsz) {
				recsz += 1024;
				recs = mandoc_realloc
					(recs, recsz * sizeof(recno_t));
a429 1
			recs[i++] = maxrec;
a430 5
		if (ch < 0) {
			perror(ibuf);
			exit((int)MANDOCLEVEL_SYSERR);
		}
		recsz = (size_t)i;
d432 6
a437 2
		assert(recsz < maxrec);
	} 
d456 3
a458 3
			if (recsz > 0) {
				--recsz;
				rec = recs[(int)recsz];
d529 1
a529 1
				printf("Indexed: %s, %s, 0x%x\n", 
d554 1
a554 1
			printf("Indexed: %s\n", fn);
a576 51
static void
op_delete(const char *fn, int verb, DB *idx, 
		const char *ibuf, DB *db, const char *fbuf)
{
	int		 ch;
	DBT		 key, val;
	recno_t		 rec;
	unsigned int	 seq, sseq;

	seq = R_FIRST;
	while (0 == (ch = (*idx->seq)(idx, &key, &val, seq))) {
		seq = R_NEXT;
		if (0 == val.size)
			continue;
		if (strcmp((char *)val.data, fn))
			continue;

		rec = *(recno_t *)key.data;

		sseq = R_FIRST;
		while (0 == (ch = (*db->seq)(db, &key, &val, sseq))) {
			sseq = R_NEXT;
			assert(8 == val.size);
			if (rec != *(recno_t *)(val.data + 4))
				continue;
			if (verb > 1)
				printf("Deleted: %s, %s\n", 
					fn, (char *)key.data);
			ch = (*db->del)(db, &key, R_CURSOR);
			if (ch < 0)
				break;
		}
		if (ch < 0) {
			perror(fbuf);
			exit((int)MANDOCLEVEL_SYSERR);
		}

		val.size = 0;
		if (verb)
			printf("Deleted: %s\n", fn);
		ch = (*idx->put)
			(idx, &key, &val, R_CURSOR);
		if (ch < 0)
			break;
	}
	if (ch < 0) {
		perror(ibuf);
		exit((int)MANDOCLEVEL_SYSERR);
	}
}

@


1.19
log
@Fairly straightforward patch adding basic update (-u) and remove (-r)
functionality to makewhatis.  This is somewhat expensive (requiring the
index file to be trawled multiple times), but it's a good start.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.18 2011/07/11 09:36:15 kristaps Exp $ */
d265 1
a265 1
	enum mandocerr	 ec;
d290 1
d402 1
a402 2
	} else
		maxrec = 0;
@


1.18
log
@Don't use a temporary buffer (unless people yell to have it back in),
and clean up the parse process a bit.  No big changes.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.17 2011/07/10 13:03:31 kristaps Exp $ */
d70 8
d96 2
d251 1
d260 1
a260 1
	int		 ch, seq, verb;
d268 4
a271 1
	recno_t		 rec; /* current record number */
d288 3
d296 1
a296 1
	while (-1 != (ch = getopt(argc, argv, "d:v")))
d301 6
d337 1
d343 7
a349 2
	db = dbopen(fbuf, MANDOC_FLAGS, 0644, DB_BTREE, &info);
	idx = dbopen(ibuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);
d360 46
d418 13
a430 1
	rec = 1;
a431 1
	while (NULL != (fn = *argv++)) {
d448 4
a451 2
		arch = NULL != mdoc ? 
			mdoc_meta(mdoc)->arch : "";
d494 1
a494 1
				printf("%s: Keyword %s: 0x%x\n", 
a496 1

a497 1

d519 1
a519 1
			printf("%s: Indexed\n", fn);
a521 1
		rec++;
a524 1

d537 1
d542 51
d1119 1
a1119 1
	fprintf(stderr, "usage: %s [-v] [-d path] [file...]\n", 
@


1.17
log
@Have descriptions for -man documents in makewhatis be properly collected.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.16 2011/07/01 13:46:39 kristaps Exp $ */
d87 1
a246 1
			 ibbuf[MAXPATHLEN], /* index backup fname */
a247 1
			 fbbuf[MAXPATHLEN], /* btree backup fname */
d254 1
d271 7
a294 7
	/*
	 * Set up temporary file-names into which we're going to write
	 * all of our data (both for the index and database).  These
	 * will be securely renamed to the real file-names after we've
	 * written all of our data.
	 */

d296 1
a296 3
		ibbuf[0] = ibbuf[MAXPATHLEN - 2] = 
		fbuf[0] = fbuf[MAXPATHLEN - 2] = 
		fbbuf[0] = fbbuf[MAXPATHLEN - 2] = '\0';
a300 3
	strlcat(fbbuf, fbuf, MAXPATHLEN);
	strlcat(fbbuf, "~", MAXPATHLEN);

a303 3
	strlcat(ibbuf, ibuf, MAXPATHLEN);
	strlcat(ibbuf, "~", MAXPATHLEN);

d305 1
a305 3
			'\0' != fbbuf[MAXPATHLEN - 2] ||
			'\0' != ibuf[MAXPATHLEN - 2] ||
			'\0' != ibbuf[MAXPATHLEN - 2]) {
d307 1
a307 1
		exit((int)MANDOCLEVEL_SYSERR);
a317 6
	db = dbopen(fbbuf, MANDOC_FLAGS, 0644, DB_BTREE, &info);

	if (NULL == db) {
		perror(fbbuf);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d319 2
a320 1
	idx = dbopen(ibbuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);
d323 5
a327 3
		perror(ibbuf);
		(*db->close)(db);
		exit((int)MANDOCLEVEL_SYSERR);
a338 6
	rec = 1;
	hash = NULL;

	memset(&buf, 0, sizeof(struct buf));
	memset(&dbuf, 0, sizeof(struct buf));

a339 1

d343 2
d347 1
a347 14

		/* Initialise the in-memory hash of keywords. */

		if (hash)
			(*hash->close)(hash);

		hash = dbopen(NULL, MANDOC_FLAGS, 0644, DB_HASH, NULL);

		if (NULL == hash) {
			perror("hash");
			exit((int)MANDOCLEVEL_SYSERR);
		}

		/* Parse and get (non-empty) AST. */
a354 1

d359 1
a359 2
			mdoc_meta(mdoc)->msec :
			man_meta(man)->msec;
d361 3
a363 3
			mdoc_meta(mdoc)->title :
			man_meta(man)->title;
		arch = NULL != mdoc ? mdoc_meta(mdoc)->arch : NULL;
d377 1
a377 2
		buf_appendb(&dbuf, arch ? arch : "", 
				arch ? strlen(arch) + 1 : 1);
d406 2
a407 2
				printf("%s: Keyword %s (%zu): 0x%x\n", 
					fn, (char *)key.data, key.size, 
d410 1
a410 1
			dbt_put(db, fbbuf, &key, &val);
a412 1

d435 1
a435 1
		dbt_put(idx, ibbuf, &key, &val);
d439 1
a439 2
	(*db->close)(db);
	(*idx->close)(idx);
d441 5
d448 2
a449 2

	mparse_free(mp);
d454 1
a454 8
	/* Atomically replace the file with our temporary one. */

	if (-1 == rename(fbbuf, fbuf))
		perror(fbuf);
	if (-1 == rename(ibbuf, ibuf))
		perror(fbuf);

	return((int)MANDOCLEVEL_OK);
d534 15
@


1.16
log
@Added `Er' in ERRORS scan to makewhatis.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.15 2011/07/01 12:02:44 kristaps Exp $ */
d964 2
a966 1
				buf->len = 0;
d989 2
@


1.15
log
@Added search for `Ev' environment variables in ENVIRONMENT section.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.14 2011/07/01 10:46:32 kristaps Exp $ */
d60 1
d91 1
d128 1
a128 1
	NULL, /* Er */ 
d771 12
@


1.14
log
@Allow `Nd' scarfed data to allow for non-text nodes as the first node, as well.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.13 2011/07/01 10:17:24 kristaps Exp $ */
d59 1
d90 1
d127 1
a127 1
	NULL, /* Ev */ 
d769 12
@


1.13
log
@Make scan for text tokens in a line recursive.  This is really only for
the benefit of `Nd', which is the only [to date] node that can consist
of sub-nodes.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.12 2011/07/01 09:11:35 kristaps Exp $ */
d79 1
a79 1
				const struct mdoc_node *);
d534 3
d539 1
a539 1
buf_appendmdoc(struct buf *buf, const struct mdoc_node *n)
d544 7
a550 2
			buf_appendmdoc(buf, n->child);
		if (MDOC_TEXT == n->type)
d552 1
d564 1
a564 1
	buf_appendmdoc(buf, n->child);
d622 1
a622 1
	buf_appendmdoc(buf, n->child);
a754 1
	size_t		 sz;
a757 5
	else if (NULL == (n = n->child))
		return;

	/* FIXME: don't assume this. */
	assert(MDOC_TEXT == n->type);
d759 2
a760 6
	sz = strlen(n->string) + 1;
	buf_appendb(dbuf, n->string, sz);
	buf_appendb(buf, n->string, sz);
	
	buf_appendmdoc(dbuf, n->next);
	buf_appendmdoc(buf, n->next);
d773 1
a773 1
	buf_appendmdoc(buf, n->child);
d783 1
a783 1
		buf_appendmdoc(buf, n->child);
d792 1
a792 1
	buf_appendmdoc(buf, n->child);
@


1.12
log
@Add path reference (`Pa' in FILES section).
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.11 2011/06/25 13:19:25 kristaps Exp $ */
d78 2
d529 18
d555 1
a555 4
	for (n = n->child; n; n = n->next)
		if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);

d613 1
a613 4
	for (n = n->child; n; n = n->next)
		if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);

a745 1
	int		 first;
a746 4
	
	for (first = 1, n = n->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			continue;
d748 7
a754 8
		if (first) {
			sz = strlen(n->string) + 1;
			buf_appendb(dbuf, n->string, sz);
			buf_appendb(buf, n->string, sz);
		} else {
			buf_append(dbuf, n->string);
			buf_append(buf, n->string);
		}
d756 6
a761 2
		first = 0;
	}
d774 1
a774 4
	for (n = n->child; n; n = n->next)
		if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);

d784 1
a784 3
		for (n = n->child; n; n = n->next)
			if (MDOC_TEXT == n->type)
				buf_append(buf, n->string);
d793 1
a793 4
	for (n = n->child; n; n = n->next)
		if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);

@


1.11
log
@Add cross-reference records to makewhatis.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.10 2011/06/22 10:36:36 kristaps Exp $ */
d58 1
d93 1
d137 1
a137 1
	NULL, /* Pa */
d756 15
@


1.10
log
@Clean up makewhatis.c a little bit and add verbosity (-v).
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.9 2011/06/22 09:10:36 kristaps Exp $ */
d57 1
d94 1
d140 1
a140 1
	NULL, /* Xr */ 
d657 19
@


1.9
log
@Make sure hash is initialised to NULL and remove an unused variable.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.8 2011/06/22 09:00:14 kristaps Exp $ */
a23 5
#ifdef __linux__
# include <db_185.h>
#else
# include <db.h>
#endif
d31 6
d48 9
a56 9
#define TYPE_NAME	0x01
#define TYPE_FUNCTION	0x02
#define TYPE_UTILITY	0x04
#define TYPE_INCLUDES	0x08
#define TYPE_VARIABLE	0x10
#define TYPE_STANDARD	0x20
#define TYPE_AUTHOR	0x40
#define TYPE_CONFIG	0x80
#define TYPE_DESC	0x100
d240 1
a240 1
	int		 ch, seq;
d260 1
d262 1
a262 1
	while (-1 != (ch = getopt(argc, argv, "d:")))
d267 3
d306 1
a306 1
		fprintf(stderr, "%s: Path too long\n", progname);
d334 3
a336 3
	 * Try parsing the manuals given on the command line.  If we
	 * totally fail, then just keep on going.  Take resulting trees
	 * and push them down into the database code.
d356 2
d374 1
d376 1
a379 2
		/* Manual section: can be empty string. */

a387 3
		assert(msec);
		assert(mtitle);

d429 3
a431 2
			printf("Added: %s (%zu): 0x%x\n",
					(char *)key.data, key.size, 
d457 2
a458 1
		printf("Indexed: %s\n", fn);
d466 1
d934 2
a935 1
	fprintf(stderr, "usage: %s [-d path] [file...]\n", progname);
@


1.8
log
@Try again to get the transfer from hash to btree working.  This time
just closing and re-opening the database, as deleting records with
(*hash->del) either in the scan loop or after it causes uncertain
behaviour (left-over keys, mystery keys, etc.).  This finally does the
Right Thing (tm).
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.7 2011/06/21 23:37:27 kristaps Exp $ */
d244 1
a244 1
	size_t		 sv, rsz; 
d338 1
a338 1
	rsz = 0;
@


1.7
log
@Fix broken transfer from hashtable to btree for makewhatis.c.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.6 2011/06/21 14:16:05 kristaps Exp $ */
a308 2
	 * For the temporary keyword hashtable, use the HASH database
	 * type.
a310 6
	hash = dbopen(NULL, MANDOC_FLAGS, 0644, DB_HASH, NULL);
	if (NULL == hash) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	}

a316 1
		(*hash->close)(hash);
a324 1
		(*hash->close)(hash);
d351 10
d425 4
a430 3
			ch = (*hash->del)(hash, &key, R_CURSOR);
			if (ch < 0)
				break;
d452 2
d460 2
a461 1
	(*hash->close)(hash);
a778 3
	if (0 == key->size)
		return;

@


1.6
log
@Let descriptions (bit-mask 0x100) also be mined for text.  This doubles
the database size (one record for each file), but it's critical
information.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.5 2011/06/21 13:54:05 kristaps Exp $ */
d419 2
d424 1
d427 3
a429 5
			if ((*hash->del)(hash, &key, 0) < 0) {
				perror("hash");
				exit((int)MANDOCLEVEL_SYSERR);
			}
			seq = R_NEXT;
d750 3
d754 1
a754 3

	if ((key.size = buf->len) < 2)
		return;
a764 3
	/*fprintf(stderr, "Hashing: [%s] (0x%x)\n", 
			(char *)key.data, mask);*/

@


1.5
log
@Have descriptions also use struct buf.   This completes the internal
migration to in-memory hashing and passing buffers instead of DBTs.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.4 2011/06/21 13:13:15 kristaps Exp $ */
d55 1
a55 1
#define	TYPE__MAX	TYPE_CONFIG
d698 1
d703 6
a708 3
		if (first) 
			buf_appendb(dbuf, n->string, strlen(n->string) + 1);
		else
d710 3
d715 2
d909 3
a911 1
			buf_appendb(dbuf, start, strlen(start) + 1);
@


1.4
log
@Don't let empty strings into the makewhatis keyword database.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.3 2011/06/21 13:05:14 kristaps Exp $ */
d45 2
d57 2
d67 1
a67 1
			  DBT *rval, size_t *rsz, \
d71 1
a71 1
			  DBT *rval, size_t *rsz, \
d75 2
a76 2
static	void		  dbt_append(DBT *, size_t *, const char *);
static	void		  dbt_appendb(DBT *, size_t *, 
a77 1
static	void		  dbt_init(DBT *, size_t *);
a79 1
static	void		  usage(void);
d92 1
a95 2
static	const char	 *progname;

d221 2
d243 1
a243 2
	DBT		 rkey, rval, /* recno entries */
			 key, val; /* persistent keyword entries */
d247 2
a248 1
	struct buf	 buf; /* keyword buffer */
a346 7
	memset(&key, 0, sizeof(DBT));
	memset(&val, 0, sizeof(DBT));
	memset(&rkey, 0, sizeof(DBT));
	memset(&rval, 0, sizeof(DBT));

	rkey.size = sizeof(recno_t);

d351 3
a354 1
	buf.size = MANDOC_BUFSZ;
d356 1
d392 5
a396 5
		dbt_init(&rval, &rsz);
		dbt_appendb(&rval, &rsz, fn, strlen(fn) + 1);
		dbt_appendb(&rval, &rsz, msec, strlen(msec) + 1);
		dbt_appendb(&rval, &rsz, mtitle, strlen(mtitle) + 1);
		dbt_appendb(&rval, &rsz, arch ? arch : "", 
d399 1
a399 1
		sv = rval.size;
d404 2
a405 3
			pmdoc_node(hash, &buf, &rval,
					&rsz, mdoc_node(mdoc), 
					mdoc_meta(mdoc));
d407 1
a407 2
			pman_node(hash, &buf, &rval, 
					&rsz, man_node(man));
d423 1
a423 3
			/*fprintf(stderr, "Recording: %s (0x%x)\n",
					(char *)key.data,
					*(int *)val.data);*/
d441 5
a445 2
		if (rval.size == sv)
			dbt_appendb(&rval, &rsz, "", 1);
d447 2
a448 2
		rkey.data = &rec;
		dbt_put(idx, ibbuf, &rkey, &rval);
d450 1
a450 1
		printf("Indexed: %s\n", fn);
a459 1
	free(rval.data);
d461 1
d474 1
a474 21
 * Initialise the stored database key whose data buffer is shared
 * between uses (as the key must sometimes be constructed from an array
 * of 
 */
static void
dbt_init(DBT *key, size_t *ksz)
{

	if (0 == *ksz) {
		assert(0 == key->size);
		assert(NULL == key->data);
		key->data = mandoc_malloc(MANDOC_BUFSZ);
		*ksz = MANDOC_BUFSZ;
	}

	key->size = 0;
}

/*
 * Append a binary value to a database entry.  This can be invoked
 * multiple times; the buffer is automatically resized.
a476 17
dbt_appendb(DBT *key, size_t *ksz, const void *cp, size_t sz)
{

	assert(key->data);

	/* Overshoot by MANDOC_BUFSZ. */

	while (key->size + sz >= *ksz) {
		*ksz = key->size + sz + MANDOC_BUFSZ;
		key->data = mandoc_realloc(key->data, *ksz);
	}

	memcpy(key->data + (int)key->size, cp, sz);
	key->size += sz;
}

static void
d492 4
a495 3
 * Append a nil-terminated string to the database entry.  This can be
 * invoked multiple times.  The database entry will be nil-terminated as
 * well; if invoked multiple times, a space is put between strings.
a497 16
dbt_append(DBT *key, size_t *ksz, const char *cp)
{
	size_t		 sz;

	if (0 == (sz = strlen(cp)))
		return;

	assert(key->data);

	if (key->size)
		((char *)key->data)[(int)key->size - 1] = ' ';

	dbt_appendb(key, ksz, cp, sz + 1);
}

static void
d703 1
a703 1
			dbt_appendb(rval, rsz, n->string, strlen(n->string) + 1);
d705 1
a705 1
			dbt_append(rval, rsz, n->string);
d770 1
a770 1
	assert(key->data);
a771 1
	assert(val->data);
d806 1
a806 1
		(*mdocs[n->tok])(hash, buf, rval, rsz, n, m);
d812 2
a813 2
	pmdoc_node(hash, buf, rval, rsz, n->child, m);
	pmdoc_node(hash, buf, rval, rsz, n->next, m);
d900 1
a900 1
			dbt_appendb(rval, rsz, start, strlen(start) + 1);
d904 1
a904 1
	if (pman_node(hash, buf, rval, rsz, n->child))
d906 1
a906 1
	if (pman_node(hash, buf, rval, rsz, n->next))
d916 1
a916 4
	fprintf(stderr, "usage: %s "
			"[-d path] "
			"[file...]\n", 
			progname);
@


1.3
log
@Big change to makewhatis: use an in-memory hashtable to collapse
multiple types of the same name (e.g., "foo" being a manual name,
utility name, etc.) into a single bitmask'd region.  This considerably
reduces the size of the keyword database.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.2 2011/05/15 02:47:17 kristaps Exp $ */
d795 2
a796 1
	if (0 == (key.size = buf->len))
@


1.2
log
@Get rid of an "#if 0" that I don't anticipate being fixed ever (nor does
it really need to be fixed, anyway).
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.1 2011/05/13 00:42:26 kristaps Exp $ */
d45 14
a58 10
enum	type {
	MANDOC_NONE = 0,
	MANDOC_NAME,
	MANDOC_FUNCTION,
	MANDOC_UTILITY,
	MANDOC_INCLUDES,
	MANDOC_VARIABLE,
	MANDOC_STANDARD,
	MANDOC_AUTHOR,
	MANDOC_CONFIG
d61 2
a62 4
#define	MAN_ARGS	  DB *db, \
			  const char *dbn, \
			  DBT *key, size_t *ksz, \
			  DBT *val, \
d65 2
a66 4
#define	MDOC_ARGS	  DB *db, \
			  const char *dbn, \
			  DBT *key, size_t *ksz, \
			  DBT *val, \
d68 2
a69 1
			  const struct mdoc_node *n
d76 1
a77 2
static	void		  pman(DB *, const char *, DBT *, size_t *, 
				DBT *, DBT *, size_t *, struct man *);
a78 2
static	void		  pmdoc(DB *, const char *, DBT *, size_t *, 
				DBT *, DBT *, size_t *, struct mdoc *);
d234 3
a236 2
			 fbbuf[MAXPATHLEN]; /* btree backup fname */
	int		 ch;
d238 2
a239 1
			*db; /* keyword database */
d242 1
a242 3
	size_t		 sv,
			 ksz, rsz; /* entry buffer size */
	char		 vbuf[8]; /* stringified record number */
d245 1
d304 4
a307 2
	 * duplicates.  For the index database, use a standard RECNO
	 * database type.
d310 6
d322 1
d331 1
a348 2
	val.size = sizeof(vbuf);
	val.data = vbuf;
d352 6
a357 1
	ksz = rsz = 0;
a403 3
		memset(val.data, 0, sizeof(uint32_t));
		memcpy(val.data + 4, &rec, sizeof(uint32_t));

d405 3
a407 2
			pmdoc(db, fbbuf, &key, &ksz, 
				&val, &rval, &rsz, mdoc);
d409 31
a439 2
			pman(db, fbbuf, &key, &ksz, 
				&val, &rval, &rsz, man);
d442 2
a443 2
		 * Apply this to the index.  If we haven't had a
		 * description set, put an empty one in now.
d458 1
a461 1
	free(key.data);
d463 1
d515 15
d551 14
a568 1
	uint32_t	 fl;
d575 1
a575 1
			dbt_append(key, ksz, n->string);
d577 1
a577 2
	fl = (uint32_t)MANDOC_AUTHOR;
	memcpy(val->data, &fl, 4);
a583 1
	uint32_t	 fl;
a618 2
	dbt_appendb(key, ksz, start, (size_t)(end - start + 1));
	dbt_appendb(key, ksz, "", 1);
d620 4
a623 2
	fl = (uint32_t)MANDOC_INCLUDES;
	memcpy(val->data, &fl, 4);
a629 1
	uint32_t	 fl;
d636 1
a636 1
			dbt_append(key, ksz, n->string);
d638 1
a638 2
	fl = (uint32_t)MANDOC_CONFIG;
	memcpy(val->data, &fl, 4);
a644 1
	uint32_t	 fl;
d651 2
a652 3
	dbt_append(key, ksz, n->child->string);
	fl = (uint32_t)MANDOC_INCLUDES;
	memcpy(val->data, &fl, 4);
a658 1
	uint32_t	 fl;
d677 2
a678 3
	dbt_append(key, ksz, cp);
	fl = (uint32_t)MANDOC_FUNCTION;
	memcpy(val->data, &fl, 4);
a684 1
	uint32_t	 fl;
d691 2
a692 3
	dbt_append(key, ksz, n->child->string);
	fl = (uint32_t)MANDOC_STANDARD;
	memcpy(val->data, &fl, 4);
a698 1
	uint32_t	 fl;
d727 3
a729 5
	dbt_appendb(key, ksz, start, sz);
	dbt_appendb(key, ksz, "", 1);

	fl = (uint32_t)MANDOC_VARIABLE;
	memcpy(val->data, &fl, 4);
a735 1
	uint32_t	 fl;
d742 2
a743 3
	dbt_append(key, ksz, n->child->string);
	fl = (uint32_t)MANDOC_FUNCTION;
	memcpy(val->data, &fl, 4);
a767 1
	uint32_t	 fl;
d770 4
a773 7
		for (n = n->child; n; n = n->next) {
			if (MDOC_TEXT != n->type)
				continue;
			dbt_append(key, ksz, n->string);
		}
		fl = (uint32_t)MANDOC_NAME;
		memcpy(val->data, &fl, 4);
d778 31
a808 5
	for (n = n->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			continue;
		dbt_append(key, ksz, n->string);
	}
d810 4
a813 2
	fl = (uint32_t)MANDOC_UTILITY;
	memcpy(val->data, &fl, 4);
d859 2
a860 4
		dbt_init(key, ksz);

		(*mdocs[n->tok])(db, dbn, key, ksz, val, rval, rsz, n);
		dbt_put(db, dbn, key, val);
d866 2
a867 2
	pmdoc_node(db, dbn, key, ksz, val, rval, rsz, n->child);
	pmdoc_node(db, dbn, key, ksz, val, rval, rsz, n->next);
a875 1
	uint32_t	 fl;
a897 3
			fl = (uint32_t)MANDOC_NAME;
			memcpy(val->data, &fl, 4);

d916 3
a918 3
				dbt_init(key, ksz);
				dbt_appendb(key, ksz, start, sz);
				dbt_appendb(key, ksz, "", 1);
d920 1
a920 1
				dbt_put(db, dbn, key, val);
d934 2
a935 2
				dbt_init(key, ksz);
				dbt_append(key, ksz, start);
d958 1
a958 1
	if (pman_node(db, dbn, key, ksz, val, rval, rsz, n->child))
d960 1
a960 1
	if (pman_node(db, dbn, key, ksz, val, rval, rsz, n->next))
a966 17
pman(DB *db, const char *dbn, DBT *key, size_t *ksz, 
		DBT *val, DBT *rval, size_t *rsz, struct man *m)
{

	pman_node(db, dbn, key, ksz, val, rval, rsz, man_node(m));
}


static void
pmdoc(DB *db, const char *dbn, DBT *key, size_t *ksz, 
		DBT *val, DBT *rval, size_t *rsz, struct mdoc *m)
{

	pmdoc_node(db, dbn, key, ksz, val, rval, rsz, mdoc_node(m));
}

static void
@


1.1
log
@Rename mandoc-db to makewhatis.  On the suggestion of schwarze@@; I agree.
Add initial version notes.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.21 2011/05/12 23:44:51 kristaps Exp $ */
a470 42
#if 0
	dstp = key->data + (int)key->size;

	while (NULL != (endp = memchr(cp, '\\', sz))) {
		ssz = endp - cp;
		memcpy(dstp, cp, ssz);

		dstp += ssz;
		key->size += ssz;
		sz -= ssz;

		cp = endp++;
		/* FIXME: expects nil-terminated string! */
		esc = mandoc_escape((const char **)&endp, NULL, NULL);

		switch (esc) {
		case (ESCAPE_ERROR):
			/* Nil-terminate this point. */
			memcpy(dstp, "", 1);
			key->size++;
			return;
		case (ESCAPE_PREDEF):
			/* FALLTHROUGH */
		case (ESCAPE_SPECIAL):
			break;
		default:
			sz -= endp - cp;
			cp = endp;
			continue;
		}

		ssz = endp - cp;
		memcpy(dstp, cp, ssz);

		dstp += ssz;
		key->size += ssz;
		sz -= ssz;

		cp = endp;
	}
#endif

@
