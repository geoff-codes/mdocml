head	1.30;
access;
symbols
	VERSION_1_9_5:1.30
	VERSION_1_8_5:1.30
	VERSION_1_8_1:1.30
	VERSION_1_7_16:1.30
	VERSION_1_7_15:1.30
	OPENBSD_CHECKIN:1.30
	VERSION_1_6_5:1.30
	VERSION_1_5_1:1.30
	VERSION_1_3_15:1.30
	VERSION_1_3_6:1.30
	VERSION_1_2_0:1.30
	VERSION_1_0_2:1.27
	VERSION_1_0_1:1.21;
locks; strict;
comment	@ * @;


1.30
date	2008.12.15.01.54.58;	author kristaps;	state dead;
branches;
next	1.29;

1.29
date	2008.12.10.17.31.57;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.10.13.41.58;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.10.12.09.47;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.10.12.05.33;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.10.10.43.57;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2008.12.10.00.52.46;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2008.12.09.17.09.12;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2008.12.08.16.29.57;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2008.12.08.12.46.28;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2008.12.07.22.40.18;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2008.12.07.21.30.49;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.07.16.41.04;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.07.14.38.57;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.06.21.10.31;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.06.19.41.41;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.06.16.50.18;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2008.12.06.13.18.44;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.05.22.34.30;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.05.19.45.15;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.05.17.43.14;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.05.11.28.17;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.04.23.10.51;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.04.19.31.57;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.04.16.34.59;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.04.16.19.52;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.04.11.25.29;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.03.21.27.56;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.03.19.21.58;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.03.14.39.59;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Purged all old files in favour of new design.  Selective reintegration.
@
text
@@


1.29
log
@*** empty log message ***
@
text
@a0 868
/* $Id: mlg.c,v 1.28 2008/12/10 13:41:58 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "ml.h"

/* TODO: literal tokens. */

enum	md_tok {
	MD_TEXT,
	MD_INLINE_IN,
	MD_INLINE_OUT,
	MD_BLK_IN,
	MD_BLK_OUT
};

struct	md_mlg {
	struct ml_args	  args;
	struct rofftree	 *tree;
	size_t		  indent;
	size_t		  pos;
	enum md_tok	  last;
	void		 *arg;
	struct ml_cbs	  cbs;
	int		  flags;
#define	ML_OVERRIDE_ONE	 (1 << 0)
#define	ML_OVERRIDE_ALL	 (1 << 1)
};

static	int		 mlg_roffmsg(void *arg, 
				enum roffmsg, const char *, 
				const char *, const char *);
static	int		 mlg_roffhead(void *, const struct tm *, 
				const char *, const char *, 
				enum roffmsec, enum roffvol);
static	int		 mlg_rofftail(void *, const struct tm *, 
				const char *, const char *, 
				enum roffmsec, enum roffvol);
static	int		 mlg_roffin(void *, int, 
				int *, const char **);
static	int		 mlg_roffdata(void *, int, 
				const char *, const char *);
static	int		 mlg_roffout(void *, int);
static	int		 mlg_roffblkin(void *, int, int *, 
				const char **);
static	int		 mlg_roffblkout(void *, int);
static	int		 mlg_roffspecial(void *, int, 
				const char *, const int *,
				const char **, const char **);
static	int		 mlg_roffblkheadin(void *, int, 
				int *, const char **);
static	int		 mlg_roffblkheadout(void *, int);
static	int		 mlg_roffblkbodyin(void *, int, 
				int *, const char **);
static	int		 mlg_roffblkbodyout(void *, int);

static	int		 mlg_ref_special(struct md_mlg *, int,
				const char *, const char **);
static	int		 mlg_formatted_special(struct md_mlg *, 
				int, const char *, const int *, 
				const char **, const char **);
static	int		 mlg_literal_special(struct md_mlg *, 
				int,  const char *, const int *, 
				const char **, const char **);
static	int		 mlg_function_special(struct md_mlg *, 
				const char *, const char **);
static	int		 mlg_atom_special(struct md_mlg *, int,
				const char *, const char **);
static	int		 mlg_link_special(struct md_mlg *, int,
				const char *, const char **);
static	int		 mlg_anchor_special(struct md_mlg *, 
				int, const char **);

static	int		 mlg_begintag(struct md_mlg *, enum md_ns, 
				int, int *, const char **);
static	int		 mlg_endtag(struct md_mlg *, enum md_ns, int);
static	int	  	 mlg_indent(struct md_mlg *);
static	int		 mlg_newline(struct md_mlg *);
static	void		 mlg_mode(struct md_mlg *, enum md_tok);
static	int		 mlg_nstring(struct md_mlg *, 
				const char *, const char *, size_t);
static	int		 mlg_string(struct md_mlg *,
				const char *, const char *);
static	int		 mlg_data(struct md_mlg *, int, 
				const char *, const char *);
static	int		 mlg_err(struct md_mlg *, const char *, 
				const char *, const char *, ...);
static	int		 mlg_msg(struct md_mlg *, 
				enum roffmsg, const char *, 
				const char *, const char *);
static	int		 mlg_vmsg(struct md_mlg *, enum roffmsg, 
				const char *, const char *, 
				const char *, va_list);

#ifdef __linux__
extern	size_t		 strlcat(char *, const char *, size_t);
extern	size_t		 strlcpy(char *, const char *, size_t);
#endif


static int
mlg_begintag(struct md_mlg *p, enum md_ns ns, int tok,
		int *argc, const char **argv)
{
	ssize_t		 res;

	assert(MD_NS_DEFAULT != ns);

	switch (ns) {
	case (MD_NS_INLINE):
		if ( ! (ML_OVERRIDE_ONE & p->flags) && 
				! (ML_OVERRIDE_ALL & p->flags) && 
				p->pos + 11 >= COLUMNS)
			if ( ! mlg_newline(p))
				return(0);
		if (0 != p->pos && (MD_TEXT == p->last || 
					MD_INLINE_OUT == p->last)
				&& ! (ML_OVERRIDE_ONE & p->flags)
				&& ! (ML_OVERRIDE_ALL & p->flags))
			if ( ! ml_nputs(p->args.mbuf, " ", 1, &p->pos))
				return(0);
		if (0 == p->pos && ! mlg_indent(p))
			return(0);
		mlg_mode(p, MD_INLINE_IN);
		break;
	default:
		if (0 != p->pos) {
			if ( ! mlg_newline(p))
				return(0);
			if ( ! mlg_indent(p))
				return(0);
		} else if ( ! mlg_indent(p))
			return(0);
		p->indent++;
		mlg_mode(p, MD_BLK_IN);
		break;
	}

	if ( ! ml_nputs(p->args.mbuf, "<", 1, &p->pos))
		return(0);

	res = (*p->cbs.ml_begintag)(&p->args, ns, tok, argc, argv);
	if (-1 == res)
		return(0);

	assert(res >= 0);
	p->pos += (size_t)res;

	if ( ! ml_nputs(p->args.mbuf, ">", 1, &p->pos))
		return(0);

	switch (ns) {
	case (MD_NS_INLINE):
		break;
	default:
		if ( ! mlg_newline(p))
			return(0);
		break;
	}

	return(1);
}


static int
mlg_endtag(struct md_mlg *p, enum md_ns ns, int tok)
{
	ssize_t		 res;

	assert(MD_NS_DEFAULT != ns);

	switch (ns) {
	case (MD_NS_INLINE):
		break;
	default:
		p->indent--;
		if (0 != p->pos) {
			if ( ! mlg_newline(p))
				return(0);
			if ( ! mlg_indent(p))
				return(0);
		} else if ( ! mlg_indent(p))
			return(0);
		break;
	}

	if ( ! ml_nputs(p->args.mbuf, "</", 2, &p->pos))
		return(0);

	res = (*p->cbs.ml_endtag)(&p->args, ns, tok);
	if (-1 == res)
		return(0);

	assert(res >= 0);
	p->pos += (size_t)res;

	if ( ! ml_nputs(p->args.mbuf, ">", 1, &p->pos))
		return(0);
	
	switch (ns) {
	case (MD_NS_INLINE):
		mlg_mode(p, MD_INLINE_OUT);
		break;
	default:
		mlg_mode(p, MD_BLK_OUT);
		break;
	}

	return(1);
}


static int
mlg_indent(struct md_mlg *p)
{

	assert(0 == p->pos);
	return(ml_putchars(p->args.mbuf, ' ', INDENT_SZ * 
				INDENT(p->indent), &p->pos));
}


static int
mlg_newline(struct md_mlg *p)
{

	p->pos = 0;
	return(ml_nputs(p->args.mbuf, "\n", 1, NULL));
}


static void
mlg_mode(struct md_mlg *p, enum md_tok ns)
{

	p->flags &= ~ML_OVERRIDE_ONE;
	p->last = ns;
}


static int
mlg_string(struct md_mlg *p, const char *start, const char *buf)
{
	
	return(mlg_nstring(p, start, buf, strlen(buf)));
}


static int
mlg_nstring(struct md_mlg *p, const char *start, 
		const char *buf, size_t sz)
{
	int		 c;
	ssize_t		 res;

	assert(p->args.mbuf);
	assert(0 != p->indent);

	res = (*p->cbs.ml_beginstring)(&p->args, buf, sz);
	if (-1 == res) 
		return(0);

	if (0 == (c = ml_nputstring(p->args.mbuf, buf, sz, &p->pos)))
		return(mlg_err(p, start, buf, "bad string "
					"encoding: `%s'", buf));
	else if (-1 == c)
		return(0);

	res = (*p->cbs.ml_endstring)(&p->args, buf, sz);
	if (-1 == res) 
		return(0);

	return(1);
}


static int
mlg_data(struct md_mlg *p, int space, 
		const char *start, const char *buf)
{
	size_t		 sz;

	assert(p->args.mbuf);
	assert(0 != p->indent);

	if (ML_OVERRIDE_ONE & p->flags || 
			ML_OVERRIDE_ALL & p->flags)
		space = 0;

	sz = strlen(buf);

	if (0 == p->pos) {
		if ( ! mlg_indent(p))
			return(0);
		if ( ! mlg_nstring(p, start, buf, sz))
			return(0);

		if (INDENT(p->indent) * INDENT_SZ + sz >= COLUMNS)
			if ( ! mlg_newline(p))
				return(0);

		return(1);
	}

	if (space && sz + p->pos >= COLUMNS) {
		if ( ! mlg_newline(p))
			return(0);
		if ( ! mlg_indent(p))
			return(0);
	} else if (space) {
		if ( ! ml_nputs(p->args.mbuf, " ", 1, &p->pos))
			return(0);
	}

	return(mlg_nstring(p, start, buf, sz));
}


int
mlg_line(struct md_mlg *p, char *buf)
{

	return(roff_engine(p->tree, buf));
}


int
mlg_exit(struct md_mlg *p, int flush)
{
	int		 c;

	c = roff_free(p->tree, flush);
	(*p->cbs.ml_free)(p->args.data);

	free(p);

	return(c);
}


struct md_mlg *
mlg_alloc(const struct md_args *args, 
		const struct md_rbuf *rbuf,
		struct md_mbuf *mbuf, 
		const struct ml_cbs *cbs)
{
	struct roffcb	 cb;
	struct md_mlg	*p;

	cb.roffhead = mlg_roffhead;
	cb.rofftail = mlg_rofftail;
	cb.roffin = mlg_roffin;
	cb.roffout = mlg_roffout;
	cb.roffblkin = mlg_roffblkin;
	cb.roffblkheadin = mlg_roffblkheadin;
	cb.roffblkheadout = mlg_roffblkheadout;
	cb.roffblkbodyin = mlg_roffblkbodyin;
	cb.roffblkbodyout = mlg_roffblkbodyout;
	cb.roffblkout = mlg_roffblkout;
	cb.roffspecial = mlg_roffspecial;
	cb.roffmsg = mlg_roffmsg;
	cb.roffdata = mlg_roffdata;

	if (NULL == (p = calloc(1, sizeof(struct md_mlg))))
		err(1, "calloc");

	p->args.args = args;
	p->args.mbuf = mbuf;
	p->args.rbuf = rbuf;

	(void)memcpy(&p->cbs, cbs, sizeof(struct ml_cbs));

	if (NULL == (p->tree = roff_alloc(&cb, p))) 
		free(p);
	else if ( ! (*p->cbs.ml_alloc)(&p->args.data))
		free(p);
	else
		return(p);

	return(NULL);
}


static int
mlg_roffhead(void *arg, const struct tm *tm, const char *os, 
		const char *title, enum roffmsec sec, enum roffvol vol)
{
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	mlg_mode(p, MD_BLK_IN);

	if ( ! (*p->cbs.ml_begin)(&p->args, tm, os, title, sec, vol))
		return(0);

	p->indent++;
	return(mlg_newline(p));
}


static int
mlg_rofftail(void *arg, const struct tm *tm, const char *os, 
		const char *title, enum roffmsec sec, enum roffvol vol)
{
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	if (0 != p->pos)
		if ( ! mlg_newline(p))
			return(0);

	if ( ! (*p->cbs.ml_end)(&p->args, tm, os, title, sec, vol))
		return(0);

	mlg_mode(p, MD_BLK_OUT);
	return(mlg_newline(p));
}


static int
mlg_literal_special(struct md_mlg *p, int tok, const char *start,
		const int *argc, const char **argv, const char **more)
{
	char		 *lit;

	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);

	lit = roff_literal(tok, argc, argv, more);
	assert(lit);

	if ( ! mlg_string(p, start, lit))
		return(0);

	while (*more) { 
		if ( ! ml_nputs(p->args.mbuf, " ", 1, &p->pos))
			return(0);
		if ( ! mlg_string(p, start, *more++))
			return(0);
	}

	return(mlg_endtag(p, MD_NS_INLINE, tok));
}


static int
mlg_ref_special(struct md_mlg *p, int tok,
		const char *start, const char **more)
{

	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);

	assert(*more);
	if ( ! ml_puts(p->args.mbuf, *more++, &p->pos))
		return(0);

	if (*more) {
		if ( ! ml_nputs(p->args.mbuf, "(", 1, &p->pos))
			return(0);
		if ( ! mlg_string(p, start, *more++))
			return(0);
		if ( ! ml_nputs(p->args.mbuf, ")", 1, &p->pos))
			return(0);
	}

	assert(NULL == *more);
	return(mlg_endtag(p, MD_NS_INLINE, tok));
}


/* ARGSUSED */
static int
mlg_formatted_special(struct md_mlg *p, int tok, const char *start,
		const int *argc, const char **argv, const char **more)
{
	char		 buf[256], *lit;

	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);

	lit = roff_fmtstring(tok);

	assert(lit);
	assert(*more);
	(void)snprintf(buf, sizeof(buf), lit, *more++);
	assert(NULL == *more);

	if ( ! mlg_string(p, start, buf))
		return(0);

	return(mlg_endtag(p, MD_NS_INLINE, tok));
}


static int
mlg_atom_special(struct md_mlg *p, int tok,
		const char *start, const char **more)
{

	if (ROFFSec_SYNOP == p->args.section) {
		if ( ! mlg_begintag(p, MD_NS_INLINE, ROFF_Pp, NULL, more))
			return(0);
		if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Pp))
			return(0);
	}

	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);

	assert(*more);
	if ( ! mlg_string(p, start, *more++))
		return(0);

	return(mlg_endtag(p, MD_NS_INLINE, tok));
}


static int
mlg_function_special(struct md_mlg *p, 
		const char *start, const char **more)
{

	assert(*more);

	if ( ! mlg_begintag(p, MD_NS_INLINE, ROFF_Fn, NULL, more))
		return(0);
	if ( ! mlg_string(p, start, *more++))
		return(0);
	if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Fn))
		return(0);

	if (NULL == *more)
		return(1);

	if ( ! ml_nputs(p->args.mbuf, "(", 1, &p->pos))
		return(0);

	p->flags |= ML_OVERRIDE_ONE;

	if ( ! mlg_begintag(p, MD_NS_INLINE, ROFF_Fa, NULL, more))
		return(0);
	if ( ! mlg_string(p, start, *more++))
		return(0);
	if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Fa))
		return(0);

	while (*more) {
		if ( ! ml_nputs(p->args.mbuf, ", ", 2, &p->pos))
			return(0);
		if ( ! mlg_begintag(p, MD_NS_INLINE, ROFF_Fa, NULL, more))
			return(0);
		if ( ! mlg_string(p, start, *more++))
			return(0);
		if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Fa))
			return(0);
	}

	return(ml_nputs(p->args.mbuf, ")", 1, &p->pos));
}


static int
mlg_anchor_special(struct md_mlg *p, int tok, const char **more)
{
	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);
	return(mlg_endtag(p, MD_NS_INLINE, tok));
}


static int
mlg_link_special(struct md_mlg *p, int tok,
		const char *start, const char **more)
{

	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);
	if ( ! mlg_string(p, start, *more++))
		return(0);
	while (*more) {
		if ( ! mlg_string(p, start, " "))
			return(0);
		if ( ! mlg_string(p, start, *more++))
			return(0);
	}
	return(mlg_endtag(p, MD_NS_INLINE, tok));
}


/* ARGSUSED */
static int
mlg_roffspecial(void *arg, int tok, const char *start, 
		const int *argc, const char **argv, const char **more)
{
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	switch (tok) {
	case (ROFF_Ns):
		p->flags |= ML_OVERRIDE_ONE;
		return(1);

	case (ROFF_Sm):
		assert(*more);
		if (0 == strcmp(*more, "on"))
			p->flags |= ML_OVERRIDE_ALL;
		else
			p->flags &= ~ML_OVERRIDE_ALL;
		return(1);

	case (ROFF_Fn):
		return(mlg_function_special(p, start, more));

	case (ROFF_Xr):
		return(mlg_ref_special(p, tok, start, more));

	case (ROFF_Sh):
		p->args.section = roff_sec(more);
		return(mlg_anchor_special(p, tok, more));
 
	case (ROFF_Sx):
		return(mlg_link_special(p, tok, start, more));

	case (ROFF_Nm):
		return(mlg_atom_special(p, tok, start, more));
	
	case (ROFF_In):
		/* NOTREACHED */
	case (ROFF_Ex):
		/* NOTREACHED */
	case (ROFF_Rv):
		return(mlg_formatted_special(p, tok, start,
					argc, argv, more));

	case (ROFF_At):
		/* FALLTHROUGH */
	case (ROFF_Bt):
		/* FALLTHROUGH */
	case (ROFF_Ud):
		/* FALLTHROUGH */
	case (ROFF_Ux):
		/* FALLTHROUGH */
	case (ROFF_Bx):
		/* FALLTHROUGH */
	case (ROFF_Bsx):
		/* FALLTHROUGH */
	case (ROFF_Fx):
		/* FALLTHROUGH */
	case (ROFF_Nx):
		/* FALLTHROUGH */
	case (ROFF_St):
		/* FALLTHROUGH */
	case (ROFF_Ox):
		return(mlg_literal_special(p, tok, start, 
					argc, argv, more));
	default:
		break;
	}

	return(mlg_err(p, start, start, "`%s' not yet supported", 
				toknames[tok]));
}


static int
mlg_roffblkin(void *arg, int tok, 
		int *argc, const char **argv)
{

	return(mlg_begintag((struct md_mlg *)arg, 
				MD_NS_BLOCK, tok, argc, argv));
}


static int
mlg_roffblkout(void *arg, int tok)
{

	return(mlg_endtag((struct md_mlg *)arg, MD_NS_BLOCK, tok));
}


static int
mlg_roffblkbodyin(void *arg, int tok, 
		int *argc, const char **argv)
{

	return(mlg_begintag((struct md_mlg *)arg, 
				MD_NS_BODY, tok, argc, argv));
}


static int
mlg_roffblkbodyout(void *arg, int tok)
{

	return(mlg_endtag((struct md_mlg *)arg, MD_NS_BODY, tok));
}


static int
mlg_roffblkheadin(void *arg, int tok, 
		int *argc, const char **argv)
{

	return(mlg_begintag((struct md_mlg *)arg, 
				MD_NS_HEAD, tok, argc, argv));
}


static int
mlg_roffblkheadout(void *arg, int tok)
{

	return(mlg_endtag((struct md_mlg *)arg, MD_NS_HEAD, tok));
}


static int
mlg_roffin(void *arg, int tok, int *argc, const char **argv)
{

	return(mlg_begintag((struct md_mlg *)arg, 
				MD_NS_INLINE, tok, argc, argv));
}


static int
mlg_roffout(void *arg, int tok)
{

	return(mlg_endtag((struct md_mlg *)arg, MD_NS_INLINE, tok));
}


static int
mlg_roffmsg(void *arg, enum roffmsg lvl, const char *buf, 
		const char *pos, const char *msg)
{

	return(mlg_msg((struct md_mlg *)arg, lvl, buf, pos, msg));
}


static int
mlg_roffdata(void *arg, int space, 
		const char *start, const char *buf)
{
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	if ( ! mlg_data(p, space, start, buf))
		return(0);

	mlg_mode(p, MD_TEXT);
	return(1);
}


static int
mlg_vmsg(struct md_mlg *p, enum roffmsg lvl, const char *start, 
		const char *pos, const char *fmt, va_list ap)
{
	char		 buf[128];

	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
	return(mlg_msg(p, lvl, start, pos, buf));
}


static int
mlg_err(struct md_mlg *p, const char *start, 
		const char *pos, const char *fmt, ...)
{
	va_list		 ap;
	int		 c;

	va_start(ap, fmt);
	c = mlg_vmsg(p, ROFF_ERROR, start, pos, fmt, ap);
	va_end(ap);
	return(c);
}


static int
mlg_msg(struct md_mlg *p, enum roffmsg lvl, 
		const char *buf, const char *pos, const char *msg)
{
	char		*level, b[256];
	size_t		 sz;
	int		 i;

	sz = sizeof(b);

	switch (lvl) {
	case (ROFF_WARN):
		level = "warning";
		if ( ! (MD_WARN_ALL & p->args.args->warnings))
			return(1);
		break;
	case (ROFF_ERROR):
		level = "error";
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	if (pos) {
		assert(pos >= buf);
		if (0 < p->args.args->verbosity) {
			(void)snprintf(b, sz, "%s:%zu: %s: %s\n",
					p->args.rbuf->name, 
					p->args.rbuf->line, 
					level, msg);

			(void)strlcat(b, "Error at: ", sz);
			(void)strlcat(b, p->args.rbuf->linebuf, sz);
			(void)strlcat(b, "\n          ", sz);

			for (i = 0; i < pos - buf; i++)
				(void)strlcat(b, " ", sz);

			(void)strlcat(b, "^", sz);
		} else
			(void)snprintf(b, sz, "%s:%zu: %s: %s (%zu)", 
					p->args.rbuf->name, 
					p->args.rbuf->line, 
					level, msg, pos - buf);
	} else 
		(void)snprintf(b, sz, "%s: %s: %s", 
				p->args.rbuf->name, level, msg);

	(void)fprintf(stderr, "%s\n", b);
	return(lvl == ROFF_WARN ? 1 : 0);
}

@


1.28
log
@Sx to Sh anchors work.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.27 2008/12/10 12:09:47 kristaps Exp $ */
d40 1
a40 4
	const struct md_args	*args;
	const struct md_rbuf	*rbuf;

	struct md_mbuf	 *mbuf;
a49 1
	void		 *data;
d142 1
a142 1
			if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
d161 1
a161 1
	if ( ! ml_nputs(p->mbuf, "<", 1, &p->pos))
d164 1
a164 2
	res = (*p->cbs.ml_begintag)(p->mbuf, p->data, 
			p->args, ns, tok, argc, argv);
d171 1
a171 1
	if ( ! ml_nputs(p->mbuf, ">", 1, &p->pos))
d209 1
a209 1
	if ( ! ml_nputs(p->mbuf, "</", 2, &p->pos))
d212 1
a212 1
	res = (*p->cbs.ml_endtag)(p->mbuf, p->data, p->args, ns, tok);
d219 1
a219 1
	if ( ! ml_nputs(p->mbuf, ">", 1, &p->pos))
d240 1
a240 1
	return(ml_putchars(p->mbuf, ' ', INDENT_SZ * 
d250 1
a250 1
	return(ml_nputs(p->mbuf, "\n", 1, NULL));
d278 1
a278 1
	assert(p->mbuf);
d281 1
a281 1
	res = (*p->cbs.ml_beginstring)(p->mbuf, p->args, buf, sz);
d285 1
a285 1
	if (0 == (c = ml_nputstring(p->mbuf, buf, sz, &p->pos)))
d291 1
a291 1
	res = (*p->cbs.ml_endstring)(p->mbuf, p->args, buf, sz);
d305 1
a305 1
	assert(p->mbuf);
d333 1
a333 1
		if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
d355 1
a355 1
	(*p->cbs.ml_free)(p->data);
d389 3
a391 3
	p->args = args;
	p->mbuf = mbuf;
	p->rbuf = rbuf;
d397 1
a397 1
	else if ( ! (*p->cbs.ml_alloc)(&p->data))
d417 1
a417 2
	if ( ! (*p->cbs.ml_begin)(p->mbuf, p->args, 
				tm, os, title, sec, vol))
d438 1
a438 2
	if ( ! (*p->cbs.ml_end)(p->mbuf, p->args, 
				tm, os, title, sec, vol))
d462 1
a462 1
		if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
d481 1
a481 1
	if ( ! ml_puts(p->mbuf, *more++, &p->pos))
d485 1
a485 1
		if ( ! ml_nputs(p->mbuf, "(", 1, &p->pos))
d489 1
a489 1
		if ( ! ml_nputs(p->mbuf, ")", 1, &p->pos))
d527 7
d562 1
a562 1
	if ( ! ml_nputs(p->mbuf, "(", 1, &p->pos))
d575 1
a575 1
		if ( ! ml_nputs(p->mbuf, ", ", 2, &p->pos))
d585 1
a585 1
	return(ml_nputs(p->mbuf, ")", 1, &p->pos));
d647 1
d820 2
a821 2
	char		*level;
	char		 b[256];
d824 2
d829 1
a829 1
		if ( ! (MD_WARN_ALL & p->args->warnings))
d842 4
a845 4
		if (0 < p->args->verbosity) {
			(void)snprintf(b, sizeof(b), 
					"%s:%zu: %s: %s\n",
					p->rbuf->name, p->rbuf->line, 
a846 2
			(void)strlcat(b, "Error at: ", sizeof(b));
			(void)strlcat(b, p->rbuf->linebuf, sizeof(b));
d848 4
a851 1
			(void)strlcat(b, "\n          ", sizeof(b));
d853 1
a853 2
				(void)strlcat(b, " ", sizeof(b));
			(void)strlcat(b, "^", sizeof(b));
d855 1
d857 3
a859 3
			(void)snprintf(b, sizeof(b), 
					"%s:%zu: %s: %s (col %zu)", 
					p->rbuf->name, p->rbuf->line, 
d862 2
a863 2
		(void)snprintf(b, sizeof(b), "%s: %s: %s", 
				p->rbuf->name, level, msg);
@


1.27
log
@Linted on NetBSD side.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.26 2008/12/10 12:05:33 kristaps Exp $ */
d95 4
a540 1
	/*assert(NULL == *more);*/ /* FIXME: ROFF_Sx */
d589 28
d645 3
d649 3
a651 2
	case (ROFF_Sx): /* FIXME */
		/* FALLTHROUGH */
@


1.26
log
@Versioning up.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.25 2008/12/10 10:43:57 kristaps Exp $ */
d36 1
a36 1
	MD_BLK_OUT,
d501 1
@


1.25
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.24 2008/12/10 00:52:46 kristaps Exp $ */
d62 3
a64 1
static	int		 mlg_rofftail(void *);
d418 2
a419 1
	if ( ! (*p->cbs.ml_begin)(p->mbuf, p->args, tm, os, title, sec, vol))
d428 2
a429 1
mlg_rofftail(void *arg)
d440 2
a441 1
	if ( ! (*p->cbs.ml_end)(p->mbuf, p->args))
a444 1

@


1.24
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.23 2008/12/09 17:09:12 kristaps Exp $ */
d61 1
a61 1
				enum roffmsec, const char *);
d407 1
a407 1
		const char *title, enum roffmsec sec, const char *vol)
@


1.23
log
@Considerable clean-ups.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.22 2008/12/08 16:29:57 kristaps Exp $ */
a26 1
#include "private.h"
a30 4
#define	COLUMNS		  72
#define	INDENT		  4
#define	MAXINDENT	  10

a236 5
	size_t		 count;

	count = p->indent > MAXINDENT ? 
		(size_t)MAXINDENT : p->indent;
	count *= INDENT;
d239 2
a240 1
	return(ml_putchars(p->mbuf, ' ', count, &p->pos));
d319 1
a319 1
		if (p->indent * INDENT + sz >= COLUMNS)
@


1.22
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.21 2008/12/08 12:46:28 kristaps Exp $ */
a26 1
#include "libmdocml.h"
d61 1
a61 1
static	void		 mlg_roffmsg(void *arg, 
d89 1
a89 1
				int, const int *, 
d111 1
a111 1
static	void		 mlg_err(struct md_mlg *, const char *, 
d113 1
a113 1
static	void		 mlg_msg(struct md_mlg *, 
d116 1
a116 1
static	void		 mlg_vmsg(struct md_mlg *, enum roffmsg, 
d293 4
a296 5
	if (0 == (c = ml_nputstring(p->mbuf, buf, sz, &p->pos))) {
		mlg_err(p, start, buf, "bad string "
				"encoding: `%s'", buf);
		return(0);
	} else if (-1 == c)
d463 1
a463 3
	/* FIXME: must be ml-filtered. */

	lit = ml_literal(tok, argc, argv, more);
d466 1
a466 1
	if ( ! ml_puts(p->mbuf, lit, &p->pos))
d468 1
d507 1
a507 1
mlg_formatted_special(struct md_mlg *p, int tok, 
d515 1
a515 3
	/* FIXME: must be ml-filtered. */

	lit = ml_literal(tok, argc, argv, more);
d522 1
a522 1
	if ( ! ml_puts(p->mbuf, buf, &p->pos))
d629 1
a629 1
		return(mlg_formatted_special(p, tok, 
d657 2
a658 3
	mlg_err(p, start, start, "`%s' not yet supported", 
			toknames[tok]);
	return(0);
d733 1
a733 1
static void
d738 1
a738 1
	mlg_msg((struct md_mlg *)arg, lvl, buf, pos, msg);
d759 1
a759 1
static void
d766 1
a766 1
	mlg_msg(p, lvl, start, pos, buf);
d770 1
a770 1
static void
d775 1
d778 1
a778 1
	mlg_vmsg(p, ROFF_ERROR, start, pos, fmt, ap);
d780 1
d784 1
a784 1
static void
d794 1
d796 1
a796 2
			return;
		level = "warning";
d803 1
d831 1
@


1.21
log
@Added warnings for using macros in the wrong sections.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.20 2008/12/07 22:40:18 kristaps Exp $ */
d546 1
a546 1
	assert(NULL == *more);
d793 2
d808 23
a830 7
	
	if (pos)
		(void)fprintf(stderr, "%s:%zu: %s: %s (column %zu)\n", 
				p->rbuf->name, p->rbuf->line, level, 
				msg, pos - buf);
	else
		(void)fprintf(stderr, "%s: %s: %s\n", 
d832 2
d835 1
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.19 2008/12/07 21:30:49 kristaps Exp $ */
d67 1
a67 1
				const char *, const char *);
d365 2
a368 2
	(*p->cbs.ml_free)(p->data);

d418 1
a418 1
		const char *title, const char *sec, const char *vol)
d465 2
a514 2
	/* FIXME: *more must be ml-filtered. */

d518 2
d521 1
@


1.19
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.18 2008/12/07 16:41:04 kristaps Exp $ */
d62 3
a64 7

static	char		*mlg_literal(int);
static	char		*mlg_At_literal(const char *);
static	char		*mlg_fmt(int);
static	char 		*mlg_St_literal(int);
static	void		 mlg_roffmsg(void *arg, enum roffmsg, 
				const char *, const char *, char *);
d69 2
a70 1
static	int		 mlg_roffin(void *, int, int *, char **);
d72 1
a72 1
				const char *, char *);
d74 2
a75 1
static	int		 mlg_roffblkin(void *, int, int *, char **);
d79 1
a79 1
				const char **, char **);
d81 1
a81 1
				int *, char **);
d84 1
a84 1
				int *, char **);
d87 13
d101 1
a101 1
				int, int *, char **);
d111 1
a111 1
				const char *, char *);
d114 3
a116 2
static	void		 mlg_msg(struct md_mlg *, enum roffmsg, 
				const char *, const char *, char *);
a126 164
static char *
mlg_St_literal(int argc)
{

	switch (argc) {
	case(ROFF_p1003_1_88):
		return("IEEE Std 1003.1-1988 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1_90):
		return("IEEE Std 1003.1-1990 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1_96):
		return("ISO/IEC 9945-1:1996 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1_2001):
		return("IEEE Std 1003.1-2001 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1_2004):
		return("IEEE Std 1003.1-2004 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1):
		return("IEEE Std 1003.1 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1b):
		return("IEEE Std 1003.1b (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1b_93):
		return("IEEE Std 1003.1b-1993 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1c_95):
		return("IEEE Std 1003.1c-1995 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_1g_2000):
		return("IEEE Std 1003.1g-2000 (&#8220;POSIX&#8221;)");
	case(ROFF_p1003_2_92):
		return("IEEE Std 1003.2-1992 (&#8220;POSIX.2&#8221;)");
	case(ROFF_p1387_2_95):
		return("IEEE Std 1387.2-1995 (&#8220;POSIX.7.2&#8221;)");
	case(ROFF_p1003_2):
		return("IEEE Std 1003.2 (&#8220;POSIX.2&#8221;)");
	case(ROFF_p1387_2):
		return("IEEE Std 1387.2 (&#8220;POSIX.7.2&#8221;)");
	case(ROFF_isoC_90):
		return("ISO/IEC 9899:1990 (&#8220;ISO C90&#8221;)");
	case(ROFF_isoC_amd1):
		return("ISO/IEC 9899/AMD1:1995 (&#8220;ISO C90&#8221;)");
	case(ROFF_isoC_tcor1):
		return("ISO/IEC 9899/TCOR1:1994 (&#8220;ISO C90&#8221;)");
	case(ROFF_isoC_tcor2):
		return("ISO/IEC 9899/TCOR2:1995 (&#8220;ISO C90&#8221;)");
	case(ROFF_isoC_99):
		return("ISO/IEC 9899:1999 (&#8220;ISO C99&#8221;)");
	case(ROFF_ansiC):
		return("ANSI X3.159-1989 (&#8220;ANSI C&#8221;)");
	case(ROFF_ansiC_89):
		return("ANSI X3.159-1989 (&#8220;ANSI C&#8221;)");
	case(ROFF_ansiC_99):
		return("ANSI/ISO/IEC 9899-1999 (&#8220;ANSI C99&#8221;)");
	case(ROFF_ieee754):
		return("IEEE Std 754-1985");
	case(ROFF_iso8802_3):
		return("ISO 8802-3: 1989");
	case(ROFF_xpg3):
		return("X/Open Portability Guide Issue 3 (&#8220;XPG3&#8221;)");
	case(ROFF_xpg4):
		return("X/Open Portability Guide Issue 4 (&#8220;XPG4&#8221;)");
	case(ROFF_xpg4_2):
		return("X/Open Portability Guide Issue 4.2 (&#8220;XPG4.2&#8221;)");
	case(ROFF_xpg4_3):
		return("X/Open Portability Guide Issue 4.3 (&#8220;XPG4.3&#8221;)");
	case(ROFF_xbd5):
		return("X/Open System Interface Definitions Issue 5 (&#8220;XBD5&#8221;)");
	case(ROFF_xcu5):
		return("X/Open Commands and Utilities Issue 5 (&#8220;XCU5&#8221;)");
	case(ROFF_xsh5):
		return("X/Open System Interfaces and Headers Issue 5 (&#8220;XSH5&#8221;)");
	case(ROFF_xns5):
		return("X/Open Networking Services Issue 5 (&#8220;XNS5&#8221;)");
	case(ROFF_xns5_2d2_0):
		return("X/Open Networking Services Issue 5.2 Draft 2.0 (&#8220;XNS5.2D2.0&#8221;)");
	case(ROFF_xcurses4_2):
		return("X/Open Curses Issue 4 Version 2 (&#8220;XCURSES4.2&#8221;)");
	case(ROFF_susv2):
		return("Version 2 of the Single UNIX Specification");
	case(ROFF_susv3):
		return("Version 3 of the Single UNIX Specification");
	case(ROFF_svid4):
		return("System V Interface Definition, Fourth Edition (&#8220;SVID4&#8221;)");
	default:
		break;
	}

	abort();
	/* NOTREACHED */
}


static char *
mlg_At_literal(const char *p)
{

	if (NULL == p)
		return("AT&amp;T UNIX");
	if (0 == strcmp(p, "v6"))
		return("Version 6 AT&amp;T UNIX");
	else if (0 == strcmp(p, "v7")) 
		return("Version 7 AT&amp;T UNIX");
	else if (0 == strcmp(p, "32v"))
		return("Version 32v AT&amp;T UNIX");
	else if (0 == strcmp(p, "V.1"))
		return("AT&amp;T System V.1 UNIX");
	else if (0 == strcmp(p, "V.4"))
		return("AT&amp;T System V.4 UNIX");

	abort();
	/* NOTREACHED */
}


static char *
mlg_fmt(int tok)
{

	switch (tok) {
	case (ROFF_Ex):
		return ("The %s utility exits 0 on success, and "
				"&gt;0 if an error occurs.");
	case (ROFF_Rv):
		return ("The %s() function returns the value 0 if "
				"successful; otherwise the value -1 "
				"is returned and the global variable "
				"<span class=\"inline-Va\">errno</span> "
				"is set to indicate the error.");
	case (ROFF_In):
		return("#include &lt;%s&gt;");
	default:
		break;
	}

	abort();
	/* NOTREACHED */
}


static char *
mlg_literal(int tok)
{

	switch (tok) {
	case (ROFF_Bt):
		return("is currently in beta test.");
	case (ROFF_Ud):
		return("currently under development.");
	case (ROFF_Fx):
		return("FreeBSD");
	case (ROFF_Nx):
		return("NetBSD");
	case (ROFF_Ox):
		return("OpenBSD");
	case (ROFF_Ux):
		return("UNIX");
	case (ROFF_Bx):
		return("BSD");
	case (ROFF_Bsx):
		return("BSDI BSD/OS");
	default:
		break;
	}
	abort();
	/* NOTREACHED */
}


d129 1
a129 1
		int *argc, char **argv)
d168 2
a169 2
	res = (*p->cbs.ml_begintag)(p->mbuf, p->data, p->args, ns, tok,
			argc, (const char **)argv);
d310 2
a311 1
mlg_data(struct md_mlg *p, int space, const char *start, char *buf)
d456 136
d595 1
a595 1
		const int *argc, const char **argv, char **more)
a597 1
	char		 buf[256];
a601 4
	/*
	 * First handle macros without content.
	 */
	
d606 1
a613 7
	default:
		break;
	}

	/* 
	 * Handle macros put into different-token tags.
	 */
a614 1
	switch (tok) {
d616 1
a616 57
		assert(*more);
		if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
			return(0);
		if ( ! mlg_string(p, start, *more++))
			return(0);
		if ( ! mlg_endtag(p, MD_NS_INLINE, tok))
			return(0);
		if (*more) {
			if ( ! ml_nputs(p->mbuf, "(", 1, &p->pos))
				return(0);
			p->flags |= ML_OVERRIDE_ONE;
			if ( ! mlg_begintag(p, MD_NS_INLINE, 
						ROFF_Fa, NULL, more))
				return(0);
			if ( ! mlg_string(p, start, *more++))
				return(0);
			if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Fa))
				return(0);
			while (*more) {
				if ( ! ml_nputs(p->mbuf, ", ", 2, &p->pos))
					return(0);
				if ( ! mlg_begintag(p, MD_NS_INLINE, ROFF_Fa, NULL, more))
					return(0);
				if ( ! mlg_string(p, start, *more++))
					return(0);
				if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Fa))
					return(0);
			}
			if ( ! ml_nputs(p->mbuf, ")", 1, &p->pos))
				return(0);
		}
		return(1);
	default:
		break;
	}

	/*
	 * Now handle macros in their environments. 
	 */

	if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, more))
		return(0);

	switch (tok) {
	case (ROFF_St):
		assert(NULL == *argv);
		assert(ROFF_ARGMAX != *argc);
		if ( ! ml_puts(p->mbuf, mlg_St_literal(*argc),
					&p->pos))
			return(0);
		while (*more) { 
			if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
				return(0);
			if ( ! mlg_string(p, start, *more++))
				return(0);
		}
		break;
d619 3
a621 21
		if ( ! *more) {
			mlg_err(p, start, start, "missing argument");
			return(0);
		}
		if ( ! ml_puts(p->mbuf, *more++, &p->pos))
			return(0);
		if (*more) {
			if ( ! ml_nputs(p->mbuf, "(", 1, &p->pos))
				return(0);
			if ( ! mlg_string(p, start, *more++))
				return(0);
			if ( ! ml_nputs(p->mbuf, ")", 1, &p->pos))
				return(0);
		}
		if (*more) {
			mlg_err(p, start, start, "too many arguments");
			return(0);
		}
		break;

	case (ROFF_Sx):
d624 1
a624 5
		assert(*more);
		if ( ! mlg_string(p, start, *more++))
			return(0);
		assert(NULL == *more);
		break;
d631 2
a632 8
		assert(*more);
		/* FIXME: *more must be ml-filtered. */
		(void)snprintf(buf, sizeof(buf), 
				mlg_fmt(tok), *more++);
		if ( ! ml_puts(p->mbuf, buf, &p->pos))
			return(0);
		assert(NULL == *more);
		break;
d635 7
a641 5
		/* FIXME: *more must be ml-filtered. */
		if ( ! ml_puts(p->mbuf, mlg_At_literal(*more), &p->pos))
			return(0);
		break;

d650 2
d653 3
a655 8
		if ( ! ml_puts(p->mbuf, mlg_literal(tok), &p->pos))
			return(0);
		while (*more) { 
			if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
				return(0);
			if ( ! mlg_string(p, start, *more++))
				return(0);
		}
a656 15

	case (ROFF_Bt):
		/* FALLTHROUGH */
	case (ROFF_Ud):
		/* FALLTHROUGH */
	case (ROFF_Ux):
		assert(NULL == *more);
		if ( ! ml_puts(p->mbuf, mlg_literal(tok), &p->pos))
			return(0);
		break;

	default:
		mlg_err(p, start, start, "`%s' not yet supported",
				toknames[tok]);
		return(0);
d659 3
a661 1
	return(mlg_endtag(p, MD_NS_INLINE, tok));
d666 2
a667 1
mlg_roffblkin(void *arg, int tok, int *argc, char **argv)
d684 2
a685 1
mlg_roffblkbodyin(void *arg, int tok, int *argc, char **argv)
d702 2
a703 1
mlg_roffblkheadin(void *arg, int tok, int *argc, char **argv)
d720 1
a720 1
mlg_roffin(void *arg, int tok, int *argc, char **argv)
d737 2
a738 2
mlg_roffmsg(void *arg, enum roffmsg lvl, 
		const char *buf, const char *pos, char *msg)
d746 2
a747 1
mlg_roffdata(void *arg, int space, const char *start, char *buf)
a757 1

d787 1
a787 1
		const char *buf, const char *pos, char *msg)
@


1.18
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.17 2008/12/07 14:38:57 kristaps Exp $ */
d95 4
a102 2
static	void		 mlg_warn(struct md_mlg *, const char *, 
				const char *, const char *, ...);
d425 37
a464 1
	int		 c;
d478 1
a478 10

		c = ml_nputstring(p->mbuf, buf, sz, &p->pos);

		if (0 == c) {
			mlg_err(p, start, buf, "bad char sequence");
			return(0);
		} else if (c > 1) {
			mlg_warn(p, start, buf, "bogus char sequence");
			return(0);
		} else if (-1 == c)
d498 1
a498 12
	c = ml_nputstring(p->mbuf, buf, sz, &p->pos);

	if (0 == c) {
		mlg_err(p, start, buf, "bad char sequence");
		return(0);
	} else if (c > 1) {
		mlg_warn(p, start, buf, "bogus char sequence");
		return(0);
	} else if (-1 == c)
		return(0);

	return(1);
d646 1
a646 1
		if ( ! ml_putstring(p->mbuf, *more++, &p->pos))
d657 1
a657 1
			if ( ! ml_putstring(p->mbuf, *more++, &p->pos))
d666 1
a666 1
				if ( ! ml_putstring(p->mbuf, *more++, &p->pos))
d696 1
a696 1
			if ( ! ml_putstring(p->mbuf, *more++, &p->pos))
d711 1
a711 1
			if ( ! ml_puts(p->mbuf, *more++, &p->pos))
d721 1
d726 1
a726 1
		if ( ! ml_putstring(p->mbuf, *more++, &p->pos))
d744 1
d746 1
d750 1
d765 1
a765 1
			if ( ! ml_putstring(p->mbuf, *more++, &p->pos))
d769 1
d779 1
a895 12
mlg_warn(struct md_mlg *p, const char *start, 
		const char *pos, const char *fmt, ...)
{
	va_list		 ap;

	va_start(ap, fmt);
	mlg_vmsg(p, ROFF_WARN, start, pos, fmt, ap);
	va_end(ap);
}


static void
@


1.17
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.16 2008/12/06 21:10:31 kristaps Exp $ */
d237 2
d619 46
d707 1
a707 1
		if ( ! ml_puts(p->mbuf, *more++, &p->pos))
d711 3
a713 1

d718 1
@


1.16
log
@.St macros in place.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.15 2008/12/06 19:41:41 kristaps Exp $ */
d65 1
d204 1
d224 23
d249 1
d593 1
d663 1
d665 2
d668 3
a670 11
		if ( ! ml_puts(p->mbuf, "The ", &p->pos))
			return(0);
		if ( ! mlg_begintag(p, MD_NS_INLINE, ROFF_Xr, NULL, NULL))
			return(0);
		if ( ! ml_puts(p->mbuf, *more++, &p->pos))
			return(0);
		if ( ! mlg_endtag(p, MD_NS_INLINE, ROFF_Xr))
			return(0);
		if ( ! ml_puts(p->mbuf, " utility exits 0 on success, "
					"and &gt;0 if an error "
					"occurs.", &p->pos))
@


1.15
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.14 2008/12/06 16:50:18 kristaps Exp $ */
d65 1
d79 2
a80 1
				const char *, char **);
d113 88
d561 1
d563 2
a564 1
mlg_roffspecial(void *arg, int tok, const char *start, char **more)
d594 14
@


1.14
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.13 2008/12/06 13:18:44 kristaps Exp $ */
d63 2
d110 49
d479 4
d484 11
a494 9
	case (ROFF_Bt):
		assert(NULL == *more);
		if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, NULL))
			return(0);
		if ( ! ml_puts(p->mbuf, "is currently in beta "
					"test.", &p->pos))
			return(0);
		if ( ! mlg_endtag(p, MD_NS_INLINE, tok))
			return(0);
d496 4
d501 1
a506 2
		if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, NULL))
			return(0);
a520 2
		if ( ! mlg_endtag(p, MD_NS_INLINE, tok))
			return(0);
d522 2
a523 1

a525 2
		if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, NULL))
			return(0);
a528 14
		if ( ! mlg_endtag(p, MD_NS_INLINE, tok))
			return(0);
		break;

	case (ROFF_Ns):
		p->flags |= ML_OVERRIDE_ONE;
		break;

	case (ROFF_Sm):
		assert(*more);
		if (0 == strcmp(*more, "on"))
			p->flags |= ML_OVERRIDE_ALL;
		else
			p->flags &= ~ML_OVERRIDE_ALL;
a529 1

a531 2
		if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, NULL))
			return(0);
d545 3
a547 1
		if ( ! mlg_endtag(p, MD_NS_INLINE, tok))
d550 20
a569 1

d571 2
d574 1
a574 6
		if ( ! mlg_begintag(p, MD_NS_INLINE, tok, NULL, NULL))
			return(0);
		if ( ! ml_puts(p->mbuf, "currently under "
					"development.", &p->pos))
			return(0);
		if ( ! mlg_endtag(p, MD_NS_INLINE, tok))
a576 1

d583 1
a583 1
	return(1);
@


1.13
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.12 2008/12/05 22:34:30 kristaps Exp $ */
d429 11
d509 11
@


1.12
log
@Nm works properly, many other changes, etc.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.11 2008/12/05 19:45:15 kristaps Exp $ */
d22 1
d93 1
a93 1
				const char *, char *);
d95 1
a95 1
				const char *, char *);
d98 3
d453 1
a453 3
	case (ROFF_Fn):
		abort(); /* TODO */
		break;
d464 1
d468 1
d476 22
d499 3
a501 1
		break;
d603 2
a604 1
mlg_err(struct md_mlg *p, const char *buf, const char *pos, char *msg)
d606 1
d608 2
a609 1
	mlg_msg(p, ROFF_ERROR, buf, pos, msg);
d614 2
a615 1
mlg_warn(struct md_mlg *p, const char *buf, const char *pos, char *msg)
d617 1
d619 15
a633 1
	mlg_msg(p, ROFF_WARN, buf, pos, msg);
a662 1

@


1.11
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.10 2008/12/05 17:43:14 kristaps Exp $ */
d450 11
@


1.10
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.9 2008/12/05 11:28:17 kristaps Exp $ */
d54 1
a54 4
	ml_begintag	  begintag;
	ml_endtag	  endtag;
	ml_begin	  begin;
	ml_end		  end;
d145 1
a145 1
	res = (*p->begintag)(p->mbuf, p->data, p->args, ns, tok,
d194 1
a194 1
	res = (*p->endtag)(p->mbuf, p->data, p->args, ns, tok);
a233 1
	size_t		 dummy;
a234 2
	if ( ! ml_nputs(p->mbuf, "\n", 1, &dummy))
		return(0);
d236 1
a236 1
	return(1);
d326 3
d334 1
a334 1
mlg_alloc(const struct md_args *args, void *data,
d337 1
a337 2
		ml_begintag begintag, ml_endtag endtag,
		ml_begin begin, ml_end end)
a361 5
	p->begintag = begintag;
	p->endtag = endtag;
	p->begin = begin;
	p->end = end;
	p->data = data;
d363 5
a367 1
	if (NULL == (p->tree = roff_alloc(&cb, p))) {
d369 2
a370 2
		return(NULL);
	}
d372 1
a372 1
	return(p);
d386 2
a387 1
	if ( ! (*p->begin)(p->mbuf, p->args, tm, os, title, sec, vol))
d403 5
a407 1
	if (0 != p->pos && ! mlg_newline(p))
a410 2
	if ( ! (*p->end)(p->mbuf, p->args))
		return(0);
d558 1
@


1.9
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.8 2008/12/04 23:10:51 kristaps Exp $ */
d61 1
d148 1
a148 1
	res = (*p->begintag)(p->mbuf, p->args, ns, tok,
d197 1
a197 1
	res = (*p->endtag)(p->mbuf, p->args, ns, tok);
d337 1
a337 1
mlg_alloc(const struct md_args *args, 
d370 1
@


1.8
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.7 2008/12/04 19:31:57 kristaps Exp $ */
a84 1
static	int		 mlg_endblk(struct md_mlg *, enum md_ns, int);
a106 21
mlg_endblk(struct md_mlg *p, enum md_ns ns, int tok)
{

	p->indent--;

	if (0 != p->pos) {
		if ( ! mlg_newline(p))
			return(0);
		if ( ! mlg_indent(p))
			return(0);
	} else if ( ! mlg_indent(p))
		return(0);

	mlg_mode(p, MD_BLK_OUT);
	if ( ! mlg_endtag(p, ns, tok))
		return(0);
	return(mlg_newline(p));
}


static int
d118 1
a118 1
				p->pos + 11 > COLUMNS) 
d176 16
a191 1
	/* TODO: extra rules for block/inline. */
d203 11
a213 1
	/* TODO: extra rules for block/inline. */
d215 1
a215 1
	return(ml_nputs(p->mbuf, ">", 1, &p->pos));
d224 2
a225 1
	count = p->indent > MAXINDENT ? (size_t)MAXINDENT : p->indent;
a415 1
/* ARGSUSED */
d427 1
a427 2
			mlg_err(p, start, start,
					"missing required argument");
d437 1
a437 1
			if ( ! mlg_data(p, 0, start, *more++))
a447 1
		mlg_mode(p, MD_INLINE_OUT);
d482 1
a482 1
	return(mlg_endblk((struct md_mlg *)arg, MD_NS_BLOCK, tok));
d499 1
a499 1
	return(mlg_endblk((struct md_mlg *)arg, MD_NS_BODY, tok));
d516 1
a516 1
	return(mlg_endblk((struct md_mlg *)arg, MD_NS_HEAD, tok));
a531 7
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	if (0 == p->pos && ! mlg_indent(p))
		return(0);
d533 1
a533 2
	mlg_mode(p, MD_INLINE_OUT);
	return(mlg_endtag(p, MD_NS_INLINE, tok));
@


1.7
log
@Moved charset recognition into the filter.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.6 2008/12/04 16:34:59 kristaps Exp $ */
d76 2
a77 2
static	int		 mlg_roffspecial(void *, int, int *, 
				char **, char **);
a84 2
static	int		 mlg_beginblk(struct md_mlg *, enum md_ns, int, 
				int *, char **);
a107 21
mlg_beginblk(struct md_mlg *p, enum md_ns ns, int tok, 
		int *argc, char **argv)
{
	if (0 != p->pos) {
		if ( ! mlg_newline(p))
			return(0);
		if ( ! mlg_indent(p))
			return(0);
	} else if ( ! mlg_indent(p))
		return(0);

	p->indent++;
	mlg_mode(p, MD_BLK_IN);

	if ( ! mlg_begintag(p, ns, tok, argc, argv))
		return(0);
	return(mlg_newline(p));
}


static int
d134 31
a164 1
	/* TODO: extra rules for block/inline. */
d177 11
a187 1
	/* TODO: extra rules for block/inline. */
d189 1
a189 1
	return(ml_nputs(p->mbuf, ">", 1, &p->pos));
a253 1
	char		*bufp;
d263 1
a263 3
	while (*buf) {
		while (*buf && isspace(*buf))
			buf++;
d265 3
a267 2
		if (0 == *buf)
			break;
d269 1
a269 3
		bufp = buf;
		while (*buf && ! isspace(*buf))
			buf++;
d271 8
a278 2
		if (0 != *buf)
			*buf++ = 0;
d280 2
a281 4
		sz = strlen(bufp);

		if (0 == p->pos) {
			if ( ! mlg_indent(p))
d284 2
a285 11
			c = ml_nputstring(p->mbuf, bufp, sz, &p->pos);
			if (0 == c) {
				mlg_err(p, start, bufp, "invalid "
						"character sequence");
				return(0);
			} else if (c > 1) {
				mlg_warn(p, start, bufp, "bogus "
						"character sequence");
				return(0);
			} else if (-1 == c)
				return(0);
d287 2
a288 22
			if (p->indent * INDENT + sz >= COLUMNS)
				if ( ! mlg_newline(p))
					return(0);
			if ( ! (ML_OVERRIDE_ALL & p->flags))
				space = 1;
			continue;
		}

		if (space && sz + p->pos >= COLUMNS) {
			if ( ! mlg_newline(p))
				return(0);
			if ( ! mlg_indent(p))
				return(0);
		} else if (space) {
			if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
				return(0);
		}

		c = ml_nputstring(p->mbuf, bufp, sz, &p->pos);
		if (0 == c) {
			mlg_err(p, start, bufp, "invalid "
					"character sequence");
d290 1
a290 3
		} else if (c > 1) {
			mlg_warn(p, start, bufp, "bogus "
					"character sequence");
d292 2
a293 1
		} else if (-1 == c)
d295 1
d297 10
a306 3
		if ( ! (ML_OVERRIDE_ALL & p->flags))
			space = 1;
	}
d414 1
a414 1
mlg_roffspecial(void *arg, int tok, int *argc, char **argv, char **more)
d422 28
d472 1
a472 1
	return(mlg_beginblk((struct md_mlg *)arg, 
d489 1
a489 1
	return(mlg_beginblk((struct md_mlg *)arg, 
d506 1
a506 1
	return(mlg_beginblk((struct md_mlg *)arg, 
a521 22
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	/* FIXME: this part. */

	if ( ! (ML_OVERRIDE_ONE & p->flags) && 
			! (ML_OVERRIDE_ALL & p->flags) && 
			p->pos + 11 > COLUMNS) 
		if ( ! mlg_newline(p))
			return(0);

	if (0 != p->pos && (MD_TEXT == p->last || 
				MD_INLINE_OUT == p->last)
			&& ! (ML_OVERRIDE_ONE & p->flags)
			&& ! (ML_OVERRIDE_ALL & p->flags))
		if ( ! ml_nputs(p->mbuf, " ", 1, &p->pos))
			return(0);

	if (0 == p->pos && ! mlg_indent(p))
		return(0);
d523 2
a524 2
	mlg_mode(p, MD_INLINE_IN);
	return(mlg_begintag(p, MD_NS_INLINE, tok, argc, argv));
@


1.6
log
@Character-set validation fixes.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.5 2008/12/04 16:19:52 kristaps Exp $ */
a72 1
static	int		 mlg_rofftoken(void *, int, int);
a358 1
	cb.rofftoken = mlg_rofftoken;
a552 136
mlg_rofftoken(void *arg, int space, int value)
{
	struct md_mlg	*p;
	const char	*seq;
	size_t		 sz, res;

	assert(arg);
	p = (struct md_mlg *)arg;

	switch (value) {
	case (ROFFTok_Sp_A):
		seq = "\\a";
		sz = 2;
		break;
	case (ROFFTok_Sp_B):
		seq = "\\b";
		sz = 2;
		break;
	case (ROFFTok_Sp_F):
		seq = "\\f";
		sz = 2;
		break;
	case (ROFFTok_Sp_N):
		seq = "\\n";
		sz = 2;
		break;
	case (ROFFTok_Sp_R):
		seq = "\\r";
		sz = 2;
		break;
	case (ROFFTok_Sp_T):
		seq = "\\t";
		sz = 2;
		break;
	case (ROFFTok_Sp_V):
		seq = "\\v";
		sz = 2;
		break;
	case (ROFFTok_Space):
		seq = "&nbsp;";
		sz = 6;
		break;
	case (ROFFTok_Hyphen):
		seq = "&#8208;";
		sz = 7;
		break;
	case (ROFFTok_Em):
		seq = "&#8212;";
		sz = 7;
		break;
	case (ROFFTok_En):
		seq = "&#8211;";
		sz = 7;
		break;
	case (ROFFTok_Ge):
		seq = "&#8805;";
		sz = 7;
		break;
	case (ROFFTok_Le):
		seq = "&#8804;";
		sz = 7;
		break;
	case (ROFFTok_Rquote):
		seq = "&#8221;";
		sz = 7;
		break;
	case (ROFFTok_Lquote):
		seq = "&#8220;";
		sz = 7;
		break;
	case (ROFFTok_Uparrow):
		seq = "&#8593;";
		sz = 7;
		break;
	case (ROFFTok_Acute):
		seq = "&#180;";
		sz = 6;
		break;
	case (ROFFTok_Grave):
		seq = "&#96;";
		sz = 5;
		break;
	case (ROFFTok_Pi):
		seq = "&#960;";
		sz = 6;
		break;
	case (ROFFTok_Ne):
		seq = "&#8800;";
		sz = 7;
		break;
	case (ROFFTok_Lt):
		seq = "&lt;";
		sz = 4;
		break;
	case (ROFFTok_Gt):
		seq = "&gt;";
		sz = 4;
		break;
	case (ROFFTok_Plusmin):
		seq = "&#177;";
		sz = 6;
		break;
	case (ROFFTok_Infty):
		seq = "&#8734;";
		sz = 7;
		break;
	case (ROFFTok_Bar):
		seq = "&#124;";
		sz = 6;
		break;
	case (ROFFTok_Nan):
		seq = "Nan";
		sz = 3;
		break;
	case (ROFFTok_Quote):
		seq = "&quot;";
		sz = 6;
		break;
	default:
		/* TODO: print error. */
		return(0);
	}

	if (space && ! ml_nputs(p->mbuf, " ", 1, &res))
		return(0);
	p->pos += res;

	if ( ! ml_nputs(p->mbuf, seq, sz, &res))
		return(0);
	p->pos += res;

	return(1);
}


static int
@


1.5
log
@Character-encoding tests.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.4 2008/12/04 11:25:29 kristaps Exp $ */
a596 4
	case (ROFFTok_Null):
		seq = "";
		sz = 0;
		break;
d669 7
d682 1
a682 1
	if (0 != sz && ! ml_nputs(p->mbuf, seq, sz, &res))
@


1.4
log
@More html-css.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.3 2008/12/03 21:27:56 kristaps Exp $ */
d71 3
a73 1
static	int		 mlg_roffdata(void *, int, char *);
d79 2
a80 1
static	int		 mlg_roffblkheadin(void *, int, int *, char **);
d82 2
a83 1
static	int		 mlg_roffblkbodyin(void *, int, int *, char **);
d95 8
a102 1
static	int		 mlg_data(struct md_mlg *, int, char *);
d235 1
a235 1
mlg_data(struct md_mlg *p, int space, char *buf)
d239 1
d267 11
a277 2
			if ( ! ml_nputstring(p->mbuf, bufp, 
						sz, &p->pos))
d279 1
d298 10
a307 1
		if ( ! ml_nputstring(p->mbuf, bufp, sz, &p->pos))
d360 1
d549 141
a689 1
	char		*level;
d695 30
a746 17


static int
mlg_roffdata(void *arg, int space, char *buf)
{
	struct md_mlg	*p;

	assert(arg);
	p = (struct md_mlg *)arg;

	if ( ! mlg_data(p, space, buf))
		return(0);

	mlg_mode(p, MD_TEXT);
	return(1);
}

@


1.3
log
@Initial html outputs working.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.2 2008/12/03 19:21:58 kristaps Exp $ */
d66 3
a68 1
static	int		 mlg_roffhead(void *);
d351 2
a352 1
mlg_roffhead(void *arg)
d360 1
a360 1
	if ( ! (*p->begin)(p->mbuf, p->args))
@


1.2
log
@Major update.
@
text
@d1 1
a1 1
/* $Id: mlg.c,v 1.1 2008/12/03 14:39:59 kristaps Exp $ */
d192 1
a192 1
	count = p->indent > MAXINDENT ? MAXINDENT : p->indent;
d215 1
d256 1
a256 1
			if (p->indent * MAXINDENT + sz >= COLUMNS)
@


1.1
log
@Abstract ml/mlg/html/xml.
@
text
@d1 1
a1 1
/* $Id: ml.c,v 1.1 2008/12/02 18:26:57 kristaps Exp $ */
d34 1
a34 1
#define	MAXINDENT	  8
d56 2
d73 10
a82 1
static	int		 mlg_roffspecial(void *, int, int *, char **, char **);
d98 42
d307 2
a308 1
		ml_begintag begintag, ml_endtag endtag)
d318 4
d335 2
d356 1
a356 1
	if ( ! mlg_begintag(p, MD_NS_DEFAULT, -1, NULL, NULL))
d376 1
a376 1
	if ( ! mlg_endtag(p, -1, MD_NS_DEFAULT))
a413 1
	struct md_mlg	*p;
d415 20
a434 2
	assert(arg);
	p = (struct md_mlg *)arg;
a435 7
	if (0 != p->pos) {
		if ( ! mlg_newline(p))
			return(0);
		if ( ! mlg_indent(p))
			return(0);
	} else if ( ! mlg_indent(p))
		return(0);
d437 3
a439 2
	p->indent++;
	mlg_mode(p, MD_BLK_IN);
d441 1
a441 3
	if ( ! mlg_begintag(p, MD_NS_BLOCK, tok, argc, argv))
		return(0);
	return(mlg_newline(p));
d446 1
a446 1
mlg_roffblkout(void *arg, int tok)
a447 1
	struct md_mlg	*p;
d449 3
a451 2
	assert(arg);
	p = (struct md_mlg *)arg;
a452 1
	p->indent--;
d454 3
a456 7
	if (0 != p->pos) {
		if ( ! mlg_newline(p))
			return(0);
		if ( ! mlg_indent(p))
			return(0);
	} else if ( ! mlg_indent(p))
		return(0);
d458 1
a458 4
	mlg_mode(p, MD_BLK_OUT);
	if ( ! mlg_endtag(p, MD_NS_BLOCK, tok))
		return(0);
	return(mlg_newline(p));
@
