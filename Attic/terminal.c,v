head	1.13;
access;
symbols
	VERSION_1_9_5:1.13
	VERSION_1_8_5:1.13
	VERSION_1_8_1:1.13
	VERSION_1_7_16:1.13
	VERSION_1_7_15:1.13
	OPENBSD_CHECKIN:1.13
	VERSION_1_7_5:1.10
	VERSION_1_6_5:1.4
	VERSION_1_6_2:1.3;
locks; strict;
comment	@ * @;


1.13
date	2009.03.31.13.50.19;	author kristaps;	state dead;
branches;
next	1.12;

1.12
date	2009.03.26.16.47.13;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.03.26.16.44.22;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.03.26.14.44.41;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.26.14.38.11;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.25.21.46.24;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.03.23.15.20.51;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.03.22.19.10.48;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.21.13.09.29;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.20.22.01.07;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.20.15.14.01;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.19.16.40.49;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.19.16.17.27;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.13
log
@General clean-ups.
@
text
@@


1.12
log
@*** empty log message ***
@
text
@a0 595
/* $Id: terminal.c,v 1.11 2009/03/26 16:44:22 kristaps Exp $ */
/*
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <assert.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "term.h"
#include "man.h"
#include "mdoc.h"

extern	int		  man_run(struct termp *, 
				const struct man *);
extern	int		  mdoc_run(struct termp *, 
				const struct mdoc *);

static	struct termp	 *term_alloc(enum termenc);
static	void		  term_free(struct termp *);
static	void		  term_pword(struct termp *, const char *, int);
static	void		  term_pescape(struct termp *, 
				const char *, int *, int);
static	void		  term_nescape(struct termp *,
				const char *, size_t);
static	void		  term_chara(struct termp *, char);
static	void		  term_stringa(struct termp *, 
				const char *, size_t);
static	int		  term_isopendelim(const char *, int);
static	int		  term_isclosedelim(const char *, int);


void *
ascii_alloc(void)
{

	return(term_alloc(TERMENC_ASCII));
}


int
terminal_run(void *arg, const struct man *man,
		const struct mdoc *mdoc)
{
	struct termp	*p;

	p = (struct termp *)arg;

	if (NULL == p->symtab)
		p->symtab = term_ascii2htab();

	if (man)
		return(man_run(p, man));
	if (mdoc)
		return(mdoc_run(p, mdoc));

	return(1);
}


void
terminal_free(void *arg)
{

	term_free((struct termp *)arg);
}


static void
term_free(struct termp *p)
{

	if (p->buf)
		free(p->buf);
	if (TERMENC_ASCII == p->enc && p->symtab)
		term_asciifree(p->symtab);

	free(p);
}


static struct termp *
term_alloc(enum termenc enc)
{
	struct termp *p;

	if (NULL == (p = malloc(sizeof(struct termp))))
		err(1, "malloc");
	bzero(p, sizeof(struct termp));
	p->maxrmargin = 78;
	p->enc = enc;
	return(p);
}


static int
term_isclosedelim(const char *p, int len)
{

	if (1 != len)
		return(0);

	switch (*p) {
	case('.'):
		/* FALLTHROUGH */
	case(','):
		/* FALLTHROUGH */
	case(';'):
		/* FALLTHROUGH */
	case(':'):
		/* FALLTHROUGH */
	case('?'):
		/* FALLTHROUGH */
	case('!'):
		/* FALLTHROUGH */
	case(')'):
		/* FALLTHROUGH */
	case(']'):
		/* FALLTHROUGH */
	case('}'):
		return(1);
	default:
		break;
	}

	return(0);
}


static int
term_isopendelim(const char *p, int len)
{

	if (1 != len)
		return(0);

	switch (*p) {
	case('('):
		/* FALLTHROUGH */
	case('['):
		/* FALLTHROUGH */
	case('{'):
		return(1);
	default:
		break;
	}

	return(0);
}


/*
 * Flush a line of text.  A "line" is loosely defined as being something
 * that should be followed by a newline, regardless of whether it's
 * broken apart by newlines getting there.  A line can also be a
 * fragment of a columnar list.
 *
 * Specifically, a line is whatever's in p->buf of length p->col, which
 * is zeroed after this function returns.
 *
 * The variables TERMP_NOLPAD, TERMP_LITERAL and TERMP_NOBREAK are of
 * critical importance here.  Their behaviour follows:
 *
 *  - TERMP_NOLPAD: when beginning to write the line, don't left-pad the
 *    offset value.  This is useful when doing columnar lists where the
 *    prior column has right-padded.
 *
 *  - TERMP_NOBREAK: this is the most important and is used when making
 *    columns.  In short: don't print a newline and instead pad to the
 *    right margin.  Used in conjunction with TERMP_NOLPAD.
 *
 *  - TERMP_NONOBREAK: don't newline when TERMP_NOBREAK is specified.
 *
 *  In-line line breaking:
 *
 *  If TERMP_NOBREAK is specified and the line overruns the right
 *  margin, it will break and pad-right to the right margin after
 *  writing.  If maxrmargin is violated, it will break and continue
 *  writing from the right-margin, which will lead to the above
 *  scenario upon exit.
 *
 *  Otherwise, the line will break at the right margin.  Extremely long
 *  lines will cause the system to emit a warning (TODO: hyphenate, if
 *  possible).
 */
void
term_flushln(struct termp *p)
{
	int		 i, j;
	size_t		 vsz, vis, maxvis, mmax, bp;

	/*
	 * First, establish the maximum columns of "visible" content.
	 * This is usually the difference between the right-margin and
	 * an indentation, but can be, for tagged lists or columns, a
	 * small set of values.
	 */

	assert(p->offset < p->rmargin);
	maxvis = p->rmargin - p->offset;
	mmax = p->maxrmargin - p->offset;
	bp = TERMP_NOBREAK & p->flags ? mmax : maxvis;
	vis = 0;

	/*
	 * If in the standard case (left-justified), then begin with our
	 * indentation, otherwise (columns, etc.) just start spitting
	 * out text.
	 */

	if ( ! (p->flags & TERMP_NOLPAD))
		/* LINTED */
		for (j = 0; j < (int)p->offset; j++)
			putchar(' ');

	for (i = 0; i < (int)p->col; i++) {
		/*
		 * Count up visible word characters.  Control sequences
		 * (starting with the CSI) aren't counted.  A space
		 * generates a non-printing word, which is valid (the
		 * space is printed according to regular spacing rules).
		 */

		/* LINTED */
		for (j = i, vsz = 0; j < (int)p->col; j++) {
			if (' ' == p->buf[j])
				break;
			else if (8 == p->buf[j])
				j += 1;
			else
				vsz++;
		}

		/*
		 * Do line-breaking.  If we're greater than our
		 * break-point and already in-line, break to the next
		 * line and start writing.  If we're at the line start,
		 * then write out the word (TODO: hyphenate) and break
		 * in a subsequent loop invocation.
		 */

		if ( ! (TERMP_NOBREAK & p->flags)) {
			if (vis && vis + vsz > bp) {
				putchar('\n');
				for (j = 0; j < (int)p->offset; j++)
					putchar(' ');
				vis = 0;
			} 
		} else if (vis && vis + vsz > bp) {
			putchar('\n');
			for (j = 0; j < (int)p->rmargin; j++)
				putchar(' ');
			vis = p->rmargin - p->offset;
		}

		/* 
		 * Write out the word and a trailing space.  Omit the
		 * space if we're the last word in the line or beyond
		 * our breakpoint.
		 */

		for ( ; i < (int)p->col; i++) {
			if (' ' == p->buf[i])
				break;
			putchar(p->buf[i]);
		}
		vis += vsz;
		if (i < (int)p->col && vis <= bp) {
			putchar(' ');
			vis++;
		}
	}

	/*
	 * If we've overstepped our maximum visible no-break space, then
	 * cause a newline and offset at the right margin.
	 */

	if ((TERMP_NOBREAK & p->flags) && vis >= maxvis) {
		if ( ! (TERMP_NONOBREAK & p->flags)) {
			putchar('\n');
			for (i = 0; i < (int)p->rmargin; i++)
				putchar(' ');
		}
		p->col = 0;
		return;
	}

	/*
	 * If we're not to right-marginalise it (newline), then instead
	 * pad to the right margin and stay off.
	 */

	if (p->flags & TERMP_NOBREAK) {
		if ( ! (TERMP_NONOBREAK & p->flags))
			for ( ; vis < maxvis; vis++)
				putchar(' ');
	} else
		putchar('\n');

	p->col = 0;
}


/* 
 * A newline only breaks an existing line; it won't assert vertical
 * space.  All data in the output buffer is flushed prior to the newline
 * assertion.
 */
void
term_newln(struct termp *p)
{

	p->flags |= TERMP_NOSPACE;
	if (0 == p->col) {
		p->flags &= ~TERMP_NOLPAD;
		return;
	}
	term_flushln(p);
	p->flags &= ~TERMP_NOLPAD;
}


/*
 * Asserts a vertical space (a full, empty line-break between lines).
 * Note that if used twice, this will cause two blank spaces and so on.
 * All data in the output buffer is flushed prior to the newline
 * assertion.
 */
void
term_vspace(struct termp *p)
{

	term_newln(p);
	putchar('\n');
}


/*
 * Break apart a word into "pwords" (partial-words, usually from
 * breaking up a phrase into individual words) and, eventually, put them
 * into the output buffer.  If we're a literal word, then don't break up
 * the word and put it verbatim into the output buffer.
 */
void
term_word(struct termp *p, const char *word)
{
	int 		 i, j, len;

	len = (int)strlen(word);

	if (p->flags & TERMP_LITERAL) {
		term_pword(p, word, len);
		return;
	}

	/* LINTED */
	for (j = i = 0; i < len; i++) {
		if (' ' != word[i]) {
			j++;
			continue;
		} 
		
		/* Escaped spaces don't delimit... */
		if (i && ' ' == word[i] && '\\' == word[i - 1]) {
			j++;
			continue;
		}

		if (0 == j)
			continue;
		assert(i >= j);
		term_pword(p, &word[i - j], j);
		j = 0;
	}
	if (j > 0) {
		assert(i >= j);
		term_pword(p, &word[i - j], j);
	}
}


/*
 * Determine the symbol indicated by an escape sequences, that is, one
 * starting with a backslash.  Once done, we pass this value into the
 * output buffer by way of the symbol table.
 */
static void
term_nescape(struct termp *p, const char *word, size_t len)
{
	const char	*rhs;
	size_t		 sz;

	if (NULL == (rhs = term_a2ascii(p->symtab, word, len, &sz))) 
		return;
	term_stringa(p, rhs, sz);
}


/*
 * Handle an escape sequence: determine its length and pass it to the
 * escape-symbol look table.  Note that we assume mdoc(3) has validated
 * the escape sequence (we assert upon badly-formed escape sequences).
 */
static void
term_pescape(struct termp *p, const char *word, int *i, int len)
{
	int		 j;

	if (++(*i) >= len)
		return;

	if ('(' == word[*i]) {
		(*i)++;
		if (*i + 1 >= len)
			return;

		term_nescape(p, &word[*i], 2);
		(*i)++;
		return;

	} else if ('*' == word[*i]) { 
		(*i)++;
		if (*i >= len)
			return;

		switch (word[*i]) {
		case ('('):
			(*i)++;
			if (*i + 1 >= len)
				return;

			term_nescape(p, &word[*i], 2);
			(*i)++;
			return;
		case ('['):
			break;
		default:
			term_nescape(p, &word[*i], 1);
			return;
		}
	
	} else if ('f' == word[*i]) {
		(*i)++;
		if (*i >= len)
			return;
		switch (word[*i]) {
		case ('B'):
			p->flags |= TERMP_BOLD;
			break;
		case ('I'):
			p->flags |= TERMP_UNDER;
			break;
		case ('P'):
			/* FALLTHROUGH */
		case ('R'):
			p->flags &= ~TERMP_STYLE;
			break;
		default:
			break;
		}
		return;

	} else if ('[' != word[*i]) {
		term_nescape(p, &word[*i], 1);
		return;
	}

	(*i)++;
	for (j = 0; word[*i] && ']' != word[*i]; (*i)++, j++)
		/* Loop... */ ;

	if (0 == word[*i])
		return;

	term_nescape(p, &word[*i - j], (size_t)j);
}


/*
 * Handle pwords, partial words, which may be either a single word or a
 * phrase that cannot be broken down (such as a literal string).  This
 * handles word styling.
 */
static void
term_pword(struct termp *p, const char *word, int len)
{
	int		 i;

	if (term_isclosedelim(word, len))
		if ( ! (TERMP_IGNDELIM & p->flags))
			p->flags |= TERMP_NOSPACE;

	if ( ! (TERMP_NOSPACE & p->flags))
		term_chara(p, ' ');

	if ( ! (p->flags & TERMP_NONOSPACE))
		p->flags &= ~TERMP_NOSPACE;

	/* 
	 * If ANSI (word-length styling), then apply our style now,
	 * before the word.
	 */

	for (i = 0; i < len; i++) {
		if ('\\' == word[i]) {
			term_pescape(p, word, &i, len);
			continue;
		}

		if (TERMP_STYLE & p->flags) {
			if (TERMP_BOLD & p->flags) {
				term_chara(p, word[i]);
				term_chara(p, 8);
			}
			if (TERMP_UNDER & p->flags) {
				term_chara(p, '_');
				term_chara(p, 8);
			}
		}

		term_chara(p, word[i]);
	}

	if (term_isopendelim(word, len))
		p->flags |= TERMP_NOSPACE;
}


/*
 * Like term_chara() but for arbitrary-length buffers.  Resize the
 * buffer by a factor of two (if the buffer is less than that) or the
 * buffer's size.
 */
static void
term_stringa(struct termp *p, const char *c, size_t sz)
{
	size_t		 s;

	if (0 == sz)
		return;

	assert(c);
	if (p->col + sz >= p->maxcols) {
		if (0 == p->maxcols)
			p->maxcols = 256;
		s = sz > p->maxcols * 2 ? sz : p->maxcols * 2;
		p->buf = realloc(p->buf, s);
		if (NULL == p->buf)
			err(1, "realloc");
		p->maxcols = s;
	}

	(void)memcpy(&p->buf[(int)p->col], c, sz);
	p->col += sz;
}


/*
 * Insert a single character into the line-buffer.  If the buffer's
 * space is exceeded, then allocate more space by doubling the buffer
 * size.
 */
static void
term_chara(struct termp *p, char c)
{
	size_t		 s;

	if (p->col + 1 >= p->maxcols) {
		if (0 == p->maxcols)
			p->maxcols = 256;
		s = p->maxcols * 2;
		p->buf = realloc(p->buf, s);
		if (NULL == p->buf)
			err(1, "realloc");
		p->maxcols = s;
	}
	p->buf[(int)(p->col)++] = c;
}

@


1.11
log
@Added simple font-escapes.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.10 2009/03/26 14:44:41 kristaps Exp $ */
d459 2
a460 1
		if (++(*i) >= len)
@


1.10
log
@Fixed after-NLINE-error assertion.
Scanned over all manuals with valgrind.
Version up.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.9 2009/03/26 14:38:11 kristaps Exp $ */
d457 20
@


1.9
log
@Initial front-end formatting for -man pages.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.8 2009/03/25 21:46:24 kristaps Exp $ */
a28 5
#ifdef __linux__
extern	size_t		  strlcpy(char *, const char *, size_t);
extern	size_t		  strlcat(char *, const char *, size_t);
#endif

@


1.8
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.7 2009/03/23 15:20:51 kristaps Exp $ */
d26 2
d34 5
a40 7
static	void		  term_body(struct termp *, struct termpair *,
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	void		  term_head(struct termp *,
				const struct mdoc_meta *);
static	void		  term_foot(struct termp *,
				const struct mdoc_meta *);
a50 1
static	void		  sanity(const struct mdoc_node *); /* XXX */
a66 3
	if (NULL == mdoc)
		return(1);

d72 4
a75 3
	term_head(p, mdoc_meta(mdoc));
	term_body(p, NULL, mdoc_meta(mdoc), mdoc_node(mdoc));
	term_foot(p, mdoc_meta(mdoc));
a402 185
static void
term_body(struct termp *p, struct termpair *ppair,
		const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	term_node(p, ppair, meta, node);
	if (node->next)
		term_body(p, ppair, meta, node->next);
}


/*
 * This is the main function for printing out nodes.  It's constituted
 * of PRE and POST functions, which correspond to prefix and infix
 * processing.  The termpair structure allows data to persist between
 * prefix and postfix invocations.
 */
void
term_node(struct termp *p, struct termpair *ppair,
		const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{
	int		 dochild;
	struct termpair	 pair;

	/* Some quick sanity-checking. */

	sanity(node);

	/* Pre-processing. */

	dochild = 1;
	pair.ppair = ppair;
	pair.type = 0;
	pair.offset = pair.rmargin = 0;
	pair.flag = 0;
	pair.count = 0;

	if (MDOC_TEXT != node->type) {
		if (termacts[node->tok].pre)
			if ( ! (*termacts[node->tok].pre)(p, &pair, meta, node))
				dochild = 0;
	} else /* MDOC_TEXT == node->type */
		term_word(p, node->string);

	/* Children. */

	if (TERMPAIR_FLAG & pair.type)
		p->flags |= pair.flag;

	if (dochild && node->child)
		term_body(p, &pair, meta, node->child);

	if (TERMPAIR_FLAG & pair.type)
		p->flags &= ~pair.flag;

	/* Post-processing. */

	if (MDOC_TEXT != node->type)
		if (termacts[node->tok].post)
			(*termacts[node->tok].post)(p, &pair, meta, node);
}


static void
term_foot(struct termp *p, const struct mdoc_meta *meta)
{
	struct tm	*tm;
	char		*buf, *os;

	if (NULL == (buf = malloc(p->rmargin)))
		err(1, "malloc");
	if (NULL == (os = malloc(p->rmargin)))
		err(1, "malloc");

	tm = localtime(&meta->date);

#ifdef __OpenBSD__
	if (NULL == strftime(buf, p->rmargin, "%B %d, %Y", tm))
#else
	if (0 == strftime(buf, p->rmargin, "%B %d, %Y", tm))
#endif
		err(1, "strftime");

	(void)strlcpy(os, meta->os, p->rmargin);

	/*
	 * This is /slightly/ different from regular groff output
	 * because we don't have page numbers.  Print the following:
	 *
	 * OS                                            MDOCDATE
	 */

	term_vspace(p);

	p->flags |= TERMP_NOSPACE | TERMP_NOBREAK;
	p->rmargin = p->maxrmargin - strlen(buf);
	p->offset = 0;

	term_word(p, os);
	term_flushln(p);

	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
	p->flags &= ~TERMP_NOBREAK;

	term_word(p, buf);
	term_flushln(p);

	free(buf);
	free(os);
}


static void
term_head(struct termp *p, const struct mdoc_meta *meta)
{
	char		*buf, *title;

	p->rmargin = p->maxrmargin;
	p->offset = 0;

	if (NULL == (buf = malloc(p->rmargin)))
		err(1, "malloc");
	if (NULL == (title = malloc(p->rmargin)))
		err(1, "malloc");

	/*
	 * The header is strange.  It has three components, which are
	 * really two with the first duplicated.  It goes like this:
	 *
	 * IDENTIFIER              TITLE                   IDENTIFIER
	 *
	 * The IDENTIFIER is NAME(SECTION), which is the command-name
	 * (if given, or "unknown" if not) followed by the manual page
	 * section.  These are given in `Dt'.  The TITLE is a free-form
	 * string depending on the manual volume.  If not specified, it
	 * switches on the manual section.
	 */

	assert(meta->vol);
	(void)strlcpy(buf, meta->vol, p->rmargin);

	if (meta->arch) {
		(void)strlcat(buf, " (", p->rmargin);
		(void)strlcat(buf, meta->arch, p->rmargin);
		(void)strlcat(buf, ")", p->rmargin);
	}

	(void)snprintf(title, p->rmargin, "%s(%d)", 
			meta->title, meta->msec);

	p->offset = 0;
	p->rmargin = (p->maxrmargin - strlen(buf)) / 2;
	p->flags |= TERMP_NOBREAK | TERMP_NOSPACE;

	term_word(p, title);
	term_flushln(p);

	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;
	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin - strlen(title);

	term_word(p, buf);
	term_flushln(p);

	p->offset = p->rmargin;
	p->rmargin = p->maxrmargin;
	p->flags &= ~TERMP_NOBREAK;
	p->flags |= TERMP_NOLPAD | TERMP_NOSPACE;

	term_word(p, title);
	term_flushln(p);

	p->rmargin = p->maxrmargin;
	p->offset = 0;
	p->flags &= ~TERMP_NOSPACE;

	free(title);
	free(buf);
}


a579 109

static void
sanity(const struct mdoc_node *n)
{

	switch (n->type) {
	case (MDOC_TEXT):
		if (n->child) 
			errx(1, "regular form violated (1)");
		if (NULL == n->parent) 
			errx(1, "regular form violated (2)");
		if (NULL == n->string)
			errx(1, "regular form violated (3)");
		switch (n->parent->type) {
		case (MDOC_TEXT):
			/* FALLTHROUGH */
		case (MDOC_ROOT):
			errx(1, "regular form violated (4)");
			/* NOTREACHED */
		default:
			break;
		}
		break;
	case (MDOC_ELEM):
		if (NULL == n->parent)
			errx(1, "regular form violated (5)");
		switch (n->parent->type) {
		case (MDOC_TAIL):
			/* FALLTHROUGH */
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			break;
		default:
			errx(1, "regular form violated (6)");
			/* NOTREACHED */
		}
		if (n->child) switch (n->child->type) {
		case (MDOC_TEXT):
			break;
		default:
			errx(1, "regular form violated (7(");
			/* NOTREACHED */
		}
		break;
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		if (NULL == n->parent)
			errx(1, "regular form violated (8)");
		if (MDOC_BLOCK != n->parent->type)
			errx(1, "regular form violated (9)");
		if (n->child) switch (n->child->type) {
		case (MDOC_BLOCK):
			/* FALLTHROUGH */
		case (MDOC_ELEM):
			/* FALLTHROUGH */
		case (MDOC_TEXT):
			break;
		default:
			errx(1, "regular form violated (a)");
			/* NOTREACHED */
		}
		break;
	case (MDOC_BLOCK):
		if (NULL == n->parent)
			errx(1, "regular form violated (b)");
		if (NULL == n->child)
			errx(1, "regular form violated (c)");
		switch (n->parent->type) {
		case (MDOC_ROOT):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			/* FALLTHROUGH */
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_TAIL):
			break;
		default:
			errx(1, "regular form violated (d)");
			/* NOTREACHED */
		}
		switch (n->child->type) {
		case (MDOC_ROOT):
			/* FALLTHROUGH */
		case (MDOC_ELEM):
			errx(1, "regular form violated (e)");
			/* NOTREACHED */
		default:
			break;
		}
		break;
	case (MDOC_ROOT):
		if (n->parent)
			errx(1, "regular form violated (f)");
		if (NULL == n->child)
			errx(1, "regular form violated (10)");
		switch (n->child->type) {
		case (MDOC_BLOCK):
			break;
		default:
			errx(1, "regular form violated (11)");
			/* NOTREACHED */
		}
		break;
	}
}
@


1.7
log
@-man printing linked to -Ttree.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.6 2009/03/22 19:10:48 kristaps Exp $ */
a54 16
latin1_alloc(void)
{

	return(term_alloc(TERMENC_LATIN1));
}


void *
utf8_alloc(void)
{

	return(term_alloc(TERMENC_UTF8));
}


void *
@


1.6
log
@Lint fixes.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.5 2009/03/21 13:09:29 kristaps Exp $ */
d79 2
a80 1
terminal_run(void *arg, const struct mdoc *mdoc)
d84 3
@


1.5
log
@`Em' accepts empty tokens.
Punctuation fully fixed (per-reserved-word).
Sm enabled.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.4 2009/03/20 22:01:07 kristaps Exp $ */
d49 2
a50 2
static	int		  term_isopendelim(const char *, size_t);
static	int		  term_isclosedelim(const char *, size_t);
d132 1
a132 1
term_isclosedelim(const char *p, size_t len)
d166 1
a166 1
term_isopendelim(const char *p, size_t len)
@


1.4
log
@Removed margin-break comment.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.3 2009/03/20 15:14:01 kristaps Exp $ */
d32 3
a34 3
static	struct termp	 *termp_alloc(enum termenc);
static	void		  termp_free(struct termp *);
static	void		  termp_body(struct termp *, struct termpair *,
d37 1
a37 1
static	void		  termp_head(struct termp *,
d39 1
a39 1
static	void		  termp_foot(struct termp *,
d41 2
a42 2
static	void		  termp_pword(struct termp *, const char *, int);
static	void		  termp_pescape(struct termp *, 
d44 1
a44 1
static	void		  termp_nescape(struct termp *,
d46 2
a47 2
static	void		  termp_chara(struct termp *, char);
static	void		  termp_stringa(struct termp *, 
d49 2
d58 1
a58 1
	return(termp_alloc(TERMENC_LATIN1));
d66 1
a66 1
	return(termp_alloc(TERMENC_UTF8));
d74 1
a74 1
	return(termp_alloc(TERMENC_ASCII));
d88 3
a90 3
	termp_head(p, mdoc_meta(mdoc));
	termp_body(p, NULL, mdoc_meta(mdoc), mdoc_node(mdoc));
	termp_foot(p, mdoc_meta(mdoc));
d100 1
a100 1
	termp_free((struct termp *)arg);
d105 1
a105 1
termp_free(struct termp *p)
d118 1
a118 1
termp_alloc(enum termenc enc)
d131 56
d388 1
a388 1
		termp_pword(p, word, len);
a391 6
	if (mdoc_isdelim(word)) {
		if ( ! (p->flags & TERMP_IGNDELIM))
			p->flags |= TERMP_NOSPACE;
		p->flags &= ~TERMP_IGNDELIM;
	}

d408 1
a408 1
		termp_pword(p, &word[i - j], j);
d413 1
a413 1
		termp_pword(p, &word[i - j], j);
d419 1
a419 1
termp_body(struct termp *p, struct termpair *ppair,
d426 1
a426 1
		termp_body(p, ppair, meta, node->next);
d470 1
a470 1
		termp_body(p, &pair, meta, node->child);
d484 1
a484 1
termp_foot(struct termp *p, const struct mdoc_meta *meta)
d535 1
a535 1
termp_head(struct termp *p, const struct mdoc_meta *meta)
d609 1
a609 1
termp_nescape(struct termp *p, const char *word, size_t len)
d616 1
a616 1
	termp_stringa(p, rhs, sz);
d626 1
a626 1
termp_pescape(struct termp *p, const char *word, int *i, int len)
d638 1
a638 1
		termp_nescape(p, &word[*i], 2);
d653 1
a653 1
			termp_nescape(p, &word[*i], 2);
d659 1
a659 1
			termp_nescape(p, &word[*i], 1);
d664 1
a664 1
		termp_nescape(p, &word[*i], 1);
d675 1
a675 1
	termp_nescape(p, &word[*i - j], (size_t)j);
d685 1
a685 1
termp_pword(struct termp *p, const char *word, int len)
d689 4
d694 1
a694 1
		termp_chara(p, ' ');
d706 1
a706 1
			termp_pescape(p, word, &i, len);
d712 2
a713 2
				termp_chara(p, word[i]);
				termp_chara(p, 8);
d716 2
a717 2
				termp_chara(p, '_');
				termp_chara(p, 8);
d721 1
a721 1
		termp_chara(p, word[i]);
d723 3
d730 1
a730 1
 * Like termp_chara() but for arbitrary-length buffers.  Resize the
d735 1
a735 1
termp_stringa(struct termp *p, const char *c, size_t sz)
d764 1
a764 1
termp_chara(struct termp *p, char c)
@


1.3
log
@Support for `Bd' of all types (see mdoc.7 for newline/tab rules).
Renamed term.c and terminal.c functions to be term_.
Some bugfixes to lists.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.2 2009/03/19 16:40:49 kristaps Exp $ */
d225 6
a230 15
			} else if (vis + vsz > bp)
				warnx("word breaks right margin");

			/* TODO: hyphenate. */

		} else {
			if (vis && vis + vsz > bp) {
				putchar('\n');
				for (j = 0; j < (int)p->rmargin; j++)
					putchar(' ');
				vis = p->rmargin - p->offset;
			} else if (vis + vsz > bp) 
				warnx("word breaks right margin");

			/* TODO: hyphenate. */
@


1.2
log
@Some Linux-isms.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.1 2009/03/19 16:17:27 kristaps Exp $ */
d84 1
a84 1
		p->symtab = ascii2htab();
d109 1
a109 1
		asciifree(p->symtab);
d164 1
a164 1
flushln(struct termp *p)
d297 1
a297 1
newln(struct termp *p)
d305 1
a305 1
	flushln(p);
d317 1
a317 1
vspace(struct termp *p)
d320 1
a320 1
	newln(p);
d332 1
a332 1
word(struct termp *p, const char *word)
d336 2
d339 1
a339 1
		termp_pword(p, word, (int)strlen(word));
a342 3
	if (0 == (len = (int)strlen(word)))
		errx(1, "blank line not in literal context");

d375 12
d393 2
a394 2
static void
termp_body(struct termp *p, struct termpair *ppair,
d419 1
a419 1
		word(p, node->string);
a436 5

	/* Siblings. */

	if (node->next)
		termp_body(p, ppair, meta, node->next);
d469 1
a469 1
	vspace(p);
d475 2
a476 2
	word(p, os);
	flushln(p);
d483 2
a484 2
	word(p, buf);
	flushln(p);
d533 2
a534 2
	word(p, title);
	flushln(p);
d540 2
a541 2
	word(p, buf);
	flushln(p);
d548 2
a549 2
	word(p, title);
	flushln(p);
d571 1
a571 1
	if (NULL == (rhs = a2ascii(p->symtab, word, len, &sz))) 
d646 1
a646 2
	if ( ! (TERMP_NOSPACE & p->flags) && 
			! (TERMP_LITERAL & p->flags))
@


1.1
log
@Split mdocterm.c -> main.c terminal.c.
Abstracted output with -T selector (default ascii).
Name change: mdocterm -> mandoc.
Re-imported tree with -Ttree.
@
text
@d1 1
a1 1
/* $Id: mdocterm.c,v 1.48 2009/03/17 13:35:46 kristaps Exp $ */
d27 5
@
