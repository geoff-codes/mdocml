head	1.12;
access;
symbols
	VERSION_1_12_3:1.11.2.2
	VERSION_1_12_2:1.11
	VERSION_1_12:1.11.0.2
	VERSION_1_12_1:1.10;
locks; strict;
comment	@ * @;


1.12
date	2012.06.09.11.27.38;	author kristaps;	state dead;
branches;
next	1.11;

1.11
date	2012.06.08.10.33.48;	author kristaps;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2012.01.03.15.17.20;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.12.25.17.49.52;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.12.18.18.51.01;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2011.12.16.12.06.35;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.16.08.04.34;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.12.12.02.00.49;	author schwarze;	state Exp;
branches;
next	1.4;

1.4
date	2011.12.08.00.20.52;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.12.04.22.52.50;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.11.27.11.46.44;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.11.26.19.54.13;	author kristaps;	state Exp;
branches;
next	;

1.11.2.1
date	2013.10.05.20.30.05;	author schwarze;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2013.10.11.00.06.48;	author schwarze;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2014.08.05.00.42.53;	author schwarze;	state dead;
branches;
next	;


desc
@@


1.12
log
@Remove catman(8): it's superfluous.
Users of man.cgi should be able to just copy in their directories and have
the CGI fine everything on its own or just suck it up or, in the cases
of multiple manroots, have a simple config file.
Besides, now that mandocdb(8) is using relative paths for everything,
needing a fancy "cp -R" is silly.
@
text
@@


1.11
log
@Use size_t in catman to match manpath.h.
Note this file will not be connected to the build for a little while as
I get the new sqlite3 stuff in.
@
text
@a0 512
/*	$Id: catman.c,v 1.10 2012/01/03 15:17:20 kristaps Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <sys/param.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef __linux__
# include <db_185.h>
#else
# include <db.h>
#endif

#include "manpath.h"
#include "mandocdb.h"

#define	xstrlcpy(_dst, _src, _sz) \
	do if (strlcpy((_dst), (_src), (_sz)) >= (_sz)) { \
		fprintf(stderr, "%s: Path too long", (_dst)); \
		exit(EXIT_FAILURE); \
	} while (/* CONSTCOND */0)

#define	xstrlcat(_dst, _src, _sz) \
	do if (strlcat((_dst), (_src), (_sz)) >= (_sz)) { \
		fprintf(stderr, "%s: Path too long", (_dst)); \
		exit(EXIT_FAILURE); \
	} while (/* CONSTCOND */0)

static	int		 indexhtml(char *, size_t, char *, size_t);
static	int		 manup(const struct manpaths *, char *);
static	int		 mkpath(char *, mode_t, mode_t);
static	int		 treecpy(char *, char *);
static	int		 update(char *, char *);
static	void		 usage(void);

static	const char	*progname;
static	int		 verbose;
static	int		 force;

int
main(int argc, char *argv[])
{
	int		 ch;
	char		*aux, *base, *conf_file;
	struct manpaths	 dirs;
	char		 buf[MAXPATHLEN];
	extern char	*optarg;
	extern int	 optind;

	progname = strrchr(argv[0], '/');
	if (progname == NULL)
		progname = argv[0];
	else
		++progname;

	aux = base = conf_file = NULL;
	xstrlcpy(buf, "/var/www/cache/man.cgi", MAXPATHLEN);

	while (-1 != (ch = getopt(argc, argv, "C:fm:M:o:v")))
		switch (ch) {
		case ('C'):
			conf_file = optarg;
			break;
		case ('f'):
			force = 1;
			break;
		case ('m'):
			aux = optarg;
			break;
		case ('M'):
			base = optarg;
			break;
		case ('o'):
			xstrlcpy(buf, optarg, MAXPATHLEN);
			break;
		case ('v'):
			verbose++;
			break;
		default:
			usage();
			return(EXIT_FAILURE);
		}

	argc -= optind;
	argv += optind;

	if (argc > 0) {
		usage();
		return(EXIT_FAILURE);
	}

	memset(&dirs, 0, sizeof(struct manpaths));
	manpath_parse(&dirs, conf_file, base, aux);
	ch = manup(&dirs, buf);
	manpath_free(&dirs);
	return(ch ? EXIT_SUCCESS : EXIT_FAILURE);
}

static void
usage(void)
{
	
	fprintf(stderr, "usage: %s "
			"[-fv] "
			"[-C file] "
			"[-o path] "
			"[-m manpath] "
			"[-M manpath]\n",
			progname);
}

/*
 * If "src" file doesn't exist (errors out), return -1.  Otherwise,
 * return 1 if "src" is newer (which also happens "dst" doesn't exist)
 * and 0 otherwise.
 */
static int
isnewer(const char *dst, const char *src)
{
	struct stat	 s1, s2;

	if (-1 == stat(src, &s1))
		return(-1);
	if (force)
		return(1);

	return(-1 == stat(dst, &s2) ? 1 : s1.st_mtime > s2.st_mtime);
}

/*
 * Copy the contents of one file into another.
 * Returns 0 on failure, 1 on success.
 */
static int
filecpy(const char *dst, const char *src)
{
	char		 buf[BUFSIZ];
	int		 sfd, dfd, rc;
	ssize_t		 rsz, wsz;

	sfd = dfd = -1;
	rc = 0;

	if (-1 == (dfd = open(dst, O_CREAT|O_TRUNC|O_WRONLY, 0644))) {
		perror(dst);
		goto out;
	} else if (-1 == (sfd = open(src, O_RDONLY, 0))) {
		perror(src);
		goto out;
	} 

	while ((rsz = read(sfd, buf, BUFSIZ)) > 0)
		if (-1 == (wsz = write(dfd, buf, (size_t)rsz))) {
			perror(dst);
			goto out;
		} else if (wsz < rsz) {
			fprintf(stderr, "%s: Short write\n", dst);
			goto out;
		}
	
	if (rsz < 0)
		perror(src);
	else
		rc = 1;
out:
	if (-1 != sfd)
		close(sfd);
	if (-1 != dfd)
		close(dfd);

	return(rc);
}

/*
 * Pass over the recno database and re-create HTML pages if they're
 * found to be out of date.
 * Returns -1 on fatal error, 1 on success.
 */
static int
indexhtml(char *src, size_t ssz, char *dst, size_t dsz)
{
	DB		*idx;
	DBT		 key, val;
	int		 c, rc;
	unsigned int	 fl;
	const char	*f;
	char		*d;
	char		 fname[MAXPATHLEN];
	pid_t		 pid;

	pid = -1;

	xstrlcpy(fname, dst, MAXPATHLEN);
	xstrlcat(fname, "/", MAXPATHLEN);
	xstrlcat(fname, MANDOC_IDX, MAXPATHLEN);

	idx = dbopen(fname, O_RDONLY, 0, DB_RECNO, NULL);
	if (NULL == idx) {
		perror(fname);
		return(-1);
	}

	fl = R_FIRST;
	while (0 == (c = (*idx->seq)(idx, &key, &val, fl))) {
		fl = R_NEXT;
		/*
		 * If the record is zero-length, then it's unassigned.
		 * Skip past these.
		 */
		if (0 == val.size)
			continue;

		f = (const char *)val.data + 1;
		if (NULL == memchr(f, '\0', val.size - 1))
			break;

		src[(int)ssz] = dst[(int)dsz] = '\0';

		xstrlcat(dst, "/", MAXPATHLEN);
		xstrlcat(dst, f, MAXPATHLEN);

		xstrlcat(src, "/", MAXPATHLEN);
		xstrlcat(src, f, MAXPATHLEN);

		if (-1 == (rc = isnewer(dst, src))) {
			fprintf(stderr, "%s: File missing\n", f);
			break;
		} else if (0 == rc)
			continue;

		d = strrchr(dst, '/');
		assert(NULL != d);
		*d = '\0';

		if (-1 == mkpath(dst, 0755, 0755)) {
			perror(dst);
			break;
		}

		*d = '/';

		if ( ! filecpy(dst, src))
			break;
		if (verbose)
			printf("%s\n", dst);
	}

	(*idx->close)(idx);

	if (c < 0)
		perror(fname);
	else if (0 == c) 
		fprintf(stderr, "%s: Corrupt index\n", fname);

	return(1 == c ? 1 : -1);
}

/*
 * Copy both recno and btree databases into the destination.
 * Call in to begin recreating HTML files.
 * Return -1 on fatal error and 1 if the update went well.
 */
static int
update(char *dst, char *src)
{
	size_t		 dsz, ssz;

	dsz = strlen(dst);
	ssz = strlen(src);

	xstrlcat(src, "/", MAXPATHLEN);
	xstrlcat(dst, "/", MAXPATHLEN);

	xstrlcat(src, MANDOC_DB, MAXPATHLEN);
	xstrlcat(dst, MANDOC_DB, MAXPATHLEN);

	if ( ! filecpy(dst, src))
		return(-1);
	if (verbose)
		printf("%s\n", dst);

	dst[(int)dsz] = src[(int)ssz] = '\0';

	xstrlcat(src, "/", MAXPATHLEN);
	xstrlcat(dst, "/", MAXPATHLEN);

	xstrlcat(src, MANDOC_IDX, MAXPATHLEN);
	xstrlcat(dst, MANDOC_IDX, MAXPATHLEN);

	if ( ! filecpy(dst, src))
		return(-1);
	if (verbose)
		printf("%s\n", dst);

	dst[(int)dsz] = src[(int)ssz] = '\0';

	return(indexhtml(src, ssz, dst, dsz));
}

/*
 * See if btree or recno databases in the destination are out of date
 * with respect to a single manpath component.
 * Return -1 on fatal error, 0 if the source is no longer valid (and
 * shouldn't be listed), and 1 if the update went well.
 */
static int
treecpy(char *dst, char *src)
{
	size_t		 dsz, ssz;
	int		 rc;

	dsz = strlen(dst);
	ssz = strlen(src);

	xstrlcat(src, "/", MAXPATHLEN);
	xstrlcat(dst, "/", MAXPATHLEN);

	xstrlcat(src, MANDOC_IDX, MAXPATHLEN);
	xstrlcat(dst, MANDOC_IDX, MAXPATHLEN);

	if (-1 == (rc = isnewer(dst, src)))
		return(0);

	dst[(int)dsz] = src[(int)ssz] = '\0';

	if (1 == rc)
		return(update(dst, src));

	xstrlcat(src, "/", MAXPATHLEN);
	xstrlcat(dst, "/", MAXPATHLEN);

	xstrlcat(src, MANDOC_DB, MAXPATHLEN);
	xstrlcat(dst, MANDOC_DB, MAXPATHLEN);

	if (-1 == (rc = isnewer(dst, src)))
		return(0);
	else if (rc == 0)
		return(1);

	dst[(int)dsz] = src[(int)ssz] = '\0';

	return(update(dst, src));
}

/*
 * Update the destination's file-tree with respect to changes in the
 * source manpath components.
 * "Change" is defined by an updated index or btree database.
 * Returns 1 on success, 0 on failure.
 */
static int
manup(const struct manpaths *dirs, char *base)
{
	char		 dst[MAXPATHLEN],
			 src[MAXPATHLEN];
	const char	*path;
	size_t		 i;
	int		 c;
	size_t		 sz;
	FILE		*f;

	/* Create the path and file for the catman.conf file. */

	sz = strlen(base);
	xstrlcpy(dst, base, MAXPATHLEN);
	xstrlcat(dst, "/etc", MAXPATHLEN);
	if (-1 == mkpath(dst, 0755, 0755)) {
		perror(dst);
		return(0);
	}

	xstrlcat(dst, "/catman.conf", MAXPATHLEN);
	if (NULL == (f = fopen(dst, "w"))) {
		perror(dst);
		return(0);
	} else if (verbose)
		printf("%s\n", dst);

	for (i = 0; i < dirs->sz; i++) {
		path = dirs->paths[i];
		dst[(int)sz] = '\0';
		xstrlcat(dst, path, MAXPATHLEN);
		if (-1 == mkpath(dst, 0755, 0755)) {
			perror(dst);
			break;
		}

		xstrlcpy(src, path, MAXPATHLEN);
		if (-1 == (c = treecpy(dst, src)))
			break;
		else if (0 == c)
			continue;

		/*
		 * We want to use a relative path here because manpath.h
		 * will realpath() when invoked with man.cgi, and we'll
		 * make sure to chdir() into the cache directory before.
		 *
		 * This allows the cache directory to be in an arbitrary
		 * place, working in both chroot() and non-chroot()
		 * "safe" modes.
		 */
		assert('/' == path[0]);
		fprintf(f, "_whatdb %s/whatis.db\n", path + 1);
	}

	fclose(f);
	return(i == dirs->sz);
}

/*
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
static int
mkpath(char *path, mode_t mode, mode_t dir_mode)
{
	struct stat sb;
	char *slash;
	int done, exists;

	slash = path;

	for (;;) {
		/* LINTED */
		slash += strspn(slash, "/");
		/* LINTED */
		slash += strcspn(slash, "/");

		done = (*slash == '\0');
		*slash = '\0';

		/* skip existing path components */
		exists = !stat(path, &sb);
		if (!done && exists && S_ISDIR(sb.st_mode)) {
			*slash = '/';
			continue;
		}

		if (mkdir(path, done ? mode : dir_mode) == 0) {
			if (mode > 0777 && chmod(path, mode) < 0)
				return (-1);
		} else {
			if (!exists) {
				/* Not there */
				return (-1);
			}
			if (!S_ISDIR(sb.st_mode)) {
				/* Is there, but isn't a directory */
				errno = ENOTDIR;
				return (-1);
			}
		}

		if (done)
			break;

		*slash = '/';
	}

	return (0);
}
@


1.11.2.1
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- do not complain about unused variables in test-*.c
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.11 2012/06/08 10:33:48 kristaps Exp $ */
d215 3
@


1.11.2.2
log
@Thomas Klausner <wiz at NetBSD dot org> finally succeeded to build
on SmartOS and sent these additional patches, thanks!
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.11.2.1 2013/10/05 20:30:05 schwarze Exp $ */
d34 1
a34 1
#if defined(__linux__) || defined(__sun)
@


1.11.2.3
log
@Remove the old man.cgi.
Running that would not be a responsible thing to do, nowadays.
@
text
@d1 509
@


1.10
log
@Local variable initialisation.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.9 2011/12/25 17:49:52 kristaps Exp $ */
d383 2
a384 1
	int		 i, c;
@


1.9
log
@Continue changing mandoc.{index,db} into whatis.{index,db}.  Use mandocdb.h
to do so.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.8 2011/12/18 18:51:01 kristaps Exp $ */
d82 1
a82 1
	aux = base = NULL;
@


1.8
log
@Give catman(8) the -C flag (like apropos and friends) and merge in some
documentation from apropos(1) to be consistent.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.7 2011/12/16 12:06:35 kristaps Exp $ */
d41 1
d220 2
a221 1
	xstrlcat(fname, "/mandoc.index", MAXPATHLEN);
d297 5
a301 2
	xstrlcat(src, "/mandoc.db", MAXPATHLEN);
	xstrlcat(dst, "/mandoc.db", MAXPATHLEN);
d310 5
a314 2
	xstrlcat(src, "/mandoc.index", MAXPATHLEN);
	xstrlcat(dst, "/mandoc.index", MAXPATHLEN);
d341 5
a345 2
	xstrlcat(src, "/mandoc.index", MAXPATHLEN);
	xstrlcat(dst, "/mandoc.index", MAXPATHLEN);
d355 5
a359 2
	xstrlcat(src, "/mandoc.db", MAXPATHLEN);
	xstrlcat(dst, "/mandoc.db", MAXPATHLEN);
@


1.7
log
@Make the stored "cat"/"mdoc"/"man" strings just be c/d/a single-character
bytes.  This cuts down a little in index size and allows for cleaner
extraction of information.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.6 2011/12/16 08:04:34 kristaps Exp $ */
d69 1
a69 1
	char		*aux, *base;
d84 1
a84 1
	while (-1 != (ch = getopt(argc, argv, "fm:M:o:v")))
d86 3
d118 1
a118 1
	manpath_parse(&dirs, NULL, base, aux);
d130 1
@


1.6
log
@Make paths in the mandocdb(8) index relative to the databases' path
prefix.  This means that an index in, say, /usr/share/man will point to
man1/foo.1 instead of /usr/share/man/man1/foo.1.  Not only does this
save a lot of space, it also allows manual trees to be moved around
without any side effects to the mandocdb(8) databases.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.5 2011/12/12 02:00:49 schwarze Exp $ */
d207 1
a207 1
	const char	*f, *cp;
d226 4
a229 1
		cp = (const char *)val.data;
d232 3
a234 5
		if (NULL == (f = memchr(cp, '\0', val.size)))
			break;
		if (++f - cp >= (int)val.size)
			break;
		if (NULL == memchr(f, '\0', val.size - (f - cp)))
@


1.5
log
@implement -C (alternative config file) for apropos(1) and mandocdb(8),
including various tweaks to the whatis(8) manual;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.4 2011/12/08 00:20:52 kristaps Exp $ */
d54 1
a54 1
static	int		 indexhtml(char *, char *);
d57 2
a58 2
static	int		 treecpy(char *, char *, char *);
static	int		 update(char *, char *, char *);
d201 1
a201 1
indexhtml(char *base, char *dst)
a204 1
	size_t		 sz;
a211 1
	sz = strlen(base);
d236 4
a239 1
		base[(int)sz] = '\0';
d241 2
a242 2
		xstrlcat(base, "/", MAXPATHLEN);
		xstrlcat(base, f, MAXPATHLEN);
d244 1
a244 1
		if (-1 == (rc = isnewer(base, f))) {
d250 1
a250 1
		d = strrchr(base, '/');
d254 2
a255 2
		if (-1 == mkpath(base, 0755, 0755)) {
			perror(base);
d261 1
a261 1
		if ( ! filecpy(base, f))
d264 1
a264 1
			printf("%s\n", base);
d283 1
a283 1
update(char *base, char *dst, char *src)
d308 1
a308 1
	dst[(int)dsz] = '\0';
d310 1
a310 1
	return(indexhtml(base, dst));
d320 1
a320 1
treecpy(char *base, char *dst, char *src)
d337 1
a337 1
		return(update(base, dst, src));
d349 1
a349 1
	return(update(base, dst, src));
d387 1
a387 1
		dst[(int)sz] = base[(int)sz] = '\0';
d395 1
a395 1
		if (-1 == (c = treecpy(base, dst, src)))
@


1.4
log
@First, remove the catman(8) jobstart() stuff.  It only copies files.
Second, when creating the destination filename, append the index's file
(which is an absolute path) to the cache directory, not to the index's
directory name.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.3 2011/12/04 22:52:50 kristaps Exp $ */
d115 1
a115 1
	manpath_parse(&dirs, base, aux);
@


1.3
log
@Make catman and man.cgi understand the index type-field.
Also make catman's man.conf be generated as catman.conf to avoid clobbering
a real man.conf file.
Finally, add a placeholder catman() function to man.cgi for preformatted
manuals in the cache.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.2 2011/11/27 11:46:44 kristaps Exp $ */
d54 2
a55 6
static	int		 indexhtml(char *);
#if 0
static	int		 jobstart(const char *, const char *, pid_t *);
static	int		 jobwait(pid_t);
#endif
static	int		 manup(const struct manpaths *, const char *);
d57 2
a58 2
static	int		 treecpy(char *, char *);
static	int		 update(char *, char *);
a69 1
	const char	*dir;
d71 1
d82 1
a82 1
	dir = "/var/www/cache/man.cgi";
d96 1
a96 1
			dir = optarg;
d116 1
a116 1
	ch = manup(&dirs, dir);
a194 61
#if 0
/*
 * Clean up existing child.
 * Return 1 if cleaned up fine (or none was started) and 0 otherwise.
 */
static int
jobwait(pid_t pid)
{
	int		 st;

	if (-1 == pid)
		return(1);

	if (-1 == waitpid(pid, &st, 0)) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}

	return(WIFEXITED(st) && 0 == WEXITSTATUS(st));
}

/*
 * Start a job (child process), first making sure that the prior one has
 * finished.
 * Return 1 if the prior child exited and the new one started, else 0.
 */
static int
jobstart(const char *dst, const char *src, pid_t *pid)
{
	int		 fd;

	if ( ! jobwait(*pid))
		return(0);

	if (-1 == (*pid = fork())) {
		perror(NULL);
		exit(EXIT_FAILURE);
	} else if (*pid > 0)
		return(1);

	if (-1 == (fd = open(dst, O_WRONLY|O_TRUNC|O_CREAT, 0644))) {
		perror(dst);
		exit(EXIT_FAILURE);
	}

	if (-1 == dup2(fd, STDOUT_FILENO)) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}

	execlp("mandoc", "mandoc", "-T", "html", 
			"-O", "fragment",
			"-O", "man=man.cgi?expr=%N&sec=%S", 
			src, (char *)NULL);

	perror("mandoc");
	exit(EXIT_FAILURE);
	/* NOTREACHED */
}
#endif

d201 1
a201 1
indexhtml(char *dst)
d213 1
a213 1
	sz = strlen(dst);
d238 1
a238 1
		dst[(int)sz] = '\0';
d240 2
a241 2
		xstrlcat(dst, "/", MAXPATHLEN);
		xstrlcat(dst, f, MAXPATHLEN);
d243 1
a243 1
		if (-1 == (rc = isnewer(dst, f))) {
d249 1
a249 1
		d = strrchr(dst, '/');
d253 2
a254 2
		if (-1 == mkpath(dst, 0755, 0755)) {
			perror(dst);
d260 1
a260 4
		if ( ! filecpy(dst, f))
			break;
#if 0
		if ( ! jobstart(dst, f, &pid))
a261 1
#endif
d263 1
a263 1
			printf("%s\n", dst);
a271 4
#if 0
	if ( ! jobwait(pid))
		c = -1;
#endif
d282 1
a282 1
update(char *dst, char *src)
d309 1
a309 1
	return(indexhtml(dst));
d319 1
a319 1
treecpy(char *dst, char *src)
d336 1
a336 1
		return(update(dst, src));
d348 1
a348 1
	return(update(dst, src));
d358 1
a358 1
manup(const struct manpaths *dirs, const char *dir)
d367 4
a370 1
	xstrlcpy(dst, dir, MAXPATHLEN);
a371 1

a377 4

	if (verbose)
		printf("%s\n", dst);

d381 2
a382 4
	}

	xstrlcpy(dst, dir, MAXPATHLEN);
	sz = strlen(dst);
d386 1
a386 2

		dst[(int)sz] = '\0';
a387 1

d394 1
a394 2

		if (-1 == (c = treecpy(dst, src)))
@


1.2
log
@Removing INSECURE mode.  This is a work in progress!  Logic for
formatting manpages is now linked into man.cgi.
@
text
@d1 1
a1 1
/*	$Id: catman.c,v 1.1 2011/11/26 19:54:13 kristaps Exp $ */
d268 1
a268 1
	DB		*db;
d273 1
a273 1
	const char	*f;
d284 2
a285 2
	db = dbopen(fname, O_RDONLY, 0, DB_RECNO, NULL);
	if (NULL == db) {
d291 1
a291 1
	while (0 == (c = (*db->seq)(db, &key, &val, fl))) {
d293 9
a301 1
		f = (const char *)val.data;
a306 1
		/*xstrlcat(dst, ".html", MAXPATHLEN);*/
d309 1
a309 1
			fprintf(stderr, "%s: Manpage missing\n", f);
d327 4
a330 3

		/*if ( ! jobstart(dst, f, &pid))
			break;*/
d335 1
a335 1
	(*db->close)(db);
d339 6
a344 2
	/*if ( ! jobwait(pid))
		c = -1;*/
d448 1
a448 1
	xstrlcat(dst, "/man.conf", MAXPATHLEN);
@


1.1
log
@Rename manup(8) to catman(8), which Linux already uses for a similar tool.
@
text
@d1 1
a1 1
/*	$Id: manup.c,v 1.2 2011/11/24 12:22:53 kristaps Exp $ */
d55 1
d58 1
d199 1
d258 1
d299 1
a299 1
		xstrlcat(dst, ".html", MAXPATHLEN);
d317 2
a318 1
		if ( ! jobstart(dst, f, &pid))
d320 3
d331 2
a332 2
	if ( ! jobwait(pid))
		c = -1;
@
