head	1.5;
access;
symbols
	VERSION_1_9_5:1.5
	VERSION_1_8_5:1.5
	VERSION_1_8_1:1.5
	VERSION_1_7_16:1.5
	VERSION_1_7_15:1.5
	OPENBSD_CHECKIN:1.5
	VERSION_1_6_5:1.5
	VERSION_1_5_1:1.5
	VERSION_1_3_15:1.5
	VERSION_1_3_6:1.5
	VERSION_1_2_0:1.5
	VERSION_1_0_2:1.4
	VERSION_1_0_1:1.3;
locks; strict;
comment	@ * @;


1.5
date	2008.12.15.01.54.58;	author kristaps;	state dead;
branches;
next	1.4;

1.4
date	2008.12.09.17.09.12;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.04.19.31.57;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.04.16.34.59;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.04.16.19.52;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Purged all old files in favour of new design.  Selective reintegration.
@
text
@@


1.4
log
@Considerable clean-ups.
@
text
@a0 193
/* $Id: tokens.c,v 1.3 2008/12/04 19:31:57 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <assert.h>
#include <stdlib.h>
#include <string.h>

#include "private.h"


static	int		 rofftok_dashes(const char *, int *);
static	int		 rofftok_special(const char *, int *);
static	int		 rofftok_predef(const char *, int *);
static	int		 rofftok_defined(const char *, int *);


static int
rofftok_defined(const char *buf, int *i)
{
	const char	 *p;

	if (0 == buf[*i])
		return(-1);
	if (0 == buf[*i + 1])
		return(-1);

	(*i)++;
	p = &buf[(*i)++];

	if (0 == memcmp(p, ">=", 2))
		return(ROFFTok_Ge);
	else if (0 == memcmp(p, "<=", 2))
		return(ROFFTok_Le);
	else if (0 == memcmp(p, "Rq", 2))
		return(ROFFTok_Rquote);
	else if (0 == memcmp(p, "Lq", 2))
		return(ROFFTok_Lquote);
	else if (0 == memcmp(p, "ua", 2))
		return(ROFFTok_Uparrow);
	else if (0 == memcmp(p, "aa", 2))
		return(ROFFTok_Acute);
	else if (0 == memcmp(p, "ga", 2))
		return(ROFFTok_Grave);
	else if (0 == memcmp(p, "Pi", 2))
		return(ROFFTok_Pi);
	else if (0 == memcmp(p, "Ne", 2))
		return(ROFFTok_Ne);
	else if (0 == memcmp(p, "Le", 2))
		return(ROFFTok_Le);
	else if (0 == memcmp(p, "Ge", 2))
		return(ROFFTok_Ge);
	else if (0 == memcmp(p, "Lt", 2))
		return(ROFFTok_Lt);
	else if (0 == memcmp(p, "Gt", 2))
		return(ROFFTok_Gt);
	else if (0 == memcmp(p, "Pm", 2))
		return(ROFFTok_Plusmin);
	else if (0 == memcmp(p, "If", 2))
		return(ROFFTok_Infty);
	else if (0 == memcmp(p, "Na", 2))
		return(ROFFTok_Nan);
	else if (0 == memcmp(p, "Ba", 2))
		return(ROFFTok_Bar);

	return(-1);
}


static int
rofftok_predef(const char *buf, int *i)
{
	if (0 == buf[*i])
		return(-1);
	if ('(' == buf[*i])
		return(rofftok_defined(buf, i));

	switch (buf[*i]) {
	case ('q'):
		return(ROFFTok_Quote);
	default:
		break;
	}

	return(-1);
}


static int
rofftok_dashes(const char *buf, int *i)
{

	if (0 == buf[*i])
		return(-1);
	else if (buf[(*i)++] != 'e')
		return(-1);
	if (0 == buf[*i])
		return(-1);

	switch (buf[*i]) {
	case ('m'):
		return(ROFFTok_Em);
	case ('n'):
		return(ROFFTok_En);
	default:
		break;
	}
	return(-1);
}


static int
rofftok_special(const char *buf, int *i)
{

	if (0 == buf[*i])
		return(ROFFTok_Slash);

	switch (buf[*i]) {
	case ('a'):
		return(ROFFTok_Sp_A);
	case ('b'):
		return(ROFFTok_Sp_B);
	case ('f'):
		return(ROFFTok_Sp_F);
	case ('n'):
		return(ROFFTok_Sp_N);
	case ('r'):
		return(ROFFTok_Sp_R);
	case ('t'):
		return(ROFFTok_Sp_T);
	case ('v'):
		return(ROFFTok_Sp_V);
	case ('0'):
		return(ROFFTok_Sp_0);
	default:
		break;
	}
	return(-1);
}


int
rofftok_scan(const char *buf, int *i)
{

	assert(*buf);
	assert(buf[*i] == '\\');

	(*i)++;

	for ( ; buf[*i]; (*i)++) {
		switch (buf[*i]) {
		case ('e'):
			(*i)++;
			return(rofftok_special(buf, i));
		case ('('):
			(*i)++;
			return(rofftok_dashes(buf, i));
		case (' '):
			return(ROFFTok_Space);
		case ('&'):
			return(ROFFTok_Null);
		case ('-'):
			return(ROFFTok_Hyphen);
		case ('*'):
			(*i)++;
			return(rofftok_predef(buf, i));
		case ('\\'):
			return(ROFFTok_Slash);
		default:
			break;
		}
	}

	return(-1);
}


@


1.3
log
@Moved charset recognition into the filter.
@
text
@d1 1
a1 1
/* $Id: tokens.c,v 1.2 2008/12/04 16:34:59 kristaps Exp $ */
a22 1
#include "libmdocml.h"
@


1.2
log
@Character-set validation fixes.
@
text
@d1 1
a1 1
/* $Id: tokens.c,v 1.1 2008/12/04 16:19:52 kristaps Exp $ */
d27 4
a30 4
static	int		 rofftok_dashes(const char *);
static	int		 rofftok_special(const char *);
static	int		 rofftok_predef(const char *);
static	int		 rofftok_defined(const char *);
d34 1
a34 1
rofftok_defined(const char *buf)
d36 3
a38 1
	if (0 == *buf)
d40 1
a40 3
	if (0 == *(buf + 1))
		return(-1);
	if (0 != *(buf + 2))
d43 4
a46 1
	if (0 == strcmp(buf, ">="))
d48 1
a48 1
	else if (0 == strcmp(buf, "<="))
d50 1
a50 1
	else if (0 == strcmp(buf, "Rq"))
d52 1
a52 1
	else if (0 == strcmp(buf, "Lq"))
d54 1
a54 1
	else if (0 == strcmp(buf, "ua"))
d56 1
a56 1
	else if (0 == strcmp(buf, "aa"))
d58 1
a58 1
	else if (0 == strcmp(buf, "ga"))
d60 1
a60 1
	else if (0 == strcmp(buf, "Pi"))
d62 1
a62 1
	else if (0 == strcmp(buf, "Ne"))
d64 1
a64 1
	else if (0 == strcmp(buf, "Le"))
d66 1
a66 1
	else if (0 == strcmp(buf, "Ge"))
d68 1
a68 1
	else if (0 == strcmp(buf, "Lt"))
d70 1
a70 1
	else if (0 == strcmp(buf, "Gt"))
d72 1
a72 1
	else if (0 == strcmp(buf, "Pm"))
d74 1
a74 1
	else if (0 == strcmp(buf, "If"))
d76 1
a76 1
	else if (0 == strcmp(buf, "Na"))
d78 1
a78 1
	else if (0 == strcmp(buf, "Ba"))
d86 1
a86 1
rofftok_predef(const char *buf)
d88 1
a88 1
	if (0 == *buf)
d90 2
d93 1
a93 4
	if ('(' == *buf)
		return(rofftok_defined(++buf));

	switch (*buf) {
d105 1
a105 1
rofftok_dashes(const char *buf)
d108 1
a108 1
	if (0 == *buf)
d110 1
a110 1
	else if (*buf++ != 'e')
d112 1
a112 4

	if (0 == *buf)
		return(-1);
	else if (0 != *(buf + 1))
d115 1
a115 1
	switch (*buf) {
d128 1
a128 1
rofftok_special(const char *buf)
d131 2
a132 4
	if (0 == *buf)
		return(-1);
	else if (0 != *(buf + 1))
		return(-1);
d134 1
a134 1
	switch (*buf) {
d149 2
d159 1
a159 1
rofftok_scan(const char *buf)
d163 3
a165 2
	if ('\\' != *buf++)
		return(ROFFTok_MAX);
d167 2
a168 2
	for ( ; *buf; buf++) {
		switch (*buf) {
d170 2
a171 1
			return(rofftok_special(++buf));
d173 2
a174 1
			return(rofftok_dashes(++buf));
d182 2
a183 1
			return(rofftok_predef(++buf));
d185 1
a185 1
			return(ROFFTok_MAX);
@


1.1
log
@Character-encoding tests.
@
text
@d1 1
a1 1
/* $Id: ml.c,v 1.3 2008/12/03 19:21:58 kristaps Exp $ */
d91 6
a96 1
	/* TODO */
d181 2
@
