head	1.22;
access;
symbols
	VERSION_1_11_1:1.5;
locks; strict;
comment	@ * @;


1.22
date	2011.05.13.00.42.26;	author kristaps;	state dead;
branches;
next	1.21;

1.21
date	2011.05.12.23.44.51;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2011.05.12.01.45.55;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2011.05.04.20.43.38;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.04.08.21.17;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2011.05.03.14.39.27;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.03.10.08.09;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.02.13.56.13;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.01.11.56.26;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.28.10.44.02;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.12.14.48.42;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.11.22.56.25;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.11.21.36.44;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.05.14.16.05;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.04.05.14.10.52;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2011.04.05.13.12.34;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.05.13.09.33;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.04.16.49.03;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.04.10.53.15;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.03.14.18.29;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.03.10.14.45;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.02.15.40.40;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Rename mandoc-db to makewhatis.  On the suggestion of schwarze@@; I agree.
Add initial version notes.
@
text
@@


1.21
log
@Correctly catch `Vt' semicolon in mandoc-db.
@
text
@a0 962
/*	$Id: mandoc-db.c,v 1.20 2011/05/12 01:45:55 kristaps Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <sys/param.h>

#include <assert.h>
#ifdef __linux__
# include <db_185.h>
#else
# include <db.h>
#endif
#include <fcntl.h>
#include <getopt.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include "man.h"
#include "mdoc.h"
#include "mandoc.h"

#define	MANDOC_DB	 "mandoc.db"
#define	MANDOC_IDX	 "mandoc.index"
#define	MANDOC_BUFSZ	  BUFSIZ
#define	MANDOC_FLAGS	  O_CREAT|O_TRUNC|O_RDWR

enum	type {
	MANDOC_NONE = 0,
	MANDOC_NAME,
	MANDOC_FUNCTION,
	MANDOC_UTILITY,
	MANDOC_INCLUDES,
	MANDOC_VARIABLE,
	MANDOC_STANDARD,
	MANDOC_AUTHOR,
	MANDOC_CONFIG
};

#define	MAN_ARGS	  DB *db, \
			  const char *dbn, \
			  DBT *key, size_t *ksz, \
			  DBT *val, \
			  DBT *rval, size_t *rsz, \
			  const struct man_node *n
#define	MDOC_ARGS	  DB *db, \
			  const char *dbn, \
			  DBT *key, size_t *ksz, \
			  DBT *val, \
			  DBT *rval, size_t *rsz, \
			  const struct mdoc_node *n

static	void		  dbt_append(DBT *, size_t *, const char *);
static	void		  dbt_appendb(DBT *, size_t *, 
				const void *, size_t);
static	void		  dbt_init(DBT *, size_t *);
static	void		  dbt_put(DB *, const char *, DBT *, DBT *);
static	void		  usage(void);
static	void		  pman(DB *, const char *, DBT *, size_t *, 
				DBT *, DBT *, size_t *, struct man *);
static	int		  pman_node(MAN_ARGS);
static	void		  pmdoc(DB *, const char *, DBT *, size_t *, 
				DBT *, DBT *, size_t *, struct mdoc *);
static	void		  pmdoc_node(MDOC_ARGS);
static	void		  pmdoc_An(MDOC_ARGS);
static	void		  pmdoc_Cd(MDOC_ARGS);
static	void		  pmdoc_Fd(MDOC_ARGS);
static	void		  pmdoc_In(MDOC_ARGS);
static	void		  pmdoc_Fn(MDOC_ARGS);
static	void		  pmdoc_Fo(MDOC_ARGS);
static	void		  pmdoc_Nd(MDOC_ARGS);
static	void		  pmdoc_Nm(MDOC_ARGS);
static	void		  pmdoc_St(MDOC_ARGS);
static	void		  pmdoc_Vt(MDOC_ARGS);

typedef	void		(*pmdoc_nf)(MDOC_ARGS);

static	const char	 *progname;

static	const pmdoc_nf	  mdocs[MDOC_MAX] = {
	NULL, /* Ap */
	NULL, /* Dd */
	NULL, /* Dt */
	NULL, /* Os */
	NULL, /* Sh */ 
	NULL, /* Ss */ 
	NULL, /* Pp */ 
	NULL, /* D1 */
	NULL, /* Dl */
	NULL, /* Bd */
	NULL, /* Ed */
	NULL, /* Bl */ 
	NULL, /* El */
	NULL, /* It */
	NULL, /* Ad */ 
	pmdoc_An, /* An */ 
	NULL, /* Ar */
	pmdoc_Cd, /* Cd */ 
	NULL, /* Cm */
	NULL, /* Dv */ 
	NULL, /* Er */ 
	NULL, /* Ev */ 
	NULL, /* Ex */ 
	NULL, /* Fa */ 
	pmdoc_Fd, /* Fd */
	NULL, /* Fl */
	pmdoc_Fn, /* Fn */ 
	NULL, /* Ft */ 
	NULL, /* Ic */ 
	pmdoc_In, /* In */ 
	NULL, /* Li */
	pmdoc_Nd, /* Nd */
	pmdoc_Nm, /* Nm */
	NULL, /* Op */
	NULL, /* Ot */
	NULL, /* Pa */
	NULL, /* Rv */
	pmdoc_St, /* St */ 
	pmdoc_Vt, /* Va */
	pmdoc_Vt, /* Vt */ 
	NULL, /* Xr */ 
	NULL, /* %A */
	NULL, /* %B */
	NULL, /* %D */
	NULL, /* %I */
	NULL, /* %J */
	NULL, /* %N */
	NULL, /* %O */
	NULL, /* %P */
	NULL, /* %R */
	NULL, /* %T */
	NULL, /* %V */
	NULL, /* Ac */
	NULL, /* Ao */
	NULL, /* Aq */
	NULL, /* At */ 
	NULL, /* Bc */
	NULL, /* Bf */
	NULL, /* Bo */
	NULL, /* Bq */
	NULL, /* Bsx */
	NULL, /* Bx */
	NULL, /* Db */
	NULL, /* Dc */
	NULL, /* Do */
	NULL, /* Dq */
	NULL, /* Ec */
	NULL, /* Ef */ 
	NULL, /* Em */ 
	NULL, /* Eo */
	NULL, /* Fx */
	NULL, /* Ms */ 
	NULL, /* No */
	NULL, /* Ns */
	NULL, /* Nx */
	NULL, /* Ox */
	NULL, /* Pc */
	NULL, /* Pf */
	NULL, /* Po */
	NULL, /* Pq */
	NULL, /* Qc */
	NULL, /* Ql */
	NULL, /* Qo */
	NULL, /* Qq */
	NULL, /* Re */
	NULL, /* Rs */
	NULL, /* Sc */
	NULL, /* So */
	NULL, /* Sq */
	NULL, /* Sm */ 
	NULL, /* Sx */
	NULL, /* Sy */
	NULL, /* Tn */
	NULL, /* Ux */
	NULL, /* Xc */
	NULL, /* Xo */
	pmdoc_Fo, /* Fo */ 
	NULL, /* Fc */ 
	NULL, /* Oo */
	NULL, /* Oc */
	NULL, /* Bk */
	NULL, /* Ek */
	NULL, /* Bt */
	NULL, /* Hf */
	NULL, /* Fr */
	NULL, /* Ud */
	NULL, /* Lb */
	NULL, /* Lp */ 
	NULL, /* Lk */ 
	NULL, /* Mt */ 
	NULL, /* Brq */ 
	NULL, /* Bro */ 
	NULL, /* Brc */ 
	NULL, /* %C */
	NULL, /* Es */
	NULL, /* En */
	NULL, /* Dx */
	NULL, /* %Q */
	NULL, /* br */
	NULL, /* sp */
	NULL, /* %U */
	NULL, /* Ta */
};

int
main(int argc, char *argv[])
{
	struct mparse	*mp; /* parse sequence */
	struct mdoc	*mdoc; /* resulting mdoc */
	struct man	*man; /* resulting man */
	char		*fn; /* current file being parsed */
	const char	*msec, /* manual section */
	      	 	*mtitle, /* manual title */
			*arch, /* manual architecture */
	      		*dir; /* result dir (default: cwd) */
	char		 ibuf[MAXPATHLEN], /* index fname */
			 ibbuf[MAXPATHLEN], /* index backup fname */
			 fbuf[MAXPATHLEN],  /* btree fname */
			 fbbuf[MAXPATHLEN]; /* btree backup fname */
	int		 ch;
	DB		*idx, /* index database */
			*db; /* keyword database */
	DBT		 rkey, rval, /* recno entries */
			 key, val; /* persistent keyword entries */
	size_t		 sv,
			 ksz, rsz; /* entry buffer size */
	char		 vbuf[8]; /* stringified record number */
	BTREEINFO	 info; /* btree configuration */
	recno_t		 rec; /* current record number */
	extern int	 optind;
	extern char	*optarg;

	progname = strrchr(argv[0], '/');
	if (progname == NULL)
		progname = argv[0];
	else
		++progname;

	dir = "";

	while (-1 != (ch = getopt(argc, argv, "d:")))
		switch (ch) {
		case ('d'):
			dir = optarg;
			break;
		default:
			usage();
			return((int)MANDOCLEVEL_BADARG);
		}

	argc -= optind;
	argv += optind;

	/*
	 * Set up temporary file-names into which we're going to write
	 * all of our data (both for the index and database).  These
	 * will be securely renamed to the real file-names after we've
	 * written all of our data.
	 */

	ibuf[0] = ibuf[MAXPATHLEN - 2] =
		ibbuf[0] = ibbuf[MAXPATHLEN - 2] = 
		fbuf[0] = fbuf[MAXPATHLEN - 2] = 
		fbbuf[0] = fbbuf[MAXPATHLEN - 2] = '\0';

	strlcat(fbuf, dir, MAXPATHLEN);
	strlcat(fbuf, MANDOC_DB, MAXPATHLEN);

	strlcat(fbbuf, fbuf, MAXPATHLEN);
	strlcat(fbbuf, "~", MAXPATHLEN);

	strlcat(ibuf, dir, MAXPATHLEN);
	strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);

	strlcat(ibbuf, ibuf, MAXPATHLEN);
	strlcat(ibbuf, "~", MAXPATHLEN);

	if ('\0' != fbuf[MAXPATHLEN - 2] ||
			'\0' != fbbuf[MAXPATHLEN - 2] ||
			'\0' != ibuf[MAXPATHLEN - 2] ||
			'\0' != ibbuf[MAXPATHLEN - 2]) {
		fprintf(stderr, "%s: Path too long\n", progname);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	/*
	 * For the keyword database, open a BTREE database that allows
	 * duplicates.  For the index database, use a standard RECNO
	 * database type.
	 */

	memset(&info, 0, sizeof(BTREEINFO));
	info.flags = R_DUP;
	db = dbopen(fbbuf, MANDOC_FLAGS, 0644, DB_BTREE, &info);

	if (NULL == db) {
		perror(fbbuf);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	idx = dbopen(ibbuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);

	if (NULL == db) {
		perror(ibbuf);
		(*db->close)(db);
		exit((int)MANDOCLEVEL_SYSERR);
	}

	/*
	 * Try parsing the manuals given on the command line.  If we
	 * totally fail, then just keep on going.  Take resulting trees
	 * and push them down into the database code.
	 * Use the auto-parser and don't report any errors.
	 */

	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);

	memset(&key, 0, sizeof(DBT));
	memset(&val, 0, sizeof(DBT));
	memset(&rkey, 0, sizeof(DBT));
	memset(&rval, 0, sizeof(DBT));

	val.size = sizeof(vbuf);
	val.data = vbuf;
	rkey.size = sizeof(recno_t);

	rec = 1;
	ksz = rsz = 0;

	while (NULL != (fn = *argv++)) {
		mparse_reset(mp);

		/* Parse and get (non-empty) AST. */

		if (mparse_readfd(mp, -1, fn) >= MANDOCLEVEL_FATAL) {
			fprintf(stderr, "%s: Parse failure\n", fn);
			continue;
		}
		mparse_result(mp, &mdoc, &man);
		if (NULL == mdoc && NULL == man)
			continue;

		/* Manual section: can be empty string. */

		msec = NULL != mdoc ? 
			mdoc_meta(mdoc)->msec :
			man_meta(man)->msec;
		mtitle = NULL != mdoc ? 
			mdoc_meta(mdoc)->title :
			man_meta(man)->title;
		arch = NULL != mdoc ? mdoc_meta(mdoc)->arch : NULL;

		assert(msec);
		assert(mtitle);

		/* 
		 * The index record value consists of a nil-terminated
		 * filename, a nil-terminated manual section, and a
		 * nil-terminated description.  Since the description
		 * may not be set, we set a sentinel to see if we're
		 * going to write a nil byte in its place.
		 */

		dbt_init(&rval, &rsz);
		dbt_appendb(&rval, &rsz, fn, strlen(fn) + 1);
		dbt_appendb(&rval, &rsz, msec, strlen(msec) + 1);
		dbt_appendb(&rval, &rsz, mtitle, strlen(mtitle) + 1);
		dbt_appendb(&rval, &rsz, arch ? arch : "", 
				arch ? strlen(arch) + 1 : 1);

		sv = rval.size;

		/* Fix the record number in the btree value. */

		memset(val.data, 0, sizeof(uint32_t));
		memcpy(val.data + 4, &rec, sizeof(uint32_t));

		if (mdoc)
			pmdoc(db, fbbuf, &key, &ksz, 
				&val, &rval, &rsz, mdoc);
		else 
			pman(db, fbbuf, &key, &ksz, 
				&val, &rval, &rsz, man);
		
		/*
		 * Apply this to the index.  If we haven't had a
		 * description set, put an empty one in now.
		 */

		if (rval.size == sv)
			dbt_appendb(&rval, &rsz, "", 1);

		rkey.data = &rec;
		dbt_put(idx, ibbuf, &rkey, &rval);

		printf("Indexed: %s\n", fn);
		rec++;
	}

	(*db->close)(db);
	(*idx->close)(idx);

	mparse_free(mp);

	free(key.data);
	free(rval.data);

	/* Atomically replace the file with our temporary one. */

	if (-1 == rename(fbbuf, fbuf))
		perror(fbuf);
	if (-1 == rename(ibbuf, ibuf))
		perror(fbuf);

	return((int)MANDOCLEVEL_OK);
}

/*
 * Initialise the stored database key whose data buffer is shared
 * between uses (as the key must sometimes be constructed from an array
 * of 
 */
static void
dbt_init(DBT *key, size_t *ksz)
{

	if (0 == *ksz) {
		assert(0 == key->size);
		assert(NULL == key->data);
		key->data = mandoc_malloc(MANDOC_BUFSZ);
		*ksz = MANDOC_BUFSZ;
	}

	key->size = 0;
}

/*
 * Append a binary value to a database entry.  This can be invoked
 * multiple times; the buffer is automatically resized.
 */
static void
dbt_appendb(DBT *key, size_t *ksz, const void *cp, size_t sz)
{

	assert(key->data);

	/* Overshoot by MANDOC_BUFSZ. */

	while (key->size + sz >= *ksz) {
		*ksz = key->size + sz + MANDOC_BUFSZ;
		key->data = mandoc_realloc(key->data, *ksz);
	}

#if 0
	dstp = key->data + (int)key->size;

	while (NULL != (endp = memchr(cp, '\\', sz))) {
		ssz = endp - cp;
		memcpy(dstp, cp, ssz);

		dstp += ssz;
		key->size += ssz;
		sz -= ssz;

		cp = endp++;
		/* FIXME: expects nil-terminated string! */
		esc = mandoc_escape((const char **)&endp, NULL, NULL);

		switch (esc) {
		case (ESCAPE_ERROR):
			/* Nil-terminate this point. */
			memcpy(dstp, "", 1);
			key->size++;
			return;
		case (ESCAPE_PREDEF):
			/* FALLTHROUGH */
		case (ESCAPE_SPECIAL):
			break;
		default:
			sz -= endp - cp;
			cp = endp;
			continue;
		}

		ssz = endp - cp;
		memcpy(dstp, cp, ssz);

		dstp += ssz;
		key->size += ssz;
		sz -= ssz;

		cp = endp;
	}
#endif

	memcpy(key->data + (int)key->size, cp, sz);
	key->size += sz;
}

/*
 * Append a nil-terminated string to the database entry.  This can be
 * invoked multiple times.  The database entry will be nil-terminated as
 * well; if invoked multiple times, a space is put between strings.
 */
static void
dbt_append(DBT *key, size_t *ksz, const char *cp)
{
	size_t		 sz;

	if (0 == (sz = strlen(cp)))
		return;

	assert(key->data);

	if (key->size)
		((char *)key->data)[(int)key->size - 1] = ' ';

	dbt_appendb(key, ksz, cp, sz + 1);
}

/* ARGSUSED */
static void
pmdoc_An(MDOC_ARGS)
{
	uint32_t	 fl;
	
	if (SEC_AUTHORS != n->sec)
		return;

	for (n = n->child; n; n = n->next)
		if (MDOC_TEXT == n->type)
			dbt_append(key, ksz, n->string);

	fl = MANDOC_AUTHOR;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_Fd(MDOC_ARGS)
{
	uint32_t	 fl;
	const char	*start, *end;
	size_t		 sz;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == (n = n->child) || MDOC_TEXT != n->type)
		return;

	/*
	 * Only consider those `Fd' macro fields that begin with an
	 * "inclusion" token (versus, e.g., #define).
	 */
	if (strcmp("#include", n->string))
		return;

	if (NULL == (n = n->next) || MDOC_TEXT != n->type)
		return;

	/*
	 * Strip away the enclosing angle brackets and make sure we're
	 * not zero-length.
	 */

	start = n->string;
	if ('<' == *start || '"' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return;

	end = &start[(int)sz - 1];
	if ('>' == *end || '"' == *end)
		end--;

	assert(end >= start);
	dbt_appendb(key, ksz, start, (size_t)(end - start + 1));
	dbt_appendb(key, ksz, "", 1);

	fl = MANDOC_INCLUDES;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_Cd(MDOC_ARGS)
{
	uint32_t	 fl;
	
	if (SEC_SYNOPSIS != n->sec)
		return;

	for (n = n->child; n; n = n->next)
		if (MDOC_TEXT == n->type)
			dbt_append(key, ksz, n->string);

	fl = MANDOC_CONFIG;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_In(MDOC_ARGS)
{
	uint32_t	 fl;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	dbt_append(key, ksz, n->child->string);
	fl = MANDOC_INCLUDES;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_Fn(MDOC_ARGS)
{
	uint32_t	 fl;
	const char	*cp;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	/* .Fn "struct type *arg" "foo" */

	cp = strrchr(n->child->string, ' ');
	if (NULL == cp)
		cp = n->child->string;

	/* Strip away pointer symbol. */

	while ('*' == *cp)
		cp++;

	dbt_append(key, ksz, cp);
	fl = MANDOC_FUNCTION;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_St(MDOC_ARGS)
{
	uint32_t	 fl;
	
	if (SEC_STANDARDS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	dbt_append(key, ksz, n->child->string);
	fl = MANDOC_STANDARD;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_Vt(MDOC_ARGS)
{
	uint32_t	 fl;
	const char	*start;
	size_t		 sz;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (MDOC_Vt == n->tok && MDOC_BODY != n->type)
		return;
	if (NULL == n->last || MDOC_TEXT != n->last->type)
		return;

	/*
	 * Strip away leading pointer symbol '*' and trailing ';'.
	 */

	start = n->last->string;

	while ('*' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return;

	if (';' == start[(int)sz - 1])
		sz--;

	if (0 == sz)
		return;

	dbt_appendb(key, ksz, start, sz);
	dbt_appendb(key, ksz, "", 1);

	fl = MANDOC_VARIABLE;
	memcpy(val->data, &fl, 4);
}

/* ARGSUSED */
static void
pmdoc_Fo(MDOC_ARGS)
{
	uint32_t	 fl;
	
	if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	dbt_append(key, ksz, n->child->string);
	fl = MANDOC_FUNCTION;
	memcpy(val->data, &fl, 4);
}


/* ARGSUSED */
static void
pmdoc_Nd(MDOC_ARGS)
{
	int		 first;
	
	for (first = 1, n = n->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			continue;
		if (first) 
			dbt_appendb(rval, rsz, n->string, strlen(n->string) + 1);
		else
			dbt_append(rval, rsz, n->string);
		first = 0;
	}
}

/* ARGSUSED */
static void
pmdoc_Nm(MDOC_ARGS)
{
	uint32_t	 fl;
	
	if (SEC_NAME == n->sec) {
		for (n = n->child; n; n = n->next) {
			if (MDOC_TEXT != n->type)
				continue;
			dbt_append(key, ksz, n->string);
		}
		fl = MANDOC_NAME;
		memcpy(val->data, &fl, 4);
		return;
	} else if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;

	for (n = n->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			continue;
		dbt_append(key, ksz, n->string);
	}

	fl = MANDOC_UTILITY;
	memcpy(val->data, &fl, 4);
}

static void
dbt_put(DB *db, const char *dbn, DBT *key, DBT *val)
{

	if (0 == key->size)
		return;

	assert(key->data);
	assert(val->size);
	assert(val->data);

	if (0 == (*db->put)(db, key, val, 0))
		return;
	
	perror(dbn);
	exit((int)MANDOCLEVEL_SYSERR);
	/* NOTREACHED */
}

/*
 * Call out to per-macro handlers after clearing the persistent database
 * key.  If the macro sets the database key, flush it to the database.
 */
static void
pmdoc_node(MDOC_ARGS)
{

	if (NULL == n)
		return;

	switch (n->type) {
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		/* FALLTHROUGH */
	case (MDOC_BLOCK):
		/* FALLTHROUGH */
	case (MDOC_ELEM):
		if (NULL == mdocs[n->tok])
			break;

		dbt_init(key, ksz);

		(*mdocs[n->tok])(db, dbn, key, ksz, val, rval, rsz, n);
		dbt_put(db, dbn, key, val);
		break;
	default:
		break;
	}

	pmdoc_node(db, dbn, key, ksz, val, rval, rsz, n->child);
	pmdoc_node(db, dbn, key, ksz, val, rval, rsz, n->next);
}

static int
pman_node(MAN_ARGS)
{
	const struct man_node *head, *body;
	const char	*start, *sv;
	size_t		 sz;
	uint32_t	 fl;

	if (NULL == n)
		return(0);

	/*
	 * We're only searching for one thing: the first text child in
	 * the BODY of a NAME section.  Since we don't keep track of
	 * sections in -man, run some hoops to find out whether we're in
	 * the correct section or not.
	 */

	if (MAN_BODY == n->type && MAN_SH == n->tok) {
		body = n;
		assert(body->parent);
		if (NULL != (head = body->parent->head) &&
				1 == head->nchild &&
				NULL != (head = (head->child)) &&
				MAN_TEXT == head->type &&
				0 == strcmp(head->string, "NAME") &&
				NULL != (body = body->child) &&
				MAN_TEXT == body->type) {

			fl = MANDOC_NAME;
			memcpy(val->data, &fl, 4);

			assert(body->string);
			start = sv = body->string;

			/* 
			 * Go through a special heuristic dance here.
			 * This is why -man manuals are great!
			 * (I'm being sarcastic: my eyes are bleeding.)
			 * Conventionally, one or more manual names are
			 * comma-specified prior to a whitespace, then a
			 * dash, then a description.  Try to puzzle out
			 * the name parts here.
			 */

			for ( ;; ) {
				sz = strcspn(start, " ,");
				if ('\0' == start[(int)sz])
					break;

				dbt_init(key, ksz);
				dbt_appendb(key, ksz, start, sz);
				dbt_appendb(key, ksz, "", 1);

				dbt_put(db, dbn, key, val);

				if (' ' == start[(int)sz]) {
					start += (int)sz + 1;
					break;
				}

				assert(',' == start[(int)sz]);
				start += (int)sz + 1;
				while (' ' == *start)
					start++;
			}

			if (sv == start) {
				dbt_init(key, ksz);
				dbt_append(key, ksz, start);
				return(1);
			}

			while (' ' == *start)
				start++;

			if (0 == strncmp(start, "-", 1))
				start += 1;
			else if (0 == strncmp(start, "\\-", 2))
				start += 2;
			else if (0 == strncmp(start, "\\(en", 4))
				start += 4;
			else if (0 == strncmp(start, "\\(em", 4))
				start += 4;

			while (' ' == *start)
				start++;

			dbt_appendb(rval, rsz, start, strlen(start) + 1);
		}
	}

	if (pman_node(db, dbn, key, ksz, val, rval, rsz, n->child))
		return(1);
	if (pman_node(db, dbn, key, ksz, val, rval, rsz, n->next))
		return(1);

	return(0);
}

static void
pman(DB *db, const char *dbn, DBT *key, size_t *ksz, 
		DBT *val, DBT *rval, size_t *rsz, struct man *m)
{

	pman_node(db, dbn, key, ksz, val, rval, rsz, man_node(m));
}


static void
pmdoc(DB *db, const char *dbn, DBT *key, size_t *ksz, 
		DBT *val, DBT *rval, size_t *rsz, struct mdoc *m)
{

	pmdoc_node(db, dbn, key, ksz, val, rval, rsz, mdoc_node(m));
}

static void
usage(void)
{

	fprintf(stderr, "usage: %s "
			"[-d path] "
			"[file...]\n", 
			progname);
}
@


1.20
log
@Make sure that we check for the \(en, \(em, \-, and - separators for
the heuristic dance to grab manual descriptions from man documents.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.19 2011/05/04 20:43:38 kristaps Exp $ */
d594 2
a595 1
	dbt_appendb(key, ksz, start, end - start + 1);
d706 1
a706 1
	if (';' == start[sz - 1])
@


1.19
log
@Grok manual architecture in mandoc-db.c.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.18 2011/05/04 08:21:17 kristaps Exp $ */
d874 1
d912 3
a914 1
			if ('\\' == *start && '-' == *(start + 1))
d916 4
a919 2
			else if ('-' == *start)
				start++;
@


1.18
log
@Add configurations (`Cd') to mandoc-db mining.
Also put some notes into index.sgml to the effect that mandoc-db exists,
but is not linked to the build.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.17 2011/05/03 14:39:27 kristaps Exp $ */
d231 1
d368 1
d385 3
@


1.17
log
@Pick up authors in mandoc-db.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.16 2011/05/03 10:08:09 kristaps Exp $ */
d53 2
a54 1
	MANDOC_AUTHOR
d83 1
d115 1
a115 1
	NULL, /* Cd */ 
d598 17
@


1.16
log
@Have mandoc-db grok `Dt'/`TH' manual title as well.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.15 2011/05/02 13:56:13 kristaps Exp $ */
d52 2
a53 1
	MANDOC_STANDARD
d81 1
d111 1
a111 1
	NULL, /* An */ 
d533 17
@


1.15
log
@Back out stripping of non-predef and non-special escape sequences from
input (this is not yet possible with mandoc_escape(), which depends on
nil-terminated strings).
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.14 2011/05/01 11:56:26 kristaps Exp $ */
d226 1
d360 3
d365 1
d378 1
@


1.14
log
@Have mandoc-db strip out escapes that aren't special or predefined
characters.  This is a work-in-progress that has some issues.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.13 2011/04/28 10:44:02 kristaps Exp $ */
a445 3
	void		*dstp, *endp;
	int		 ssz;
	enum mandoc_esc	 esc;
d456 1
d496 1
d498 1
a498 1
	memcpy(dstp, cp, sz);
@


1.13
log
@Let mandoc-db grok `St' tokens.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.12 2011/04/12 14:48:42 kristaps Exp $ */
d446 3
d459 41
a499 1
	memcpy(key->data + (int)key->size, cp, sz);
a530 1
	const char	 nil = '\0';
d564 1
a564 1
	dbt_appendb(key, ksz, &nil, 1);
d635 1
a635 1
	const char	*start, *end;
a636 1
	const char	 nil = '\0';
d657 2
a658 3
	end = &start[sz - 1];
	while (end > start && ';' == *end)
		end--;
d660 1
a660 1
	if (end == start)
d663 3
a665 2
	dbt_appendb(key, ksz, start, end - start + 1);
	dbt_appendb(key, ksz, &nil, 1);
a699 1

d776 1
a777 1

a792 1
	const char	 nil = '\0';
d839 1
a839 1
				dbt_appendb(key, ksz, &nil, 1);
@


1.12
log
@Let mandoc-db also collect -man descriptions.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.11 2011/04/11 22:56:25 kristaps Exp $ */
d51 2
a52 1
	MANDOC_VARIABLE
d86 1
d131 1
a131 1
	NULL, /* St */ 
d574 16
@


1.11
log
@Have mandoc-db accumulate manual page descriptions (`Nd' in -mdoc parlance)
in the index.  This allows, with both the btree and index, full emulation
of apropos(1) and other goodies.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.10 2011/04/11 21:36:44 kristaps Exp $ */
d734 1
a734 1
	const char	*start;
d763 2
a764 1
			start = body->string;
d775 1
a775 1
			while (start) {
d786 2
a787 1
				if (' ' == start[(int)sz])
d789 1
d797 18
a814 1
			return(1);
@


1.10
log
@Use dbt_xxxx functions to stash both filename and manual section in the
value part of the index.  This is the actual manual section---before,
mandoc.cgi was relying on the file suffix, but this can be (e.g.) .man or
whatnot.  This is The Correct Way (tm).
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.9 2011/04/05 14:16:05 kristaps Exp $ */
d58 1
d64 1
d73 2
a74 2
static	void		  pman(DB *, const char *, DBT *, 
				size_t *, DBT *, struct man *);
d76 2
a77 2
static	void		  pmdoc(DB *, const char *, DBT *, 
				size_t *, DBT *, struct mdoc *);
d83 1
d123 1
a123 1
	NULL, /* Nd */
d222 2
a223 2
	char		*fn;
	const char	*msec,
d229 1
a229 1
	int		 c;
d234 3
a236 2
	size_t		 ksz, rsz; /* entry buffer size */
	char		 vbuf[8];
d238 1
a238 1
	recno_t		 rec;
d250 2
a251 2
	while (-1 != (c = getopt(argc, argv, "d:")))
		switch (c) {
d342 2
a347 1

d352 2
d358 9
a366 1
		rkey.data = &rec;
d371 1
d373 1
a373 1
		dbt_put(idx, ibbuf, &rkey, &rval);
d379 2
a380 1
			pmdoc(db, fbbuf, &key, &ksz, &val, mdoc);
d382 15
a396 1
			pman(db, fbbuf, &key, &ksz, &val, man);
d627 19
d718 1
a718 1
		(*mdocs[n->tok])(db, dbn, key, ksz, val, n);
d726 2
a727 2
	pmdoc_node(db, dbn, key, ksz, val, n->child);
	pmdoc_node(db, dbn, key, ksz, val, n->next);
d798 1
a798 1
	if (pman_node(db, dbn, key, ksz, val, n->child))
d800 1
a800 1
	if (pman_node(db, dbn, key, ksz, val, n->next))
d807 2
a808 2
pman(DB *db, const char *dbn, DBT *key, 
		size_t *ksz, DBT *val, struct man *m)
d811 1
a811 1
	pman_node(db, dbn, key, ksz, val, man_node(m));
d816 2
a817 2
pmdoc(DB *db, const char *dbn, DBT *key, 
		size_t *ksz, DBT *val, struct mdoc *m)
d820 1
a820 1
	pmdoc_node(db, dbn, key, ksz, val, mdoc_node(m));
@


1.9
log
@Lint-checks over mandoc-db.c.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.8 2011/04/05 14:10:52 kristaps Exp $ */
d220 2
a221 1
	const char	*dir; /* result dir (default: cwd) */
d231 1
a231 1
	size_t		 ksz; /* entry buffer size */
d333 1
a333 1
	ksz = 0;
d347 4
a351 2
		rval.data = fn;
		rval.size = strlen(fn) + 1;
d353 5
a357 4
		if (-1 == (*idx->put)(idx, &rkey, &rval, 0)) {
			perror(ibbuf);
			break;
		}
d375 1
d455 1
a455 1
	char		 nil;
a487 1
	nil = '\0';
d546 1
a546 1
	char		 nil;
a573 1
	nil = '\0';
d632 1
a632 1
	assert(8 == val->size);
d685 1
a685 1
	char		 nil;
a708 1
			nil = '\0';
@


1.8
log
@Use a little more horsepower in parsing out NAME sections from -man
manuals.  This covers the majority case.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.7 2011/04/05 13:12:34 kristaps Exp $ */
d71 2
a72 3
static	void		  pman(DB *, const char *, 
				DBT *, size_t *, DBT *, 
				const char *, struct man *);
d74 2
a75 3
static	void		  pmdoc(DB *, const char *, 
				DBT *, size_t *, DBT *, 
				const char *, struct mdoc *);
d226 1
a226 1
	DB		*index, /* index database */
d305 1
a305 1
	index = dbopen(ibbuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);
d350 1
a350 1
		if (-1 == (*index->put)(index, &rkey, &rval, 0)) {
d359 1
a359 1
			pmdoc(db, fbbuf, &key, &ksz, &val, fn, mdoc);
d361 1
a361 1
			pman(db, fbbuf, &key, &ksz, &val, fn, man);
d366 1
a366 1
	(*index->close)(index);
d755 2
a756 3
pman(DB *db, const char *dbn, 
		DBT *key, size_t *ksz, DBT *val, 
		const char *path, struct man *m)
d764 2
a765 3
pmdoc(DB *db, const char *dbn, 
		DBT *key, size_t *ksz, DBT *val, 
		const char *path, struct mdoc *m)
@


1.7
log
@Fix type- and NULL-check to be correct node (last, not child).  Prevents
segfault in NetBSD.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.6 2011/04/05 13:09:33 kristaps Exp $ */
d69 1
d623 19
d669 2
a670 8
		if (0 == key->size)
			break;
		if (0 == (*db->put)(db, key, val, 0))
			break;
		
		perror(dbn);
		exit((int)MANDOCLEVEL_SYSERR);
		/* NOTREACHED */
d683 1
a683 1
	const char	*end, *start;
d685 1
d710 3
a713 2
			if (NULL == (end = strchr(start, ' ')))
				end = start + strlen(start);
d715 29
a743 5
			dbt_init(key, ksz);
			dbt_appendb(key, ksz, start, end - start + 1);
			dbt_appendb(key, ksz, &nil, 1);
			fl = MANDOC_NAME;
			memcpy(val->data, &fl, 4);
@


1.6
log
@Add mandoc-db.c checking for utility-name in NAME section of -man
documents.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.5 2011/04/04 16:49:03 kristaps Exp $ */
d549 1
a549 1
	if (NULL == n->child || MDOC_TEXT != n->child->type)
@


1.5
log
@Have `Fd' detection in mandoc-db also look for local includes (i.e.,
those that are quoted and not angular-bracketed).
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.4 2011/04/04 10:53:15 kristaps Exp $ */
d54 5
d70 4
d219 1
d343 2
a344 2
		mparse_result(mp, &mdoc, NULL);
		if (NULL == mdoc)
d359 4
a362 1
		pmdoc(db, fbbuf, &key, &ksz, &val, fn, mdoc);
d665 61
@


1.4
log
@Add manual page for mandoc-db (mostly to document the file format of
the generated index and keyword databases).  Add some documentation
within mandoc-db.c.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.3 2011/04/03 14:18:29 kristaps Exp $ */
d461 1
a461 1
	if ('<' == *start)
d468 1
a468 1
	if ('>' == *end)
@


1.3
log
@Have mandoc-db create an recno-addressed index of files alongside the
keyword database, which references the index of hard-coding files.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.2 2011/04/03 10:14:45 kristaps Exp $ */
a63 1
static	void		  version(void);
d236 1
a236 1
	while (-1 != (c = getopt(argc, argv, "d:V")))
a240 3
		case ('V'):
			version();
			return((int)MANDOCLEVEL_OK);
d328 2
a329 1
		if (mparse_readfd(mp, -1, fn) >= MANDOCLEVEL_FATAL)
d331 1
d444 5
d451 1
d455 5
d513 1
a513 1
	/* Ignore pointers. */
d540 1
a540 1
	 * Strip away leading '*' and trailing ';'.
a661 7
version(void)
{

	printf("%s %s\n", progname, VERSION);
}

static void
a665 1
			"[-V] "
@


1.2
log
@Have mandoc-db use config.h for strlcat().  Then create the btree
database from a directory, instead of a path.  This is because it'll
also output an index of files to that same directory.  Add documentation
to the local variable names, too.
@
text
@d1 1
a1 1
/*	$Id: mandoc-db.c,v 1.1 2011/04/02 15:40:40 kristaps Exp $ */
d41 1
d43 1
d67 1
a67 2
				DBT *, size_t *, 
				DBT *, size_t *, 
d211 5
a215 3
	const char	*fn, 
	      		*dir; /* result dir (default: cwd) */
	char		 fbuf[MAXPATHLEN],  /* btree fname */
d218 6
a223 3
	DB		*db; /* open database */
	DBT		 key, val; /* persistent entries */
	size_t		 ksz, vsz; /* entry buffer sizes */
d225 1
d235 1
a235 1
	dir = "./";
d254 4
a257 3
	 * Set up a temporary file-name into which we're going to write
	 * all of our data.  This is securely renamed to the real
	 * file-name after we've written all of our data.
d260 4
a263 2
	fbuf[0] = fbuf[MAXPATHLEN - 2] = 
		fbbuf[0] = fbbuf[MAXPATHLEN - 1] = '\0';
d267 1
d271 6
d278 4
a281 2
			'\0' != fbbuf[MAXPATHLEN - 2]) {
		fprintf(stderr, "%s: Bad filename\n", progname);
d286 3
a288 3
	 * Open a BTREE database that allows duplicates.  If the
	 * database already exists (it's a backup anyway), then blow it
	 * away with O_TRUNC.
d293 1
a293 3

	db = dbopen(fbbuf, O_CREAT|O_TRUNC|O_RDWR, 
			0644, DB_BTREE, &info);
d300 1
a300 1
	/* Use the auto-parser and don't report any errors. */
d302 5
a306 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
d312 1
d315 2
d319 9
a327 1
	ksz = vsz = 0;
d331 1
d334 1
d336 17
a352 3
		if (mdoc)
			pmdoc(db, fbbuf, &key, &ksz, 
				&val, &vsz, fn, mdoc);
d356 2
a360 1
	free(val.data);
d366 2
a404 1
		*ksz = *ksz + (4 - (*ksz % 4));
a421 3
	assert(key->data);
	assert(key->size <= *ksz);

d425 1
a425 9
	/* Overshoot by MANDOC_BUFSZ (and nil terminator). */

	while (key->size + sz + 1 >= *ksz) {
		*ksz = key->size + sz + 1 + MANDOC_BUFSZ;
		*ksz = *ksz + (4 - (*ksz % 4));
		key->data = mandoc_realloc(key->data, *ksz);
	}

	/* Space-separate appended tokens. */
d430 1
a430 2
	memcpy(key->data + (int)key->size, cp, sz + 1);
	key->size += sz + 1;
d645 1
a645 2
		DBT *key, size_t *ksz, 
		DBT *val, size_t *valsz,
a647 13
	uint32_t	 flag;

	flag = MANDOC_NONE;

	/* 
	 * Database values are a 4-byte bit-field followed by the path
	 * of the manual.  Allocate all the space we'll need now; we
	 * change the bit-field depending on the key type.
	 */

	dbt_init(val, valsz);
	dbt_appendb(val, valsz, &flag, 4);
	dbt_append(val, valsz, path);
@


1.1
log
@Add an initial keyword-indexer as an alternative front-end to libmandoc.a.
This will be used during BSDCan-2011, paired with a web front-end, as a
demonstrandum of semantic annotations (mdoc) versus those of man.  This
isn't linked to the build in any way but for cleaning created files.  This
code has been heavily tested under valgrind and is known to work on
GNU/Linux (needs -ldb library), all BSDs, and Mac OSX.

Please don't repost this, for the time being, as I don't want to spoil the
fun for the conference.  This utility is still constantly under development
(e.g., it will also generate a recno database of filenames and `Nd' output
so that paths needn't be hard-coded) but is mature enough to warrant being
checked in.
@
text
@d1 1
a1 1
/*	$Id: main.c,v 1.160 2011/03/28 21:49:42 kristaps Exp $ */
d17 4
d41 1
a41 1
#define	MANDOC_BUFSZ	  10
d208 6
a213 6
	struct mparse	*mp;
	struct mdoc	*mdoc;
	struct man	*man;
	const char	*f, *fn;
	size_t		 sz;
	char		 fbuf[MAXPATHLEN];
d215 4
a218 4
	DB		*db;
	DBT		 key, val;
	size_t		 ksz, vsz;
	BTREEINFO	 info;
a221 2
	f = MANDOC_DB;

d228 3
a230 1
	while (-1 != (c = getopt(argc, argv, "f:V")))
d232 2
a233 2
		case ('f'):
			f = optarg;
d252 10
a261 1
	if (0 == (sz = strlen(f)) || sz + 5 >= MAXPATHLEN) {
a265 4
	memcpy(fbuf, f, sz);
	memcpy(fbuf + (int)sz, ".bak", 4);
	fbuf[(int)sz + 4] = '\0';

d275 1
a275 1
	db = dbopen(fbuf, O_CREAT|O_TRUNC|O_RDWR, 
d279 1
a279 1
		perror(f);
a297 1
		printf("Trying: %s\n", fn);
d301 1
a301 1
		mparse_result(mp, &mdoc, &man);
d303 1
a303 1
			pmdoc(db, fbuf, &key, &ksz, 
d315 2
a316 2
	if (-1 == rename(fbuf, f))
		perror(f);
d641 1
a641 1
			"[-f path] "
@
