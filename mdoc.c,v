head	1.256;
access;
symbols
	VERSION_1_13_3:1.238
	VERSION_1_13_2:1.233
	VERSION_1_12_4:1.224
	VERSION_1_13_1:1.223
	VERSION_1_12_3:1.206
	VERSION_1_12_2:1.203
	VERSION_1_12:1.224.0.2
	VERSION_1_12_1:1.196
	VERSION_1_12_0:1.196
	VERSION_1_11_7:1.195
	VERSION_1_11_6:1.195
	VERSION_1_11_5:1.190
	VERSION_1_11_4:1.188
	VERSION_1_11_3:1.188
	VERSION_1_11_2:1.188
	VERSION_1_11_1:1.188
	VERSION_1_10_10:1.184
	VERSION_1_10_9:1.177
	VERSION_1_10_8:1.172
	VERSION_1_10_7:1.168
	VERSION_1_10_6:1.164
	VERSION_1_10_5:1.159
	VERSION_1_10_5_PREPDF:1.159
	VERSION_1_10_4:1.158
	VERSION_1_10_3:1.151
	VERSION_1_10_2:1.146
	VERSION_1_10_1:1.145
	VERSION_1_9_24:1.127
	VERSION_1_9_25:1.130
	VERSION_1_9_23:1.121
	VERSION_1_9_22:1.118
	VERSION_1_9_21:1.116
	VERSION_1_9_20:1.116
	VERSION_1_9_19:1.116
	VERSION_1_9_18:1.116
	VERSION_1_9_17:1.116
	VERSION_1_9_16:1.116
	VERSION_1_9_15:1.116
	VERSION_1_9_15-pre2:1.114
	VERSION_1_9_15-pre1:1.113
	VERSION_1_9_14:1.113
	VERSION_1_9_13:1.113
	VERSION_1_9_12:1.113
	VERSION_1_9_11:1.111
	VERSION_1_9_10:1.111
	VERSION_1_9_9:1.109
	VERSION_1_9_8:1.107
	VERSION_1_9_7:1.107
	VERSION_1_9_6:1.107
	VERSION_1_9_5:1.105
	VERSION_1_9_2:1.104
	VERSION_1_9_1:1.103
	VERSION_1_9_0:1.100
	VERSION_1_8_5:1.96
	VERSION_1_8_4:1.95
	VERSION_1_8_3:1.95
	VERSION_1_8_2:1.95
	VERSION_1_8_1:1.94
	VERSION_1_8_0:1.90
	VERSION_1_7_24:1.89
	VERSION_1_7_23:1.89
	VERSION_1_7_22:1.86
	VERSION_1_7_21:1.86
	VERSION_1_7_20:1.86
	VERSION_1_7_19:1.85
	VERSION_1_7_17:1.80
	VERSION_1_7_16:1.77
	VERSION_1_7_15:1.77
	VERSION_1_7_14:1.76
	VERSION_1_7_13:1.75
	VERSION_1_7_12:1.74
	OPENBSD_CHECKIN:1.74
	VERSION_1_7_10:1.74
	VERSION_1_7_5:1.72
	VERSION_1_6_5:1.69
	VERSION_1_6_2:1.68
	VERSION_1_5_3:1.66
	VERSION_1_5_1:1.64
	VERSION_1_4_6:1.59
	VERSION_1_4_5:1.58
	VERSION_1_4_4:1.58
	VERSION_1_4_2:1.55
	VERSION_1_3_15:1.49
	VERSION_1_3_13:1.48
	VERSION_1_3_11:1.48
	VERSION_1_3_10:1.48
	VERSION_1_3_9:1.48
	VERSION_1_3_8:1.48
	VERSION_1_3_6:1.48
	VERSION_1_3_5:1.48
	VERSION_1_2_0:1.42
	VERSION_1_1_0:1.30;
locks; strict;
comment	@ * @;


1.256
date	2015.10.30.19.04.16;	author schwarze;	state Exp;
branches;
next	1.255;

1.255
date	2015.10.20.02.01.31;	author schwarze;	state Exp;
branches;
next	1.254;

1.254
date	2015.10.12.00.08.15;	author schwarze;	state Exp;
branches;
next	1.253;

1.253
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.252;

1.252
date	2015.04.23.16.17.44;	author schwarze;	state Exp;
branches;
next	1.251;

1.251
date	2015.04.23.15.35.59;	author schwarze;	state Exp;
branches;
next	1.250;

1.250
date	2015.04.19.14.57.38;	author schwarze;	state Exp;
branches;
next	1.249;

1.249
date	2015.04.19.14.25.41;	author schwarze;	state Exp;
branches;
next	1.248;

1.248
date	2015.04.19.14.00.19;	author schwarze;	state Exp;
branches;
next	1.247;

1.247
date	2015.04.19.13.50.26;	author schwarze;	state Exp;
branches;
next	1.246;

1.246
date	2015.04.18.17.53.21;	author schwarze;	state Exp;
branches;
next	1.245;

1.245
date	2015.04.18.17.28.36;	author schwarze;	state Exp;
branches;
next	1.244;

1.244
date	2015.04.18.17.01.58;	author schwarze;	state Exp;
branches;
next	1.243;

1.243
date	2015.04.18.16.34.25;	author schwarze;	state Exp;
branches;
next	1.242;

1.242
date	2015.04.18.16.06.40;	author schwarze;	state Exp;
branches;
next	1.241;

1.241
date	2015.04.02.23.48.19;	author schwarze;	state Exp;
branches;
next	1.240;

1.240
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.239;

1.239
date	2015.04.02.21.36.50;	author schwarze;	state Exp;
branches;
next	1.238;

1.238
date	2015.02.12.13.00.52;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2015.02.12.12.24.33;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2015.02.05.00.14.13;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2015.02.02.04.26.44;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2015.01.15.04.26.40;	author schwarze;	state Exp;
branches;
next	1.233;

1.233
date	2014.11.28.06.27.05;	author schwarze;	state Exp;
branches;
next	1.232;

1.232
date	2014.11.28.04.47.03;	author schwarze;	state Exp;
branches;
next	1.231;

1.231
date	2014.11.28.03.14.18;	author schwarze;	state Exp;
branches;
next	1.230;

1.230
date	2014.11.28.01.05.43;	author schwarze;	state Exp;
branches;
next	1.229;

1.229
date	2014.11.19.03.08.17;	author schwarze;	state Exp;
branches;
next	1.228;

1.228
date	2014.10.20.15.50.24;	author schwarze;	state Exp;
branches;
next	1.227;

1.227
date	2014.10.20.02.33.06;	author schwarze;	state Exp;
branches;
next	1.226;

1.226
date	2014.10.16.01.11.20;	author schwarze;	state Exp;
branches;
next	1.225;

1.225
date	2014.09.06.23.24.32;	author schwarze;	state Exp;
branches;
next	1.224;

1.224
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.223;

1.223
date	2014.08.06.15.09.05;	author schwarze;	state Exp;
branches;
next	1.222;

1.222
date	2014.08.01.17.27.44;	author schwarze;	state Exp;
branches;
next	1.221;

1.221
date	2014.07.30.21.18.24;	author schwarze;	state Exp;
branches;
next	1.220;

1.220
date	2014.07.09.11.31.43;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2014.07.07.15.03.43;	author schwarze;	state Exp;
branches;
next	1.218;

1.218
date	2014.07.06.19.09.00;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2014.07.02.03.48.07;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2014.07.01.22.37.15;	author schwarze;	state Exp;
branches;
next	1.215;

1.215
date	2014.06.20.17.24.00;	author schwarze;	state Exp;
branches;
next	1.214;

1.214
date	2014.04.25.14.11.30;	author schwarze;	state Exp;
branches;
next	1.213;

1.213
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2014.03.30.19.47.48;	author schwarze;	state Exp;
branches;
next	1.211;

1.211
date	2014.03.23.12.44.56;	author schwarze;	state Exp;
branches;
next	1.210;

1.210
date	2014.03.23.12.11.18;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2014.01.05.20.26.36;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2013.12.31.23.23.11;	author schwarze;	state Exp;
branches;
next	1.206;

1.206
date	2013.12.24.19.11.46;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2013.10.21.23.47.58;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2013.10.05.22.08.12;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2012.11.17.00.26.33;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2012.11.16.13.40.36;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2012.07.18.11.11.12;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2012.07.18.10.39.19;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2012.07.16.09.51.54;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2012.06.12.20.21.04;	author kristaps;	state Exp;
branches;
next	1.197;

1.197
date	2012.05.27.17.48.57;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2011.09.30.00.13.28;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2011.07.28.14.17.11;	author kristaps;	state Exp;
branches;
next	1.194;

1.194
date	2011.07.27.12.43.02;	author kristaps;	state Exp;
branches;
next	1.193;

1.193
date	2011.07.27.12.41.02;	author kristaps;	state Exp;
branches;
next	1.192;

1.192
date	2011.07.27.07.09.41;	author kristaps;	state Exp;
branches;
next	1.191;

1.191
date	2011.07.25.15.37.00;	author kristaps;	state Exp;
branches;
next	1.190;

1.190
date	2011.07.21.10.24.35;	author kristaps;	state Exp;
branches;
next	1.189;

1.189
date	2011.07.18.07.46.41;	author kristaps;	state Exp;
branches;
next	1.188;

1.188
date	2011.03.28.23.52.13;	author kristaps;	state Exp;
branches;
next	1.187;

1.187
date	2011.03.22.14.33.05;	author kristaps;	state Exp;
branches;
next	1.186;

1.186
date	2011.03.22.14.05.45;	author kristaps;	state Exp;
branches;
next	1.185;

1.185
date	2011.03.20.16.02.05;	author kristaps;	state Exp;
branches;
next	1.184;

1.184
date	2011.03.17.11.30.23;	author kristaps;	state Exp;
branches;
next	1.183;

1.183
date	2011.03.15.13.23.33;	author kristaps;	state Exp;
branches;
next	1.182;

1.182
date	2011.03.07.01.35.51;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2011.02.09.09.05.52;	author kristaps;	state Exp;
branches;
next	1.180;

1.180
date	2011.02.08.07.40.23;	author kristaps;	state Exp;
branches;
next	1.179;

1.179
date	2011.02.06.22.05.20;	author kristaps;	state Exp;
branches;
next	1.178;

1.178
date	2011.02.06.22.02.58;	author kristaps;	state Exp;
branches;
next	1.177;

1.177
date	2011.01.03.11.27.33;	author kristaps;	state Exp;
branches;
next	1.176;

1.176
date	2011.01.01.12.59.17;	author kristaps;	state Exp;
branches;
next	1.175;

1.175
date	2011.01.01.12.18.37;	author kristaps;	state Exp;
branches;
next	1.174;

1.174
date	2011.01.01.10.51.30;	author kristaps;	state Exp;
branches;
next	1.173;

1.173
date	2010.12.25.13.50.37;	author kristaps;	state Exp;
branches;
next	1.172;

1.172
date	2010.12.24.14.00.40;	author kristaps;	state Exp;
branches;
next	1.171;

1.171
date	2010.12.22.11.15.16;	author kristaps;	state Exp;
branches;
next	1.170;

1.170
date	2010.12.16.17.14.48;	author kristaps;	state Exp;
branches;
next	1.169;

1.169
date	2010.12.15.23.39.40;	author kristaps;	state Exp;
branches;
next	1.168;

1.168
date	2010.12.06.11.01.19;	author kristaps;	state Exp;
branches;
next	1.167;

1.167
date	2010.12.01.16.38.57;	author kristaps;	state Exp;
branches;
next	1.166;

1.166
date	2010.11.30.13.04.14;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2010.09.27.23.03.44;	author schwarze;	state Exp;
branches;
next	1.164;

1.164
date	2010.08.29.11.29.51;	author kristaps;	state Exp;
branches;
next	1.163;

1.163
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.162;

1.162
date	2010.08.08.14.51.32;	author schwarze;	state Exp;
branches;
next	1.161;

1.161
date	2010.08.07.20.57.33;	author kristaps;	state Exp;
branches;
next	1.160;

1.160
date	2010.08.07.20.33.55;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2010.07.18.17.00.26;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2010.07.07.15.04.54;	author kristaps;	state Exp;
branches;
next	1.157;

1.157
date	2010.07.04.22.04.04;	author schwarze;	state Exp;
branches;
next	1.156;

1.156
date	2010.07.02.12.54.33;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2010.07.01.23.01.47;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2010.07.01.22.56.17;	author kristaps;	state Exp;
branches;
next	1.153;

1.153
date	2010.07.01.22.35.54;	author schwarze;	state Exp;
branches;
next	1.152;

1.152
date	2010.06.29.19.20.38;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2010.06.27.16.36.22;	author kristaps;	state Exp;
branches;
next	1.150;

1.150
date	2010.06.27.16.18.13;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2010.06.27.15.52.41;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2010.06.26.16.07.08;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2010.06.26.15.36.37;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2010.06.12.11.58.22;	author kristaps;	state Exp;
branches;
next	1.145;

1.145
date	2010.05.31.21.32.57;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2010.05.31.20.14.10;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2010.05.31.15.50.48;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2010.05.31.15.42.09;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2010.05.31.10.28.04;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2010.05.30.11.00.53;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2010.05.26.09.35.35;	author kristaps;	state Exp;
branches;
next	1.138;

1.138
date	2010.05.25.12.37.20;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2010.05.24.13.39.47;	author schwarze;	state Exp;
branches;
next	1.136;

1.136
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.16.10.59.36;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.16.00.04.46;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.15.16.24.37;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2010.05.15.06.48.13;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2010.05.14.17.31.25;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2010.05.13.06.22.11;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2010.05.12.17.08.03;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2010.05.12.16.01.01;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2010.05.08.10.25.27;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2010.05.08.08.36.44;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2010.05.08.07.30.19;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2010.05.07.15.49.36;	author kristaps;	state Exp;
branches;
next	1.123;

1.123
date	2010.04.08.07.53.01;	author kristaps;	state Exp;
branches;
next	1.122;

1.122
date	2010.04.08.07.06.15;	author kristaps;	state Exp;
branches;
next	1.121;

1.121
date	2010.04.06.11.33.00;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2010.04.05.08.59.46;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2010.04.03.13.02.35;	author kristaps;	state Exp;
branches;
next	1.118;

1.118
date	2010.03.31.07.42.04;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2010.03.31.07.13.53;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2010.01.07.10.24.43;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2010.01.07.10.05.24;	author kristaps;	state Exp;
branches;
next	1.114;

1.114
date	2010.01.01.17.14.29;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.30.05.58.38;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2009.10.27.08.26.12;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2009.10.26.07.11.07;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2009.10.24.05.52.13;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2009.10.15.02.56.51;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2009.10.15.01.33.12;	author kristaps;	state Exp;
branches;
next	1.107;

1.107
date	2009.09.24.15.01.06;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2009.09.23.11.53.45;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2009.09.16.14.40.56;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2009.08.22.08.56.16;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2009.08.20.11.44.47;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2009.08.19.14.09.33;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2009.08.19.11.58.32;	author kristaps;	state Exp;
branches;
next	1.100;

1.100
date	2009.08.18.14.27.16;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.13.11.43.24;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2009.07.29.08.52.24;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2009.07.29.08.46.06;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2009.07.27.19.43.02;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2009.07.20.14.09.38;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2009.07.17.12.27.49;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2009.07.17.10.56.57;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.16.13.42.12;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2009.07.15.15.36.38;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2009.07.12.20.50.08;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2009.07.07.09.29.15;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.06.13.04.52;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2009.07.06.09.21.24;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2009.06.18.20.46.19;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2009.06.17.10.53.32;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2009.06.17.07.59.47;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.16.20.22.23;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.16.19.45.51;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.16.19.13.28;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.15.10.36.01;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.15.10.02.53;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2009.06.15.09.55.43;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2009.06.12.12.52.51;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2009.06.10.20.18.43;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.02.06.51.44;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.31.13.50.19;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.23.15.41.09;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.23.15.20.51;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.23.14.22.11;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.21.09.42.07;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.20.15.14.01;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.19.11.49.00;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.16.23.37.28;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.16.22.19.19;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2009.03.12.16.30.50;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.12.15.55.11;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.12.02.57.36;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.11.00.39.58;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.09.14.19.59;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.09.13.35.09;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.09.13.04.01;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.08.20.57.35;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.08.20.50.12;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.08.18.02.36;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.08.12.40.27;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.08.11.41.22;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.06.14.13.47;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.05.13.12.12;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.02.17.14.46;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.01.23.14.15;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.02.23.12.45.19;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.02.22.22.58.39;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.02.22.14.31.08;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.20.07.43.15;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.21.11.35.26;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.01.20.20.56.21;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.01.20.13.49.36;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.01.20.13.44.05;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.20.13.05.28;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.20.12.51.28;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.19.17.53.54;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.19.17.51.33;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.19.17.02.58;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.17.20.10.36;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.17.16.15.27;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.01.16.15.58.50;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.16.14.04.26;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.15.17.38.57;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.15.15.46.45;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.01.14.11.58.24;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.01.12.16.39.57;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.01.12.12.52.21;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.01.12.10.31.53;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.09.14.45.44;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.08.15.05.50;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.08.14.55.59;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.01.07.16.11.40;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.07.15.57.14;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.07.15.53.00;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.06.15.49.44;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.05.17.57.08;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.05.16.11.14;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.05.14.14.04;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.03.22.10.22;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.02.14.06.16;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.01.20.40.16;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.30.19.06.03;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.30.13.43.53;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2008.12.29.19.25.29;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.29.18.08.44;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.29.12.19.41;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.28.23.07.04;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.28.21.25.09;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.12.28.00.34.20;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.23.05.30.49;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.12.17.17.18.38;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.12.15.02.23.12;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.12.15.01.54.58;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.256
log
@If a .Bd block has no arguments at all, drop the block and only keep
its contents.  Removing a gratuitious difference to groff output
found after a related bug report from krw@@.
@
text
@/*	$Id: mdoc.c,v 1.255 2015/10/20 02:01:31 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

const	char *const __mdoc_macronames[MDOC_MAX + 1] = {
	"text",
	"Ap",		"Dd",		"Dt",		"Os",
	"Sh",		"Ss",		"Pp",		"D1",
	"Dl",		"Bd",		"Ed",		"Bl",
	"El",		"It",		"Ad",		"An",
	"Ar",		"Cd",		"Cm",		"Dv",
	"Er",		"Ev",		"Ex",		"Fa",
	"Fd",		"Fl",		"Fn",		"Ft",
	"Ic",		"In",		"Li",		"Nd",
	"Nm",		"Op",		"Ot",		"Pa",
	"Rv",		"St",		"Va",		"Vt",
	"Xr",		"%A",		"%B",		"%D",
	"%I",		"%J",		"%N",		"%O",
	"%P",		"%R",		"%T",		"%V",
	"Ac",		"Ao",		"Aq",		"At",
	"Bc",		"Bf",		"Bo",		"Bq",
	"Bsx",		"Bx",		"Db",		"Dc",
	"Do",		"Dq",		"Ec",		"Ef",
	"Em",		"Eo",		"Fx",		"Ms",
	"No",		"Ns",		"Nx",		"Ox",
	"Pc",		"Pf",		"Po",		"Pq",
	"Qc",		"Ql",		"Qo",		"Qq",
	"Re",		"Rs",		"Sc",		"So",
	"Sq",		"Sm",		"Sx",		"Sy",
	"Tn",		"Ux",		"Xc",		"Xo",
	"Fo",		"Fc",		"Oo",		"Oc",
	"Bk",		"Ek",		"Bt",		"Hf",
	"Fr",		"Ud",		"Lb",		"Lp",
	"Lk",		"Mt",		"Brq",		"Bro",
	"Brc",		"%C",		"Es",		"En",
	"Dx",		"%Q",		"br",		"sp",
	"%U",		"Ta",		"ll",
};

const	char *const __mdoc_argnames[MDOC_ARG_MAX] = {
	"split",		"nosplit",		"ragged",
	"unfilled",		"literal",		"file",
	"offset",		"bullet",		"dash",
	"hyphen",		"item",			"enum",
	"tag",			"diag",			"hang",
	"ohang",		"inset",		"column",
	"width",		"compact",		"std",
	"filled",		"words",		"emphasis",
	"symbolic",		"nested",		"centered"
	};

const	char * const *mdoc_macronames = __mdoc_macronames + 1;
const	char * const *mdoc_argnames = __mdoc_argnames;

static	int		  mdoc_ptext(struct roff_man *, int, char *, int);
static	int		  mdoc_pmacro(struct roff_man *, int, char *, int);


/*
 * Main parse routine.  Parses a single line -- really just hands off to
 * the macro (mdoc_pmacro()) or text parser (mdoc_ptext()).
 */
int
mdoc_parseln(struct roff_man *mdoc, int ln, char *buf, int offs)
{

	if (mdoc->last->type != ROFFT_EQN || ln > mdoc->last->line)
		mdoc->flags |= MDOC_NEWLINE;

	/*
	 * Let the roff nS register switch SYNOPSIS mode early,
	 * such that the parser knows at all times
	 * whether this mode is on or off.
	 * Note that this mode is also switched by the Sh macro.
	 */
	if (roff_getreg(mdoc->roff, "nS"))
		mdoc->flags |= MDOC_SYNOPSIS;
	else
		mdoc->flags &= ~MDOC_SYNOPSIS;

	return roff_getcontrol(mdoc->roff, buf, &offs) ?
	    mdoc_pmacro(mdoc, ln, buf, offs) :
	    mdoc_ptext(mdoc, ln, buf, offs);
}

void
mdoc_macro(MACRO_PROT_ARGS)
{
	assert(tok > TOKEN_NONE && tok < MDOC_MAX);

	(*mdoc_macros[tok].fp)(mdoc, tok, line, ppos, pos, buf);
}

void
mdoc_tail_alloc(struct roff_man *mdoc, int line, int pos, int tok)
{
	struct roff_node *p;

	p = roff_node_alloc(mdoc, line, pos, ROFFT_TAIL, tok);
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
}

struct roff_node *
mdoc_endbody_alloc(struct roff_man *mdoc, int line, int pos, int tok,
		struct roff_node *body, enum mdoc_endbody end)
{
	struct roff_node *p;

	body->flags |= MDOC_ENDED;
	body->parent->flags |= MDOC_ENDED;
	p = roff_node_alloc(mdoc, line, pos, ROFFT_BODY, tok);
	p->body = body;
	p->norm = body->norm;
	p->end = end;
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_SIBLING;
	return p;
}

struct roff_node *
mdoc_block_alloc(struct roff_man *mdoc, int line, int pos,
	int tok, struct mdoc_arg *args)
{
	struct roff_node *p;

	p = roff_node_alloc(mdoc, line, pos, ROFFT_BLOCK, tok);
	p->args = args;
	if (p->args)
		(args->refcnt)++;

	switch (tok) {
	case MDOC_Bd:
	case MDOC_Bf:
	case MDOC_Bl:
	case MDOC_En:
	case MDOC_Rs:
		p->norm = mandoc_calloc(1, sizeof(union mdoc_data));
		break;
	default:
		break;
	}
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
	return p;
}

void
mdoc_elem_alloc(struct roff_man *mdoc, int line, int pos,
	int tok, struct mdoc_arg *args)
{
	struct roff_node *p;

	p = roff_node_alloc(mdoc, line, pos, ROFFT_ELEM, tok);
	p->args = args;
	if (p->args)
		(args->refcnt)++;

	switch (tok) {
	case MDOC_An:
		p->norm = mandoc_calloc(1, sizeof(union mdoc_data));
		break;
	default:
		break;
	}
	roff_node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
}

void
mdoc_node_relink(struct roff_man *mdoc, struct roff_node *p)
{

	roff_node_unlink(mdoc, p);
	p->prev = p->next = NULL;
	roff_node_append(mdoc, p);
}

/*
 * Parse free-form text, that is, a line that does not begin with the
 * control character.
 */
static int
mdoc_ptext(struct roff_man *mdoc, int line, char *buf, int offs)
{
	struct roff_node *n;
	char		 *c, *ws, *end;

	assert(mdoc->last);
	n = mdoc->last;

	/*
	 * Divert directly to list processing if we're encountering a
	 * columnar ROFFT_BLOCK with or without a prior ROFFT_BLOCK entry
	 * (a ROFFT_BODY means it's already open, in which case we should
	 * process within its context in the normal way).
	 */

	if (n->tok == MDOC_Bl && n->type == ROFFT_BODY &&
	    n->end == ENDBODY_NOT && n->norm->Bl.type == LIST_column) {
		/* `Bl' is open without any children. */
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf);
		return 1;
	}

	if (n->tok == MDOC_It && n->type == ROFFT_BLOCK &&
	    NULL != n->parent &&
	    MDOC_Bl == n->parent->tok &&
	    LIST_column == n->parent->norm->Bl.type) {
		/* `Bl' has block-level `It' children. */
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf);
		return 1;
	}

	/*
	 * Search for the beginning of unescaped trailing whitespace (ws)
	 * and for the first character not to be output (end).
	 */

	/* FIXME: replace with strcspn(). */
	ws = NULL;
	for (c = end = buf + offs; *c; c++) {
		switch (*c) {
		case ' ':
			if (NULL == ws)
				ws = c;
			continue;
		case '\t':
			/*
			 * Always warn about trailing tabs,
			 * even outside literal context,
			 * where they should be put on the next line.
			 */
			if (NULL == ws)
				ws = c;
			/*
			 * Strip trailing tabs in literal context only;
			 * outside, they affect the next line.
			 */
			if (MDOC_LITERAL & mdoc->flags)
				continue;
			break;
		case '\\':
			/* Skip the escaped character, too, if any. */
			if (c[1])
				c++;
			/* FALLTHROUGH */
		default:
			ws = NULL;
			break;
		}
		end = c + 1;
	}
	*end = '\0';

	if (ws)
		mandoc_msg(MANDOCERR_SPACE_EOL, mdoc->parse,
		    line, (int)(ws-buf), NULL);

	if (buf[offs] == '\0' && ! (mdoc->flags & MDOC_LITERAL)) {
		mandoc_msg(MANDOCERR_FI_BLANK, mdoc->parse,
		    line, (int)(c - buf), NULL);

		/*
		 * Insert a `sp' in the case of a blank line.  Technically,
		 * blank lines aren't allowed, but enough manuals assume this
		 * behaviour that we want to work around it.
		 */
		roff_elem_alloc(mdoc, line, offs, MDOC_sp);
		mdoc->last->flags |= MDOC_VALID | MDOC_ENDED;
		mdoc->next = ROFF_NEXT_SIBLING;
		return 1;
	}

	roff_word_alloc(mdoc, line, offs, buf+offs);

	if (mdoc->flags & MDOC_LITERAL)
		return 1;

	/*
	 * End-of-sentence check.  If the last character is an unescaped
	 * EOS character, then flag the node as being the end of a
	 * sentence.  The front-end will know how to interpret this.
	 */

	assert(buf < end);

	if (mandoc_eos(buf+offs, (size_t)(end-buf-offs)))
		mdoc->last->flags |= MDOC_EOS;
	return 1;
}

/*
 * Parse a macro line, that is, a line beginning with the control
 * character.
 */
static int
mdoc_pmacro(struct roff_man *mdoc, int ln, char *buf, int offs)
{
	struct roff_node *n;
	const char	 *cp;
	int		  tok;
	int		  i, sv;
	char		  mac[5];

	sv = offs;

	/*
	 * Copy the first word into a nil-terminated buffer.
	 * Stop when a space, tab, escape, or eoln is encountered.
	 */

	i = 0;
	while (i < 4 && strchr(" \t\\", buf[offs]) == NULL)
		mac[i++] = buf[offs++];

	mac[i] = '\0';

	tok = (i > 1 && i < 4) ? mdoc_hash_find(mac) : TOKEN_NONE;

	if (tok == TOKEN_NONE) {
		mandoc_msg(MANDOCERR_MACRO, mdoc->parse,
		    ln, sv, buf + sv - 1);
		return 1;
	}

	/* Skip a leading escape sequence or tab. */

	switch (buf[offs]) {
	case '\\':
		cp = buf + offs + 1;
		mandoc_escape(&cp, NULL, NULL);
		offs = cp - buf;
		break;
	case '\t':
		offs++;
		break;
	default:
		break;
	}

	/* Jump to the next non-whitespace word. */

	while (buf[offs] && ' ' == buf[offs])
		offs++;

	/*
	 * Trailing whitespace.  Note that tabs are allowed to be passed
	 * into the parser as "text", so we only warn about spaces here.
	 */

	if ('\0' == buf[offs] && ' ' == buf[offs - 1])
		mandoc_msg(MANDOCERR_SPACE_EOL, mdoc->parse,
		    ln, offs - 1, NULL);

	/*
	 * If an initial macro or a list invocation, divert directly
	 * into macro processing.
	 */

	if (NULL == mdoc->last || MDOC_It == tok || MDOC_El == tok) {
		mdoc_macro(mdoc, tok, ln, sv, &offs, buf);
		return 1;
	}

	n = mdoc->last;
	assert(mdoc->last);

	/*
	 * If the first macro of a `Bl -column', open an `It' block
	 * context around the parsed macro.
	 */

	if (n->tok == MDOC_Bl && n->type == ROFFT_BODY &&
	    n->end == ENDBODY_NOT && n->norm->Bl.type == LIST_column) {
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf);
		return 1;
	}

	/*
	 * If we're following a block-level `It' within a `Bl -column'
	 * context (perhaps opened in the above block or in ptext()),
	 * then open an `It' block context around the parsed macro.
	 */

	if (n->tok == MDOC_It && n->type == ROFFT_BLOCK &&
	    NULL != n->parent &&
	    MDOC_Bl == n->parent->tok &&
	    LIST_column == n->parent->norm->Bl.type) {
		mdoc->flags |= MDOC_FREECOL;
		mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf);
		return 1;
	}

	/* Normal processing of a macro. */

	mdoc_macro(mdoc, tok, ln, sv, &offs, buf);

	/* In quick mode (for mandocdb), abort after the NAME section. */

	if (mdoc->quick && MDOC_Sh == tok &&
	    SEC_NAME != mdoc->last->sec)
		return 2;

	return 1;
}

enum mdelim
mdoc_isdelim(const char *p)
{

	if ('\0' == p[0])
		return DELIM_NONE;

	if ('\0' == p[1])
		switch (p[0]) {
		case '(':
		case '[':
			return DELIM_OPEN;
		case '|':
			return DELIM_MIDDLE;
		case '.':
		case ',':
		case ';':
		case ':':
		case '?':
		case '!':
		case ')':
		case ']':
			return DELIM_CLOSE;
		default:
			return DELIM_NONE;
		}

	if ('\\' != p[0])
		return DELIM_NONE;

	if (0 == strcmp(p + 1, "."))
		return DELIM_CLOSE;
	if (0 == strcmp(p + 1, "fR|\\fP"))
		return DELIM_MIDDLE;

	return DELIM_NONE;
}

void
mdoc_validate(struct roff_man *mdoc)
{

	mdoc->last = mdoc->first;
	mdoc_node_validate(mdoc);
	mdoc_state_reset(mdoc);
}
@


1.255
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.254 2015/10/12 00:08:15 schwarze Exp $ */
d208 1
@


1.254
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.253 2015/10/06 18:32:19 schwarze Exp $ */
a123 18
	if (mdoc->flags & MDOC_PBODY) {
		if (tok == MDOC_Dt) {
			mandoc_vmsg(MANDOCERR_DT_LATE,
			    mdoc->parse, line, ppos,
			    "Dt %s", buf + *pos);
			return;
		}
	} else if ( ! (mdoc_macros[tok].flags & MDOC_PROLOGUE)) {
		if (mdoc->meta.title == NULL) {
			mandoc_vmsg(MANDOCERR_DT_NOTITLE,
			    mdoc->parse, line, ppos, "%s %s",
			    mdoc_macronames[tok], buf + *pos);
			mdoc->meta.title = mandoc_strdup("UNTITLED");
		}
		if (NULL == mdoc->meta.vol)
			mdoc->meta.vol = mandoc_strdup("LOCAL");
		mdoc->flags |= MDOC_PBODY;
	}
d304 1
a305 1
		mdoc_valid_post(mdoc);
d480 9
@


1.253
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.252 2015/04/23 16:17:44 schwarze Exp $ */
a184 1
		/* FALLTHROUGH */
a185 1
		/* FALLTHROUGH */
a186 1
		/* FALLTHROUGH */
a187 1
		/* FALLTHROUGH */
a470 1
			/* FALLTHROUGH */
a475 1
			/* FALLTHROUGH */
a476 1
			/* FALLTHROUGH */
a477 1
			/* FALLTHROUGH */
a478 1
			/* FALLTHROUGH */
a479 1
			/* FALLTHROUGH */
a480 1
			/* FALLTHROUGH */
a481 1
			/* FALLTHROUGH */
@


1.252
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.251 2015/04/23 15:35:59 schwarze Exp $ */
d114 1
a114 1
	return(roff_getcontrol(mdoc->roff, buf, &offs) ?
d116 1
a116 1
	    mdoc_ptext(mdoc, ln, buf, offs));
d169 1
a169 1
	return(p);
d200 1
a200 1
	return(p);
d258 1
a258 1
		return(1);
d268 1
a268 1
		return(1);
d328 1
a328 1
		return(1);
d334 1
a334 1
		return(1);
d346 1
a346 1
	return(1);
d380 1
a380 1
		return(1);
d419 1
a419 1
		return(1);
d434 1
a434 1
		return(1);
d449 1
a449 1
		return(1);
d460 1
a460 1
		return(2);
d462 1
a462 1
	return(1);
d470 1
a470 1
		return(DELIM_NONE);
d477 1
a477 1
			return(DELIM_OPEN);
d479 1
a479 1
			return(DELIM_MIDDLE);
d495 1
a495 1
			return(DELIM_CLOSE);
d497 1
a497 1
			return(DELIM_NONE);
d501 1
a501 1
		return(DELIM_NONE);
d504 1
a504 1
		return(DELIM_CLOSE);
d506 1
a506 1
		return(DELIM_MIDDLE);
d508 1
a508 1
	return(DELIM_NONE);
@


1.251
log
@Get rid of two empty wrapper functions.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.250 2015/04/19 14:57:38 schwarze Exp $ */
a509 39

void
mdoc_deroff(char **dest, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT) {
		for (n = n->child; n; n = n->next)
			mdoc_deroff(dest, n);
		return;
	}

	/* Skip leading whitespace. */

	for (cp = n->string; '\0' != *cp; cp++)
		if (0 == isspace((unsigned char)*cp))
			break;

	/* Skip trailing whitespace. */

	for (sz = strlen(cp); sz; sz--)
		if (0 == isspace((unsigned char)cp[sz-1]))
			break;

	/* Skip empty strings. */

	if (0 == sz)
		return;

	if (NULL == *dest) {
		*dest = mandoc_strndup(cp, sz);
		return;
	}

	mandoc_asprintf(&cp, "%s %*s", *dest, (int)sz, cp);
	free(*dest);
	*dest = cp;
}
@


1.250
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.249 2015/04/19 14:25:41 schwarze Exp $ */
a91 7
void
mdoc_endparse(struct roff_man *mdoc)
{

	mdoc_macroend(mdoc);
}

@


1.249
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.248 2015/04/19 14:00:19 schwarze Exp $ */
d332 1
a332 1
		mdoc_elem_alloc(mdoc, line, offs, MDOC_sp, NULL);
@


1.248
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.247 2015/04/19 13:50:26 schwarze Exp $ */
a98 25
void
mdoc_addeqn(struct roff_man *mdoc, const struct eqn *ep)
{
	struct roff_node *n;

	n = roff_node_alloc(mdoc, ep->ln, ep->pos, ROFFT_EQN, TOKEN_NONE);
	n->eqn = ep;
	if (ep->ln > mdoc->last->line)
		n->flags |= MDOC_LINE;
	roff_node_append(mdoc, n);
	mdoc->next = ROFF_NEXT_SIBLING;
}

void
mdoc_addspan(struct roff_man *mdoc, const struct tbl_span *sp)
{
	struct roff_node *n;

	n = roff_node_alloc(mdoc, sp->line, 0, ROFFT_TBL, TOKEN_NONE);
	n->span = sp;
	roff_node_append(mdoc, n);
	mdoc_valid_post(mdoc);
	mdoc->next = ROFF_NEXT_SIBLING;
}

a232 27
mdoc_word_alloc(struct roff_man *mdoc, int line, int pos, const char *p)
{
	struct roff_node *n;

	n = roff_node_alloc(mdoc, line, pos, ROFFT_TEXT, TOKEN_NONE);
	n->string = roff_strdup(mdoc->roff, p);
	roff_node_append(mdoc, n);
	mdoc_valid_post(mdoc);
	mdoc->next = ROFF_NEXT_SIBLING;
}

void
mdoc_word_append(struct roff_man *mdoc, const char *p)
{
	struct roff_node	*n;
	char			*addstr, *newstr;

	n = mdoc->last;
	addstr = roff_strdup(mdoc->roff, p);
	mandoc_asprintf(&newstr, "%s %s", n->string, addstr);
	free(addstr);
	free(n->string);
	n->string = newstr;
	mdoc->next = ROFF_NEXT_SIBLING;
}

void
d338 1
a338 1
	mdoc_word_alloc(mdoc, line, offs, buf+offs);
@


1.247
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.246 2015/04/18 17:53:21 schwarze Exp $ */
d39 1
d70 2
a71 2
	"%U",		"Ta",		"ll",		"text",
	};
d85 1
a85 1
const	char * const *mdoc_macronames = __mdoc_macronames;
d104 1
a104 1
	n = roff_node_alloc(mdoc, ep->ln, ep->pos, ROFFT_EQN, MDOC_MAX);
d117 1
a117 1
	n = roff_node_alloc(mdoc, sp->line, 0, ROFFT_TBL, MDOC_MAX);
d154 1
a154 1
	assert(tok < MDOC_MAX);
d262 1
a262 1
	n = roff_node_alloc(mdoc, line, pos, ROFFT_TEXT, MDOC_MAX);
d434 1
a434 1
	tok = (i > 1 && i < 4) ? mdoc_hash_find(mac) : MDOC_MAX;
d436 1
a436 1
	if (tok == MDOC_MAX) {
@


1.246
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.245 2015/04/18 17:28:36 schwarze Exp $ */
d35 1
a86 6
static	void		  mdoc_node_free(struct roff_node *);
static	void		  mdoc_node_unlink(struct roff_man *,
				struct roff_node *);
static	struct roff_node *node_alloc(struct roff_man *, int, int,
				int, enum roff_type);
static	void		  node_append(struct roff_man *, struct roff_node *);
d103 1
a103 1
	n = node_alloc(mdoc, ep->ln, ep->pos, MDOC_MAX, ROFFT_EQN);
d107 1
a107 1
	node_append(mdoc, n);
d116 1
a116 1
	n = node_alloc(mdoc, sp->line, 0, MDOC_MAX, ROFFT_TBL);
d118 2
a119 1
	node_append(mdoc, n);
a175 105

static void
node_append(struct roff_man *mdoc, struct roff_node *p)
{

	assert(mdoc->last);
	assert(mdoc->first);
	assert(p->type != ROFFT_ROOT);

	switch (mdoc->next) {
	case ROFF_NEXT_SIBLING:
		mdoc->last->next = p;
		p->prev = mdoc->last;
		p->parent = mdoc->last->parent;
		break;
	case ROFF_NEXT_CHILD:
		mdoc->last->child = p;
		p->parent = mdoc->last;
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	p->parent->nchild++;

	/*
	 * Copy over the normalised-data pointer of our parent.  Not
	 * everybody has one, but copying a null pointer is fine.
	 */

	switch (p->type) {
	case ROFFT_BODY:
		if (ENDBODY_NOT != p->end)
			break;
		/* FALLTHROUGH */
	case ROFFT_TAIL:
		/* FALLTHROUGH */
	case ROFFT_HEAD:
		p->norm = p->parent->norm;
		break;
	default:
		break;
	}

	mdoc_valid_pre(mdoc, p);

	switch (p->type) {
	case ROFFT_HEAD:
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->head = p;
		break;
	case ROFFT_TAIL:
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->tail = p;
		break;
	case ROFFT_BODY:
		if (p->end)
			break;
		assert(p->parent->type == ROFFT_BLOCK);
		p->parent->body = p;
		break;
	default:
		break;
	}

	mdoc->last = p;

	switch (p->type) {
	case ROFFT_TBL:
		/* FALLTHROUGH */
	case ROFFT_TEXT:
		mdoc_valid_post(mdoc);
		break;
	default:
		break;
	}
}

static struct roff_node *
node_alloc(struct roff_man *mdoc, int line, int pos,
	int tok, enum roff_type type)
{
	struct roff_node *p;

	p = mandoc_calloc(1, sizeof(*p));
	p->sec = mdoc->lastsec;
	p->line = line;
	p->pos = pos;
	p->tok = tok;
	p->type = type;

	/* Flag analysis. */

	if (MDOC_SYNOPSIS & mdoc->flags)
		p->flags |= MDOC_SYNPRETTY;
	else
		p->flags &= ~MDOC_SYNPRETTY;
	if (MDOC_NEWLINE & mdoc->flags)
		p->flags |= MDOC_LINE;
	mdoc->flags &= ~MDOC_NEWLINE;

	return(p);
}

d181 2
a182 2
	p = node_alloc(mdoc, line, pos, tok, ROFFT_TAIL);
	node_append(mdoc, p);
a186 24
mdoc_head_alloc(struct roff_man *mdoc, int line, int pos, int tok)
{
	struct roff_node *p;

	assert(mdoc->first);
	assert(mdoc->last);
	p = node_alloc(mdoc, line, pos, tok, ROFFT_HEAD);
	node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
	return(p);
}

struct roff_node *
mdoc_body_alloc(struct roff_man *mdoc, int line, int pos, int tok)
{
	struct roff_node *p;

	p = node_alloc(mdoc, line, pos, tok, ROFFT_BODY);
	node_append(mdoc, p);
	mdoc->next = ROFF_NEXT_CHILD;
	return(p);
}

struct roff_node *
d194 1
a194 1
	p = node_alloc(mdoc, line, pos, tok, ROFFT_BODY);
d198 1
a198 1
	node_append(mdoc, p);
d209 1
a209 1
	p = node_alloc(mdoc, line, pos, tok, ROFFT_BLOCK);
d229 1
a229 1
	node_append(mdoc, p);
d240 1
a240 1
	p = node_alloc(mdoc, line, pos, tok, ROFFT_ELEM);
d252 1
a252 1
	node_append(mdoc, p);
d261 1
a261 1
	n = node_alloc(mdoc, line, pos, MDOC_MAX, ROFFT_TEXT);
d263 2
a264 1
	node_append(mdoc, n);
a282 64
static void
mdoc_node_free(struct roff_node *p)
{

	if (p->type == ROFFT_BLOCK || p->type == ROFFT_ELEM)
		free(p->norm);
	if (p->string)
		free(p->string);
	if (p->args)
		mdoc_argv_free(p->args);
	free(p);
}

static void
mdoc_node_unlink(struct roff_man *mdoc, struct roff_node *n)
{

	/* Adjust siblings. */

	if (n->prev)
		n->prev->next = n->next;
	if (n->next)
		n->next->prev = n->prev;

	/* Adjust parent. */

	if (n->parent) {
		n->parent->nchild--;
		if (n->parent->child == n)
			n->parent->child = n->prev ? n->prev : n->next;
		if (n->parent->last == n)
			n->parent->last = n->prev ? n->prev : NULL;
	}

	/* Adjust parse point, if applicable. */

	if (mdoc && mdoc->last == n) {
		if (n->prev) {
			mdoc->last = n->prev;
			mdoc->next = ROFF_NEXT_SIBLING;
		} else {
			mdoc->last = n->parent;
			mdoc->next = ROFF_NEXT_CHILD;
		}
	}

	if (mdoc && mdoc->first == n)
		mdoc->first = NULL;
}

void
mdoc_node_delete(struct roff_man *mdoc, struct roff_node *p)
{

	while (p->child) {
		assert(p->nchild);
		mdoc_node_delete(mdoc, p->child);
	}
	assert(0 == p->nchild);

	mdoc_node_unlink(mdoc, p);
	mdoc_node_free(p);
}

d287 2
a288 2
	mdoc_node_unlink(mdoc, p);
	node_append(mdoc, p);
@


1.245
log
@Unify {mdoc,man}_{alloc,reset,free}() into roff_man_{alloc,reset,free}().
Minus 80 lines of code, no functional change.
Written on the train from Koeln to Wolfsburg returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.244 2015/04/18 17:01:58 schwarze Exp $ */
a95 14
const struct roff_node *
mdoc_node(const struct roff_man *mdoc)
{

	return(mdoc->first);
}

const struct roff_meta *
mdoc_meta(const struct roff_man *mdoc)
{

	return(&mdoc->meta);
}

@


1.244
log
@Move mdoc_hash_init() and man_hash_init() to libmandoc.h
and call them from mparse_alloc() and choose_parser(),
preparing unified allocation of struct roff_man.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.243 2015/04/18 16:34:25 schwarze Exp $ */
a88 2
static	void		  mdoc_free1(struct roff_man *);
static	void		  mdoc_alloc1(struct roff_man *);
a109 82
/*
 * Frees volatile resources (parse tree, meta-data, fields).
 */
static void
mdoc_free1(struct roff_man *mdoc)
{

	if (mdoc->first)
		mdoc_node_delete(mdoc, mdoc->first);
	free(mdoc->meta.msec);
	free(mdoc->meta.vol);
	free(mdoc->meta.arch);
	free(mdoc->meta.date);
	free(mdoc->meta.title);
	free(mdoc->meta.os);
	free(mdoc->meta.name);
}

/*
 * Allocate all volatile resources (parse tree, meta-data, fields).
 */
static void
mdoc_alloc1(struct roff_man *mdoc)
{

	memset(&mdoc->meta, 0, sizeof(mdoc->meta));
	mdoc->macroset = MACROSET_MDOC;
	mdoc->flags = 0;
	mdoc->lastnamed = mdoc->lastsec = SEC_NONE;
	mdoc->last = mandoc_calloc(1, sizeof(*mdoc->last));
	mdoc->first = mdoc->last;
	mdoc->last->type = ROFFT_ROOT;
	mdoc->last->tok = MDOC_MAX;
	mdoc->next = ROFF_NEXT_CHILD;
}

/*
 * Free up volatile resources (see mdoc_free1()) then re-initialises the
 * data with mdoc_alloc1().  After invocation, parse data has been reset
 * and the parser is ready for re-invocation on a new tree; however,
 * cross-parse non-volatile data is kept intact.
 */
void
mdoc_reset(struct roff_man *mdoc)
{

	mdoc_free1(mdoc);
	mdoc_alloc1(mdoc);
}

/*
 * Completely free up all volatile and non-volatile parse resources.
 * After invocation, the pointer is no longer usable.
 */
void
mdoc_free(struct roff_man *mdoc)
{

	mdoc_free1(mdoc);
	free(mdoc);
}

/*
 * Allocate volatile and non-volatile parse resources.
 */
struct roff_man *
mdoc_alloc(struct roff *roff, struct mparse *parse,
	const char *defos, int quick)
{
	struct roff_man	*p;

	p = mandoc_calloc(1, sizeof(*p));

	p->parse = parse;
	p->defos = defos;
	p->quick = quick;
	p->roff = roff;

	mdoc_alloc1(p);
	return(p);
}

@


1.243
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.242 2015/04/18 16:06:40 schwarze Exp $ */
a189 1
	mdoc_hash_init();
@


1.242
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.241 2015/04/02 23:48:19 schwarze Exp $ */
d138 1
@


1.241
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.240 2015/04/02 22:48:17 schwarze Exp $ */
d87 1
a87 1
static	void		  mdoc_node_unlink(struct mdoc *,
d89 3
a91 3
static	void		  mdoc_free1(struct mdoc *);
static	void		  mdoc_alloc1(struct mdoc *);
static	struct roff_node *node_alloc(struct mdoc *, int, int,
d93 3
a95 3
static	void		  node_append(struct mdoc *, struct roff_node *);
static	int		  mdoc_ptext(struct mdoc *, int, char *, int);
static	int		  mdoc_pmacro(struct mdoc *, int, char *, int);
d99 1
a99 1
mdoc_node(const struct mdoc *mdoc)
d106 1
a106 1
mdoc_meta(const struct mdoc *mdoc)
d116 1
a116 1
mdoc_free1(struct mdoc *mdoc)
d134 1
a134 1
mdoc_alloc1(struct mdoc *mdoc)
d144 1
a144 1
	mdoc->next = MDOC_NEXT_CHILD;
d154 1
a154 1
mdoc_reset(struct mdoc *mdoc)
d166 1
a166 1
mdoc_free(struct mdoc *mdoc)
d176 1
a176 1
struct mdoc *
d180 1
a180 1
	struct mdoc	*p;
d182 1
a182 1
	p = mandoc_calloc(1, sizeof(struct mdoc));
d195 1
a195 1
mdoc_endparse(struct mdoc *mdoc)
d202 1
a202 1
mdoc_addeqn(struct mdoc *mdoc, const struct eqn *ep)
d211 1
a211 1
	mdoc->next = MDOC_NEXT_SIBLING;
d215 1
a215 1
mdoc_addspan(struct mdoc *mdoc, const struct tbl_span *sp)
d222 1
a222 1
	mdoc->next = MDOC_NEXT_SIBLING;
d230 1
a230 1
mdoc_parseln(struct mdoc *mdoc, int ln, char *buf, int offs)
d280 1
a280 1
node_append(struct mdoc *mdoc, struct roff_node *p)
d288 1
a288 1
	case MDOC_NEXT_SIBLING:
d293 1
a293 1
	case MDOC_NEXT_CHILD:
d358 1
a358 1
node_alloc(struct mdoc *mdoc, int line, int pos,
d384 1
a384 1
mdoc_tail_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d390 1
a390 1
	mdoc->next = MDOC_NEXT_CHILD;
d394 1
a394 1
mdoc_head_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d402 1
a402 1
	mdoc->next = MDOC_NEXT_CHILD;
d407 1
a407 1
mdoc_body_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d413 1
a413 1
	mdoc->next = MDOC_NEXT_CHILD;
d418 1
a418 1
mdoc_endbody_alloc(struct mdoc *mdoc, int line, int pos, int tok,
d430 1
a430 1
	mdoc->next = MDOC_NEXT_SIBLING;
d435 1
a435 1
mdoc_block_alloc(struct mdoc *mdoc, int line, int pos,
d461 1
a461 1
	mdoc->next = MDOC_NEXT_CHILD;
d466 1
a466 1
mdoc_elem_alloc(struct mdoc *mdoc, int line, int pos,
d484 1
a484 1
	mdoc->next = MDOC_NEXT_CHILD;
d488 1
a488 1
mdoc_word_alloc(struct mdoc *mdoc, int line, int pos, const char *p)
d495 1
a495 1
	mdoc->next = MDOC_NEXT_SIBLING;
d499 1
a499 1
mdoc_word_append(struct mdoc *mdoc, const char *p)
d510 1
a510 1
	mdoc->next = MDOC_NEXT_SIBLING;
d527 1
a527 1
mdoc_node_unlink(struct mdoc *mdoc, struct roff_node *n)
d552 1
a552 1
			mdoc->next = MDOC_NEXT_SIBLING;
d555 1
a555 1
			mdoc->next = MDOC_NEXT_CHILD;
d564 1
a564 1
mdoc_node_delete(struct mdoc *mdoc, struct roff_node *p)
d578 1
a578 1
mdoc_node_relink(struct mdoc *mdoc, struct roff_node *p)
d590 1
a590 1
mdoc_ptext(struct mdoc *mdoc, int line, char *buf, int offs)
d678 1
a678 1
		mdoc->next = MDOC_NEXT_SIBLING;
d706 1
a706 1
mdoc_pmacro(struct mdoc *mdoc, int ln, char *buf, int offs)
@


1.240
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.239 2015/04/02 21:36:50 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d105 1
a105 1
const struct mdoc_meta *
d137 1
a137 1
	memset(&mdoc->meta, 0, sizeof(struct mdoc_meta));
@


1.239
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.238 2015/02/12 13:00:52 schwarze Exp $ */
d86 1
a86 1
static	void		  mdoc_node_free(struct mdoc_node *);
d88 1
a88 1
				struct mdoc_node *);
d91 3
a93 3
static	struct mdoc_node *node_alloc(struct mdoc *, int, int,
				enum mdoct, enum roff_type);
static	void		  node_append(struct mdoc *, struct mdoc_node *);
d98 1
a98 1
const struct mdoc_node *
d140 1
a140 1
	mdoc->last = mandoc_calloc(1, sizeof(struct mdoc_node));
d204 1
a204 1
	struct mdoc_node *n;
d217 1
a217 1
	struct mdoc_node *n;
d280 1
a280 1
node_append(struct mdoc *mdoc, struct mdoc_node *p)
d357 1
a357 1
static struct mdoc_node *
d359 1
a359 1
		enum mdoct tok, enum roff_type type)
d361 1
a361 1
	struct mdoc_node *p;
d363 1
a363 1
	p = mandoc_calloc(1, sizeof(struct mdoc_node));
d384 1
a384 1
mdoc_tail_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok)
d386 1
a386 1
	struct mdoc_node *p;
d393 2
a394 2
struct mdoc_node *
mdoc_head_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok)
d396 1
a396 1
	struct mdoc_node *p;
d406 2
a407 2
struct mdoc_node *
mdoc_body_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok)
d409 1
a409 1
	struct mdoc_node *p;
d417 3
a419 3
struct mdoc_node *
mdoc_endbody_alloc(struct mdoc *mdoc, int line, int pos, enum mdoct tok,
		struct mdoc_node *body, enum mdoc_endbody end)
d421 1
a421 1
	struct mdoc_node *p;
d434 1
a434 1
struct mdoc_node *
d436 1
a436 1
		enum mdoct tok, struct mdoc_arg *args)
d438 1
a438 1
	struct mdoc_node *p;
d467 1
a467 1
		enum mdoct tok, struct mdoc_arg *args)
d469 1
a469 1
	struct mdoc_node *p;
d490 1
a490 1
	struct mdoc_node *n;
d501 1
a501 1
	struct mdoc_node	*n;
d514 1
a514 1
mdoc_node_free(struct mdoc_node *p)
d527 1
a527 1
mdoc_node_unlink(struct mdoc *mdoc, struct mdoc_node *n)
d564 1
a564 1
mdoc_node_delete(struct mdoc *mdoc, struct mdoc_node *p)
d578 1
a578 1
mdoc_node_relink(struct mdoc *mdoc, struct mdoc_node *p)
d592 1
a593 1
	struct mdoc_node *n;
d708 1
a708 1
	struct mdoc_node *n;
d710 1
a710 1
	enum mdoct	  tok;
d864 1
a864 1
mdoc_deroff(char **dest, const struct mdoc_node *n)
@


1.238
log
@Do not confuse .Bl -column lists that just broken another block
with newly opened .Bl -column lists;
fixing an assertion failure jsg@@ found with afl:
test case #481, Bl It Bl -column It Bd El text text El
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.237 2015/02/12 12:24:33 schwarze Exp $ */
d30 3
d34 1
a34 2
#include "mandoc.h"
#include "mandoc_aux.h"
a35 1
#include "libmandoc.h"
d92 1
a92 1
				enum mdoct, enum mdoc_type);
d142 1
a142 1
	mdoc->last->type = MDOC_ROOT;
d206 1
a206 1
	n = node_alloc(mdoc, ep->ln, ep->pos, MDOC_MAX, MDOC_EQN);
d219 1
a219 1
	n = node_alloc(mdoc, sp->line, 0, MDOC_MAX, MDOC_TBL);
d233 1
a233 1
	if (mdoc->last->type != MDOC_EQN || ln > mdoc->last->line)
d285 1
a285 1
	assert(MDOC_ROOT != p->type);
d310 1
a310 1
	case MDOC_BODY:
d314 1
a314 1
	case MDOC_TAIL:
d316 1
a316 1
	case MDOC_HEAD:
d326 2
a327 2
	case MDOC_HEAD:
		assert(MDOC_BLOCK == p->parent->type);
d330 2
a331 2
	case MDOC_TAIL:
		assert(MDOC_BLOCK == p->parent->type);
d334 1
a334 1
	case MDOC_BODY:
d337 1
a337 1
		assert(MDOC_BLOCK == p->parent->type);
d347 1
a347 1
	case MDOC_TBL:
d349 1
a349 1
	case MDOC_TEXT:
d359 1
a359 1
		enum mdoct tok, enum mdoc_type type)
d388 1
a388 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_TAIL);
d400 1
a400 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_HEAD);
d411 1
a411 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BODY);
d425 1
a425 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BODY);
d440 1
a440 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BLOCK);
d471 1
a471 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_ELEM);
d492 1
a492 1
	n = node_alloc(mdoc, line, pos, MDOC_MAX, MDOC_TEXT);
d517 1
a517 1
	if (MDOC_BLOCK == p->type || MDOC_ELEM == p->type)
d600 2
a601 2
	 * columnar MDOC_BLOCK with or without a prior MDOC_BLOCK entry
	 * (a MDOC_BODY means it's already open, in which case we should
d605 1
a605 1
	if (n->tok == MDOC_Bl && n->type == MDOC_BODY &&
d613 1
a613 1
	if (MDOC_It == n->tok && MDOC_BLOCK == n->type &&
d782 1
a782 1
	if (n->tok == MDOC_Bl && n->type == MDOC_BODY &&
d795 1
a795 1
	if (MDOC_It == n->tok && MDOC_BLOCK == n->type &&
d869 1
a869 1
	if (MDOC_TEXT != n->type) {
@


1.237
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.236 2015/02/05 00:14:13 schwarze Exp $ */
d604 2
a605 2
	if (MDOC_Bl == n->tok && MDOC_BODY == n->type &&
	    LIST_column == n->norm->Bl.type) {
d781 2
a782 2
	if (MDOC_Bl == n->tok && MDOC_BODY == n->type &&
	    LIST_column == n->norm->Bl.type) {
@


1.236
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.235 2015/02/02 04:26:44 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d422 2
d425 1
a425 1
	p->pending = body;
@


1.235
log
@Get rid of all calls to rew_sub() in blk_exp_close(); only ten calls
remain in other functions.  As a bonus, this fixes an assertion failure
jsg@@ found some time ago with afl (test case 982) and improves minor
details in error reporting.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.234 2015/01/15 04:26:40 schwarze Exp $ */
a365 1
	p->lastline = line;
@


1.234
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.233 2014/11/28 06:27:05 schwarze Exp $ */
d417 1
a417 1
void
d429 1
@


1.233
log
@Simplify by making the eqn and tbl steering functions void;
no functional change, minus 15 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.232 2014/11/28 04:47:03 schwarze Exp $ */
d193 1
a193 1
int
a197 1
	return(1);
@


1.232
log
@Simplify by making the mdoc parser callbacks void, and some cleanup;
no functional change, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.231 2014/11/28 03:14:18 schwarze Exp $ */
d201 1
a201 1
int
a211 1
	return(1);
d214 1
a214 1
int
a222 1
	return(1);
@


1.231
log
@Simplify the code by making various mdoc parser helper functions void.
No functional change, minus 130 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.230 2014/11/28 01:05:43 schwarze Exp $ */
d197 2
a198 1
	return(mdoc_macroend(mdoc));
d254 1
a254 1
int
d264 1
a264 1
			return(1);
d277 1
a277 2

	return((*mdoc_macros[tok].fp)(mdoc, tok, line, ppos, pos, buf));
d609 2
a610 1
		return(mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf));
d619 2
a620 1
		return(mdoc_macro(mdoc, MDOC_It, line, offs, &offs, buf));
a697 1

d769 4
a772 2
	if (NULL == mdoc->last || MDOC_It == tok || MDOC_El == tok)
		return(mdoc_macro(mdoc, tok, ln, sv, &offs, buf));
d785 2
a786 1
		return(mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf));
d800 2
a801 1
		return(mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf));
d806 1
a806 2
	if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf))
		return(0);
@


1.230
log
@Simplify code by making mdoc validation handlers void.
No functional change, minus 90 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.229 2014/11/19 03:08:17 schwarze Exp $ */
d386 1
a386 1
int
a393 1
	return(1);
d396 1
a396 1
int
a402 1

d406 1
a406 1
	return(1);
d409 1
a409 1
int
d417 1
a417 1
	return(1);
d420 1
a420 1
int
a431 1
	return(1);
d434 1
a434 1
int
d462 1
a462 1
	return(1);
d465 1
a465 1
int
a484 1
	return(1);
d487 1
a487 1
int
a495 1
	return(1);
d577 1
a577 1
int
a582 1
	return(1);
d666 1
a666 1
	if ('\0' == buf[offs] && ! (MDOC_LITERAL & mdoc->flags)) {
d675 1
a675 3
		if ( ! mdoc_elem_alloc(mdoc, line, offs, MDOC_sp, NULL))
			return(0);

a676 1

d681 1
a681 2
	if ( ! mdoc_word_alloc(mdoc, line, offs, buf+offs))
		return(0);
d683 1
a683 1
	if (MDOC_LITERAL & mdoc->flags)
@


1.229
log
@Escape sequences terminate high-level macro names, and when doing so,
they are ignored, just in the same way as for request names
and for low-level macro names.
This also cures a warning in the pod2man(1) preamble.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.228 2014/10/20 15:50:24 schwarze Exp $ */
d92 1
a92 2
static	int		  node_append(struct mdoc *,
				struct mdoc_node *);
d209 1
a209 4

	if ( ! node_append(mdoc, n))
		return(0);

d221 1
a221 4

	if ( ! node_append(mdoc, n))
		return(0);

d281 1
a281 1
static int
d325 1
a325 2
	if ( ! mdoc_valid_pre(mdoc, p))
		return(0);
d352 1
a352 2
		if ( ! mdoc_valid_post(mdoc))
			return(0);
a356 2

	return(1);
d392 1
a392 2
	if ( ! node_append(mdoc, p))
		return(0);
d406 1
a406 2
	if ( ! node_append(mdoc, p))
		return(0);
d417 1
a417 2
	if ( ! node_append(mdoc, p))
		return(0);
d432 1
a432 2
	if ( ! node_append(mdoc, p))
		return(0);
d463 1
a463 3

	if ( ! node_append(mdoc, p))
		return(0);
d486 1
a486 3

	if ( ! node_append(mdoc, p))
		return(0);
d498 1
a498 4

	if ( ! node_append(mdoc, n))
		return(0);

d587 2
a588 1
	return(node_append(mdoc, p));
d686 2
a687 1
		return(mdoc_valid_post(mdoc));
@


1.228
log
@correct the spacing after in-line equations
that start at the beginning of an input line
but end before the end of an input line
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.227 2014/10/20 02:33:06 schwarze Exp $ */
d737 2
a741 1
	struct mdoc_node *n;
d747 1
a747 1
	 * Stop copying when a tab, space, or eoln is encountered.
d751 1
a751 2
	while (i < 4 && '\0' != buf[offs] && ' ' != buf[offs] &&
	    '\t' != buf[offs])
d758 1
a758 1
	if (MDOC_MAX == tok) {
d764 1
a764 1
	/* Disregard the first trailing tab, if applicable. */
d766 7
a772 1
	if ('\t' == buf[offs])
d774 4
@


1.227
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.226 2014/10/16 01:11:20 schwarze Exp $ */
d241 2
a242 1
	mdoc->flags |= MDOC_NEWLINE;
@


1.226
log
@Implement in-line equations, much needed by Xenocara manuals.
Put the steering into the roff parser rather than into the mdoc
parser such that it works for all macro languages and on both text
and macro lines.
Line breaks and blank characters generated before and after in-line
equations are not perfect yet, but let's do one thing at a time.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.225 2014/09/06 23:24:32 schwarze Exp $ */
d208 2
@


1.225
log
@Simplify by handling empty request lines at the one logical place
in the roff parser instead of in three other places in other parsers.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.224 2014/08/10 23:54:41 schwarze Exp $ */
a93 3
#if 0
static	int		  mdoc_preptext(struct mdoc *, int, char *, int);
#endif
a608 54
#if 0
/*
 * Pre-treat a text line.
 * Text lines can consist of equations, which must be handled apart from
 * the regular text.
 * Thus, use this function to step through a line checking if it has any
 * equations embedded in it.
 * This must handle multiple equations AND equations that do not end at
 * the end-of-line, i.e., will re-enter in the next roff parse.
 */
static int
mdoc_preptext(struct mdoc *mdoc, int line, char *buf, int offs)
{
	char		*start, *end;
	char		 delim;

	while ('\0' != buf[offs]) {
		/* Mark starting position if eqn is set. */
		start = NULL;
		if ('\0' != (delim = roff_eqndelim(mdoc->roff)))
			if (NULL != (start = strchr(buf + offs, delim)))
				*start++ = '\0';

		/* Parse text as normal. */
		if ( ! mdoc_ptext(mdoc, line, buf, offs))
			return(0);

		/* Continue only if an equation exists. */
		if (NULL == start)
			break;

		/* Read past the end of the equation. */
		offs += start - (buf + offs);
		assert(start == &buf[offs]);
		if (NULL != (end = strchr(buf + offs, delim))) {
			*end++ = '\0';
			while (' ' == *end)
				end++;
		}

		/* Parse the equation itself. */
		roff_openeqn(mdoc->roff, NULL, line, offs, buf);

		/* Process a finished equation? */
		if (roff_closeeqn(mdoc->roff))
			if ( ! mdoc_addeqn(mdoc, roff_eqn(mdoc->roff)))
				return(0);
		offs += (end - (buf + offs));
	}

	return(1);
}
#endif

@


1.224
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.223 2014/08/06 15:09:05 schwarze Exp $ */
a795 9
	/* Empty post-control lines are ignored. */

	if ('"' == buf[offs]) {
		mandoc_msg(MANDOCERR_COMMENT_BAD, mdoc->parse,
		    ln, offs, NULL);
		return(1);
	} else if ('\0' == buf[offs])
		return(1);

@


1.223
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.222 2014/08/01 17:27:44 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
@


1.222
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.221 2014/07/30 21:18:24 schwarze Exp $ */
d126 7
a132 14
	if (mdoc->meta.title)
		free(mdoc->meta.title);
	if (mdoc->meta.os)
		free(mdoc->meta.os);
	if (mdoc->meta.name)
		free(mdoc->meta.name);
	if (mdoc->meta.arch)
		free(mdoc->meta.arch);
	if (mdoc->meta.vol)
		free(mdoc->meta.vol);
	if (mdoc->meta.msec)
		free(mdoc->meta.msec);
	if (mdoc->meta.date)
		free(mdoc->meta.date);
d267 14
a280 19
	/* If we're in the body, deny prologue calls. */

	if (MDOC_PROLOGUE & mdoc_macros[tok].flags &&
	    MDOC_PBODY & mdoc->flags) {
		mandoc_vmsg(MANDOCERR_PROLOG_ONLY, mdoc->parse,
		    line, ppos, "%s", mdoc_macronames[tok]);
		return(1);
	}

	/* If we're in the prologue, deny "body" macros.  */

	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) &&
	     ! (MDOC_PBODY & mdoc->flags)) {
		mandoc_vmsg(MANDOCERR_PROLOG_BAD, mdoc->parse,
		    line, ppos, "%s", mdoc_macronames[tok]);
		if (NULL == mdoc->meta.msec)
			mdoc->meta.msec = mandoc_strdup("1");
		if (NULL == mdoc->meta.title)
			mdoc->meta.title = mandoc_strdup("UNKNOWN");
a282 5
		if (NULL == mdoc->meta.os)
			mdoc->meta.os = mandoc_strdup("LOCAL");
		if (NULL == mdoc->meta.date)
			mdoc->meta.date = mandoc_normdate
				(mdoc->parse, NULL, line, ppos);
@


1.221
log
@garbage collect three unused global flags; no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.220 2014/07/09 11:31:43 schwarze Exp $ */
d841 2
a842 2
		mandoc_vmsg(MANDOCERR_MACRO, mdoc->parse,
		    ln, sv, "%s", buf + sv - 1);
@


1.220
log
@mark defos as const; nobody needs to change it,
and it is occasionally useful to be able to pass literal strings
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.219 2014/07/07 15:03:43 schwarze Exp $ */
a106 1
	assert( ! (MDOC_HALT & mdoc->flags));
a113 1
	assert( ! (MDOC_HALT & mdoc->flags));
a205 4
/*
 * Climb back up the parse tree, validating open scopes.  Mostly calls
 * through to macro_end() in macro.c.
 */
d210 1
a210 5
	assert( ! (MDOC_HALT & mdoc->flags));
	if (mdoc_macroend(mdoc))
		return(1);
	mdoc->flags |= MDOC_HALT;
	return(0);
a217 2
	assert( ! (MDOC_HALT & mdoc->flags));

a232 2
	assert( ! (MDOC_HALT & mdoc->flags));

a250 2
	assert( ! (MDOC_HALT & mdoc->flags));

d870 2
a871 5
	if (NULL == mdoc->last || MDOC_It == tok || MDOC_El == tok) {
		if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf))
			goto err;
		return(1);
	}
d884 1
a884 3
		if ( ! mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf))
			goto err;
		return(1);
d898 1
a898 3
		if ( ! mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf))
			goto err;
		return(1);
d904 1
a904 1
		goto err;
a912 5

err:	/* Error out. */

	mdoc->flags |= MDOC_HALT;
	return(0);
@


1.219
log
@no need to skip content before first section header
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.218 2014/07/06 19:09:00 schwarze Exp $ */
d192 1
a192 1
	char *defos, int quick)
@


1.218
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.217 2014/07/02 03:48:07 schwarze Exp $ */
a229 7
	/* No text before an initial macro. */

	if (SEC_NONE == mdoc->lastnamed) {
		mdoc_pmsg(mdoc, ep->ln, ep->pos, MANDOCERR_NOTEXT);
		return(1);
	}

a246 7
	/* No text before an initial macro. */

	if (SEC_NONE == mdoc->lastnamed) {
		mdoc_pmsg(mdoc, sp->line, 0, MANDOCERR_NOTEXT);
		return(1);
	}

a710 7
	/* No text before an initial macro. */

	if (SEC_NONE == mdoc->lastnamed) {
		mdoc_pmsg(mdoc, line, offs, MANDOCERR_NOTEXT);
		return(1);
	}

@


1.217
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.216 2014/07/01 22:37:15 schwarze Exp $ */
d800 2
a801 1
		mdoc_pmsg(mdoc, line, (int)(ws-buf), MANDOCERR_EOLNSPACE);
d804 2
a805 1
		mdoc_pmsg(mdoc, line, (int)(c-buf), MANDOCERR_NOBLANKLN);
d855 2
a856 1
		mdoc_pmsg(mdoc, ln, offs, MANDOCERR_BADCOMMENT);
d899 2
a900 1
		mdoc_pmsg(mdoc, ln, offs - 1, MANDOCERR_EOLNSPACE);
@


1.216
log
@Clean up the warnings related to document structure.
* Hierarchical naming of the related enum mandocerr items.
* Mention the offending macro, section title, or string.
While here, improve some wordings:
* Descriptive instead of imperative style.
* Uniform style for "missing" and "skipping".
* Where applicable, mention the fallback used.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.215 2014/06/20 17:24:00 schwarze Exp $ */
d519 2
@


1.215
log
@Start systematic improvements of error reporting.
So far, this covers all WARNINGs related to the prologue.

1) hierarchical naming of MANDOCERR_* constants
2) mention the macro name in messages where that adds clarity
3) add one missing MANDOCERR_DATE_MISSING msg
4) fix the wording of one message related to the man(7) prologue

Started on the plane back from Ottawa.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.214 2014/04/25 14:11:30 schwarze Exp $ */
d38 1
a38 1
const	char *const __mdoc_macronames[MDOC_MAX] = {
d69 1
a69 1
	"%U",		"Ta",		"ll",
@


1.214
log
@Fix a minor optimization i broke in rev. 1.163 on August 20, 2010:
Do not bother looking into the hash table when the length of the macro
already tells us it's invalid.  No functional change.
Noticed by jsg@@, thanks!
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.213 2014/04/20 16:46:05 schwarze Exp $ */
d308 2
a309 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_BADBODY);
d317 2
a318 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_BADPROLOG);
@


1.213
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.212 2014/03/30 19:47:48 schwarze Exp $ */
d868 1
a868 1
	tok = (i > 1 || i < 4) ? mdoc_hash_find(mac) : MDOC_MAX;
@


1.212
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.211 2014/03/23 12:44:56 schwarze Exp $ */
d38 1
a38 1
const	char *const __mdoc_macronames[MDOC_MAX] = {		 
a48 1
	/* LINTED */
a49 1
	/* LINTED */
a50 1
	/* LINTED */
a66 1
	/* LINTED */
a67 1
	/* LINTED */
a68 1
	/* LINTED */
d72 1
a72 1
const	char *const __mdoc_argnames[MDOC_ARG_MAX] = {		 
d74 6
a79 6
	"unfilled",		"literal",		"file",		 
	"offset",		"bullet",		"dash",		 
	"hyphen",		"item",			"enum",		 
	"tag",			"diag",			"hang",		 
	"ohang",		"inset",		"column",	 
	"width",		"compact",		"std",	 
d88 1
a88 1
static	void		  mdoc_node_unlink(struct mdoc *, 
d92 1
a92 1
static	struct mdoc_node *node_alloc(struct mdoc *, int, int, 
d94 1
a94 1
static	int		  node_append(struct mdoc *, 
d102 1
a110 1

a118 1

a143 1

a160 1

a174 1

a186 1

d188 1
a188 1
 * Allocate volatile and non-volatile parse resources.  
a207 1

a270 1

d295 2
a296 2
			mdoc_pmacro(mdoc, ln, buf, offs) :
			mdoc_ptext(mdoc, ln, buf, offs));
d306 2
a307 2
	if (MDOC_PROLOGUE & mdoc_macros[tok].flags && 
			MDOC_PBODY & mdoc->flags) {
d314 2
a315 2
	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) && 
			! (MDOC_PBODY & mdoc->flags)) {
d344 1
a344 1
	case (MDOC_NEXT_SIBLING):
d349 1
a349 1
	case (MDOC_NEXT_CHILD):
d366 1
a366 1
	case (MDOC_BODY):
d370 1
a370 1
	case (MDOC_TAIL):
d372 1
a372 1
	case (MDOC_HEAD):
d383 1
a383 1
	case (MDOC_HEAD):
d387 1
a387 1
	case (MDOC_TAIL):
d391 1
a391 1
	case (MDOC_BODY):
d404 1
a404 1
	case (MDOC_TBL):
d406 1
a406 1
	case (MDOC_TEXT):
a416 1

d418 1
a418 1
node_alloc(struct mdoc *mdoc, int line, int pos, 
a443 1

a455 1

a470 1

a482 1

a498 1

d500 1
a500 1
mdoc_block_alloc(struct mdoc *mdoc, int line, int pos, 
d511 1
a511 1
	case (MDOC_Bd):
d513 1
a513 1
	case (MDOC_Bf):
d515 1
a515 1
	case (MDOC_Bl):
d517 1
a517 1
	case (MDOC_Rs):
a529 1

d531 1
a531 1
mdoc_elem_alloc(struct mdoc *mdoc, int line, int pos, 
d542 1
a542 1
	case (MDOC_An):
a597 1

a634 1

d705 1
a705 1
	} 
d739 1
a739 1
			LIST_column == n->norm->Bl.type) {
d746 3
a748 3
			NULL != n->parent &&
			MDOC_Bl == n->parent->tok &&
			LIST_column == n->parent->norm->Bl.type) {
a833 1

d856 1
a856 1
	/* 
d862 2
a863 2
	while (i < 4 && '\0' != buf[offs] && 
			' ' != buf[offs] && '\t' != buf[offs])
d871 2
a872 2
		mandoc_vmsg(MANDOCERR_MACRO, mdoc->parse, 
				ln, sv, "%s", buf + sv - 1);
d886 1
a886 1
	/* 
d900 1
a900 1
		if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf)) 
d914 1
a914 1
			LIST_column == n->norm->Bl.type) {
d928 3
a930 3
			NULL != n->parent &&
			MDOC_Bl == n->parent->tok &&
			LIST_column == n->parent->norm->Bl.type) {
d932 1
a932 1
		if ( ! mdoc_macro(mdoc, MDOC_It, ln, sv, &sv, buf)) 
d939 1
a939 1
	if ( ! mdoc_macro(mdoc, tok, ln, sv, &offs, buf)) 
d965 1
a965 1
		case('('):
d967 1
a967 1
		case('['):
d969 1
a969 1
		case('|'):
d971 1
a971 1
		case('.'):
d973 1
a973 1
		case(','):
d975 1
a975 1
		case(';'):
d977 1
a977 1
		case(':'):
d979 1
a979 1
		case('?'):
d981 1
a981 1
		case('!'):
d983 1
a983 1
		case(')'):
d985 1
a985 1
		case(']'):
@


1.211
log
@If an .Nd block contains macros, avoid fragmented entries in mandocdb(8),
instead use the .Nd content recursively.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.210 2014/03/23 12:11:18 schwarze Exp $ */
d75 1
a75 1
	"%U",		"Ta"
@


1.210
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.209 2014/03/23 11:25:26 schwarze Exp $ */
d25 1
d1024 39
@


1.209
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.208 2014/01/05 20:26:36 schwarze Exp $ */
d597 1
a597 4
	if (-1 == asprintf(&newstr, "%s %s", n->string, addstr)) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.208
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute of
struct mparse and mparse_alloc() and fix some errors in mandoc(3).

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.207 2013/12/31 23:23:11 schwarze Exp $ */
d33 1
@


1.207
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.206 2013/12/24 19:11:46 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d200 2
a201 1
mdoc_alloc(struct roff *roff, struct mparse *parse, char *defos)
d209 1
d966 6
@


1.206
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.205 2013/10/21 23:47:58 schwarze Exp $ */
d849 1
a849 1
	if (mandoc_eos(buf+offs, (size_t)(end-buf-offs), 0))
@


1.205
log
@There are three kinds of input lines: text lines, macros taking
positional arguments (like Dt Fn Xr) and macros taking text as
arguments (like Nd Sh Em %T An).  In the past, even the latter put
each word of their arguments into its own MDOC_TEXT node; instead,
concatenate arguments unless delimiters, keeps or spacing mode
prevent that.  Regarding mandoc(1), this is internal refactoring,
no output change intended.

Regarding mandocdb(8), this fixes yet another regression introduced
when switching from DB to SQLite: The ability to search for strings
crossing word boundaries was lost and is hereby restored.  At the
same time, database sizes and build times are both reduced by a bit
more than 5% each.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.204 2013/10/05 22:08:12 schwarze Exp $ */
d437 1
@


1.204
log
@Support setting arbitrary roff(7) number registers,
preserving read support for the ".nr nS" SYNOPSIS state register.

Inspired by NetBSD roff.c rev. 1.18 (Christos Zoulas, March 21, 2013),
but implemented differently.  I don't want to have yet another different
implementation of a hash table in mandoc - it would be the second one
in roff.c alone and the fifth one in mandoc grand total.
Instead, i designed and implemented roff_setreg() and roff_getreg()
to be similar to roff_setstrn() and roff_getstrn().

Once we feel the need to optimize, we can introduce one common
hash table implementation for everything in mandoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.203 2012/11/17 00:26:33 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d585 17
@


1.203
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.202 2012/11/16 13:40:36 schwarze Exp $ */
d298 4
a301 6
	if (roff_regisset(mdoc->roff, REG_nS)) {
		if (roff_regget(mdoc->roff, REG_nS))
			mdoc->flags |= MDOC_SYNOPSIS;
		else
			mdoc->flags &= ~MDOC_SYNOPSIS;
	}
@


1.202
log
@Fix a crash triggered by .Bl -tag .It Xo .El .Sh found by florian@@.

* When allocating a body end marker, copy the pointer to the normalized
block information from the body block, avoiding the risk of subsequent
null pointer derefence.
* When inserting the body end marker into the syntax tree, do not try to
copy that pointer from the parent block, because not being a direkt child
of the block it belongs to is the whole point of a body end marker.
* Even non-callable blocks (like Bd and Bl) can break other blocks;
when this happens, postpone closing them out in the usual way.

Completed and tested at the OpenBSD impromptu Coimbra hackathon (c2k12).
Thanks to Pedro Almeida and the Laborat'orio de Computa,c~ao Avan,cada
da Universidade de Coimbra (http://www.uc.pt/lca) for their hospitality!
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.201 2012/07/18 11:11:12 schwarze Exp $ */
d107 1
a107 1
mdoc_node(const struct mdoc *m)
d110 2
a111 2
	assert( ! (MDOC_HALT & m->flags));
	return(m->first);
d116 1
a116 1
mdoc_meta(const struct mdoc *m)
d119 2
a120 2
	assert( ! (MDOC_HALT & m->flags));
	return(&m->meta);
d221 1
a221 1
mdoc_endparse(struct mdoc *m)
d224 2
a225 2
	assert( ! (MDOC_HALT & m->flags));
	if (mdoc_macroend(m))
d227 1
a227 1
	m->flags |= MDOC_HALT;
d232 1
a232 1
mdoc_addeqn(struct mdoc *m, const struct eqn *ep)
d236 1
a236 1
	assert( ! (MDOC_HALT & m->flags));
d240 2
a241 2
	if (SEC_NONE == m->lastnamed) {
		mdoc_pmsg(m, ep->ln, ep->pos, MANDOCERR_NOTEXT);
d245 1
a245 1
	n = node_alloc(m, ep->ln, ep->pos, MDOC_MAX, MDOC_EQN);
d248 1
a248 1
	if ( ! node_append(m, n))
d251 1
a251 1
	m->next = MDOC_NEXT_SIBLING;
d256 1
a256 1
mdoc_addspan(struct mdoc *m, const struct tbl_span *sp)
d260 1
a260 1
	assert( ! (MDOC_HALT & m->flags));
d264 2
a265 2
	if (SEC_NONE == m->lastnamed) {
		mdoc_pmsg(m, sp->line, 0, MANDOCERR_NOTEXT);
d269 1
a269 1
	n = node_alloc(m, sp->line, 0, MDOC_MAX, MDOC_TBL);
d272 1
a272 1
	if ( ! node_append(m, n))
d275 1
a275 1
	m->next = MDOC_NEXT_SIBLING;
d285 1
a285 1
mdoc_parseln(struct mdoc *m, int ln, char *buf, int offs)
d288 1
a288 1
	assert( ! (MDOC_HALT & m->flags));
d290 1
a290 1
	m->flags |= MDOC_NEWLINE;
d298 3
a300 3
	if (roff_regisset(m->roff, REG_nS)) {
		if (roff_regget(m->roff, REG_nS))
			m->flags |= MDOC_SYNOPSIS;
d302 1
a302 1
			m->flags &= ~MDOC_SYNOPSIS;
d305 3
a307 3
	return(roff_getcontrol(m->roff, buf, &offs) ?
			mdoc_pmacro(m, ln, buf, offs) :
			mdoc_ptext(m, ln, buf, offs));
d318 2
a319 2
			MDOC_PBODY & m->flags) {
		mdoc_pmsg(m, line, ppos, MANDOCERR_BADBODY);
d326 14
a339 14
			! (MDOC_PBODY & m->flags)) {
		mdoc_pmsg(m, line, ppos, MANDOCERR_BADPROLOG);
		if (NULL == m->meta.msec)
			m->meta.msec = mandoc_strdup("1");
		if (NULL == m->meta.title)
			m->meta.title = mandoc_strdup("UNKNOWN");
		if (NULL == m->meta.vol)
			m->meta.vol = mandoc_strdup("LOCAL");
		if (NULL == m->meta.os)
			m->meta.os = mandoc_strdup("LOCAL");
		if (NULL == m->meta.date)
			m->meta.date = mandoc_normdate
				(m->parse, NULL, line, ppos);
		m->flags |= MDOC_PBODY;
d342 1
a342 1
	return((*mdoc_macros[tok].fp)(m, tok, line, ppos, pos, buf));
d430 1
a430 1
node_alloc(struct mdoc *m, int line, int pos, 
d436 1
a436 1
	p->sec = m->lastsec;
d444 1
a444 1
	if (MDOC_SYNOPSIS & m->flags)
d448 1
a448 1
	if (MDOC_NEWLINE & m->flags)
d450 1
a450 1
	m->flags &= ~MDOC_NEWLINE;
d457 1
a457 1
mdoc_tail_alloc(struct mdoc *m, int line, int pos, enum mdoct tok)
d461 2
a462 2
	p = node_alloc(m, line, pos, tok, MDOC_TAIL);
	if ( ! node_append(m, p))
d464 1
a464 1
	m->next = MDOC_NEXT_CHILD;
d470 1
a470 1
mdoc_head_alloc(struct mdoc *m, int line, int pos, enum mdoct tok)
d474 2
a475 2
	assert(m->first);
	assert(m->last);
d477 2
a478 2
	p = node_alloc(m, line, pos, tok, MDOC_HEAD);
	if ( ! node_append(m, p))
d480 1
a480 1
	m->next = MDOC_NEXT_CHILD;
d486 1
a486 1
mdoc_body_alloc(struct mdoc *m, int line, int pos, enum mdoct tok)
d490 2
a491 2
	p = node_alloc(m, line, pos, tok, MDOC_BODY);
	if ( ! node_append(m, p))
d493 1
a493 1
	m->next = MDOC_NEXT_CHILD;
d499 1
a499 1
mdoc_endbody_alloc(struct mdoc *m, int line, int pos, enum mdoct tok,
d504 1
a504 1
	p = node_alloc(m, line, pos, tok, MDOC_BODY);
d508 1
a508 1
	if ( ! node_append(m, p))
d510 1
a510 1
	m->next = MDOC_NEXT_SIBLING;
d516 1
a516 1
mdoc_block_alloc(struct mdoc *m, int line, int pos, 
d521 1
a521 1
	p = node_alloc(m, line, pos, tok, MDOC_BLOCK);
d540 1
a540 1
	if ( ! node_append(m, p))
d542 1
a542 1
	m->next = MDOC_NEXT_CHILD;
d548 1
a548 1
mdoc_elem_alloc(struct mdoc *m, int line, int pos, 
d553 1
a553 1
	p = node_alloc(m, line, pos, tok, MDOC_ELEM);
d566 1
a566 1
	if ( ! node_append(m, p))
d568 1
a568 1
	m->next = MDOC_NEXT_CHILD;
d573 1
a573 1
mdoc_word_alloc(struct mdoc *m, int line, int pos, const char *p)
d577 2
a578 2
	n = node_alloc(m, line, pos, MDOC_MAX, MDOC_TEXT);
	n->string = roff_strdup(m->roff, p);
d580 1
a580 1
	if ( ! node_append(m, n))
d583 1
a583 1
	m->next = MDOC_NEXT_SIBLING;
d603 1
a603 1
mdoc_node_unlink(struct mdoc *m, struct mdoc_node *n)
d625 1
a625 1
	if (m && m->last == n) {
d627 2
a628 2
			m->last = n->prev;
			m->next = MDOC_NEXT_SIBLING;
d630 2
a631 2
			m->last = n->parent;
			m->next = MDOC_NEXT_CHILD;
d635 2
a636 2
	if (m && m->first == n)
		m->first = NULL;
d641 1
a641 1
mdoc_node_delete(struct mdoc *m, struct mdoc_node *p)
d646 1
a646 1
		mdoc_node_delete(m, p->child);
d650 1
a650 1
	mdoc_node_unlink(m, p);
d655 1
a655 1
mdoc_node_relink(struct mdoc *m, struct mdoc_node *p)
d658 2
a659 2
	mdoc_node_unlink(m, p);
	return(node_append(m, p));
d673 1
a673 1
mdoc_preptext(struct mdoc *m, int line, char *buf, int offs)
d681 1
a681 1
		if ('\0' != (delim = roff_eqndelim(m->roff)))
d686 1
a686 1
		if ( ! mdoc_ptext(m, line, buf, offs))
d703 1
a703 1
		roff_openeqn(m->roff, NULL, line, offs, buf);
d706 2
a707 2
		if (roff_closeeqn(m->roff))
			if ( ! mdoc_addeqn(m, roff_eqn(m->roff)))
d721 1
a721 1
mdoc_ptext(struct mdoc *m, int line, char *buf, int offs)
d728 2
a729 2
	if (SEC_NONE == m->lastnamed) {
		mdoc_pmsg(m, line, offs, MANDOCERR_NOTEXT);
d733 2
a734 2
	assert(m->last);
	n = m->last;
d746 2
a747 2
		m->flags |= MDOC_FREECOL;
		return(mdoc_macro(m, MDOC_It, line, offs, &offs, buf));
d755 2
a756 2
		m->flags |= MDOC_FREECOL;
		return(mdoc_macro(m, MDOC_It, line, offs, &offs, buf));
d784 1
a784 1
			if (MDOC_LITERAL & m->flags)
d801 1
a801 1
		mdoc_pmsg(m, line, (int)(ws-buf), MANDOCERR_EOLNSPACE);
d803 2
a804 2
	if ('\0' == buf[offs] && ! (MDOC_LITERAL & m->flags)) {
		mdoc_pmsg(m, line, (int)(c-buf), MANDOCERR_NOBLANKLN);
d811 1
a811 1
		if ( ! mdoc_elem_alloc(m, line, offs, MDOC_sp, NULL))
d814 1
a814 1
		m->next = MDOC_NEXT_SIBLING;
d816 1
a816 1
		return(mdoc_valid_post(m));
d819 1
a819 1
	if ( ! mdoc_word_alloc(m, line, offs, buf+offs))
d822 1
a822 1
	if (MDOC_LITERAL & m->flags)
d834 1
a834 1
		m->last->flags |= MDOC_EOS;
d845 1
a845 1
mdoc_pmacro(struct mdoc *m, int ln, char *buf, int offs)
d855 1
a855 1
		mdoc_pmsg(m, ln, offs, MANDOCERR_BADCOMMENT);
d877 1
a877 1
		mandoc_vmsg(MANDOCERR_MACRO, m->parse, 
d898 1
a898 1
		mdoc_pmsg(m, ln, offs - 1, MANDOCERR_EOLNSPACE);
d905 2
a906 2
	if (NULL == m->last || MDOC_It == tok || MDOC_El == tok) {
		if ( ! mdoc_macro(m, tok, ln, sv, &offs, buf)) 
d911 2
a912 2
	n = m->last;
	assert(m->last);
d921 2
a922 2
		m->flags |= MDOC_FREECOL;
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf))
d937 2
a938 2
		m->flags |= MDOC_FREECOL;
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf)) 
d945 1
a945 1
	if ( ! mdoc_macro(m, tok, ln, sv, &offs, buf)) 
d952 1
a952 1
	m->flags |= MDOC_HALT;
@


1.201
log
@Fix handling of paragraph macros inside lists:
* When they are trailing the last item, move them outside the list.
* When they are trailing any other none-compact item, drop them.

OpenBSD rev. mdoc_validate.c 1.107, mdoc.c 1.91
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.200 2012/07/18 10:39:19 schwarze Exp $ */
d378 2
d506 1
@


1.200
log
@The mdoc(7) \*(Ba predefined string actually forces roman font;
that's stupid because it may break enclosing font changes,
but let's do the same for groff bug compatibility.

--> Never use \*(Ba, use just plain "|"! <--

Also, predefined strings are already expanded by the roff(7) parser,
so the mdoc(7) parser has to look for the expanded string.

OpenBSD rev. mdoc.c 1.90 and predefs.in 1.3
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.199 2012/07/16 09:51:54 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d651 8
@


1.199
log
@Several -mdoc parser improvements related to vertical spacing:
* So far, .Pp and .Lp were removed before paragraph type blocks.
* Now also remove .br before paragraph type blocks.
* Treat .Lp as a paragraph like .Pp, so remove .Pp, .Lp, .br before it.
* Do not treat .sp as a paragraph, don't remove anything before it.
* After .Sh, .Ss, .Pp, and .Lp, remove .Pp, .Lp, .sp, .br, and blank lines.
* After .sp and .br, remove .br.
OpenBSD rev. mdoc.c 1.89 and mdoc_validate.c 1.106
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.198 2012/06/12 20:21:04 kristaps Exp $ */
d985 1
a985 1
	if (0 == strcmp(p + 1, "*(Ba"))
@


1.198
log
@Add `cc' support.
This was reported by espie@@ and in the TODO.
Caveat: `cc' has buggy behaviour when invoked in groff(1) and followed
by a line-breaking control character macro, e.g., in a -man doc,

  .cc |
  .B foo
  'B foo
  |cc
  'B foo

will cause groff(1) to behave properly for `.B' but inline the macro
definition for `B' when invoked with the line-breaking macro.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.197 2012/05/27 17:48:57 schwarze Exp $ */
d804 2
a805 1
		return(1);
@


1.197
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.196 2011/09/30 00:13:28 schwarze Exp $ */
d305 1
a305 1
	return(mandoc_getcontrol(buf, &offs) ?
@


1.196
log
@implement .Ap .Bd .Bo .Bq .D1 .Ic .Lp .Oo .Pf .Po .Ss .Sx .Sy .br .sp
implement .Bl -bullet
add more information to the .TH line
escape dots at the beginnings of lines
add trailing newline character at the end of the file
do not misinterpret the ROOT block as .Ap
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.195 2011/07/28 14:17:11 kristaps Exp $ */
d200 1
a200 1
mdoc_alloc(struct roff *roff, struct mparse *parse)
d207 1
@


1.195
log
@An implementation of `tr'.  This routes allocations of TEXT nodes
through libroff, which does the appropriate translations of `tr'.  This
is SLOW: it uses the backend of `ds' and `de', which is a simple linear
list.  However, unlike `ds' and `de', it iterates over EACH CHARACTER of
the entire file looking for replacements.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.194 2011/07/27 12:43:02 kristaps Exp $ */
d163 1
@


1.194
log
@Simply word allocation in libmdoc and libman.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.193 2011/07/27 12:41:02 kristaps Exp $ */
d573 1
a573 1
	n->string = mandoc_strdup(p);
@


1.193
log
@Disable in-line eqn processing for a bit.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.192 2011/07/27 07:09:41 kristaps Exp $ */
a570 3
	size_t		  sv, len;

	len = strlen(p);
d573 1
a573 5
	n->string = mandoc_malloc(len + 1);
	sv = strlcpy(n->string, p, len + 1);

	/* Prohibit truncation. */
	assert(sv < len + 1);
@


1.192
log
@First, roff_res() has no need to invoke ROFF_RERUN: since it's executed
before any other roff processing occurs, it's Ok to just let it do its
thing and pass through.  Also, make sure this function is ALWAYS called,
not just when first_string is defined.

Second, add a new function, roff_parsetext(), that post-processes
non-macro lines.  This, for the time being, amounts to detecting soft
hyphens.  This fixes a long-standing bug in that -man now has proper
hyphen breaking!
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.191 2011/07/25 15:37:00 kristaps Exp $ */
d100 1
d102 1
d305 1
a305 1
			mdoc_preptext(m, ln, buf, offs));
d656 1
d708 1
@


1.191
log
@Implement the first steps of equation parsing from within libmdoc.
This consists of a shim around the text parser that calls out to libroff
if equation components exist on the line.  Right now this will do
nothing, as the equation delimiter always returns nil.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.190 2011/07/21 10:24:35 kristaps Exp $ */
a757 5
		case '-':
			if (mandoc_hyph(buf + offs, c))
				*c = ASCII_HYPH;
			ws = NULL;
			break;
@


1.190
log
@Finish the eqn syntactic parser.  This correctly parses terms and does
the proper `define' dance, which amounts to pure word-replace (you can,
say, define `foo' as `define' then define `define' as something else).
eqn.c is now ready for some semantic parsing of `box' and `eqn'
productions as defined by the grammar.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.189 2011/07/18 07:46:41 kristaps Exp $ */
d100 1
d303 1
a303 1
			mdoc_ptext(m, ln, buf, offs));
d654 51
@


1.189
log
@Make `struct roff' be passed into libmdoc and libman upon creation.
This is required for supporting in-line equations.  While here, push
registers properly into roff and add an set/get/mod interface.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.188 2011/03/28 23:52:13 kristaps Exp $ */
d236 1
a236 1
		mdoc_pmsg(m, ep->line, ep->pos, MANDOCERR_NOTEXT);
d240 1
a240 1
	n = node_alloc(m, ep->line, ep->pos, MDOC_MAX, MDOC_EQN);
@


1.188
log
@Have libman and libmdoc use mandoc_getcontrol() to determine whether a
macro has been invoked.  libroff is next.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.187 2011/03/22 14:33:05 kristaps Exp $ */
d196 1
a196 1
mdoc_alloc(struct regset *regs, struct mparse *parse)
d203 1
a203 1
	p->regs = regs;
d293 2
a294 2
	if (m->regs->regs[(int)REG_nS].set) {
		if (m->regs->regs[(int)REG_nS].v.u)
@


1.187
log
@libmdoc.h and libman.h were including mdoc.h and man.h, respectively.
Don't have them do that (includes in header files = faugh), and have
individual files directly include these files.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.186 2011/03/22 14:05:45 kristaps Exp $ */
d300 1
a300 1
	return(('.' == buf[offs] || '\'' == buf[offs]) ? 
a663 9
	/* Ignore bogus comments. */

	if ('\\' == buf[offs] && 
			'.' == buf[offs + 1] && 
			'"' == buf[offs + 2]) {
		mdoc_pmsg(m, line, offs, MANDOCERR_BADCOMMENT);
		return(1);
	}

d790 1
a790 1
	int		  i, j, sv;
d794 1
a794 1
	/* Empty lines are ignored. */
d796 4
a799 3
	offs++;

	if ('\0' == buf[offs])
d802 1
a802 13
	i = offs;

	/* Accept tabs/whitespace after the initial control char. */

	if (' ' == buf[i] || '\t' == buf[i]) {
		i++;
		while (buf[i] && (' ' == buf[i] || '\t' == buf[i]))
			i++;
		if ('\0' == buf[i])
			return(1);
	}

	sv = i;
d809 8
a816 4
	j = 0;
	while (j < 4 && '\0' != buf[i] && ' ' != buf[i] && '\t' != buf[i])
		mac[j++] = buf[i++];
	mac[j] = '\0';
a817 1
	tok = (j > 1 || j < 4) ? mdoc_hash_find(mac) : MDOC_MAX;
d826 2
a827 2
	if ('\t' == buf[i])
		i++;
d831 2
a832 2
	while (buf[i] && ' ' == buf[i])
		i++;
d839 2
a840 2
	if ('\0' == buf[i] && ' ' == buf[i - 1])
		mdoc_pmsg(m, ln, i - 1, MANDOCERR_EOLNSPACE);
d848 1
a848 1
		if ( ! mdoc_macro(m, tok, ln, sv, &i, buf)) 
d887 1
a887 1
	if ( ! mdoc_macro(m, tok, ln, sv, &i, buf)) 
@


1.186
log
@Move mandoc_isdelim() back into libmdoc.h.  This fixes an unreported
error where (1) -man pages were punctuating delimiters (e.g., `.B a ;')
and where (2) standalone punctuation in -mdoc or -man (e.g., ";" on its
own line) would also be punctuated.  This introduces a small amount of
complexity of mdoc_{html,term}.c must manage their own spacing with
running print_word() or print_text().  The check for delimiting now
happens in mdoc_macro.c's dword().
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.185 2011/03/20 16:02:05 kristaps Exp $ */
d31 1
@


1.185
log
@Consolidate messages.  Have all parse-time messages (in libmdoc,
libroff, etc., etc.) route into mandoc_msg() and mandoc_vmsg(), for the
time being in libmandoc.h.  This requires struct mparse to be passed
into the allocation routines instead of mandocmsg and a void pointer.
Then, move some of the functionality of the old mmsg() into read.c's
mparse_mmsg() (check against wlevel and setting of file_status) and use
main.c's mmsg() as simply a printing tool.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.184 2011/03/17 11:30:23 kristaps Exp $ */
d914 37
d952 7
@


1.184
log
@Clean-up in libmdoc: fix last checks for mdoc_*msg return value, then
make mdoc_vmsg not return an int.  libmdoc is now completely clean of
return-value checks from the message subsystem.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.183 2011/03/15 13:23:33 kristaps Exp $ */
d195 1
a195 1
mdoc_alloc(struct regset *regs, void *data, mandocmsg msg)
d201 1
a201 2
	p->msg = msg;
	p->data = data;
a303 16

void
mdoc_vmsg(struct mdoc *mdoc, enum mandocerr t, 
		int ln, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	va_start(ap, fmt);
	vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);

	(*mdoc->msg)(t, mdoc->data, ln, pos, buf);
}


d331 2
a332 2
			m->meta.date = mandoc_normdate(NULL,
			    m->msg, m->data, line, ppos);
d835 2
a836 1
		mdoc_vmsg(m, MANDOCERR_MACRO, ln, sv, "%s", buf + sv - 1);
@


1.183
log
@Plug memory leak of normalised-date field.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.182 2011/03/07 01:35:51 schwarze Exp $ */
d306 1
a306 1
int
d317 1
a317 1
	return((*mdoc->msg)(t, mdoc->data, ln, pos, buf));
@


1.182
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.181 2011/02/09 09:05:52 kristaps Exp $ */
d141 2
@


1.181
log
@Allow EQN data to be pushed down into libmdoc via mdoc_addeqn().  Only
the adding itself is implemented; equation data is not yet shown.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.180 2011/02/08 07:40:23 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d345 3
a347 2
		if (0 == m->meta.date)
			m->meta.date = time(NULL);
@


1.180
log
@Put tbl_alloc function right into the addspan() one, as this is the only
place that it's called.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.179 2011/02/06 22:05:20 kristaps Exp $ */
d225 24
@


1.179
log
@Use tbl_span line number for warnings/errors.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.178 2011/02/06 22:02:58 kristaps Exp $ */
a100 3
static	int		  mdoc_span_alloc(struct mdoc *, 
				const struct tbl_span *);

d227 1
d238 8
a245 1
	return(mdoc_span_alloc(m, sp));
a552 16
static int
mdoc_span_alloc(struct mdoc *m, const struct tbl_span *sp)
{
	struct mdoc_node *n;

	n = node_alloc(m, sp->line, 0, MDOC_MAX, MDOC_TBL);
	n->span = sp;

	if ( ! node_append(m, n))
		return(0);

	m->next = MDOC_NEXT_SIBLING;
	return(1);
}


@


1.178
log
@Let the line-number of a tbl_span be remembered.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.177 2011/01/03 11:27:33 kristaps Exp $ */
d236 1
a236 2
		/* FIXME: grab from span. */
		mdoc_pmsg(m, 0, 0, MANDOCERR_NOTEXT);
@


1.177
log
@Clarified the role of MDOC_HALT in libmdoc functions by having accessor
functions assert() if they're called after MDOC_HALT is set.

This makes more sense than returning 0 because this return value is used
for parse errors, not programme-flow errors, and it's inconsistent to
use the same value for both.  Plus, prior to this, I'd return 0 without
printing an error message, which would cause failure to go unreported to
the operator.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.176 2011/01/01 12:59:17 kristaps Exp $ */
d554 1
a554 2
	/* FIXME: grab from tbl_span. */
	n = node_alloc(m, 0, 0, MDOC_MAX, MDOC_TBL);
@


1.176
log
@Add -man support for tables.  Like -mdoc, this consists of an
external-facing function man_addspan() (this required shuffling around
the descope routine) and hooks elsewhere.

Also fixed mdoc.c's post-validation of tables.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.175 2011/01/01 12:18:37 kristaps Exp $ */
d109 2
a110 1
	return(MDOC_HALT & m->flags ? NULL : m->first);
d118 2
a119 1
	return(MDOC_HALT & m->flags ? NULL : &m->meta);
d220 2
a221 3
	if (MDOC_HALT & m->flags)
		return(0);
	else if (mdoc_macroend(m))
d231 1
a231 2
	if (MDOC_HALT & m->flags)
		return(0);
d253 1
a253 2
	if (MDOC_HALT & m->flags)
		return(0);
@


1.175
log
@Add table processing structures to -mdoc.  This consists of an
external-facing function mdoc_addspan(), then various bits to prohibit
printing and scanning (this requires some if's to be converted into
switch's).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.174 2011/01/01 10:51:30 kristaps Exp $ */
d394 2
@


1.174
log
@Clean up {mdoc,man}_pmsg and vmsg invocations (ignore return values).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.173 2010/12/25 13:50:37 kristaps Exp $ */
d101 2
d226 18
d548 16
@


1.173
log
@Specifying both %T and %J in an `Rs' block causes the title to be quoted
instead of underlined.  This only happens in -Tascii, as -T[x]html both
underlines and italicises.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.172 2010/12/24 14:00:40 kristaps Exp $ */
d280 4
a283 2
			MDOC_PBODY & m->flags)
		return(mdoc_pmsg(m, line, ppos, MANDOCERR_BADBODY));
d289 1
a289 2
		if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_BADPROLOG))
			return(0);
d633 4
a636 2
			'"' == buf[offs + 2])
		return(mdoc_pmsg(m, line, offs, MANDOCERR_BADCOMMENT));
d640 4
a643 2
	if (SEC_NONE == m->lastnamed)
		return(mdoc_pmsg(m, line, offs, MANDOCERR_NOTEXT));
d718 1
a718 2
		if ( ! mdoc_pmsg(m, line, (int)(ws-buf), MANDOCERR_EOLNSPACE))
			return(0);
d721 1
a721 2
		if ( ! mdoc_pmsg(m, line, (int)(c-buf), MANDOCERR_NOBLANKLN))
			return(0);
d821 1
a821 2
		if ( ! mdoc_pmsg(m, ln, i - 1, MANDOCERR_EOLNSPACE))
			goto err;
@


1.172
log
@As per schwarze@@'s suggestions, roll back the refcount structure in
favour of a simpler shim for normalised data in the node allocation and
free routines.  This removes the need to bump and copy references within
validator handlers, removes a pointer redirect, and also kills the
refcount structure itself.  Data is assumed to "live" either in a
MDOC_BLOCK or MDOC_ELEM and is copied accordingly.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.171 2010/12/22 11:15:16 kristaps Exp $ */
d487 2
@


1.171
log
@Implement reference-counted version of original union mdoc_data.  This
simplifies clean-up and allows for more types without extra hassle.

Also made in-line literal types in -T[x]html use CODE instead of SPAN to
match how literal blocks use PRE.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.170 2010/12/16 17:14:48 kristaps Exp $ */
d331 17
d480 13
d510 9
d553 1
a553 1
	if (p->norm && 0 == --(p->norm->refcnt))
a554 1

d649 1
a649 1
			LIST_column == n->norm->d.Bl.type) {
d658 1
a658 1
			LIST_column == n->parent->norm->d.Bl.type) {
d839 1
a839 1
			LIST_column == n->norm->d.Bl.type) {
d855 1
a855 1
			LIST_column == n->parent->norm->d.Bl.type) {
@


1.170
log
@Migrate `An' to use a pointer in its data, like everybody else.  This is
the first step to having a simpler ref-counted system for "data"
associated with a node.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.169 2010/12/15 23:39:40 kristaps Exp $ */
d514 2
a515 18
	/*
	 * XXX: if these end up being problematic in terms of memory
	 * management and dereferencing freed blocks, then make them
	 * into reference-counted double-pointers.
	 */

	if (MDOC_Bd == p->tok && MDOC_BLOCK == p->type)
		if (p->data.Bd)
			free(p->data.Bd);
	if (MDOC_Bl == p->tok && MDOC_BLOCK == p->type)
		if (p->data.Bl)
			free(p->data.Bl);
	if (MDOC_Bf == p->tok && MDOC_HEAD == p->type)
		if (p->data.Bf)
			free(p->data.Bf);
	if (MDOC_An == p->tok)
		if (p->data.An)
			free(p->data.An);
d611 1
a611 1
			LIST_column == n->data.Bl->type) {
d620 1
a620 1
			LIST_column == n->parent->data.Bl->type) {
d801 1
a801 1
			LIST_column == n->data.Bl->type) {
d817 1
a817 1
			LIST_column == n->parent->data.Bl->type) {
@


1.169
log
@Add a "last child" member of struct mdoc_node.

Remove `Pp' or `Lp' if it is the FIRST or LAST child of an `Sh' or `Sh' body.

Make "skipping paragraph" be an error, not a warning, as information (an
invoked macro) is ignored.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.168 2010/12/06 11:01:19 kristaps Exp $ */
d529 3
@


1.168
log
@Merge schwarze@@'s relaxation of scope-breaking rules: allow implicit
ending of scopes and drop stray scope-endings.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.167 2010/12/01 16:38:57 kristaps Exp $ */
d555 2
@


1.167
log
@Make sure that the manual section defaults to `1' if it's unset.  This
behaviour only happens if `Dt' isn't specified, which can be exhibited
by running mandoc -mdoc on a man manual.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.166 2010/11/30 13:04:14 kristaps Exp $ */
d769 1
a769 3
		mdoc_vmsg(m, MANDOCERR_MACRO, ln, sv, 
		    "unknown macro: %s%s", 
		    buf, strlen(buf) > 3 ? "..." : "");
@


1.166
log
@mdoc_action.c is no more.  Attic it and remove it from the Makefile.
Remove references to MDOC_ACTED (it was only assertions) and the pre-
and post-action functions.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.165 2010/09/27 23:03:44 schwarze Exp $ */
d289 2
@


1.165
log
@Merge from OpenBSD right after 1.10.6; now back to full sync.
* mdoc.c: blank lines outside literal mode are more similar to .sp than .Pp
* backslashes do not terminate macros; partial revert of mdoc.c 1.164;
  the intention of that commit is fully achieved in roff.c
* mdoc_term.c: no need to list the same prototype twice
* mdoc_validate.c: drop .Pp before .sp just like .Pp before .Pp
* fix off-by-one found by jsg@@ with parfait, OpenBSD term_ps.c 1.12
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.164 2010/08/29 11:29:51 kristaps Exp $ */
a330 2
	if ( ! mdoc_action_pre(mdoc, p))
		return(0);
a356 2
		if ( ! mdoc_action_post(mdoc))
			return(0);
@


1.164
log
@Allow `.xx\}' where xx is a macro (e.g., `.br\}') to close scope.  This is
experimental and hasn't been rigorously tested.  It's only implemented in
-mdoc for the time being.  This is absolutely required for pod2man.  It
does, however, make the pod2man preamble be processed in full.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.163 2010/08/20 01:02:07 schwarze Exp $ */
d694 1
a694 1
		 * Insert a `Pp' in the case of a blank line.  Technically,
d698 1
a698 1
		if ( ! mdoc_elem_alloc(m, line, offs, MDOC_Pp, NULL))
d761 1
a761 1
	 * Stop copying when a tab, space, backslash, or eoln is encountered.
d765 1
a765 4
	while (j < 4 && '\0' != buf[i] && 
			' ' != buf[i] && 
			'\t' != buf[i] && 
			'\\' != buf[i])
@


1.163
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.162 2010/08/08 14:51:32 schwarze Exp $ */
d761 1
a761 1
	 * Stop copying when a tab, space, or eoln is encountered.
d765 4
a768 1
	while (j < 4 && '\0' != buf[i] && ' ' != buf[i] && '\t' != buf[i])
@


1.162
log
@simplify the code copying the macro name, and sync the
accompagnying comment between man_pmacro() and mdoc_pmacro();
ok'd by kristaps@@ together with main.c rev. 1.102
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.161 2010/08/07 20:57:33 kristaps Exp $ */
a100 2
static	int		  macrowarn(struct mdoc *, int, 
				const char *, int);
d192 1
a192 2
mdoc_alloc(struct regset *regs, void *data, 
		int pflags, mandocmsg msg)
a199 1
	p->pflags = pflags;
a725 15
static int
macrowarn(struct mdoc *m, int ln, const char *buf, int offs)
{
	int		 rc;

	rc = mdoc_vmsg(m, MANDOCERR_MACRO, ln, offs, 
			"unknown macro: %s%s", 
			buf, strlen(buf) > 3 ? "..." : "");

	/* FIXME: logic should be in driver. */
	/* FIXME: broken, will error out and not omit a message. */
	return(MDOC_IGN_MACRO & m->pflags ? rc : 0);
}


d769 5
a773 9
	if (j == 4 || j < 2) {
		if ( ! macrowarn(m, ln, mac, sv))
			goto err;
		return(1);
	} 
	
	if (MDOC_MAX == (tok = mdoc_hash_find(mac))) {
		if ( ! macrowarn(m, ln, mac, sv))
			goto err;
@


1.161
log
@Clean out the isgraph() checks in mdoc.c and man.c.  These code paths
were never taken since main.c begin skipping over unrecognisable
characters, so they were noops.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.160 2010/08/07 20:33:55 kristaps Exp $ */
d779 2
a780 2
	 * Copy the first word into a nil-terminated buffer.  Stop
	 * copying when a tab, space, or eoln is encountered.
d783 3
a785 6
	for (j = 0; j < 4; j++, i++)
		if ('\0' == (mac[j] = buf[i]))
			break;
		else if (' ' == buf[i] || '\t' == buf[i])
			break;

@


1.160
log
@"Groff allows the initial macro on a line to be delimited by a space of
by a tab; so allow the tab in mandoc, too."  Original problem noted by
schwarze@@.  Sync with OpenBSD.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.159 2010/07/18 17:00:26 schwarze Exp $ */
a24 1
#include <ctype.h>
d783 1
a783 1
	for (j = 0; j < 4; j++, i++) {
a788 10
		/* Check for invalid characters. */
		/* TODO: remove me, already done in main.c. */

		if (isgraph((u_char)buf[i]))
			continue;
		if ( ! mdoc_pmsg(m, ln, i, MANDOCERR_BADCHAR))
			return(0);
		i--;
	}

@


1.159
log
@Text ending in a full stop, exclamation mark or question mark
should not flag the end of a sentence if:

1) The punctuation is followed by closing delimiters
and not preceded by alphanumeric characters, like in
"There is no full stop (.) in this sentence"

or

2) The punctuation is a child of a macro
and not preceded by alphanumeric characters, like in
"There is no full stop
.Pq \&.
in this sentence"

"looks fine" to kristaps@@; tested by jmc@@ and sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.158 2010/07/07 15:04:54 kristaps Exp $ */
d767 1
a767 1
	/* Accept whitespace after the initial control char. */
d769 1
a769 1
	if (' ' == buf[i]) {
d771 1
a771 1
		while (buf[i] && ' ' == buf[i])
d779 4
a782 1
	/* Copy the first word into a nil-terminated buffer. */
d787 1
a787 1
		else if (' ' == buf[i])
d791 1
d814 6
a819 1
	/* The macro is sane.  Jump to the next word. */
@


1.158
log
@Re-constitution of `ds' symbol processing.  First, push the
roff_getstr() family of functions into roff.c with the "first_string"
directly in struct roff.  Second, pre-process each line for reserved
words in libroff, splicing and re-running a line if it has one (this
allows defined symbols to be macros).  Remove term.c's invocation of the
roff_getstrn() function.  Removed function documentation in roff.3 and
added roff.7 `ds' documentation.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.157 2010/07/04 22:04:04 schwarze Exp $ */
d724 1
a724 1
	if (mandoc_eos(buf+offs, (size_t)(end-buf-offs)))
@


1.157
log
@Assert my copyright, making it explicit that i'm granting the same license
on those parts of the code and text that i have written as Kristaps is.
"fine with me" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.156 2010/07/02 12:54:33 kristaps Exp $ */
a32 1
#include "regs.h"
@


1.156
log
@Stash `Bf' parameters into struct mdoc_bf.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.155 2010/07/01 23:01:47 kristaps Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.155
log
@Remove my own dumb FIXME and mark a static function defn as static.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.154 2010/07/01 22:56:17 kristaps Exp $ */
d521 6
d533 3
@


1.154
log
@Make struct_bl and struct_bd into pointers.  This removes the need to do
copying on internals after modification.  Even more importantly, if an
ENDBODY token is provided, it would have been impossible for post-change
copying of the data to take place in the BLOCK.  This allows it to
happen by dint of pointers.

Also did some bikeshedding in mdoc_term.c: checking against enum type
and explicitly casting to the "post" function to void.  This is for my
own readability.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.153 2010/07/01 22:35:54 schwarze Exp $ */
d517 1
a517 2
/* FIXME: put in mdoc_node_delete(). */
void
d741 1
a741 1
int
@


1.153
log
@In the mdoc(7) parser, inspect roff registers early such that all parts
of the parser can use the resulting cues.  In particular, this allows
to use .nr nS to force SYNOPSIS-style .Nm indentation outside the
SYNOPSIS as needed by ifconfig(8).

To actually make this useable, .Pp must rewind .Nm, or the rest of the
section would end up indented.  Implement a quick hack for now,
a generic solution can be designed later.

ok kristaps@@ and tested by sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.152 2010/06/29 19:20:38 schwarze Exp $ */
d517 1
d522 7
d621 1
a621 1
			LIST_column == n->data.Bl.type) {
d630 1
a630 1
			LIST_column == n->parent->data.Bl.type) {
d836 1
a836 1
			LIST_column == n->data.Bl.type) {
d852 1
a852 1
			LIST_column == n->parent->data.Bl.type) {
@


1.152
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.151 2010/06/27 16:36:22 kristaps Exp $ */
d242 14
d390 4
a397 14
	/* Section analysis. */

	if (SEC_SYNOPSIS == p->sec)
		p->flags |= MDOC_SYNPRETTY;

	/* Register analysis. */

	if (m->regs->regs[(int)REG_nS].set) {
		if (m->regs->regs[(int)REG_nS].v.u)
			p->flags |= MDOC_SYNPRETTY;
		else
			p->flags &= ~MDOC_SYNPRETTY;
	}

@


1.151
log
@Allow registers to be unset.  Implement and document the `.nr nS val'.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.150 2010/06/27 16:18:13 kristaps Exp $ */
d335 2
d441 16
@


1.150
log
@Following clue-stick applied by schwarze@@, back out const-ness of regset
passed in to libmdoc and libman.

Fix mdoc.3 and man.3 EXAMPLE sections to include regset.

Add MDOC_SYNPRETTY flag cueing front-end to nicely format certain values
as if SEC_SYNOPSIS were the current section.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.149 2010/06/27 15:52:41 kristaps Exp $ */
d383 9
@


1.149
log
@Downstream maintainers: this removes UGLY!  I don't want diverging
functionality and UGLY works quite well thanks to schwarze@@'s careful
attention.

This also backs out function-prototype changes for struct regset,
instead stuffing a pointer to the regset directly into struct
mdoc/man/roff.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.148 2010/06/26 16:07:08 kristaps Exp $ */
d195 2
a196 2
mdoc_alloc(const struct regset *regs, 
		void *data, int pflags, mandocmsg msg)
d371 3
d377 6
@


1.148
log
@Mechanical diff allowing the const struct regset to propogate through
libman and libmdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.147 2010/06/26 15:36:37 kristaps Exp $ */
d100 2
a101 6
static	int		  mdoc_ptext(struct mdoc *, 
				const struct regset *,
				int, char *, int);
static	int		  mdoc_pmacro(struct mdoc *, 
				const struct regset *,
				int, char *, int);
d195 2
a196 1
mdoc_alloc(void *data, int pflags, mandocmsg msg)
d205 1
d235 1
a235 2
mdoc_parseln(struct mdoc *m, const struct regset *regs,
		int ln, char *buf, int offs)
d243 2
a244 2
			mdoc_pmacro(m, regs, ln, buf, offs) :
			mdoc_ptext(m, regs, ln, buf, offs));
d291 1
a291 2
	return((*mdoc_macros[tok].fp)
			(m, regs, tok, line, ppos, pos, buf));
d545 1
a545 2
mdoc_ptext(struct mdoc *m, const struct regset *regs,
		int line, char *buf, int offs)
d576 1
a576 2
		return(mdoc_macro(m, regs, MDOC_It, 
					line, offs, &offs, buf));
d585 1
a585 2
		return(mdoc_macro(m, regs, MDOC_It, 
					line, offs, &offs, buf));
d695 1
a695 2
mdoc_pmacro(struct mdoc *m, const struct regset *regs,
		int ln, char *buf, int offs)
d774 1
a774 1
		if ( ! mdoc_macro(m, regs, tok, ln, sv, &i, buf)) 
d790 1
a790 1
		if ( ! mdoc_macro(m, regs, MDOC_It, ln, sv, &sv, buf))
d806 1
a806 1
		if ( ! mdoc_macro(m, regs, MDOC_It, ln, sv, &sv, buf)) 
d813 1
a813 1
	if ( ! mdoc_macro(m, regs, tok, ln, sv, &i, buf)) 
@


1.147
log
@Churn-ish check-in getting mdoc_parseln() and man_parseln() to accept a
const struct regset pointer.  No functionality.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.146 2010/06/12 11:58:22 kristaps Exp $ */
d100 6
a105 2
static	int		  mdoc_ptext(struct mdoc *, int, char *, int);
static	int		  mdoc_pmacro(struct mdoc *, int, char *, int);
d246 2
a247 2
			mdoc_pmacro(m, ln, buf, offs) :
			mdoc_ptext(m, ln, buf, offs));
d267 1
a267 2
mdoc_macro(struct mdoc *m, enum mdoct tok, 
		int ln, int pp, int *pos, char *buf)
d275 1
a275 1
		return(mdoc_pmsg(m, ln, pp, MANDOCERR_BADBODY));
d281 1
a281 1
		if ( ! mdoc_pmsg(m, ln, pp, MANDOCERR_BADPROLOG))
d294 2
a295 1
	return((*mdoc_macros[tok].fp)(m, tok, ln, pp, pos, buf));
d549 2
a550 1
mdoc_ptext(struct mdoc *m, int line, char *buf, int offs)
d581 2
a582 1
		return(mdoc_macro(m, MDOC_It, line, offs, &offs, buf));
d591 2
a592 1
		return(mdoc_macro(m, MDOC_It, line, offs, &offs, buf));
d702 2
a703 1
mdoc_pmacro(struct mdoc *m, int ln, char *buf, int offs)
d782 1
a782 1
		if ( ! mdoc_macro(m, tok, ln, sv, &i, buf)) 
d798 1
a798 1
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf)) 
d814 1
a814 1
		if ( ! mdoc_macro(m, MDOC_It, ln, sv, &sv, buf)) 
d821 1
a821 1
	if ( ! mdoc_macro(m, tok, ln, sv, &i, buf)) 
@


1.146
log
@`Bl' is now using a struct instead of a single enum mdoc_list for its
cached values.  You can probably guess where this is going.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.145 2010/05/31 21:32:57 kristaps Exp $ */
d32 1
d233 2
a234 1
mdoc_parseln(struct mdoc *m, int ln, char *buf, int offs)
@


1.145
log
@Fixed my breaking of Ingo's eoln-whitespace detection code, where a
hyphen wasn't resetting the fact of being whitespace.  Noted by Jason
McIntyre.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.144 2010/05/31 20:14:10 kristaps Exp $ */
d571 1
a571 1
			LIST_column == n->data.list) {
d580 1
a580 1
			LIST_column == n->parent->data.list) {
d786 1
a786 1
			LIST_column == n->data.list) {
d802 1
a802 1
			LIST_column == n->parent->data.list) {
@


1.144
log
@Macro lines now infer an `It' if they immediately follow a `Bl -column'
or a closed-out `It' block within a `Bl -column' (which only happens
when a macro or free-form text is encountered prior to an `It').

Added some regression tests for this behaviour.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.143 2010/05/31 15:50:48 kristaps Exp $ */
d598 1
@


1.143
log
@Strengthened constraint for passing into `It'.

Added regression test for constrained condition.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.142 2010/05/31 15:42:09 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
d564 1
a564 1
	 * Diver directly into list processing if we're encountering a
d566 2
a567 2
	 * (if it's a MDOC_BODY that means it's open, in which case we
	 * should process within its context).
d572 1
d581 1
d682 1
d694 4
a697 3
	enum mdoct	tok;
	int		i, j, sv;
	char		mac[5];
d765 31
a795 3
	/* 
	 * Begin recursive parse sequence.  Since we're at the start of
	 * the line, we don't need to do callable/parseable checks.
d797 13
@


1.142
log
@Add ability to interpret initial free-form lines as part of a `Bl
-column' up until the first `It'.  This is UGLY and should have all
sorts of warnings, and will.  On the one hand, it fits with groff's
notion of tabs and tab-spaces.  On the other hand, it's not really
"free-form" text any more.  Note that this does not yet accomodate for
macros coming on these lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.141 2010/05/31 10:28:04 kristaps Exp $ */
d570 2
a571 1
	if (MDOC_Bl == n->tok && LIST_column == n->data.list) {
@


1.141
log
@Remove enum mdocargerr from phrase() (unused).

Add `Ta' macro, which is basically a NULL case everywhere but in
mdoc_macro.c, where it closes out an existing `It' body scope and opens
a new one, then continues parsing as in phrase() (TODO: merge these
two?).

Fix where scope-breaking was silently just dying instead of printing an
error.

Fix where trailing `Ta' or tab weren't creating a new MDOC_BODY context.

We now support arbitrarily complex `It' contents for `Bl -column'.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.140 2010/05/30 11:00:53 kristaps Exp $ */
d545 2
a546 1
	char		*c, *ws, *end;
d560 23
@


1.140
log
@Made `Dt' default to LOCAL and UNKNOWN instead of local and unknown (note case).

Have `Dt' default to UNKNOWN if it's an empty string.

Raise a warning if `Dt' title isn't capitalised.

Sync'd `Dt' documentation with reality.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.139 2010/05/26 09:35:35 kristaps Exp $ */
d72 1
a72 1
	"%U"
@


1.139
log
@Fixed `Lb' to be in_line (reported by Ulrich Spoerlein).

Added `Lb' documentation to mdoc.7.

Removed harmless but superfluous pre_lb check (was just NULL entries).

Added regressions for `Lb' (NOTE that these will only run on new groff,
as old groff doesn't support `Lb' at all).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.138 2010/05/25 12:37:20 kristaps Exp $ */
d279 1
a279 1
			m->meta.title = mandoc_strdup("unknown");
d281 1
a281 1
			m->meta.vol = mandoc_strdup("local");
d283 1
a283 1
			m->meta.os = mandoc_strdup("local");
@


1.138
log
@Modified version of Ingo Schwarze's patch for hyphen-breaking.
Breakable hyphens are cued in the back-ends (with ASCII_HYPH) and acted
upon in term.c or ignored in html.c.

Also cleaned up XML decl printing (no need for extra vars).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.137 2010/05/24 13:39:47 schwarze Exp $ */
d563 2
@


1.137
log
@rewrite the main mdoc text parser, mdoc_ptext(),
making it easier to understand and fixing various bugs:
* correctly strip whitespace from the end of text lines
* issue consistent warnings regarding trailing spaces and tabs
* escaped backslashes no longer escape the following character
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.136 2010/05/17 22:11:42 kristaps Exp $ */
d566 4
@


1.136
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.135 2010/05/16 10:59:36 kristaps Exp $ */
d545 1
a545 1
	int		 i;
d559 38
a596 4
	/* Literal just gets pulled in as-is. */
	
	if (MDOC_LITERAL & m->flags)
		return(mdoc_word_alloc(m, line, offs, buf + offs));
d598 3
a600 1
	/* Check for a blank line, which may also consist of spaces. */
d602 2
a603 5
	for (i = offs; ' ' == buf[i]; i++)
		/* Skip to first non-space. */ ;

	if ('\0' == buf[i]) {
		if ( ! mdoc_pmsg(m, line, offs, MANDOCERR_NOBLANKLN))
d618 2
a619 4
	/* 
	 * Warn if the last un-escaped character is whitespace. Then
	 * strip away the remaining spaces (tabs stay!).   
	 */
d621 2
a622 21
	i = (int)strlen(buf);
	assert(i);

	if (' ' == buf[i - 1] || '\t' == buf[i - 1]) {
		if (i > 1 && '\\' != buf[i - 2])
			if ( ! mdoc_pmsg(m, line, i - 1, MANDOCERR_EOLNSPACE))
				return(0);

		for (--i; i && ' ' == buf[i]; i--)
			/* Spin back to non-space. */ ;

		/* Jump ahead of escaped whitespace. */
		i += '\\' == buf[i] ? 2 : 1;

		buf[i] = '\0';
	}

	/* Allocate the whole word. */

	if ( ! mdoc_word_alloc(m, line, offs, buf + offs))
		return(0);
d630 3
a632 2
	assert(i);
	if (mandoc_eos(buf, (size_t)i))
@


1.135
log
@Allow roff_parseln() to be re-run.
Allow roff_parseln() to manipulate the line buffer offset.  This is used
in situations like `.ie n .TH FOO 1' or `.ie n .ie n', where the line
buffer offset is recalculated then the roff parser re-run.
Fix mdoc_parseln() and man_parseln() to accept the initial line offset.
WARNING: backed-out ALL roff macros whilst accomodating for how roff
handles multi-line conditionals (in short, re-running the parser).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.134 2010/05/16 00:04:46 kristaps Exp $ */
d31 1
a34 55
const	char *const __mdoc_merrnames[MERRMAX] = {		 
	"trailing whitespace", /* ETAILWS */
	"unexpected quoted parameter", /* EQUOTPARM */
	"unterminated quoted parameter", /* EQUOTTERM */
	"argument parameter suggested", /* EARGVAL */
	"macro disallowed in prologue", /* EBODYPROL */
	"macro disallowed in body", /* EPROLBODY */
	"text disallowed in prologue", /* ETEXTPROL */
	"blank line disallowed", /* ENOBLANK */
	"text parameter too long", /* ETOOLONG */
	"invalid escape sequence", /* EESCAPE */
	"invalid character", /* EPRINT */
	"document has no body", /* ENODAT */
	"document has no prologue", /* ENOPROLOGUE */
	"expected line arguments", /* ELINE */
	"invalid AT&T argument", /* EATT */
	"default name not yet set", /* ENAME */
	"missing list type", /* ELISTTYPE */
	"missing display type", /* EDISPTYPE */
	"too many display types", /* EMULTIDISP */
	"too many list types", /* EMULTILIST */
	"NAME section must be first", /* ESECNAME */
	"badly-formed NAME section", /* ENAMESECINC */
	"argument repeated", /* EARGREP */
	"expected boolean parameter", /* EBOOL */
	"inconsistent column syntax", /* ECOLMIS */
	"nested display invalid", /* ENESTDISP */
	"width argument missing", /* EMISSWIDTH */
	"invalid section for this manual section", /* EWRONGMSEC */
	"section out of conventional order", /* ESECOOO */
	"section repeated", /* ESECREP */
	"invalid standard argument", /* EBADSTAND */
	"multi-line arguments discouraged", /* ENOMULTILINE */
	"multi-line arguments suggested", /* EMULTILINE */
	"line arguments discouraged", /* ENOLINE */
	"prologue macro out of conventional order", /* EPROLOOO */
	"prologue macro repeated", /* EPROLREP */
	"invalid manual section", /* EBADMSEC */
	"invalid font mode", /* EFONT */
	"invalid date syntax", /* EBADDATE */
	"invalid number format", /* ENUMFMT */
	"superfluous width argument", /* ENOWIDTH */
	"system: utsname error", /* EUTSNAME */
	"obsolete macro", /* EOBS */
	"end-of-line scope violation", /* EIMPBRK */
	"empty macro ignored", /* EIGNE */
	"unclosed explicit scope", /* EOPEN */
	"unterminated quoted phrase", /* EQUOTPHR */
	"closure macro without prior context", /* ENOCTX */
	"no description found for library", /* ELIB */
	"bad child for parent context", /* EBADCHILD */
	"list arguments preceding type", /* ENOTYPE */
	"deprecated comment style", /* EBADCOMMENT */
};

d194 1
a194 1
mdoc_alloc(void *data, int pflags, const struct mdoc_cb *cb)
d200 1
a200 3
	if (cb)
		memcpy(&p->cb, cb, sizeof(struct mdoc_cb));

d246 2
a247 19
mdoc_verr(struct mdoc *mdoc, int ln, int pos, 
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);

	return((*mdoc->cb.mdoc_err)(mdoc->data, ln, pos, buf));
}


int
mdoc_vwarn(struct mdoc *mdoc, int ln, int pos, const char *fmt, ...)
a251 3
	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

d253 1
a253 1
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
d256 1
a256 16
	return((*mdoc->cb.mdoc_warn)(mdoc->data, ln, pos, buf));
}


int
mdoc_err(struct mdoc *m, int line, int pos, int iserr, enum merr type)
{
	const char	*p;

	p = __mdoc_merrnames[(int)type];
	assert(p);

	if (iserr)
		return(mdoc_verr(m, line, pos, p));

	return(mdoc_vwarn(m, line, pos, p));
d270 1
a270 1
		return(mdoc_perr(m, ln, pp, EPROLBODY));
d276 1
a276 1
		if ( ! mdoc_pwarn(m, ln, pp, EBODYPROL))
d552 1
a552 1
		return(mdoc_pwarn(m, line, offs, EBADCOMMENT));
d557 1
a557 1
		return(mdoc_perr(m, line, offs, ETEXTPROL));
d570 1
a570 1
		if ( ! mdoc_pwarn(m, line, offs, ENOBLANK))
d595 1
a595 1
			if ( ! mdoc_pwarn(m, line, i - 1, ETAILWS))
d629 8
a636 5
	if ( ! (MDOC_IGN_MACRO & m->pflags))
		return(mdoc_verr(m, ln, offs, "unknown macro: %s%s", 
				buf, strlen(buf) > 3 ? "..." : ""));
	return(mdoc_vwarn(m, ln, offs, "unknown macro: %s%s",
				buf, strlen(buf) > 3 ? "..." : ""));
d684 3
a686 1
		return(mdoc_perr(m, ln, i, EPRINT));
d714 1
a714 1
		if ( ! mdoc_pwarn(m, ln, i - 1, ETAILWS))
@


1.134
log
@Fix allowing silly '\'' control character.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.133 2010/05/15 16:24:37 kristaps Exp $ */
d153 4
a156 3
static	int		  mdoc_ptext(struct mdoc *, int, char *);
static	int		  mdoc_pmacro(struct mdoc *, int, char *);
static	int		  macrowarn(struct mdoc *, int, const char *);
d288 1
a288 1
mdoc_parseln(struct mdoc *m, int ln, char *buf)
d295 3
a297 3
	return(('.' == *buf || '\'' == *buf) ? 
			mdoc_pmacro(m, ln, buf) :
			mdoc_ptext(m, ln, buf));
d634 1
a634 1
mdoc_ptext(struct mdoc *m, int line, char *buf)
d640 4
a643 2
	if ('\\' == buf[0] && '.' == buf[1] && '\"' == buf[2])
		return(mdoc_pwarn(m, line, 0, EBADCOMMENT));
d648 1
a648 1
		return(mdoc_perr(m, line, 0, ETEXTPROL));
d653 1
a653 1
		return(mdoc_word_alloc(m, line, 0, buf));
d657 1
a657 1
	for (i = 0; ' ' == buf[i]; i++)
d661 1
a661 1
		if ( ! mdoc_pwarn(m, line, 0, ENOBLANK))
d669 1
a669 1
		if ( ! mdoc_elem_alloc(m, line, 0, MDOC_Pp, NULL))
d700 1
a700 1
	if ( ! mdoc_word_alloc(m, line, 0, buf))
a708 2
	/* FIXME: chain of close delims. */

a709 1

d718 1
a718 1
macrowarn(struct mdoc *m, int ln, const char *buf)
d721 1
a721 1
		return(mdoc_verr(m, ln, 0, "unknown macro: %s%s", 
d723 1
a723 1
	return(mdoc_vwarn(m, ln, 0, "unknown macro: %s%s",
d733 1
a733 1
mdoc_pmacro(struct mdoc *m, int ln, char *buf)
d741 3
a743 1
	if ('\0' == buf[1])
d746 1
a746 1
	i = 1;
d775 1
a775 1
	mac[j] = 0;
d778 1
a778 1
		if ( ! macrowarn(m, ln, mac))
d784 1
a784 1
		if ( ! macrowarn(m, ln, mac))
@


1.133
log
@LIBRARY can also occur in section 9.
All manual sections (unknown, 3p, 3f, etc.) correctly handled by -mdoc.
Useful warning printed if unknown manual section.
Checking for manual sections (e.g., LIBRARY) checks only first character, so 3p, 3f, etc. are free.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.132 2010/05/15 06:48:13 kristaps Exp $ */
d294 1
a294 1
	return('.' == *buf ? 
@


1.132
log
@More EOS: append_delims() fitted with EOS detection, so ANY macro with appended delimiters will properly EOS.
Fixed mandoc_eos() to accept sentence punctuation followed by close-delim buffers.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.131 2010/05/14 17:31:25 kristaps Exp $ */
d71 1
a71 1
	"invalid section", /* EBADSEC */
d193 2
@


1.131
log
@Backed out check for `Ex' manual sec (ok schwarze@@, joerg@@), in turn backing out check_msec() and deps.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.130 2010/05/13 06:22:11 kristaps Exp $ */
d704 2
@


1.130
log
@Fixed bug in -Thtml -mdoc where `Lb' would line-break in LIBRARY section.
Fixed assumption that parse-point == 1 equates to beginning of line (false if whitespace separates macro and control character).
Fixed line-break for non-first-macro in several SYNOPSIS macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.129 2010/05/12 17:08:03 kristaps Exp $ */
a70 1
	"invalid manual section", /* EBADMSEC */
@


1.129
log
@Put the eos-checker into libmandoc.h.
Added bits in mdoc.7 and man.7 about EOS spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.128 2010/05/12 16:01:01 kristaps Exp $ */
d292 3
a294 1
	return('.' == *buf ? mdoc_pmacro(m, ln, buf) :
d458 3
a460 1

d733 1
a733 1
	int		i, j;
d753 2
d802 1
a802 1
	if ( ! mdoc_macro(m, tok, ln, 1, &i, buf)) 
@


1.128
log
@Tiny EOS patch.  Back-end cues front-end through flag.  Front-end cues output engine with flag.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.127 2010/05/08 10:25:27 kristaps Exp $ */
d703 1
a703 8
	switch (buf[i - 1]) {
	case ('.'):
		if (i > 1 && '\\' == buf[i - 2])
			break;
		/* FALLTHROUGH */
	case ('!'):
		/* FALLTHROUGH */
	case ('?'):
a704 5
		break;
	default:
		break;

	}
@


1.127
log
@Fix asserts on stripping end-of-line whitespace.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.126 2010/05/08 08:36:44 kristaps Exp $ */
d692 27
a718 1
	return(mdoc_word_alloc(m, line, 0, buf));
@


1.126
log
@Strip trailing, unescaped whitespace from free-form, non-literal lines (like groff).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.125 2010/05/08 07:30:19 kristaps Exp $ */
d677 1
a677 2
		assert(i > 1);
		if ('\\' != buf[i - 2])
a684 1
		assert(i);
@


1.125
log
@Lint fixes (type-safety for enums via -cefuh).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.124 2010/05/07 15:49:36 kristaps Exp $ */
d668 4
a671 1
	/* Warn if the last un-escaped character is whitespace. */
d676 3
a678 2
	if (' ' == buf[i - 1] || '\t' == buf[i - 1])
		if (1 == i || ('\\' != buf[i - 2]))
d682 10
@


1.124
log
@De-chunking of text removed from parsers.  This is a significant change (and I don't really like it), but it's what groff does.
Distinction of ARGS_PHRASE and ARGS_PPHRASE in backend (not yet used).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.123 2010/04/08 07:53:01 kristaps Exp $ */
d545 1
a545 1
	n = node_alloc(m, line, pos, -1, MDOC_TEXT);
a683 1

d688 1
a688 2
		return(mdoc_verr(m, ln, 0, 
				"unknown macro: %s%s", 
d702 3
a704 2
	int		  i, j, c;
	char		  mac[5];
d746 1
a746 1
	if (MDOC_MAX == (c = mdoc_hash_find(mac))) {
d757 4
a760 1
	/* Trailing whitespace? */
d770 1
a770 1
	if ( ! mdoc_macro(m, c, ln, 1, &i, buf)) 
@


1.123
log
@Sync'd mdoc.c's function names with man.c.
Prompted by Ingo and Claus Assman, added warn/ignore for text lines beginning with `\."'.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.122 2010/04/08 07:06:15 kristaps Exp $ */
d157 1
a157 2
static	int		  pstring(struct mdoc *, int, int, 
				const char *, size_t);
d537 2
a538 2
static int
pstring(struct mdoc *m, int line, int pos, const char *p, size_t len)
d541 3
a543 1
	size_t		  sv;
d554 1
a559 8
int
mdoc_word_alloc(struct mdoc *m, int line, int pos, const char *p)
{

	return(pstring(m, line, pos, p, strlen(p)));
}


d630 1
a630 2
	int		 i, j;
	char		 sv;
d637 2
d641 2
a643 5
	/*
	 * If in literal mode, then pass the buffer directly to the
	 * back-end, as it should be preserved as a single term.
	 */

d647 1
a647 1
	/* Disallow blank/white-space lines in non-literal mode. */
d650 1
a650 1
		/* Skip leading whitespace. */ ;
d655 1
d657 3
a659 4
		 * Assume that a `Pp' should be inserted in the case of
		 * a blank line.  Technically, blank lines aren't
		 * allowed, but enough manuals assume this behaviour
		 * that we want to work around it.
d663 3
d668 1
a668 4
	/*
	 * Break apart a free-form line into tokens.  Spaces are
	 * stripped out of the input.
	 */
d670 2
a671 19
	for (j = i; buf[i]; i++) {
		if (' ' != buf[i])
			continue;

		/* Escaped whitespace. */
		if (i && ' ' == buf[i] && '\\' == buf[i - 1])
			continue;

		sv = buf[i];
		buf[i++] = '\0';

		if ( ! pstring(m, line, j, &buf[j], (size_t)(i - j)))
			return(0);

		/* Trailing whitespace?  Check at overwritten byte. */

		if (' ' == sv && '\0' == buf[i])
			if ( ! mdoc_pwarn(m, line, i - 1, ETAILWS))
				return(0);
d673 2
a674 8
		for ( ; ' ' == buf[i]; i++)
			/* Skip trailing whitespace. */ ;

		j = i;

		/* Trailing whitespace? */

		if (' ' == buf[i - 1] && '\0' == buf[i])
d678 1
a678 6
		if ('\0' == buf[i])
			break;
	}

	if (j != i && ! pstring(m, line, j, &buf[j], (size_t)(i - j)))
		return(0);
d680 1
a680 2
	m->next = MDOC_NEXT_SIBLING;
	return(1);
@


1.122
log
@Properly checked in Ingo Schwarze' prologue/body-breaking patch, which I'd munged.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.121 2010/04/06 11:33:00 kristaps Exp $ */
d87 1
d154 2
a155 2
static	int		  parsetext(struct mdoc *, int, char *);
static	int		  parsemacro(struct mdoc *, int, char *);
d284 1
a284 1
 * the macro (parsemacro()) or text parser (parsetext()).
d293 2
a294 2
	return('.' == *buf ? parsemacro(m, ln, buf) :
			parsetext(m, ln, buf));
d634 1
a634 1
parsetext(struct mdoc *m, int line, char *buf)
d639 5
d739 1
a739 1
parsemacro(struct mdoc *m, int ln, char *buf)
@


1.121
log
@Migrating mdoc_node_free() and mdoc_node_freelist() to use mdoc_node_delete(), which has a more intuitive interface and mirrors libman.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.120 2010/04/05 08:59:46 kristaps Exp $ */
d351 3
a354 5
	assert(tok < MDOC_MAX);
	/*
	 * If we're in the prologue, deny "body" macros.  Similarly, if
	 * we're in the body, deny prologue calls.
	 */
d356 7
a362 1
			MDOC_PBODY & m->flags) {
a364 3
		/*
		 * FIXME: do this in mdoc_action.c.
		 */
a374 3
	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) && 
			! (MDOC_PBODY & m->flags))
		return(mdoc_perr(m, ln, pp, EBODYPROL));
@


1.120
log
@Commited relaxation of title-less document error-out noted by Christian Weisgerber and patched by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.119 2010/04/03 13:02:35 kristaps Exp $ */
d144 3
d183 1
a183 1
		mdoc_node_freelist(mdoc->first);
a570 2
	if (p->parent)
		p->parent->nchild--;
d579 36
d616 1
a616 1
mdoc_node_freelist(struct mdoc_node *p)
d619 5
a623 4
	if (p->child)
		mdoc_node_freelist(p->child);
	if (p->next)
		mdoc_node_freelist(p->next);
d625 1
a625 1
	assert(0 == p->nchild);
@


1.119
log
@Merging patch by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.118 2010/03/31 07:42:04 kristaps Exp $ */
d29 1
d355 16
a370 2
			MDOC_PBODY & m->flags)
		return(mdoc_perr(m, ln, pp, EPROLBODY));
@


1.118
log
@Re-adjusting UGLY tags.
Fixed removed assignment of type.
Removed superfluous checks of mdoc_argflags (from days when comments were a macro tag).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.117 2010/03/31 07:13:53 kristaps Exp $ */
d603 12
a614 2
	if ('\0' == buf[i])
		return(mdoc_perr(m, line, 0, ENOBLANK));
@


1.117
log
@Macro types enum-ated (enum mdoct) (for easier debugging in gdb of "tok" values).
Initial check-in of Ingo Schwarze's patch for Xo/Xc handling (in blocks ifdef'd "UGLY").
Put Oc-close-Op parts into UGLY ifdef blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.116 2010/01/07 10:24:43 kristaps Exp $ */
d439 1
@


1.116
log
@Check for white-space at the end of free-form text.  Lack of check spotted by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.115 2010/01/07 10:05:24 kristaps Exp $ */
d146 1
a146 1
				int, enum mdoc_type);
d344 1
a344 1
mdoc_macro(struct mdoc *m, int tok, 
d347 2
d429 2
a430 2
node_alloc(struct mdoc *m, int line, 
		int pos, int tok, enum mdoc_type type)
a438 2
	if (MDOC_TEXT != (p->type = type))
		assert(p->tok >= 0);
d445 1
a445 1
mdoc_tail_alloc(struct mdoc *m, int line, int pos, int tok)
d458 1
a458 1
mdoc_head_alloc(struct mdoc *m, int line, int pos, int tok)
d474 1
a474 1
mdoc_body_alloc(struct mdoc *m, int line, int pos, int tok)
d488 1
a488 1
		int tok, struct mdoc_arg *args)
d505 1
a505 1
		int tok, struct mdoc_arg *args)
@


1.115
log
@Check for white-space at end of stand-alone macro line.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.114 2010/01/01 17:14:29 kristaps Exp $ */
d584 1
d618 1
d624 6
d634 7
@


1.114
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.113 2009/10/30 05:58:38 kristaps Exp $ */
d600 2
a601 1
	if (0 == buf[i])
d617 2
a618 1
		buf[i++] = 0;
d626 1
a626 1
		if (0 == buf[i])
d663 1
a663 1
	if (0 == buf[1])
d674 1
a674 1
		if (0 == buf[i])
d681 1
a681 1
		if (0 == (mac[j] = buf[i]))
d712 6
@


1.113
log
@libmdoc and libman now using non-recoverable allocations (simpler code).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.112 2009/10/27 08:26:12 kristaps Exp $ */
d17 4
d100 1
a100 1
	"Xr",		"\%A",		"\%B",		"\%D",
d102 1
a102 1
	"\%I",		"\%J",		"\%N",		"\%O",
d104 1
a104 1
	"\%P",		"\%R",		"\%T",		"\%V",
d121 1
a121 1
	"Brc",		"\%C",		"Es",		"En",
d123 1
a123 1
	"Dx",		"\%Q",		"br",		"sp",
d125 1
a125 1
	"\%U"
a154 5
#ifdef __linux__
extern	size_t	  	  strlcpy(char *, const char *, size_t);
#endif


@


1.112
log
@bzero() -> memset() (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.111 2009/10/26 07:11:07 kristaps Exp $ */
d27 1
a32 1
	"system: malloc error", /* EMALLOC */
d140 1
a140 1
static	int		  mdoc_alloc1(struct mdoc *);
d197 1
a197 1
static int
d204 1
a204 4
	mdoc->last = calloc(1, sizeof(struct mdoc_node));
	if (NULL == mdoc->last)
		return(0);

a207 1
	return(1);
d217 1
a217 1
int
d222 1
a222 1
	return(mdoc_alloc1(mdoc));
d247 2
a248 2
	if (NULL == (p = calloc(1, sizeof(struct mdoc))))
		return(NULL);
d250 1
a250 3
		(void)memcpy(&p->cb, cb, sizeof(struct mdoc_cb));

	mdoc_hash_init();
d255 3
a257 5
	if (mdoc_alloc1(p))
		return(p);

	free(p);
	return(NULL);
d433 1
a433 5
	if (NULL == (p = calloc(1, sizeof(struct mdoc_node)))) {
		(void)mdoc_nerr(m, m->last, EMALLOC);
		return(NULL);
	}

a450 2
	if (NULL == p)
		return(0);
a466 2
	if (NULL == p)
		return(0);
a479 2
	if (NULL == p)
		return(0);
a493 2
	if (NULL == p)
		return(0);
a510 2
	if (NULL == p)
		return(0);
d528 1
a528 9
	if (NULL == n)
		return(mdoc_nerr(m, m->last, EMALLOC));

	n->string = malloc(len + 1);
	if (NULL == n->string) {
		free(n);
		return(mdoc_nerr(m, m->last, EMALLOC));
	}

@


1.111
log
@-man also prints unknown macro (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.110 2009/10/24 05:52:13 kristaps Exp $ */
d201 1
a201 1
	bzero(&mdoc->meta, sizeof(struct mdoc_meta));
@


1.110
log
@Added `%U' to -mdoc (doesn't render in a nice way yet).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.109 2009/10/15 02:56:51 kristaps Exp $ */
a667 1

@


1.109
log
@Added warning about specifying list arguments before type (suggested by Joerg Sonnenberg).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.108 2009/10/15 01:33:12 kristaps Exp $ */
d119 3
a121 1
	"Dx",		"\%Q",		"br",		"sp"
@


1.108
log
@Added support for `Bd -centered', which appears in newer groffs (not yet implemented in centre-capable front-ends, i.e., -Thtml).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.107 2009/09/24 15:01:06 kristaps Exp $ */
d81 1
@


1.107
log
@Added EBADCHILD error (bad child of parent context).
`Rs' post-checks that all children are proper bibliographic elements.
`Rs' correctly re-orders its children as per groff's output (including %C).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.106 2009/09/23 11:53:45 kristaps Exp $ */
d130 1
a130 1
	"symbolic",		"nested"
@


1.106
log
@FreeBSD compile fixes (uqs@@spoerlein.net).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.105 2009/09/16 14:40:56 kristaps Exp $ */
d79 2
a80 1
	"no description found for library" /* ELIB */
@


1.105
log
@Lookup hashes are now static tables, ordered first-level by second character, then randomly along a chain.  Improves performance by a small fraction and considerably cleans up hash sources.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.104 2009/08/22 08:56:16 kristaps Exp $ */
d17 2
@


1.104
log
@Added check for graphable characters in initial-line parse for libman and libmdoc (joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.103 2009/08/20 11:44:47 kristaps Exp $ */
a232 2
	if (mdoc->htab)
		mdoc_hash_free(mdoc->htab);
d250 2
d255 1
a255 4
	if (NULL == (p->htab = mdoc_hash_alloc())) {
		free(p);
		return(NULL);
	} else if (mdoc_alloc1(p))
d725 1
a725 1
	if (MDOC_MAX == (c = mdoc_hash_find(m->htab, mac))) {
@


1.103
log
@Fix to libmdoc passing over delimiters.
`RS' and `RE' documented in man.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.102 2009/08/19 14:09:33 kristaps Exp $ */
d712 6
@


1.102
log
@In-line documentation of mdoc_macro file.
Moved _NEXT_ macros into _alloc_ routines (where they belong).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.101 2009/08/19 11:58:32 kristaps Exp $ */
d685 1
a685 1
	int		  i, j, c, ppos;
a704 2
	ppos = i;

d737 1
a737 1
	if ( ! mdoc_macro(m, c, ln, ppos, &i, buf)) 
@


1.101
log
@Moved MDOC_NEXT_SIBLING into mdoc_word (libmdoc).
De-chunking of word terms in libman.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.100 2009/08/18 14:27:16 kristaps Exp $ */
d462 4
a465 1
	return(node_append(m, p));
d480 4
a483 1
	return(node_append(m, p));
d495 4
a498 1
	return(node_append(m, p));
d514 4
a517 1
	return(node_append(m, p));
d533 4
a536 1
	return(node_append(m, p));
@


1.100
log
@libmdoc accepts whitespace following control character.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.99 2009/08/13 11:43:24 kristaps Exp $ */
d546 4
a549 1
	return(node_append(m, n));
d606 2
a607 6
	if (MDOC_LITERAL & m->flags) {
		if ( ! mdoc_word_alloc(m, line, 0, buf))
			return(0);
		m->next = MDOC_NEXT_SIBLING;
		return(1);
	}
a631 1
		m->next = MDOC_NEXT_SIBLING;
@


1.99
log
@Noted areas that need work in libmdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.98 2009/07/29 08:52:24 kristaps Exp $ */
a76 1
	"invalid whitespace after control character", /* ESPACE */
d672 1
a672 1
	int		  i, c;
a676 2
	/* FIXME: this can accept `.    xx' like libman! */

d680 6
a685 2
	if (' ' == buf[1]) {
		i = 2;
a689 1
		return(mdoc_perr(m, ln, 1, ESPACE));
d692 2
d696 2
a697 2
	for (i = 1; i < 5; i++) {
		if (0 == (mac[i - 1] = buf[i]))
d703 1
a703 1
	mac[i - 1] = 0;
d705 1
a705 1
	if (i == 5 || i <= 2) {
d726 1
a726 1
	if ( ! mdoc_macro(m, c, ln, 1, &i, buf)) 
d736 2
@


1.98
log
@Columns with `Bl -column' correctly check for CALLABLE status.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.97 2009/07/29 08:46:06 kristaps Exp $ */
d678 2
@


1.97
log
@Moved CALLABLE check to lookup_raw().
Made PARSABLE check occur prior to lookup().
Non-PARSEABLE macros no longer warn against having macro-like parameters.
Non-CALLABLE macros no longer produce an error, just display their symbols (as in groff) (pointed out by joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.96 2009/07/27 19:43:02 kristaps Exp $ */
d718 4
a721 2
	/* Begin recursive parse sequence. */

@


1.96
log
@main.c using fprintf instead of warnx for parse errors (like cc).
Error string is now file:line:col: message.
Removed sed from vim -q example in manuals.7.
Fixed column reporting (off by one).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.95 2009/07/20 14:09:38 kristaps Exp $ */
a31 1
	"macro not callable", /* ENOCALL */
a71 1
	"macro-like parameter", /* EMACPARM */
d354 4
a357 1

a364 3
	if (1 != pp && ! (MDOC_CALLABLE & mdoc_macros[tok].flags))
		return(mdoc_perr(m, ln, pp, ENOCALL));

@


1.95
log
@Replaced ugly TABSEP handling with simpler routine.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.94 2009/07/17 12:27:49 kristaps Exp $ */
d660 1
a660 1
		return(mdoc_verr(m, ln, 1, 
d663 1
a663 1
	return(mdoc_vwarn(m, ln, 1, "unknown macro: %s%s",
@


1.94
log
@Removed EARGVPARM (superfluous, overly error-generating).
Added `sp' handler.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.93 2009/07/17 10:56:57 kristaps Exp $ */
a27 1
	"empty last list column", /* ECOLEMPTY */
@


1.93
log
@Added `br' and `sp' macros (requested by joerg@@netbsd.org, jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.92 2009/07/16 13:42:12 kristaps Exp $ */
a28 1
	"argument-like parameter", /* EARGVPARM */
@


1.92
log
@Added Linux compat (strlcpy).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.91 2009/07/15 15:36:38 kristaps Exp $ */
d120 1
a120 1
	"Dx",		"\%Q"
@


1.91
log
@libmdoc now breaks up free-form lines into tokens prior to be passed to the backend (simplifies LITERAL mode in front-end).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.90 2009/07/12 20:50:08 kristaps Exp $ */
d150 4
@


1.90
log
@Replacement of `Lb' in mdoc_action.c.
Added warning against bogus `Lb' (like groff does).
Added proper quotes around `Lb' in mdoc_term.c.
Moved mdoc_a2lib -> libmdoc (where it belongs).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.89 2009/07/07 09:29:15 kristaps Exp $ */
d147 2
d434 1
a434 1
node_alloc(struct mdoc *mdoc, int line, 
d440 1
a440 1
		(void)mdoc_nerr(mdoc, mdoc->last, EMALLOC);
d444 1
a444 1
	p->sec = mdoc->lastsec;
d456 1
a456 1
mdoc_tail_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d460 1
a460 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_TAIL);
d463 1
a463 1
	return(node_append(mdoc, p));
d468 1
a468 1
mdoc_head_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d472 2
a473 2
	assert(mdoc->first);
	assert(mdoc->last);
d475 1
a475 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_HEAD);
d478 1
a478 1
	return(node_append(mdoc, p));
d483 1
a483 1
mdoc_body_alloc(struct mdoc *mdoc, int line, int pos, int tok)
d487 1
a487 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BODY);
d490 1
a490 1
	return(node_append(mdoc, p));
d495 1
a495 1
mdoc_block_alloc(struct mdoc *mdoc, int line, int pos, 
d500 1
a500 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_BLOCK);
d506 1
a506 1
	return(node_append(mdoc, p));
d511 1
a511 1
mdoc_elem_alloc(struct mdoc *mdoc, int line, int pos, 
d516 1
a516 1
	p = node_alloc(mdoc, line, pos, tok, MDOC_ELEM);
d522 1
a522 1
	return(node_append(mdoc, p));
d526 2
a527 3
int
mdoc_word_alloc(struct mdoc *mdoc, 
		int line, int pos, const char *word)
d529 2
a530 1
	struct mdoc_node *p;
d532 8
a539 6
	p = node_alloc(mdoc, line, pos, -1, MDOC_TEXT);
	if (NULL == p)
		return(0);
	if (NULL == (p->string = strdup(word))) {
		(void)mdoc_nerr(mdoc, mdoc->last, EMALLOC);
		return(0);
d542 14
a555 1
	return(node_append(mdoc, p));
d594 1
d598 14
d613 3
a615 1
	if (0 == buf[0] && ! (MDOC_LITERAL & m->flags))
d618 27
a644 1
	if ( ! mdoc_word_alloc(m, line, 0, buf))
d652 2
@


1.89
log
@Tabularised error-code lookup in mdoc.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.88 2009/07/06 13:04:52 kristaps Exp $ */
d82 1
@


1.88
log
@Consolidated all err/warnings into mdoc.c via libmdoc.h.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.87 2009/07/06 09:21:24 kristaps Exp $ */
d26 58
d335 1
a335 174
	char		 *p;
	
	p = NULL;

	switch (type) {
	case (ENOCALL):
		p = "not callable";
		break;
	case (EPROLBODY):
		p = "macro disallowed in document body";
		break;
	case (EBODYPROL):
		p = "macro disallowed in document prologue";
		break;
	case (EMALLOC):
		p = "memory exhausted";
		break;
	case (ETEXTPROL):
		p = "text disallowed in document prologue";
		break;
	case (ENOBLANK):
		p = "blank lines disallowed in non-literal contexts";
		break;
	case (ESPACE):
		p = "whitespace disallowed after delimiter";
		break;
	case (ETOOLONG):
		p = "text argument too long";
		break;
	case (EESCAPE):
		p = "invalid escape sequence";
		break;
	case (EPRINT):
		p = "invalid character";
		break;
	case (ENESTDISP):
		p = "displays may not be nested";
		break;
	case (EBOOL):
		p = "expected boolean value";
		break;
	case (EARGREP):
		p = "argument repeated";
		break;
	case (EMULTIDISP):
		p = "multiple display types specified";
		break;
	case (EMULTILIST):
		p = "multiple list types specified";
		break;
	case (ELISTTYPE):
		p = "missing list type";
		break;
	case (EDISPTYPE):
		p = "missing display type";
		break;
	case (ESECNAME):
		p = "the NAME section must come first";
		break;
	case (ELINE):
		p = "expected line arguments";
		break;
	case (ENOPROLOGUE):
		p = "document has no prologue";
		break;
	case (ENODAT):
		p = "document has no data";
		break;
	case (ECOLMIS):
		p = "column syntax style mismatch";
		break;
	case (EATT):
		p = "expected valid AT&T symbol";
		break;
	case (ENAME):
		p = "default name not yet set";
		break;
	case (ENOWIDTH):
		p = "superfluous width argument";
		break;
	case (EMISSWIDTH):
		p = "missing width argument";
		break;
	case (EWRONGMSEC):
		p = "document section in wrong manual section";
		break;
	case (ESECOOO):
		p = "document section out of conventional order";
		break;
	case (ESECREP):
		p = "document section repeated";
		break;
	case (EBADSTAND):
		p = "unknown standard";
		break;
	case (ENAMESECINC):
		p = "NAME section contents incomplete/badly-ordered";
		break;
	case (ENOMULTILINE):
		p = "suggested no multi-line arguments";
		break;
	case (EMULTILINE):
		p = "suggested multi-line arguments";
		break;
	case (ENOLINE):
		p = "suggested no line arguments";
		break;
	case (EPROLOOO):
		p = "prologue macros out-of-order";
		break;
	case (EPROLREP):
		p = "prologue macros repeated";
		break;
	case (EARGVAL):
		p = "argument value suggested";
		break;
	case (EFONT):
		p = "invalid font mode";
		break;
	case (EBADMSEC):
		p = "inappropriate manual section";
		break;
	case (EBADSEC):
		p = "inappropriate document section";
		break;
	case (EQUOTTERM):
		p = "unterminated quoted parameter";
		break;
	case (EQUOTPARM):
		p = "unexpected quoted parameter";
		break;
	case (EARGVPARM):
		p = "argument-like parameter";
		break;
	case (ECOLEMPTY):
		p = "last list column is empty";
		break;
	case (ETAILWS):
		p = "trailing whitespace";
		break;
	case (ENUMFMT):
		p = "bad number format";
		break;
	case (EUTSNAME):
		p = "utsname";
		break;
	case (EBADDATE):
		p = "malformed date syntax";
		break;
	case (EOPEN):
		p = "explicit scope still open on exit";
		break;
	case (EQUOT):
		p = "unterminated quotation";
		break;
	case (ENOCTX):
		p = "closure has no prior context";
		break;
	case (ENOPARMS):
		p = "unexpect line arguments";
		break;
	case (EIGNE):
		p = "ignoring empty element";
		break;
	case (EIMPBRK):
		p = "crufty end-of-line scope violation";
		break;
	case (EMACPARM):
		p = "macro-like parameter";
		break;
	case (EOBS):
		p = "macro marked obsolete";
		break;
	}
d337 1
@


1.87
log
@Initial removal of enum mdoc_warn from mdoc warnings (unnecessary complication).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.86 2009/06/18 20:46:19 kristaps Exp $ */
a25 10
enum	merr {
	ENOCALL,
	EBODYPROL,
	EPROLBODY,
	ESPACE,
	ETEXTPROL,
	ENOBLANK,
	EMALLOC
};

d88 1
a88 1
static	int		  perr(struct mdoc *, int, int, enum merr);
d252 1
d269 1
d275 1
a275 2
mdoc_nerr(struct mdoc *mdoc, const struct mdoc_node *node, 
		const char *fmt, ...)
d277 3
a279 102
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, 
				node->line, node->pos, buf));
}


int
mdoc_warn(struct mdoc *mdoc, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, mdoc->last->line, 
				mdoc->last->pos, buf));
}


int
mdoc_err(struct mdoc *mdoc, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, mdoc->last->line,
				mdoc->last->pos, buf));
}


int
mdoc_pwarn(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, line, pos, buf));
}

int
mdoc_perr(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_err)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_err)(mdoc->data, line, pos, buf));
}


int
mdoc_macro(struct mdoc *m, int tok, 
		int ln, int pp, int *pos, char *buf)
{

	if (MDOC_PROLOGUE & mdoc_macros[tok].flags && 
			MDOC_PBODY & m->flags)
		return(perr(m, ln, pp, EPROLBODY));
	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) && 
			! (MDOC_PBODY & m->flags))
		return(perr(m, ln, pp, EBODYPROL));

	if (1 != pp && ! (MDOC_CALLABLE & mdoc_macros[tok].flags))
		return(perr(m, ln, pp, ENOCALL));

	return((*mdoc_macros[tok].fp)(m, tok, ln, pp, pos, buf));
}


static int
perr(struct mdoc *m, int line, int pos, enum merr type)
{
	char		*p;
a280 1
	p = NULL;
d303 147
d451 1
d453 24
a476 1
	return(mdoc_perr(m, line, pos, p));
d551 1
a551 2
		(void)perr(mdoc, (mdoc)->last->line, 
				(mdoc)->last->pos, EMALLOC);
d647 1
a647 2
		(void)perr(mdoc, (mdoc)->last->line, 
				(mdoc)->last->pos, EMALLOC);
d650 1
d692 1
a692 1
		return(perr(m, line, 0, ETEXTPROL));
d695 1
a695 1
		return(perr(m, line, 0, ENOBLANK));
d709 1
a709 1
		return(mdoc_perr(m, ln, 1, 
d712 1
a712 1
	return(mdoc_pwarn(m, ln, 1, "unknown macro: %s%s",
d738 1
a738 1
		return(perr(m, ln, 1, ESPACE));
@


1.86
log
@Added nchild decrement in libman (not used, but better in than forgotten).
Added nchild to libmdoc, deprecated count() functions in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.85 2009/06/17 10:53:32 kristaps Exp $ */
d267 1
a267 2
mdoc_vwarn(struct mdoc *mdoc, int ln, int pos, 
		enum mdoc_warn type, const char *fmt, ...)
d278 1
a278 1
	return((*mdoc->cb.mdoc_warn)(mdoc->data, ln, pos, type, buf));
d301 1
a301 2
mdoc_warn(struct mdoc *mdoc, enum mdoc_warn type, 
		const char *fmt, ...)
d312 2
a313 2
	return((*mdoc->cb.mdoc_warn)(mdoc->data, mdoc->last->line,
				mdoc->last->pos, type, buf));
d335 1
a335 2
mdoc_pwarn(struct mdoc *mdoc, int line, int pos, enum mdoc_warn type,
		const char *fmt, ...)
d346 1
a346 2
	return((*mdoc->cb.mdoc_warn)(mdoc->data, 
				line, pos, type, buf));
d651 1
a651 2
	return(mdoc_pwarn(m, ln, 1, WARN_SYNTAX,
				"unknown macro: %s%s",
@


1.85
log
@Section orders are more elegantly handled (MDOC_PBODY is a flag).
Cleaned up string->enum conversion for section lookup.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.84 2009/06/17 07:59:47 kristaps Exp $ */
d445 2
d602 2
d621 1
@


1.84
log
@Fixed lint invocation in Makefile.
Minor cleanups in mdoc.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.83 2009/06/16 20:22:23 kristaps Exp $ */
d116 3
d138 3
d147 1
a147 1
	mdoc->lastnamed = mdoc->lastsec = 0;
d160 4
a163 3
 * Free up all resources contributed by a parse:  the node tree,
 * meta-data and so on.  Then reallocate the root node for another
 * parse.
d175 2
a176 1
 * Completely free up all resources.
d189 3
d218 1
a218 1
 * through to macro_end in macro.c.
d235 1
a235 1
 * the macro or text parser.
a373 2
	/* FIXME - these should happen during validation. */

d375 1
a375 1
			SEC_PROLOGUE != m->lastnamed)
a376 1

d378 1
a378 1
			SEC_PROLOGUE == m->lastnamed)
d629 1
a629 1
	if (SEC_PROLOGUE == m->lastnamed)
@


1.83
log
@Clean-up: in-source documentation.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.82 2009/06/16 19:45:51 kristaps Exp $ */
a99 2
#define verr(m, t) perr((m), (m)->last->line, (m)->last->pos, (t))

a229 2
	/* If in error-mode, then we parse no more. */

d273 2
a274 1
mdoc_nerr(struct mdoc *mdoc, const struct mdoc_node *node, const char *fmt, ...)
d285 2
a286 1
	return((*mdoc->cb.mdoc_err)(mdoc->data, node->line, node->pos, buf));
d291 2
a292 1
mdoc_warn(struct mdoc *mdoc, enum mdoc_warn type, const char *fmt, ...)
d304 1
a304 1
	    mdoc->last->pos, type, buf));
d321 1
a321 1
	    mdoc->last->pos, buf));
d338 2
a339 1
	return((*mdoc->cb.mdoc_warn)(mdoc->data, line, pos, type, buf));
d483 2
a484 1
		(void)verr(mdoc, EMALLOC);
d580 2
a581 1
		(void)verr(mdoc, EMALLOC);
@


1.82
log
@Removed MDOC___: moved MDOC_Ap to its index (comments not passed into mdoc parser).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.81 2009/06/16 19:13:28 kristaps Exp $ */
a101 3
/*
 * Get the first (root) node of the parse tree.
 */
a645 1

@


1.81
log
@Modernised comment handling: text following \" is thrown away before
either parser is invoked.  Single-dot lines correctly handled.  This
confirms with both new- and old-groff.  "Comment" subsection added to
mdoc.7 and man.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.80 2009/06/15 10:36:01 kristaps Exp $ */
d37 1
a37 1
	"\\\"",		"Dd",		"Dt",		"Os",
d66 2
a67 2
	"Fr",		"Ud",		"Lb",		"Ap",
	"Lp",		"Lk",		"Mt",		"Brq",
d69 1
a69 1
	"Bro",		"Brc",		"\%C",		"Es",
d71 1
a71 1
	"En",		"Dx",		"\%Q"
@


1.80
log
@Deprecated mdoc_msg (not being used anywhere).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.79 2009/06/15 10:02:53 kristaps Exp $ */
d660 1
a660 1
	/* Comments and empties are quickly ignored. */
a673 4
	if (buf[1] && '\\' == buf[1])
		if (buf[2] && '\"' == buf[2])
			return(1);

@


1.79
log
@Removed mdoc_nwarn (not being used anywhere).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.78 2009/06/15 09:55:43 kristaps Exp $ */
a244 16
void
mdoc_vmsg(struct mdoc *mdoc, int ln, int pos, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, ln, pos, buf);
}


a328 33
void
mdoc_msg(struct mdoc *mdoc, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, mdoc->last->line, mdoc->last->pos,
	    buf);
}


void
mdoc_pmsg(struct mdoc *mdoc, int line, int pos, const char *fmt, ...)
{
	char		  buf[256];
	va_list		  ap;

	if (NULL == mdoc->cb.mdoc_msg)
		return;

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	(*mdoc->cb.mdoc_msg)(mdoc->data, line, pos, buf);
}


@


1.78
log
@mdoc error/warn macros replaced with real functions for GCC2 support (miod@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.77 2009/06/12 12:52:51 kristaps Exp $ */
a295 17
mdoc_nwarn(struct mdoc *mdoc, const struct mdoc_node *node, enum mdoc_warn type,
		const char *fmt, ...)
{
	char		 buf[256];
	va_list		 ap;

	if (NULL == mdoc->cb.mdoc_warn)
		return(0);

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf) - 1, fmt, ap);
	va_end(ap);
	return((*mdoc->cb.mdoc_warn)(mdoc->data, node->line, node->pos, type,
	    buf));
}

int
@


1.77
log
@Lint fixes (no effect).
Versioning up.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.76 2009/06/10 20:18:43 kristaps Exp $ */
d296 132
@


1.76
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.75 2009/04/12 19:45:26 kristaps Exp $ */
d483 2
a484 1
	if ((p->args = args))
d499 2
a500 1
	if ((p->args = args))
@


1.75
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.74 2009/04/02 06:51:44 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.74
log
@mdoc_tokhash -> hash
Initial man hashtab (BROKEN).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.73 2009/03/31 13:50:19 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.73
log
@General clean-ups.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.72 2009/03/23 15:41:09 kristaps Exp $ */
d183 1
a183 1
		mdoc_tokhash_free(mdoc->htab);
d195 2
a198 1
	p->htab = mdoc_tokhash_alloc();
d201 5
a205 2
	if (cb)
		(void)memcpy(&p->cb, cb, sizeof(struct mdoc_cb));
a206 2
	if (mdoc_alloc1(p))
		return(p);
d629 1
a629 1
	if (MDOC_MAX == (c = mdoc_tokhash_find(m->htab, mac))) {
@


1.72
log
@-man linked to mandoc in documentation.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.71 2009/03/23 15:20:51 kristaps Exp $ */
a20 1
#include <err.h>
d22 1
a23 1
#include <stdio.h>
d28 9
a36 5
/*
 * Main caller in the libmdoc library.  This begins the parsing routine,
 * handles allocation of data, and so forth.  Most of the "work" is done
 * in macro.c, validate.c and action.c.
 */
d91 5
a95 4
/* FIXME: have this accept line/pos/tok. */
/* FIXME: mdoc_alloc1 and mdoc_free1 like in man.c. */
static	struct mdoc_node *mdoc_node_alloc(const struct mdoc *);
static	int		  mdoc_node_append(struct mdoc *, 
a96 1

d100 1
d102 1
d123 2
a124 7
/*
 * Free up all resources contributed by a parse:  the node tree,
 * meta-data and so on.  Then reallocate the root node for another
 * parse.
 */
void
mdoc_reset(struct mdoc *mdoc)
d139 6
d151 2
a152 1
		err(1, "calloc");
d156 15
d181 1
a181 13
	if (mdoc->first)
		mdoc_node_freelist(mdoc->first);
	if (mdoc->meta.title)
		free(mdoc->meta.title);
	if (mdoc->meta.os)
		free(mdoc->meta.os);
	if (mdoc->meta.name)
		free(mdoc->meta.name);
	if (mdoc->meta.arch)
		free(mdoc->meta.arch);
	if (mdoc->meta.vol)
		free(mdoc->meta.vol);

a183 1

d194 1
a194 1
		err(1, "calloc");
d197 3
d203 4
a206 8
	if (NULL == (p->first = calloc(1, sizeof(struct mdoc_node))))
		err(1, "calloc");
	p->last = p->first;
	p->last->type = MDOC_ROOT;
	p->pflags = pflags;
	p->next = MDOC_NEXT_CHILD;
	p->htab = mdoc_tokhash_alloc();
	return(p);
d304 1
a304 2
		return(mdoc_perr(m, ln, pp, 
				"disallowed in document body"));
d308 1
a308 2
		return(mdoc_perr(m, ln, pp, 
				"disallowed in prologue"));
d311 1
a311 2
		return(mdoc_perr(m, ln, pp, "%s not callable",
					mdoc_macronames[tok]));
d318 35
a352 1
mdoc_node_append(struct mdoc *mdoc, struct mdoc_node *p)
d414 2
a415 1
mdoc_node_alloc(const struct mdoc *mdoc)
d419 5
a423 2
	if (NULL == (p = calloc(1, sizeof(struct mdoc_node))))
		err(1, "calloc");
d425 5
d440 4
a443 11
	assert(mdoc->first);
	assert(mdoc->last);

	p = mdoc_node_alloc(mdoc);

	p->line = line;
	p->pos = pos;
	p->type = MDOC_TAIL;
	p->tok = tok;

	return(mdoc_node_append(mdoc, p));
d455 4
a458 8
	p = mdoc_node_alloc(mdoc);

	p->line = line;
	p->pos = pos;
	p->type = MDOC_HEAD;
	p->tok = tok;

	return(mdoc_node_append(mdoc, p));
d467 4
a470 11
	assert(mdoc->first);
	assert(mdoc->last);

	p = mdoc_node_alloc(mdoc);

	p->line = line;
	p->pos = pos;
	p->type = MDOC_BODY;
	p->tok = tok;

	return(mdoc_node_append(mdoc, p));
d480 4
a483 9
	p = mdoc_node_alloc(mdoc);

	p->pos = pos;
	p->line = line;
	p->type = MDOC_BLOCK;
	p->tok = tok;
	p->args = args;

	if (args)
d485 1
a485 2

	return(mdoc_node_append(mdoc, p));
d495 4
a498 9
	p = mdoc_node_alloc(mdoc);

	p->line = line;
	p->pos = pos;
	p->type = MDOC_ELEM;
	p->tok = tok;
	p->args = args;

	if (args)
d500 1
a500 2

	return(mdoc_node_append(mdoc, p));
d510 8
a517 9
	p = mdoc_node_alloc(mdoc);

	p->line = line;
	p->pos = pos;
	p->type = MDOC_TEXT;
	if (NULL == (p->string = strdup(word)))
		err(1, "strdup");

	return(mdoc_node_append(mdoc, p));
d555 1
a555 2
		return(mdoc_perr(m, line, 0,
			"text disallowed in prologue"));
d558 1
a558 2
		return(mdoc_perr(m, line, 0,
			"blank lines only in literal context"));
d572 2
a573 1
		return(mdoc_perr(m, ln, 1, "unknown macro: %s%s", 
d603 1
a603 1
		return(mdoc_perr(m, ln, 1, "invalid syntax"));
@


1.71
log
@-man printing linked to -Ttree.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.70 2009/03/23 14:22:11 kristaps Exp $ */
d207 1
a207 1
mdoc_endparse(struct mdoc *mdoc)
d210 1
a210 1
	if (MDOC_HALT & mdoc->flags)
d212 1
a212 1
	if (NULL == mdoc->first)
d214 2
a215 7

	assert(mdoc->last);
	if ( ! macro_end(mdoc)) {
		mdoc->flags |= MDOC_HALT;
		return(0);
	}
	return(1);
@


1.70
log
@First addition of -man macro support.
Abstraction of mdoc.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.69 2009/03/21 09:42:07 kristaps Exp $ */
a34 10
/* FIXME: have this accept line/pos/tok. */
static	struct mdoc_node *mdoc_node_alloc(const struct mdoc *);
static	int		  mdoc_node_append(struct mdoc *, 
				struct mdoc_node *);

static	int		  parsetext(struct mdoc *, int, char *);
static	int		  parsemacro(struct mdoc *, int, char *);
static	int		  macrowarn(struct mdoc *, int, const char *);


d88 10
d103 1
a103 1
mdoc_node(const struct mdoc *mdoc)
d106 1
a106 5
	if (MDOC_HALT & mdoc->flags)
		return(NULL);
	if (mdoc->first)
		assert(MDOC_ROOT == mdoc->first->type);
	return(mdoc->first);
d111 1
a111 1
mdoc_meta(const struct mdoc *mdoc)
d114 1
a114 3
	if (MDOC_HALT & mdoc->flags)
		return(NULL);
	return(&mdoc->meta);
d363 12
@


1.69
log
@Added %Q macro.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.68 2009/03/20 15:14:01 kristaps Exp $ */
d27 1
a27 1
#include "private.h"
d35 1
d125 3
a127 2
 * Free up all resources contributed by a parse:  the node tree, meta-data and
 * so on.  Then reallocate the root node for another parse.
d149 4
a152 3

	mdoc->first = mdoc->last = 
		xcalloc(1, sizeof(struct mdoc_node));
d190 2
a191 1
	p = xcalloc(1, sizeof(struct mdoc));
d197 3
a199 2
	p->last = p->first = 
		xcalloc(1, sizeof(struct mdoc_node));
d378 2
a379 1
	p = xcalloc(1, sizeof(struct mdoc_node));
a443 13
mdoc_root_alloc(struct mdoc *mdoc)
{
	struct mdoc_node *p;

	p = mdoc_node_alloc(mdoc);

	p->type = MDOC_ROOT;

	return(mdoc_node_append(mdoc, p));
}


int
d496 2
a497 1
	p->string = xstrdup(word);
a625 6
	/*
	 * If we're in literal mode, then add a newline to the end of
	 * macro lines.  Our frontends will interpret this correctly
	 * (it's documented in mdoc.3).
	 */

@


1.68
log
@Support for `Bd' of all types (see mdoc.7 for newline/tab rules).
Renamed term.c and terminal.c functions to be term_.
Some bugfixes to lists.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.67 2009/03/19 11:49:00 kristaps Exp $ */
d78 2
a79 1
	"En",		"Dx"
@


1.67
log
@Many more ASCII escapes added.
Stripped nroff punt from mdocterm.c.
Fixed multiple-file handling for mdocterm.c.
Cleared up mdoc.h API.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.66 2009/03/16 23:37:28 kristaps Exp $ */
d32 1
a32 1
 * in macro.c and validate.c.
d97 3
d104 4
d116 2
d122 4
d154 3
a162 2
	if (mdoc->htab)
		mdoc_tokhash_free(mdoc->htab);
d174 3
d202 4
d342 2
d538 1
a538 1
parsetext(struct mdoc *mdoc, int line, char *buf)
d541 2
a542 2
	if (SEC_PROLOGUE == mdoc->lastnamed)
		return(mdoc_perr(mdoc, line, 0,
d545 5
a549 1
	if ( ! mdoc_word_alloc(mdoc, line, 0, buf))
d552 1
a552 1
	mdoc->next = MDOC_NEXT_SIBLING;
d631 6
@


1.66
log
@Changed e-mail address to @@openbsd.
Cleaned up manual-page documentation.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.65 2009/03/16 22:19:19 kristaps Exp $ */
d114 28
d175 2
a176 1
	p->last = xcalloc(1, sizeof(struct mdoc_node));
a177 1
	p->first = p->last;
a180 1

@


1.65
log
@Fixed mdoc_phrase escape handling.
Added MDOC_IGNDELIM (Pf, soon Li, etc.).
macro_constant_delimited ignargs -> argv.c parsing.
Renamed macro functions to correspond to ontologies.
`Fo' and `St' made callable (compat documented).
strings.sh deprecated (directly using CPP).
Abstracted ASCII translation into ascii.{c,in}.
ASCII table uses a self-reordering chained hashtable.
Removed old regressions.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.64 2009/03/12 16:30:50 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
d78 1
a78 1
	"En"
@


1.64
log
@Added -nested (doesn't do anything).
Added .%C.
.Cd is now callable.
Added .Rv -std.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.63 2009/03/12 15:55:11 kristaps Exp $ */
d77 2
a78 1
	"Bro",		"Brc",		"\%C"
d531 1
a531 1
	if (isspace((unsigned char)buf[1])) {
d533 1
a533 1
		while (buf[i] && isspace((unsigned char)buf[i]))
d549 1
a549 1
		else if (isspace((unsigned char)buf[i]))
d569 1
a569 1
	while (buf[i] && isspace((unsigned char)buf[i]))
@


1.63
log
@NetBSD '.[[:whitespace:]]*' properly handled.
mdoc.3 indicates compatibilities and bugs.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.62 2009/03/12 02:57:36 kristaps Exp $ */
d76 2
a77 1
	"Bro",		"Brc"
d89 1
a89 1
	"symbolic"
d261 2
a262 1
		return(mdoc_perr(m, ln, pp, "not callable"));
@


1.62
log
@Brq/Bro/Brc fixed up and pretty.
Cleaned up Aq/Sq use of escapes in term.c.
Added initial -column support.
Fixed argv returning ARGV_WORD and tokenising anyway.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.61 2009/03/11 00:39:58 kristaps Exp $ */
d523 13
a535 1
	/* Comments are quickly ignored. */
@


1.61
log
@Expanded perfect htab to use 27 * 26 * 3 space.
Added Brq, Bro and Brc macros.
Added lbrace and rbrace to special characters.
Fixed spacing in braces.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.60 2009/03/09 14:19:59 kristaps Exp $ */
a537 2
	/* FIXME: be able to skip unknown macro lines! */

@


1.60
log
@Added `Mt' and `Lk' macros (NetBSD).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.59 2009/03/09 13:35:09 kristaps Exp $ */
d75 2
a76 1
	"Lp",		"Lk",		"Mt"
@


1.59
log
@Fixed valgrind issues.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.58 2009/03/09 13:04:01 kristaps Exp $ */
d75 1
a75 1
	"Lp"
@


1.58
log
@Added "Input Encoding" section to mdoc*.1.
Newline-escaped lines are concatenated.
Added -fign-macro option.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.57 2009/03/08 20:57:35 kristaps Exp $ */
d504 1
a504 1
				buf, buf[3] ? "..." : ""));
d507 1
a507 1
				buf, buf[3] ? "..." : ""));
@


1.57
log
@Added `Lp' macro.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.56 2009/03/08 20:50:12 kristaps Exp $ */
d41 1
d499 13
d542 3
a544 3
		(void)mdoc_perr(m, ln, 1, "unknown macro: %s%s", 
				mac, i == 5 ? "..." : "");
		goto err;
d548 3
a550 2
		(void)mdoc_perr(m, ln, 1, "unknown macro: %s", mac);
		goto err;
@


1.56
log
@Added .Ap.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.55 2009/03/08 18:02:36 kristaps Exp $ */
d73 2
a74 1
	"Fr",		"Ud",		"Lb",		"Ap"
@


1.55
log
@Updated manuals.
Added -fign-scope and -fign-escape.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.54 2009/03/08 12:40:27 kristaps Exp $ */
d73 1
a73 1
	"Fr",		"Ud",		"Lb",
@


1.54
log
@Memory fixes in new dynamic schema.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.53 2009/03/08 11:41:22 kristaps Exp $ */
d132 1
a132 1
mdoc_alloc(void *data, const struct mdoc_cb *cb)
d145 1
a145 1

@


1.53
log
@BROKEN CHECK-IN.  Wide-ranging updates.
Removed libmdoc internal argv limit (all dynamic).
Removed "data" union in mdoc_node (to be selectively re-added).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.52 2009/03/06 14:13:47 kristaps Exp $ */
d522 2
@


1.52
log
@Strings abstracted into dynamically-created C files.
Added -V option.
Deprecated README files.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.51 2009/03/05 13:12:12 kristaps Exp $ */
a34 5
static	struct mdoc_arg	 *argdup(size_t, const struct mdoc_arg *);
static	void		  argfree(size_t, struct mdoc_arg *);
static	void	  	  argcpy(struct mdoc_arg *, 
				const struct mdoc_arg *);

d38 3
a40 2
static	void		  mdoc_elem_free(struct mdoc_elem *);
static	void		  mdoc_text_free(struct mdoc_text *);
d172 2
a173 4
 * Main line-parsing routine.  If the line is a macro-line (started with
 * a '.' control character), then pass along to the parser, which parses
 * subsequent macros until the end of line.  If normal text, simply
 * append the entire line to the chain.
d176 1
a176 1
mdoc_parseln(struct mdoc *mdoc, int line, char *buf)
a177 21
	int		  c, i;
	char		  tmp[5];

	if (MDOC_HALT & mdoc->flags)
		return(0);

	mdoc->linetok = 0;

	if ('.' != *buf) {
		/*
		 * Free-form text.  Not allowed in the prologue.
		 */
		if (SEC_PROLOGUE == mdoc->lastnamed)
			return(mdoc_perr(mdoc, line, 0, 
					"no text in prologue"));

		if ( ! mdoc_word_alloc(mdoc, line, 0, buf))
			return(0);
		mdoc->next = MDOC_NEXT_SIBLING;
		return(1);
	}
d179 1
a179 3
	/*
	 * Control-character detected.  Begin the parsing sequence.
	 */
d181 1
a181 32
	if (buf[1] && '\\' == buf[1])
		if (buf[2] && '\"' == buf[2])
			return(1);

	i = 1;
	while (buf[i] && ! isspace((u_char)buf[i]) && 
			i < (int)sizeof(tmp))
		i++;

	if (i == (int)sizeof(tmp)) {
		mdoc->flags |= MDOC_HALT;
		return(mdoc_perr(mdoc, line, 1, "unknown macro"));
	} else if (i <= 2) {
		mdoc->flags |= MDOC_HALT;
		return(mdoc_perr(mdoc, line, 1, "unknown macro"));
	}

	i--;

	(void)memcpy(tmp, buf + 1, (size_t)i);
	tmp[i++] = 0;

	if (MDOC_MAX == (c = mdoc_find(mdoc, tmp))) {
		mdoc->flags |= MDOC_HALT;
		return(mdoc_perr(mdoc, line, 1, "unknown macro"));
	}

	while (buf[i] && isspace((u_char)buf[i]))
		i++;

	if ( ! mdoc_macro(mdoc, c, line, 1, &i, buf)) {
		mdoc->flags |= MDOC_HALT;
a182 1
	}
d184 2
a185 1
	return(1);
d240 2
a241 2
mdoc_macro(struct mdoc *mdoc, int tok, 
		int ln, int ppos, int *pos, char *buf)
d244 1
a244 1
	assert(mdoc_macros[tok].fp);
d247 4
a250 2
			SEC_PROLOGUE != mdoc->lastnamed)
		return(mdoc_perr(mdoc, ln, ppos, "macro disallowed in document body"));
d252 8
a259 5
			SEC_PROLOGUE == mdoc->lastnamed)
		return(mdoc_perr(mdoc, ln, ppos, "macro disallowed in document prologue"));
	if (1 != ppos && ! (MDOC_CALLABLE & mdoc_macros[tok].flags))
		return(mdoc_perr(mdoc, ln, ppos, "macro not callable"));
	return((*mdoc_macros[tok].fp)(mdoc, tok, ln, ppos, pos, buf));
a270 21
	/* See if we exceed the suggest line-max. */

	switch (p->type) {
	case (MDOC_TEXT):
		/* FALLTHROUGH */
	case (MDOC_ELEM):
		/* FALLTHROUGH */
	case (MDOC_BLOCK):
		mdoc->linetok++;
		break;
	default:
		break;
	}

	/* This sort-of works (re-opening of text macros...). */
	if (mdoc->linetok > MDOC_LINEARG_SOFTMAX) 
		if ( ! mdoc_nwarn(mdoc, p, WARN_COMPAT, 
					"suggested %d tokens per line exceeded (has %d)",
					MDOC_LINEARG_SOFTMAX, mdoc->linetok))
			return(0);

d292 1
a292 1
		p->parent->data.block.head = p;
d296 1
a296 1
		p->parent->data.block.tail = p;
d300 1
a300 1
		p->parent->data.block.body = p;
d395 1
a395 1
		int tok, size_t argsz, const struct mdoc_arg *args)
d405 4
a408 2
	p->data.block.argc = argsz;
	p->data.block.argv = argdup(argsz, args);
d416 1
a416 1
		int tok, size_t argsz, const struct mdoc_arg *args)
d426 4
a429 2
	p->data.elem.argc = argsz;
	p->data.elem.argv = argdup(argsz, args);
d446 1
a446 1
	p->data.text.string = xstrdup(word);
d452 2
a453 2
static void
argfree(size_t sz, struct mdoc_arg *p)
a454 1
	int		 i, j;
d456 4
a459 13
	if (0 == sz)
		return;

	assert(p);
	/* LINTED */
	for (i = 0; i < (int)sz; i++)
		if (p[i].sz > 0) {
			assert(p[i].value);
			/* LINTED */
			for (j = 0; j < (int)p[i].sz; j++)
				free(p[i].value[j]);
			free(p[i].value);
		}
d464 2
a465 2
static void
mdoc_elem_free(struct mdoc_elem *p)
d468 4
a471 2
	argfree(p->argc, p->argv);
}
d473 1
a473 6

static void
mdoc_block_free(struct mdoc_block *p)
{

	argfree(p->argc, p->argv);
d477 6
a482 2
static void
mdoc_text_free(struct mdoc_text *p)
d485 3
a487 3
	if (p->string)
		free(p->string);
}
d489 2
d492 2
a493 19
void
mdoc_node_free(struct mdoc_node *p)
{

	switch (p->type) {
	case (MDOC_TEXT):
		mdoc_text_free(&p->data.text);
		break;
	case (MDOC_ELEM):
		mdoc_elem_free(&p->data.elem);
		break;
	case (MDOC_BLOCK):
		mdoc_block_free(&p->data.block);
		break;
	default:
		break;
	}

	free(p);
d497 6
a502 2
void
mdoc_node_freelist(struct mdoc_node *p)
d504 2
d507 1
a507 4
	if (p->child)
		mdoc_node_freelist(p->child);
	if (p->next)
		mdoc_node_freelist(p->next);
d509 3
a511 2
	mdoc_node_free(p);
}
d513 1
d515 6
a520 3
int
mdoc_find(const struct mdoc *mdoc, const char *key)
{
d522 1
a522 2
	return(mdoc_tokhash_find(mdoc->htab, key));
}
d524 10
d535 1
a535 4
static void
argcpy(struct mdoc_arg *dst, const struct mdoc_arg *src)
{
	int		 i;
d537 2
a538 9
	dst->line = src->line;
	dst->pos = src->pos;
	dst->arg = src->arg;
	if (0 == (dst->sz = src->sz))
		return;
	dst->value = xcalloc(dst->sz, sizeof(char *));
	for (i = 0; i < (int)dst->sz; i++)
		dst->value[i] = xstrdup(src->value[i]);
}
d540 1
d542 2
a543 5
static struct mdoc_arg *
argdup(size_t argsz, const struct mdoc_arg *args)
{
	struct mdoc_arg	*pp;
	int		 i;
d545 1
a545 2
	if (0 == argsz)
		return(NULL);
d547 1
a547 3
	pp = xcalloc((size_t)argsz, sizeof(struct mdoc_arg));
	for (i = 0; i < (int)argsz; i++)
		argcpy(&pp[i], &args[i]);
d549 2
a550 1
	return(pp);
a551 1

@


1.51
log
@Cleaned up ctype functions (netbsd).
Fixed .Ex/.Rv -std usage.
Made Ar provide default value.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.50 2009/03/02 17:14:46 kristaps Exp $ */
d77 1
a77 1
	"Fr",		"Ud",
d88 2
a89 14
	"p1003.1-88",		"p1003.1-90",		"p1003.1-96",
	"p1003.1-2001",		"p1003.1-2004",		"p1003.1",
	"p1003.1b",		"p1003.1b-93",		"p1003.1c-95",
	"p1003.1g-2000",	"p1003.2-92",		"p1387.2-95",
	"p1003.2",		"p1387.2",		"isoC-90",
	"isoC-amd1",		"isoC-tcor1",		"isoC-tcor2",
	"isoC-99",		"ansiC",		"ansiC-89",
	"ansiC-99",		"ieee754",		"iso8802-3",
	"xpg3",			"xpg4",			"xpg4.2",
	"xpg4.3",		"xbd5",			"xcu5",
	"xsh5",			"xns5",			"xns5.2d2.0",
	"xcurses4.2",		"susv2",		"susv3",
	"svid4",		"filled",		"words",
	"emphasis",		"symbolic",
d126 4
a320 1
	const char	 *nn, *nt, *on, *ot, *act;
a346 17
	if (MDOC_TEXT == mdoc->last->type)
		on = "<text>";
	else if (MDOC_ROOT == mdoc->last->type)
		on = "<root>";
	else
		on = mdoc_macronames[mdoc->last->tok];

	if (MDOC_TEXT == p->type)
		nn = "<text>";
	else if (MDOC_ROOT == p->type)
		nn = "<root>";
	else
		nn = mdoc_macronames[p->tok];

	ot = mdoc_type2a(mdoc->last->type);
	nt = mdoc_type2a(p->type);

a351 1
		act = "sibling";
a355 1
		act = "child";
a382 2
	mdoc_msg(mdoc, "parse: %s `%s' %s of %s `%s'", 
			nt, nn, act, ot, on);
a645 24

/* FIXME: deprecate. */
char *
mdoc_node2a(struct mdoc_node *node)
{
	static char	 buf[64];

	assert(node);

	buf[0] = 0;
	(void)xstrlcat(buf, mdoc_type2a(node->type), 64);
	if (MDOC_ROOT == node->type)
		return(buf);
	(void)xstrlcat(buf, " `", 64);
	if (MDOC_TEXT == node->type)
		(void)xstrlcat(buf, node->data.text.string, 64);
	else
		(void)xstrlcat(buf, mdoc_macronames[node->tok], 64);
	(void)xstrlcat(buf, "'", 64);

	return(buf);
}


@


1.50
log
@Added new old escape sequence \*[nn].
Initial correct .Bd support (still only text in literal displays).
Symbols put into tables (character-encoding).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.49 2009/03/01 23:14:15 kristaps Exp $ */
d223 2
a224 1
	while (buf[i] && ! isspace((int)buf[i]) && i < (int)sizeof(tmp))
d245 1
a245 1
	while (buf[i] && isspace((int)buf[i]))
@


1.49
log
@Backed-out warning about Ds.
Backed-out assertion about Bd subtypes.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.48 2009/02/23 12:45:19 kristaps Exp $ */
d183 6
a199 4
	/*
	 * FIXME: should puke on whitespace in non-literal displays.
	 */

d201 3
d206 2
a207 1
				"no text in document prologue"));
d214 4
d251 1
@


1.48
log
@More in-file documentation and Linux-isation.
Moved mdoc_macros table definition into macro.c, where it belongs.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.47 2009/02/22 22:58:39 kristaps Exp $ */
d194 4
d200 2
a201 1
			return(mdoc_perr(mdoc, line, 0, "text disallowed in document prologue"));
@


1.47
log
@BROKEN BUILD: migrating to mmain stuff.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.46 2009/02/22 14:31:08 kristaps Exp $ */
d32 1
a32 1
 * in macro.c, but this orchestrates who does what, when.
d35 12
a103 114
/* Central table of library: who gets parsed how. */

const	struct mdoc_macro __mdoc_macros[MDOC_MAX] = {
	{ NULL, 0 }, /* \" */
	{ macro_constant, MDOC_PROLOGUE }, /* Dd */
	{ macro_constant, MDOC_PROLOGUE }, /* Dt */
	{ macro_constant, MDOC_PROLOGUE }, /* Os */
	{ macro_scoped, 0 }, /* Sh */
	{ macro_scoped, 0 }, /* Ss */ 
	{ macro_text, 0 }, /* Pp */ 
	{ macro_scoped_line, MDOC_PARSED }, /* D1 */
	{ macro_scoped_line, MDOC_PARSED }, /* Dl */
	{ macro_scoped, MDOC_EXPLICIT }, /* Bd */
	{ macro_scoped_close, MDOC_EXPLICIT }, /* Ed */
	{ macro_scoped, MDOC_EXPLICIT }, /* Bl */
	{ macro_scoped_close, MDOC_EXPLICIT }, /* El */
	{ macro_scoped, MDOC_PARSED }, /* It */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Ad */ 
	{ macro_text, MDOC_PARSED }, /* An */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Ar */
	{ macro_constant, 0 }, /* Cd */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Cm */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Dv */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Er */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Ev */ 
	{ macro_constant, 0 }, /* Ex */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Fa */ 
	{ macro_constant, 0 }, /* Fd */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Fl */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Fn */ 
	{ macro_text, MDOC_PARSED }, /* Ft */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Ic */ 
	{ macro_constant, 0 }, /* In */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Li */
	{ macro_constant, 0 }, /* Nd */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */ 
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Op */
	{ macro_obsolete, 0 }, /* Ot */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Pa */
	{ macro_constant, 0 }, /* Rv */
	/* XXX - .St supposed to be (but isn't) callable. */
	{ macro_constant_delimited, MDOC_PARSED }, /* St */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Va */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */ 
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Xr */
	{ macro_constant, 0 }, /* %A */
	{ macro_constant, 0 }, /* %B */
	{ macro_constant, 0 }, /* %D */
	{ macro_constant, 0 }, /* %I */
	{ macro_constant, 0 }, /* %J */
	{ macro_constant, 0 }, /* %N */
	{ macro_constant, 0 }, /* %O */
	{ macro_constant, 0 }, /* %P */
	{ macro_constant, 0 }, /* %R */
	{ macro_constant, 0 }, /* %T */
	{ macro_constant, 0 }, /* %V */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Ac */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Ao */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Aq */
	{ macro_constant_delimited, 0 }, /* At */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Bc */
	{ macro_scoped, MDOC_EXPLICIT }, /* Bf */ 
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Bo */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Bq */
	{ macro_constant_delimited, MDOC_PARSED }, /* Bsx */
	{ macro_constant_delimited, MDOC_PARSED }, /* Bx */
	{ macro_constant, 0 }, /* Db */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Dc */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Do */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Dq */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Ec */
	{ macro_scoped_close, MDOC_EXPLICIT }, /* Ef */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Em */ 
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Eo */
	{ macro_constant_delimited, MDOC_PARSED }, /* Fx */
	{ macro_text, MDOC_PARSED }, /* Ms */
	{ macro_constant_delimited, MDOC_CALLABLE | MDOC_PARSED }, /* No */
	{ macro_constant_delimited, MDOC_CALLABLE | MDOC_PARSED }, /* Ns */
	{ macro_constant_delimited, MDOC_PARSED }, /* Nx */
	{ macro_constant_delimited, MDOC_PARSED }, /* Ox */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Pc */
	{ macro_constant_delimited, MDOC_PARSED }, /* Pf */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Po */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Pq */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Qc */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ql */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Qo */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Qq */
	{ macro_scoped_close, MDOC_EXPLICIT }, /* Re */
	{ macro_scoped, MDOC_EXPLICIT }, /* Rs */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Sc */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* So */
	{ macro_scoped_line, MDOC_CALLABLE | MDOC_PARSED }, /* Sq */
	{ macro_constant, 0 }, /* Sm */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Sx */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Sy */
	{ macro_text, MDOC_CALLABLE | MDOC_PARSED }, /* Tn */
	{ macro_constant_delimited, MDOC_PARSED }, /* Ux */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Xc */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Xo */
	/* XXX - .Fo supposed to be (but isn't) callable. */
	{ macro_scoped, MDOC_EXPLICIT }, /* Fo */ 
	/* XXX - .Fc supposed to be (but isn't) callable. */
	{ macro_scoped_close, MDOC_EXPLICIT }, /* Fc */ 
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Oo */
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Oc */
	{ macro_scoped, MDOC_EXPLICIT }, /* Bk */
	{ macro_scoped_close, MDOC_EXPLICIT }, /* Ek */
	{ macro_constant, 0 }, /* Bt */
	{ macro_constant, 0 }, /* Hf */
	{ macro_obsolete, 0 }, /* Fr */
	{ macro_constant, 0 }, /* Ud */
};

a105 13
const	struct mdoc_macro * const mdoc_macros = __mdoc_macros;

static	struct mdoc_arg	 *argdup(size_t, const struct mdoc_arg *);
static	void		  argfree(size_t, struct mdoc_arg *);
static	void	  	  argcpy(struct mdoc_arg *, 
				const struct mdoc_arg *);

static	struct mdoc_node *mdoc_node_alloc(const struct mdoc *);
static	int		  mdoc_node_append(struct mdoc *, 
				struct mdoc_node *);
static	void		  mdoc_elem_free(struct mdoc_elem *);
static	void		  mdoc_text_free(struct mdoc_text *);

@


1.46
log
@Cleaned up validation source a bit.
Fixed `Nm' and `Nd' detection.
Added a few more terminal outputs.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.45 2009/02/20 07:43:15 kristaps Exp $ */
d224 1
a224 1
mdoc_node(struct mdoc *mdoc)
d232 1
a232 1
mdoc_meta(struct mdoc *mdoc)
@


1.45
log
@Removed tree-writing capability (for now, only validates and exits).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.44 2009/01/21 11:35:26 kristaps Exp $ */
d215 1
a215 1
static	struct mdoc_node *mdoc_node_alloc(void);
d516 1
a516 1
mdoc_node_alloc(void)
d518 4
d523 1
a523 1
	return(xcalloc(1, sizeof(struct mdoc_node)));
d535 1
a535 1
	p = mdoc_node_alloc();
d554 1
a554 1
	p = mdoc_node_alloc();
d573 1
a573 1
	p = mdoc_node_alloc();
d589 1
a589 1
	p = mdoc_node_alloc();
d603 1
a603 1
	p = mdoc_node_alloc();
d622 1
a622 1
	p = mdoc_node_alloc();
d641 1
a641 1
	p = mdoc_node_alloc();
@


1.44
log
@More validation on prologue/first NAME section.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.43 2009/01/20 20:56:21 kristaps Exp $ */
d215 1
d222 1
d515 8
d531 1
a531 1
	p = xcalloc(1, sizeof(struct mdoc_node));
d550 1
a550 1
	p = xcalloc(1, sizeof(struct mdoc_node));
d569 1
a569 1
	p = xcalloc(1, sizeof(struct mdoc_node));
d585 1
a585 1
	p = xcalloc(1, sizeof(struct mdoc_node));
d599 1
a599 1
	p = xcalloc(1, sizeof(struct mdoc_node));
d618 1
a618 1
	p = xcalloc(1, sizeof(struct mdoc_node));
d637 2
a638 1
	p = xcalloc(1, sizeof(struct mdoc_node));
@


1.43
log
@In-progress migration to ARGV separation.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.42 2009/01/20 13:49:36 kristaps Exp $ */
d308 2
a309 2
		if ( ! (MDOC_BODYPARSE & mdoc->flags))
			return(mdoc_perr(mdoc, line, 0, "text disallowed"));
d410 6
a415 3
	if ( ! (MDOC_PROLOGUE & mdoc_macros[tok].flags) &&
			! (MDOC_BODYPARSE & mdoc->flags))
		return(mdoc_perr(mdoc, ln, ppos, "macro disallowed: not in document body"));
@


1.42
log
@Lint- and NetBSD-compiler checks.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.41 2009/01/20 13:44:05 kristaps Exp $ */
d108 1
a108 1
	{ macro_scoped, MDOC_PARSED | MDOC_TABSEP}, /* It */
d112 1
a112 1
	{ macro_constant, MDOC_QUOTABLE }, /* Cd */
d118 1
a118 1
	{ macro_text, MDOC_CALLABLE | MDOC_QUOTABLE | MDOC_PARSED }, /* Fa */ 
d121 2
a122 2
	{ macro_text, MDOC_CALLABLE | MDOC_QUOTABLE | MDOC_PARSED }, /* Fn */ 
	{ macro_text, MDOC_PARSED | MDOC_QUOTABLE }, /* Ft */ 
d137 11
a147 11
	{ macro_constant, MDOC_QUOTABLE }, /* %A */
	{ macro_constant, MDOC_QUOTABLE }, /* %B */
	{ macro_constant, MDOC_QUOTABLE }, /* %D */
	{ macro_constant, MDOC_QUOTABLE }, /* %I */
	{ macro_constant, MDOC_QUOTABLE }, /* %J */
	{ macro_constant, MDOC_QUOTABLE }, /* %N */
	{ macro_constant, MDOC_QUOTABLE }, /* %O */
	{ macro_constant, MDOC_QUOTABLE }, /* %P */
	{ macro_constant, MDOC_QUOTABLE }, /* %R */
	{ macro_constant, MDOC_QUOTABLE }, /* %T */
	{ macro_constant, MDOC_QUOTABLE }, /* %V */
d193 1
a193 1
	{ macro_scoped, MDOC_EXPLICIT | MDOC_PARSED }, /* Fo */ 
d195 1
a195 1
	{ macro_scoped_close, MDOC_EXPLICIT | MDOC_PARSED }, /* Fc */ 
@


1.41
log
@Re-merged old port-building routines.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.40 2009/01/20 13:05:28 kristaps Exp $ */
d321 1
a321 1
	while (buf[i] && ! isspace(buf[i]) && i < (int)sizeof(tmp))
d342 1
a342 1
	while (buf[i] && isspace(buf[i]))
@


1.40
log
@Quoted-literals handled correctly.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.39 2009/01/20 12:51:28 kristaps Exp $ */
d29 6
d92 2
a209 1

@


1.39
log
@Moved prologue-pruning into action.c.
Added line-arg softmax.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.38 2009/01/19 17:53:54 kristaps Exp $ */
d435 1
@


1.38
log
@Plugged memory leak in meta free.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.37 2009/01/19 17:51:33 kristaps Exp $ */
d88 3
a90 3
	{ macro_constant, MDOC_PROLOGUE | MDOC_NOKEEP }, /* Dd */
	{ macro_constant, MDOC_PROLOGUE | MDOC_NOKEEP }, /* Dt */
	{ macro_constant, MDOC_PROLOGUE | MDOC_NOKEEP }, /* Os */
d298 2
d301 6
a306 7
		if (SEC_PROLOGUE != mdoc->sec_lastn) {
			if ( ! mdoc_word_alloc(mdoc, line, 0, buf))
				return(0);
			mdoc->next = MDOC_NEXT_SIBLING;
			return(1);
		}
		return(mdoc_perr(mdoc, line, 0, "text disallowed"));
d404 2
a405 2
			SEC_PROLOGUE == mdoc->sec_lastn)
		return(mdoc_perr(mdoc, ln, ppos, "macro disallowed in document prologue"));
d421 20
@


1.37
log
@More correct validation.
Elision of prologue macros from main tree.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.36 2009/01/19 17:02:58 kristaps Exp $ */
d231 1
a231 1
mdoc_meta_free(struct mdoc *mdoc)
d234 4
a243 1
}
a244 10

void
mdoc_free(struct mdoc *mdoc)
{

	if (mdoc->first)
		mdoc_node_freelist(mdoc->first);
	if (mdoc->htab)
		mdoc_tokhash_free(mdoc->htab);
	
@


1.36
log
@Removed unnecessary test cases (most were for visual).
Finally fixed scope-rewinding (MDOC_VALID).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.35 2009/01/17 20:10:36 kristaps Exp $ */
d88 3
a90 3
	{ macro_constant, MDOC_PROLOGUE }, /* Dd */
	{ macro_constant, MDOC_PROLOGUE }, /* Dt */
	{ macro_constant, MDOC_PROLOGUE }, /* Os */
a207 1
static	void		  mdoc_node_freelist(struct mdoc_node *);
d215 1
a215 1
mdoc_result(struct mdoc *mdoc)
d222 8
d681 1
a681 1
static void
@


1.35
log
@Lint checks.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.34 2009/01/17 16:15:27 kristaps Exp $ */
d728 1
d745 1
@


1.34
log
@Documentation, more validations, cleaned up actions, added Nm action.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.33 2009/01/16 15:58:50 kristaps Exp $ */
d727 22
@


1.33
log
@Initial separation of tree/mdocml.1.
Finished mdoc.3.
Broken build: mdocml.c.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.32 2009/01/16 14:04:26 kristaps Exp $ */
d143 1
a143 1
	{ macro_constant, 0 }, /* At */
d224 13
a455 2
	if ( ! mdoc_action_pre(mdoc, p))
		return(0);
@


1.32
log
@Added more validation (parents/msecs).
Initial function documentation for mdoc.3.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.31 2009/01/15 17:38:57 kristaps Exp $ */
d244 2
a245 1
	(void)memcpy(&p->cb, cb, sizeof(struct mdoc_cb));
@


1.31
log
@Broken build (changing err/warn/msg function prototypes for clarity).
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.30 2009/01/15 15:46:45 kristaps Exp $ */
d102 1
a102 1
	{ macro_constant, MDOC_PARSED }, /* An */
d114 1
a114 1
	{ macro_text, MDOC_PARSED }, /* Ft */ 
d165 1
a165 1
	{ macro_constant, MDOC_PARSED }, /* Pf */
@


1.30
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.29 2009/01/14 11:58:24 kristaps Exp $ */
d291 1
a291 1
		return(mdoc_perr(mdoc, line, 0, ERR_SYNTAX_NOTEXT));
d304 1
a304 1
		return(mdoc_perr(mdoc, line, 1, ERR_MACRO_NOTSUP));
d307 1
a307 1
		return(mdoc_perr(mdoc, line, 1, ERR_MACRO_NOTSUP));
d317 1
a317 1
		return(mdoc_perr(mdoc, line, 1, ERR_MACRO_NOTSUP));
d332 1
a332 1
mdoc_msg(struct mdoc *mdoc, const char *fmt, ...)
d334 1
a334 1
	struct mdoc_node *n;
a335 1
	char		  buf[256];
a339 3
	n = mdoc->last;
	assert(n);

d341 1
a341 1
	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
d343 1
a343 2

	(*mdoc->cb.mdoc_msg)(mdoc->data, n->line, n->pos, buf);
d348 2
a349 2
mdoc_perr(struct mdoc *mdoc, 
		int line, int pos, enum mdoc_err type)
d351 2
d356 5
a360 1
	return((*mdoc->cb.mdoc_err)(mdoc->data, line, pos, type));
d365 2
a366 2
mdoc_pwarn(struct mdoc *mdoc, 
		int line, int pos, enum mdoc_warn type)
d368 2
d373 5
a377 1
	return((*mdoc->cb.mdoc_warn)(mdoc->data, line, pos, type));
d386 2
d390 1
a390 5
		return(mdoc_perr(mdoc, ln, ppos, ERR_SEC_PROLOGUE));

	if (NULL == (mdoc_macros[tok].fp))
		return(mdoc_perr(mdoc, ln, ppos, ERR_MACRO_NOTSUP));

d392 1
a392 2
		return(mdoc_perr(mdoc, ln, ppos, ERR_MACRO_NOTCALL));

@


1.29
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.28 2009/01/12 16:39:57 kristaps Exp $ */
d396 1
a396 1
	const char	 *on, *ot, *act;
d409 9
a417 27
	/* FIXME: put this into util.c. */
	switch (mdoc->last->type) {
	case (MDOC_TEXT):
		ot = "text";
		break;
	case (MDOC_BODY):
		ot = "body";
		break;
	case (MDOC_ELEM):
		ot = "elem";
		break;
	case (MDOC_HEAD):
		ot = "head";
		break;
	case (MDOC_TAIL):
		ot = "tail";
		break;
	case (MDOC_BLOCK):
		ot = "block";
		break;
	case (MDOC_ROOT):
		ot = "root";
		break;
	default:
		abort();
		/* NOTREACHED */
	}
d459 2
a460 1
	mdoc_msg(mdoc, "parse: %s of %s `%s'", act, ot, on);
@


1.28
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.27 2009/01/12 12:52:21 kristaps Exp $ */
d97 1
a97 1
	{ macro_close_explicit, 0 }, /* Ed */
d99 2
a100 2
	{ macro_close_explicit, 0 }, /* El */
	{ macro_scoped, MDOC_NESTED | MDOC_PARSED | MDOC_TABSEP}, /* It */
d140 2
a141 2
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Ac */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Ao */
d144 1
a144 1
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Bc */
d146 1
a146 1
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Bo */
d151 2
a152 2
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Dc */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Do */
d154 2
a155 2
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Ec */
	{ macro_close_explicit, 0 }, /* Ef */
d157 1
a157 1
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Eo */
d164 1
a164 1
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Pc */
d166 1
a166 1
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Po */
d168 1
a168 1
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Qc */
d170 1
a170 1
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Qo */
d172 1
a172 1
	{ macro_close_explicit, 0 }, /* Re */
d174 2
a175 2
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Sc */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* So */
d182 2
a183 2
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Xc */
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Xo */
d187 3
a189 3
	{ macro_close_explicit, MDOC_PARSED }, /* Fc */ 
	{ macro_constant_scoped, MDOC_CALLABLE | MDOC_PARSED }, /* Oo */
	{ macro_close_explicit, MDOC_CALLABLE | MDOC_PARSED }, /* Oc */
d191 1
a191 1
	{ macro_close_explicit, 0 }, /* Ek */
@


1.27
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.26 2009/01/12 10:31:53 kristaps Exp $ */
d100 1
a100 1
	{ macro_scoped, MDOC_NESTED | MDOC_PARSED }, /* It */
@


1.26
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.25 2009/01/09 14:45:44 kristaps Exp $ */
d402 8
a411 1
		on = "<text>";
a414 1
		on = mdoc_macronames[mdoc->last->data.body.tok];
a417 1
		on = mdoc_macronames[mdoc->last->data.elem.tok];
a420 1
		on = mdoc_macronames[mdoc->last->data.head.tok];
a423 1
		on = mdoc_macronames[mdoc->last->data.tail.tok];
a426 1
		on = mdoc_macronames[mdoc->last->data.block.tok];
a429 1
		on = "root";
d458 18
d495 1
a495 1
	p->data.tail.tok = tok;
d514 1
a514 1
	p->data.head.tok = tok;
d533 1
a533 1
	p->data.body.tok = tok;
d563 1
a563 1
	p->data.block.tok = tok;
d582 1
a582 1
	p->data.elem.tok = tok;
@


1.25
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.24 2009/01/08 15:05:50 kristaps Exp $ */
d286 2
a287 1
			mdoc_word_alloc(mdoc, line, 0, buf);
d396 1
a396 31
	const char	 *nn, *on, *nt, *ot, *act;

	switch (p->type) {
	case (MDOC_TEXT):
		nn = p->data.text.string;
		nt = "text";
		break;
	case (MDOC_BODY):
		nn = mdoc_macronames[p->data.body.tok];
		nt = "body";
		break;
	case (MDOC_ELEM):
		nn = mdoc_macronames[p->data.elem.tok];
		nt = "elem";
		break;
	case (MDOC_HEAD):
		nn = mdoc_macronames[p->data.head.tok];
		nt = "head";
		break;
	case (MDOC_TAIL):
		nn = mdoc_macronames[p->data.tail.tok];
		nt = "tail";
		break;
	case (MDOC_BLOCK):
		nn = mdoc_macronames[p->data.block.tok];
		nt = "block";
		break;
	default:
		abort();
		/* NOTREACHED */
	}
d682 2
@


1.24
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.23 2009/01/08 14:55:59 kristaps Exp $ */
d246 5
d252 1
d427 3
a429 11
	if (NULL == mdoc->first) {
		assert(NULL == mdoc->last);
		if ( ! mdoc_valid_pre(mdoc, p))
			return(0);
		if ( ! mdoc_action_pre(mdoc, p))
			return(0);
		mdoc->first = p;
		mdoc->last = p;
		mdoc_msg(mdoc, "parse: root %s `%s'", nt, nn);
		return(1);
	}
d456 4
d550 13
@


1.23
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.22 2009/01/07 16:11:40 kristaps Exp $ */
d88 3
a90 3
	{ macro_prologue, MDOC_PROLOGUE }, /* Dd */
	{ macro_prologue, MDOC_PROLOGUE }, /* Dt */
	{ macro_prologue, MDOC_PROLOGUE }, /* Os */
@


1.22
log
@All macros have lines/positions.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.21 2009/01/07 15:57:14 kristaps Exp $ */
d129 2
a130 2
	{ macro_constant, MDOC_QUOTABLE | MDOC_PARSED }, /* %A */
	{ macro_constant, MDOC_QUOTABLE | MDOC_PARSED }, /* %B */
d132 2
a133 2
	{ macro_constant, MDOC_QUOTABLE | MDOC_PARSED }, /* %I */
	{ macro_constant, MDOC_QUOTABLE | MDOC_PARSED }, /* %J */
d138 1
a138 1
	{ macro_constant, MDOC_QUOTABLE | MDOC_PARSED }, /* %T */
d209 1
a209 1
static	void		  mdoc_node_append(struct mdoc *, int, 
d279 6
a284 5
		if (SEC_PROLOGUE == mdoc->sec_lastn)
			return(mdoc_err(mdoc, -1, 0, ERR_SYNTAX_NOTEXT));
		mdoc_word_alloc(mdoc, line, 0, buf);
		mdoc->next = MDOC_NEXT_SIBLING;
		return(1);
d297 1
a297 1
		return(mdoc_err(mdoc, -1, 1, ERR_MACRO_NOTSUP));
d300 1
a300 1
		return(mdoc_err(mdoc, -1, 1, ERR_MACRO_NOTSUP));
d310 1
a310 1
		return(mdoc_err(mdoc, c, 1, ERR_MACRO_NOTSUP));
d325 1
a325 1
mdoc_msg(struct mdoc *mdoc, int pos, const char *fmt, ...)
d327 3
a329 2
	va_list		 ap;
	char		 buf[256];
d334 3
d341 1
a341 1
	(*mdoc->cb.mdoc_msg)(mdoc->data, pos, buf);
d346 2
a347 1
mdoc_err(struct mdoc *mdoc, int tok, int pos, enum mdoc_err type)
d352 1
a352 1
	return((*mdoc->cb.mdoc_err)(mdoc->data, tok, pos, type));
d357 2
a358 1
mdoc_warn(struct mdoc *mdoc, int tok, int pos, enum mdoc_warn type)
d363 1
a363 1
	return((*mdoc->cb.mdoc_warn)(mdoc->data, tok, pos, type));
d369 1
a369 1
		int line, int ppos, int *pos, char *buf)
d374 1
a374 1
		return(mdoc_err(mdoc, tok, ppos, ERR_SEC_PROLOGUE));
d376 2
a377 4
	if (NULL == (mdoc_macros[tok].fp)) {
		(void)mdoc_err(mdoc, tok, ppos, ERR_MACRO_NOTSUP);
		return(0);
	}
d379 2
a380 4
	if (1 != ppos && ! (MDOC_CALLABLE & mdoc_macros[tok].flags)) {
		(void)mdoc_err(mdoc, tok, ppos, ERR_MACRO_NOTCALL);
		return(0);
	}
d382 1
a382 2
	return((*mdoc_macros[tok].fp)(mdoc, tok, 
				line, ppos, pos, buf));
d386 2
a387 2
static void
mdoc_node_append(struct mdoc *mdoc, int pos, struct mdoc_node *p)
d423 4
d429 2
a430 2
		mdoc_msg(mdoc, pos, "parse: root %s `%s'", nt, nn);
		return;
d480 4
a483 3
	mdoc_msg(mdoc, pos, "parse: %s `%s' %s of %s `%s'", 
			nt, nn, act, ot, on);

d485 2
d490 1
a490 1
void
d505 1
a505 1
	mdoc_node_append(mdoc, pos, p);
d509 1
a509 1
void
d524 1
a524 1
	mdoc_node_append(mdoc, pos, p);
d528 1
a528 1
void
d543 1
a543 1
	mdoc_node_append(mdoc, pos, p);
d547 1
a547 1
void
d562 1
a562 1
	mdoc_node_append(mdoc, pos, p);
d566 1
a566 1
void
d581 1
a581 1
	mdoc_node_append(mdoc, pos, p);
d585 1
a585 1
void
d597 1
a597 1
	mdoc_node_append(mdoc, pos, p);
@


1.21
log
@Added line numbering.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.20 2009/01/07 15:53:00 kristaps Exp $ */
d124 1
a124 1
	/* XXX - supposed to be (but isn't) callable. */
d281 1
a281 1
		mdoc_word_alloc(mdoc, 0, buf);
d379 2
a380 1
	return((*mdoc_macros[tok].fp)(mdoc, tok, line, ppos, pos, buf));
d482 1
a482 1
mdoc_tail_alloc(struct mdoc *mdoc, int pos, int tok)
d491 2
d501 1
a501 1
mdoc_head_alloc(struct mdoc *mdoc, int pos, int tok)
d510 2
d520 1
a520 1
mdoc_body_alloc(struct mdoc *mdoc, int pos, int tok)
d529 2
d539 2
a540 2
mdoc_block_alloc(struct mdoc *mdoc, int pos, int tok,
		size_t argsz, const struct mdoc_arg *args)
d546 2
d558 2
a559 2
mdoc_elem_alloc(struct mdoc *mdoc, int pos, int tok, 
		size_t argsz, const struct mdoc_arg *args)
d564 3
d577 2
a578 1
mdoc_word_alloc(struct mdoc *mdoc, int pos, const char *word)
d583 2
@


1.20
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.19 2009/01/06 15:49:44 kristaps Exp $ */
d315 1
a315 1
	if ( ! mdoc_macro(mdoc, c, 1, &i, buf)) {
d361 2
a362 1
mdoc_macro(struct mdoc *mdoc, int tok, int ppos, int *pos, char *buf)
d379 1
a379 1
	return((*mdoc_macros[tok].fp)(mdoc, tok, ppos, pos, buf));
@


1.19
log
@Memory leak, some mdoc(7) conformities.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.18 2009/01/05 17:57:08 kristaps Exp $ */
d252 19
a270 1
mdoc_parseln(struct mdoc *mdoc, char *buf)
d275 3
d294 2
a295 1
	if (i == (int)sizeof(tmp))
d297 2
a298 1
	else if (i <= 2)
d300 1
d307 2
a308 1
	if (MDOC_MAX == (c = mdoc_find(mdoc, tmp)))
d310 1
d315 5
a319 1
	return(mdoc_macro(mdoc, c, 1, &i, buf));
@


1.18
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.17 2009/01/05 16:11:14 kristaps Exp $ */
d94 2
a95 2
	{ macro_scoped_line, 0 }, /* D1 */
	{ macro_scoped_line, 0 }, /* Dl */
d100 4
a103 4
	{ macro_scoped, MDOC_NESTED }, /* It */
	{ macro_text, MDOC_CALLABLE }, /* Ad */ 
	{ macro_constant, 0 }, /* An */ 
	{ macro_text, MDOC_CALLABLE }, /* Ar */
d105 4
a108 4
	{ macro_text, MDOC_CALLABLE }, /* Cm */
	{ macro_text, MDOC_CALLABLE }, /* Dv */ 
	{ macro_text, MDOC_CALLABLE }, /* Er */ 
	{ macro_text, MDOC_CALLABLE }, /* Ev */ 
d110 1
a110 1
	{ macro_text, MDOC_CALLABLE | MDOC_QUOTABLE }, /* Fa */ 
d112 4
a115 4
	{ macro_text, MDOC_CALLABLE }, /* Fl */
	{ macro_text, MDOC_CALLABLE | MDOC_QUOTABLE }, /* Fn */ 
	{ macro_text, 0 }, /* Ft */ 
	{ macro_text, MDOC_CALLABLE }, /* Ic */ 
d117 1
a117 1
	{ macro_text, MDOC_CALLABLE }, /* Li */
d119 2
a120 2
	{ macro_text, MDOC_CALLABLE }, /* Nm */ 
	{ macro_scoped_line, MDOC_CALLABLE }, /* Op */
d122 1
a122 1
	{ macro_text, MDOC_CALLABLE }, /* Pa */
d124 7
a130 6
	{ macro_constant, 0 }, /* St */
	{ macro_text, MDOC_CALLABLE }, /* Va */
	{ macro_text, MDOC_CALLABLE }, /* Vt */ 
	{ macro_text, MDOC_CALLABLE }, /* Xr */
	{ macro_constant, MDOC_QUOTABLE }, /* %A */
	{ macro_constant, MDOC_QUOTABLE }, /* %B */
d132 2
a133 2
	{ macro_constant, MDOC_QUOTABLE }, /* %I */
	{ macro_constant, MDOC_QUOTABLE }, /* %J */
d138 1
a138 1
	{ macro_constant, MDOC_QUOTABLE }, /* %T */
d140 3
a142 3
	{ macro_close_explicit, MDOC_CALLABLE }, /* Ac */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Ao */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Aq */
d144 1
a144 1
	{ macro_close_explicit, MDOC_CALLABLE }, /* Bc */
d146 4
a149 4
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Bo */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Bq */
	{ macro_constant_delimited, 0 }, /* Bsx */
	{ macro_constant_delimited, 0 }, /* Bx */
d151 4
a154 4
	{ macro_close_explicit, MDOC_CALLABLE }, /* Dc */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Do */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Dq */
	{ macro_close_explicit, MDOC_CALLABLE }, /* Ec */
d156 16
a171 16
	{ macro_text, MDOC_CALLABLE }, /* Em */ 
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Eo */
	{ macro_constant_delimited, 0 }, /* Fx */
	{ macro_text, 0 }, /* Ms */
	{ macro_constant_delimited, MDOC_CALLABLE }, /* No */
	{ macro_constant_delimited, MDOC_CALLABLE }, /* Ns */
	{ macro_constant_delimited, 0 }, /* Nx */
	{ macro_constant_delimited, 0 }, /* Ox */
	{ macro_close_explicit, MDOC_CALLABLE }, /* Pc */
	{ macro_constant, 0 }, /* Pf */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Po */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Pq */
	{ macro_close_explicit, MDOC_CALLABLE }, /* Qc */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Ql */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Qo */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Qq */
d174 3
a176 3
	{ macro_close_explicit, MDOC_CALLABLE }, /* Sc */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* So */
	{ macro_scoped_line, MDOC_CALLABLE }, /* Sq */
d178 12
a189 10
	{ macro_text, MDOC_CALLABLE }, /* Sx */
	{ macro_text, MDOC_CALLABLE }, /* Sy */
	{ macro_text, MDOC_CALLABLE }, /* Tn */
	{ macro_constant_delimited, 0 }, /* Ux */
	{ macro_close_explicit, MDOC_CALLABLE }, /* Xc */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Xo */
	{ macro_scoped, MDOC_EXPLICIT }, /* Fo */ /* XXX - supposed to be (but isn't) callable. */
	{ macro_close_explicit, 0 }, /* Fc */ /* XXX - supposed to be (but isn't) callable. */
	{ macro_constant_scoped, MDOC_CALLABLE }, /* Oo */
	{ macro_close_explicit, MDOC_CALLABLE }, /* Oc */
d562 1
@


1.17
log
@Finished initial parse sequence.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.16 2009/01/05 14:14:04 kristaps Exp $ */
d110 1
a110 1
	{ macro_text, MDOC_CALLABLE }, /* Fa */ 
d171 1
a171 1
	{ macro_scoped, MDOC_EXPLICIT }, /* Re */
d255 2
@


1.16
log
@Actions and validations properly added.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.15 2009/01/03 22:10:22 kristaps Exp $ */
d88 3
a90 3
	{ NULL, MDOC_PROLOGUE }, /* Dd */
	{ NULL, MDOC_PROLOGUE }, /* Dt */
	{ NULL, MDOC_PROLOGUE }, /* Os */
d100 1
a100 1
	{ NULL, 0 }, /* It */
d119 1
a119 1
	{ NULL, 0 }, /* Nm */ 
d139 2
a140 2
	{ NULL, 0 }, /* Ac */
	{ NULL, 0 }, /* Ao */
d143 1
a143 1
	{ NULL, 0 }, /* Bc */
d145 1
a145 1
	{ NULL, 0 }, /* Bo */
d150 2
a151 2
	{ NULL, 0 }, /* Dc */
	{ NULL, 0 }, /* Do */
d153 1
a153 1
	{ NULL, 0 }, /* Ec */
d156 1
a156 1
	{ NULL, 0 }, /* Eo */
d163 1
a163 1
	{ NULL, 0 }, /* Pc */
d165 1
a165 1
	{ NULL, 0 }, /* Po */
d167 1
a167 1
	{ NULL, 0 }, /* Qc */
d169 1
a169 1
	{ NULL, 0 }, /* Qo */
d173 2
a174 2
	{ NULL, 0 }, /* Sc */
	{ NULL, 0 }, /* So */
d181 8
a188 8
	{ NULL, 0 }, /* Xc */
	{ NULL, 0 }, /* Xo */
	{ NULL, 0 }, /* Fo */ 
	{ NULL, 0 }, /* Fc */ 
	{ NULL, 0 }, /* Oo */
	{ NULL, 0 }, /* Oc */
	{ NULL, 0 }, /* Bk */
	{ NULL, 0 }, /* Ek */
d329 1
a329 1
	if (MDOC_PROLOGUE & mdoc_macros[tok].flags &&
a330 3
		return(macro_prologue(mdoc, tok, ppos, pos, buf));
	
	if (SEC_PROLOGUE == mdoc->sec_lastn)
d369 4
d407 4
d445 17
a520 1
	/* FIXME: freeing of params... */
@


1.15
log
@Huge changes.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.14 2009/01/02 14:06:16 kristaps Exp $ */
d144 1
a144 1
	{ macro_scoped, 0 }, /* Bf */ 
a203 2
static	char		**paramdup(size_t, const char **);
static	void		  paramfree(size_t, char **);
a544 1
	paramfree(p->sz, p->args);
a638 32

static void
paramfree(size_t sz, char **p)
{
	int		 i;

	if (0 == sz)
		return;

	assert(p);
	/* LINTED */
	for (i = 0; i < (int)sz; i++)
		free(p[i]);
	free(p);
}


static char **
paramdup(size_t sz, const char **p)
{
	char		**pp;
	int		  i;

	if (0 == sz)
		return(NULL);

	pp = xcalloc(sz, sizeof(char *));
	for (i = 0; i < (int)sz; i++) 
		pp[i] = xstrdup(p[i]);

	return(pp);
}
@


1.14
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.13 2009/01/01 20:40:16 kristaps Exp $ */
d494 1
a494 2
		size_t argsz, const struct mdoc_arg *args, 
		size_t paramsz, const char **params)
d501 1
a501 2
	p->data.elem.sz = paramsz;
	p->data.elem.args = paramdup(paramsz, params);
@


1.13
log
@Broke apart macro_prologuexxx into prologue.
Fixed validation for line-scoped.
Merged const_arg and const.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.12 2008/12/30 19:06:03 kristaps Exp $ */
d83 1
d102 1
a102 1
	{ NULL, 0 }, /* An */ 
d144 1
a144 1
	{ NULL, 0 }, /* Bf */ 
d154 1
a154 1
	{ NULL, 0 }, /* Ef */
d164 1
a164 1
	{ NULL, 0 }, /* Pf */
@


1.12
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.11 2008/12/30 13:43:53 kristaps Exp $ */
d87 5
a91 5
	{ macro_prologue_ddate, 0 }, /* Dd */
	{ macro_prologue_dtitle, 0 }, /* Dt */
	{ macro_prologue_os, 0 }, /* Os */
	{ macro_scoped_implicit, 0 }, /* Sh */
	{ macro_scoped_implicit, 0 }, /* Ss */ 
d95 4
a98 4
	{ macro_scoped_explicit, MDOC_EXPLICIT }, /* Bd */
	{ macro_scoped_explicit, 0 }, /* Ed */
	{ macro_scoped_explicit, MDOC_EXPLICIT }, /* Bl */
	{ macro_scoped_explicit, 0 }, /* El */
d108 1
a108 1
	{ macro_constant_argv, 0 }, /* Ex */
d110 1
a110 1
	{ NULL, 0 }, /* Fd */ 
d115 1
a115 1
	{ NULL, 0 }, /* In */ 
d119 2
a120 2
	{ NULL, 0 }, /* Op */
	{ NULL, 0 }, /* Ot */
d122 2
a123 2
	{ macro_constant_argv, 0 }, /* Rv */
	{ NULL, 0 }, /* St */
d126 12
a137 12
	{ NULL, 0 }, /* Xr */
	{ NULL, 0 }, /* %A */
	{ NULL, 0 }, /* %B */
	{ NULL, 0 }, /* %D */
	{ NULL, 0 }, /* %I */
	{ NULL, 0 }, /* %J */
	{ NULL, 0 }, /* %N */
	{ NULL, 0 }, /* %O */
	{ NULL, 0 }, /* %P */
	{ NULL, 0 }, /* %R */
	{ NULL, 0 }, /* %T */
	{ NULL, 0 }, /* %V */
d140 1
a140 1
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Aq */
d145 1
a145 1
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Bq */
d148 1
a148 1
	{ NULL, 0 }, /* Db */
d151 1
a151 1
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Dq */
d158 2
a159 2
	{ NULL, 0 }, /* No */
	{ NULL, 0 }, /* Ns */
d165 1
a165 1
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Pq */
d167 1
a167 1
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Ql */
d169 3
a171 3
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Qq */
	{ NULL, 0 }, /* Re */
	{ NULL, 0 }, /* Rs */
d174 2
a175 2
	{ macro_scoped_pline, MDOC_CALLABLE }, /* Sq */
	{ NULL, 0 }, /* Sm */
d257 1
d330 7
a346 2
	/*mdoc_msg(mdoc, ppos, "calling `%s'", mdoc_macronames[tok]);*/

d416 2
a417 3
	switch (p->type) {
	case (MDOC_BODY):
		p->parent = mdoc->last->parent;
d420 1
d423 2
a424 3

	case (MDOC_HEAD):
		assert(mdoc->last->type == MDOC_BLOCK);
a425 1
		mdoc->last->child = p;
a427 1

d429 2
a430 16
		switch (mdoc->last->type) {
		case (MDOC_BODY):
			/* FALLTHROUGH */
		case (MDOC_HEAD):
			p->parent = mdoc->last;
			mdoc->last->child = p;
			act = "child";
			break;
		default:
			p->parent = mdoc->last->parent;
			p->prev = mdoc->last;
			mdoc->last->next = p;
			act = "sibling";
			break;
		}
		break;
d433 1
a433 1
	mdoc_msg(mdoc, pos, "parse: %s `%s' %s %s `%s'", 
d435 1
a439 1
/* FIXME: deprecate paramsz, params. */
d441 1
a441 2
mdoc_head_alloc(struct mdoc *mdoc, int pos, int tok, 
		size_t paramsz, const char **params)
a446 2
	assert(mdoc->last->type == MDOC_BLOCK);
	assert(mdoc->last->data.block.tok == tok);
d449 1
a451 2
	p->data.head.sz = paramsz;
	p->data.head.args = paramdup(paramsz, params);
a463 6
	assert((mdoc->last->type == MDOC_BLOCK) ||
			(mdoc->last->type == MDOC_HEAD));
	if (mdoc->last->type == MDOC_BLOCK) 
		assert(mdoc->last->data.block.tok == tok);
	else
		assert(mdoc->last->data.head.tok == tok);
a569 8
static void
mdoc_head_free(struct mdoc_head *p)
{

	paramfree(p->sz, p->args);
}


a583 3
	case (MDOC_HEAD):
		mdoc_head_free(&p->data.head);
		break;
@


1.11
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.10 2008/12/29 19:25:29 kristaps Exp $ */
d103 1
a103 1
	{ NULL, 0 }, /* Cd */
d112 1
a112 1
	{ NULL, 0 }, /* Fn */ 
d190 1
a190 1
	{ NULL, 0 }, /* Fr */
@


1.10
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.9 2008/12/29 18:08:44 kristaps Exp $ */
d108 1
a108 1
	{ NULL, 0 }, /* Ex */
d122 1
a122 1
	{ NULL, 0 }, /* Rv */
@


1.9
log
@More macros.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.8 2008/12/29 12:19:41 kristaps Exp $ */
d117 1
a117 1
	{ NULL, 0 }, /* Nd */ 
d176 2
a177 2
	{ NULL, 0 }, /* Sx */
	{ NULL, 0 }, /* Sy */
d189 1
a189 1
	{ NULL, 0 }, /* Hf */
@


1.8
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.7 2008/12/28 23:07:04 kristaps Exp $ */
d141 1
a141 1
	{ NULL, 0 }, /* At */
d188 1
a188 1
	{ NULL, 0 }, /* Bt */
d191 1
a191 1
	{ NULL, 0 }, /* Ud */
@


1.7
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.6 2008/12/28 21:25:09 kristaps Exp $ */
d146 2
a147 2
	{ NULL, 0 }, /* Bsx */
	{ NULL, 0 }, /* Bx */
d156 1
a156 1
	{ NULL, 0 }, /* Fx */
d160 2
a161 2
	{ NULL, 0 }, /* Nx */
	{ NULL, 0 }, /* Ox */
d179 1
a179 1
	{ NULL, 0 }, /* Ux */
@


1.6
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.5 2008/12/28 00:34:20 kristaps Exp $ */
d140 1
a140 1
	{ NULL, 0 }, /* Aq */
d145 1
a145 1
	{ NULL, 0 }, /* Bq */
d151 1
a151 1
	{ NULL, 0 }, /* Dq */
d165 1
a165 1
	{ NULL, 0 }, /* Pq */
d167 1
a167 1
	{ NULL, 0 }, /* Ql */
d174 1
a174 1
	{ NULL, 0 }, /* Sq */
@


1.5
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.4 2008/12/23 05:30:49 kristaps Exp $ */
d93 2
a94 2
	{ NULL, 0 }, /* D1 */
	{ NULL, 0 }, /* Dl */
d169 1
a169 1
	{ NULL, 0 }, /* Qq */
d339 2
d412 4
a415 16
		switch (mdoc->last->type) {
		case (MDOC_BLOCK):
			p->parent = mdoc->last;
			mdoc->last->child = p;
			act = "child";
			break;
		case (MDOC_HEAD):
			p->parent = mdoc->last->parent;
			mdoc->last->next = p;
			p->prev = mdoc->last;
			act = "sibling";
			break;
		default:
			abort();
			/* NOTREACHED */
		}
d417 1
d424 1
d430 1
a430 1
			p->parent = mdoc->last->parent;
d450 1
@


1.4
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.3 2008/12/17 17:18:38 kristaps Exp $ */
d92 1
a92 1
	{ NULL, 0 }, /* Pp */ 
d95 2
a96 2
	{ NULL, 0 }, /* Bd */
	{ NULL, 0 }, /* Ed */
d255 3
a257 3
	if ('.' != *buf)  {
		/* TODO. */
		return(1); 
d350 1
a350 1
		nn = "<text>";
d419 1
d444 1
@


1.3
log
@Prologue Dd and Dt macros.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.2 2008/12/15 02:23:12 kristaps Exp $ */
d89 1
a89 1
	{ NULL, 0 }, /* Os */
d97 2
a98 2
	{ NULL, 0 }, /* Bl */
	{ NULL, 0 }, /* El */
a198 3
static	void	 	 *xcalloc(size_t, size_t);
static	char	 	 *xstrdup(const char *);

d228 1
a228 1
		mdoc_hash_free(mdoc->htab);
d244 1
a244 12
	p->htab = mdoc_hash_alloc();
	return(p);
}


static void *
xcalloc(size_t num, size_t sz)
{
	void		*p;

	if (NULL == (p = calloc(num, sz)))
		err(EXIT_FAILURE, "calloc");
a248 11
static char *
xstrdup(const char *p)
{
	char		*pp;

	if (NULL == (pp = strdup(p)))
		err(EXIT_FAILURE, "strdup");
	return(pp);
}


d646 1
a646 1
	return(mdoc_hash_find(mdoc->htab, key));
@


1.2
log
@Linted.
@
text
@d1 1
a1 1
/* $Id: mdoc.c,v 1.1 2008/12/15 01:54:58 kristaps Exp $ */
a28 4
extern	int	macro_text(struct mdoc *, int, int, int *, char *);
extern	int	macro_scoped_implicit(struct mdoc *, 
			int, int, int *, char *);

d87 2
a88 2
	{ NULL, 0 }, /* Dd */
	{ NULL, 0 }, /* Dt */
d309 1
a309 6
	if (NULL == (mdoc_macros[c].fp)) {
		(void)mdoc_err(mdoc, c, 1, ERR_MACRO_NOTSUP);
		return(0);
	} 

	return((*mdoc_macros[c].fp)(mdoc, c, 1, &i, buf));
d357 3
a359 1
	} else if ( ! (MDOC_CALLABLE & mdoc_macros[tok].flags)) {
@


1.1
log
@Purged all old files in favour of new design.  Selective reintegration.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.64 2008/12/12 10:11:10 kristaps Exp $ */
d304 1
a304 1
	(void)memcpy(tmp, buf + 1, i);
d401 3
d435 3
d584 1
a584 1
	size_t		 i, j;
d590 2
a591 1
	for (i = 0; i < sz; i++)
d594 2
a595 1
			for (j = 0; j < p[i].sz; j++)
d685 1
a685 1
	size_t		 i;
d691 1
a691 1
	for (i = 0; i < dst->sz; i++)
d700 1
a700 1
	size_t		 i;
d706 1
a706 1
	for (i = 0; i < argsz; i++)
d716 1
a716 1
	size_t		 i;
d722 2
a723 1
	for (i = 0; i < sz; i++)
d733 1
a733 1
	size_t		  i;
d739 1
a739 1
	for (i = 0; i < sz; i++) 
@
