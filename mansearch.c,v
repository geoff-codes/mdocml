head	1.63;
access;
symbols
	VERSION_1_13_3:1.55
	VERSION_1_13_2:1.52
	VERSION_1_13_1:1.42;
locks; strict;
comment	@ * @;


1.63
date	2015.11.26.07.42.11;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2015.11.07.14.22.29;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2015.11.06.21.19.09;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2015.10.13.15.53.05;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2015.10.11.21.12.55;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2015.04.01.12.48.33;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2015.03.27.17.37.25;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2015.03.11.13.11.22;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2015.02.27.16.02.10;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2015.01.20.18.21.18;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2014.12.06.01.23.24;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2014.11.27.01.58.21;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2014.11.18.01.15.21;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2014.11.11.19.04.55;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2014.09.03.18.09.14;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2014.09.01.22.45.53;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2014.08.21.20.29.07;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2014.08.17.03.24.47;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2014.08.16.19.00.01;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2014.08.09.14.24.53;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2014.08.05.14.43.10;	author schwarze;	state Exp;
branches;
next	1.40;

1.40
date	2014.08.05.12.34.08;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2014.07.24.20.30.45;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2014.07.12.14.00.25;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2014.06.20.02.24.40;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2014.04.23.21.06.41;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2014.04.23.16.34.50;	author schwarze;	state Exp;
branches;
next	1.34;

1.34
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2014.04.17.19.20.01;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2014.04.16.21.36.18;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.16.00.33.47;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.15.23.51.39;	author schwarze;	state Exp;
branches;
next	1.29;

1.29
date	2014.04.15.23.48.51;	author schwarze;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.11.15.46.52;	author schwarze;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.10.02.46.21;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.09.21.50.08;	author schwarze;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.28.19.17.12;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.23.12.11.18;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2014.03.17.16.31.44;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2014.01.19.23.09.30;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.19.01.18.34;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2014.01.06.03.52.13;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.06.03.02.46;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2014.01.05.04.13.52;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.05.03.25.51;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.05.03.06.43;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2014.01.05.00.29.54;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2014.01.04.23.43.53;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2013.12.31.03.41.14;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2013.12.31.02.42.29;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2013.12.27.18.51.25;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2013.12.27.01.16.54;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2013.10.20.00.03.05;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.19.20.43.13;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.05.02.00.26;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2012.06.09.14.11.16;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.09.11.00.13;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2012.06.08.15.06.28;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2012.06.08.14.14.30;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2012.06.08.10.36.23;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.63
log
@No point in trying to go on when elementary database operations
like preparing queries or binding variables fail; that won't yield
useful results anyway but may generate huge pointless error messages.
Issue reported by deraadt@@.
@
text
@/*	$Id: mansearch.c,v 1.62 2015/11/07 14:22:29 schwarze Exp $ */
/*
 * Copyright (c) 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2013, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/mman.h>
#include <sys/types.h>

#include <assert.h>
#if HAVE_ERR
#include <err.h>
#endif
#include <errno.h>
#include <fcntl.h>
#include <getopt.h>
#include <glob.h>
#include <limits.h>
#include <regex.h>
#include <stdio.h>
#include <stdint.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sqlite3.h>
#ifndef SQLITE_DETERMINISTIC
#define SQLITE_DETERMINISTIC 0
#endif

#include "mandoc.h"
#include "mandoc_aux.h"
#include "mandoc_ohash.h"
#include "manconf.h"
#include "mansearch.h"

extern int mansearch_keymax;
extern const char *const mansearch_keynames[];

#define	SQL_BIND_TEXT(_db, _s, _i, _v) \
	do { if (SQLITE_OK != sqlite3_bind_text \
		((_s), (_i)++, (_v), -1, SQLITE_STATIC)) \
		errx((int)MANDOCLEVEL_SYSERR, "%s", sqlite3_errmsg((_db))); \
	} while (0)
#define	SQL_BIND_INT64(_db, _s, _i, _v) \
	do { if (SQLITE_OK != sqlite3_bind_int64 \
		((_s), (_i)++, (_v))) \
		errx((int)MANDOCLEVEL_SYSERR, "%s", sqlite3_errmsg((_db))); \
	} while (0)
#define	SQL_BIND_BLOB(_db, _s, _i, _v) \
	do { if (SQLITE_OK != sqlite3_bind_blob \
		((_s), (_i)++, (&_v), sizeof(_v), SQLITE_STATIC)) \
		errx((int)MANDOCLEVEL_SYSERR, "%s", sqlite3_errmsg((_db))); \
	} while (0)

struct	expr {
	regex_t		 regexp;  /* compiled regexp, if applicable */
	const char	*substr;  /* to search for, if applicable */
	struct expr	*next;    /* next in sequence */
	uint64_t	 bits;    /* type-mask */
	int		 equal;   /* equality, not subsring match */
	int		 open;    /* opening parentheses before */
	int		 and;	  /* logical AND before */
	int		 close;   /* closing parentheses after */
};

struct	match {
	uint64_t	 pageid; /* identifier in database */
	uint64_t	 bits; /* name type mask */
	char		*desc; /* manual page description */
	int		 form; /* bit field: formatted, zipped? */
};

static	void		 buildnames(const struct mansearch *,
				struct manpage *, sqlite3 *,
				sqlite3_stmt *, uint64_t,
				const char *, int form);
static	char		*buildoutput(sqlite3 *, sqlite3_stmt *,
				 uint64_t, uint64_t);
static	struct expr	*exprcomp(const struct mansearch *,
				int, char *[]);
static	void		 exprfree(struct expr *);
static	struct expr	*exprterm(const struct mansearch *, char *, int);
static	int		 manpage_compare(const void *, const void *);
static	void		 sql_append(char **sql, size_t *sz,
				const char *newstr, int count);
static	void		 sql_match(sqlite3_context *context,
				int argc, sqlite3_value **argv);
static	void		 sql_regexp(sqlite3_context *context,
				int argc, sqlite3_value **argv);
static	char		*sql_statement(const struct expr *);


int
mansearch_setup(int start)
{
	static void	*pagecache;
	int		 c;

#define	PC_PAGESIZE	1280
#define	PC_NUMPAGES	256

	if (start) {
		if (NULL != pagecache) {
			warnx("pagecache already enabled");
			return (int)MANDOCLEVEL_BADARG;
		}

		pagecache = mmap(NULL, PC_PAGESIZE * PC_NUMPAGES,
		    PROT_READ | PROT_WRITE,
		    MAP_SHARED | MAP_ANON, -1, 0);

		if (MAP_FAILED == pagecache) {
			perror("mmap");
			pagecache = NULL;
			return (int)MANDOCLEVEL_SYSERR;
		}

		c = sqlite3_config(SQLITE_CONFIG_PAGECACHE,
		    pagecache, PC_PAGESIZE, PC_NUMPAGES);

		if (SQLITE_OK == c)
			return (int)MANDOCLEVEL_OK;

		warnx("pagecache: %s", sqlite3_errstr(c));

	} else if (NULL == pagecache) {
		warnx("pagecache missing");
		return (int)MANDOCLEVEL_BADARG;
	}

	if (-1 == munmap(pagecache, PC_PAGESIZE * PC_NUMPAGES)) {
		perror("munmap");
		pagecache = NULL;
		return (int)MANDOCLEVEL_SYSERR;
	}

	pagecache = NULL;
	return (int)MANDOCLEVEL_OK;
}

int
mansearch(const struct mansearch *search,
		const struct manpaths *paths,
		int argc, char *argv[],
		struct manpage **res, size_t *sz)
{
	int64_t		 pageid;
	uint64_t	 outbit, iterbit;
	char		 buf[PATH_MAX];
	char		*sql;
	struct manpage	*mpage;
	struct expr	*e, *ep;
	sqlite3		*db;
	sqlite3_stmt	*s, *s2;
	struct match	*mp;
	struct ohash	 htab;
	unsigned int	 idx;
	size_t		 i, j, cur, maxres;
	int		 c, chdir_status, getcwd_status, indexbit;

	if (argc == 0 || (e = exprcomp(search, argc, argv)) == NULL) {
		*sz = 0;
		return 0;
	}

	cur = maxres = 0;
	*res = NULL;

	if (NULL != search->outkey) {
		outbit = TYPE_Nd;
		for (indexbit = 0, iterbit = 1;
		     indexbit < mansearch_keymax;
		     indexbit++, iterbit <<= 1) {
			if (0 == strcasecmp(search->outkey,
			    mansearch_keynames[indexbit])) {
				outbit = iterbit;
				break;
			}
		}
	} else
		outbit = 0;

	/*
	 * Remember the original working directory, if possible.
	 * This will be needed if the second or a later directory
	 * is given as a relative path.
	 * Do not error out if the current directory is not
	 * searchable: Maybe it won't be needed after all.
	 */

	if (getcwd(buf, PATH_MAX) == NULL) {
		getcwd_status = 0;
		(void)strlcpy(buf, strerror(errno), sizeof(buf));
	} else
		getcwd_status = 1;

	sql = sql_statement(e);

	/*
	 * Loop over the directories (containing databases) for us to
	 * search.
	 * Don't let missing/bad databases/directories phase us.
	 * In each, try to open the resident database and, if it opens,
	 * scan it for our match expression.
	 */

	chdir_status = 0;
	for (i = 0; i < paths->sz; i++) {
		if (chdir_status && paths->paths[i][0] != '/') {
			if ( ! getcwd_status) {
				warnx("%s: getcwd: %s", paths->paths[i], buf);
				continue;
			} else if (chdir(buf) == -1) {
				perror(buf);
				continue;
			}
		}
		if (chdir(paths->paths[i]) == -1) {
			perror(paths->paths[i]);
			continue;
		}
		chdir_status = 1;

		c = sqlite3_open_v2(MANDOC_DB, &db,
		    SQLITE_OPEN_READONLY, NULL);

		if (SQLITE_OK != c) {
			warn("%s/%s", paths->paths[i], MANDOC_DB);
			sqlite3_close(db);
			continue;
		}

		/*
		 * Define the SQL functions for substring
		 * and regular expression matching.
		 */

		c = sqlite3_create_function(db, "match", 2,
		    SQLITE_UTF8 | SQLITE_DETERMINISTIC,
		    NULL, sql_match, NULL, NULL);
		assert(SQLITE_OK == c);
		c = sqlite3_create_function(db, "regexp", 2,
		    SQLITE_UTF8 | SQLITE_DETERMINISTIC,
		    NULL, sql_regexp, NULL, NULL);
		assert(SQLITE_OK == c);

		j = 1;
		c = sqlite3_prepare_v2(db, sql, -1, &s, NULL);
		if (SQLITE_OK != c)
			errx((int)MANDOCLEVEL_SYSERR,
			    "%s", sqlite3_errmsg(db));

		for (ep = e; NULL != ep; ep = ep->next) {
			if (NULL == ep->substr) {
				SQL_BIND_BLOB(db, s, j, ep->regexp);
			} else
				SQL_BIND_TEXT(db, s, j, ep->substr);
			if (0 == ((TYPE_Nd | TYPE_Nm) & ep->bits))
				SQL_BIND_INT64(db, s, j, ep->bits);
		}

		mandoc_ohash_init(&htab, 4, offsetof(struct match, pageid));

		/*
		 * Hash each entry on its [unique] document identifier.
		 * This is a uint64_t.
		 * Instead of using a hash function, simply convert the
		 * uint64_t to a uint32_t, the hash value's type.
		 * This gives good performance and preserves the
		 * distribution of buckets in the table.
		 */
		while (SQLITE_ROW == (c = sqlite3_step(s))) {
			pageid = sqlite3_column_int64(s, 2);
			idx = ohash_lookup_memory(&htab,
			    (char *)&pageid, sizeof(uint64_t),
			    (uint32_t)pageid);

			if (NULL != ohash_find(&htab, idx))
				continue;

			mp = mandoc_calloc(1, sizeof(struct match));
			mp->pageid = pageid;
			mp->form = sqlite3_column_int(s, 1);
			mp->bits = sqlite3_column_int64(s, 3);
			if (TYPE_Nd == outbit)
				mp->desc = mandoc_strdup((const char *)
				    sqlite3_column_text(s, 0));
			ohash_insert(&htab, idx, mp);
		}

		if (SQLITE_DONE != c)
			warnx("%s", sqlite3_errmsg(db));

		sqlite3_finalize(s);

		c = sqlite3_prepare_v2(db,
		    "SELECT sec, arch, name, pageid FROM mlinks "
		    "WHERE pageid=? ORDER BY sec, arch, name",
		    -1, &s, NULL);
		if (SQLITE_OK != c)
			errx((int)MANDOCLEVEL_SYSERR,
			    "%s", sqlite3_errmsg(db));

		c = sqlite3_prepare_v2(db,
		    "SELECT bits, key, pageid FROM keys "
		    "WHERE pageid=? AND bits & ?",
		    -1, &s2, NULL);
		if (SQLITE_OK != c)
			errx((int)MANDOCLEVEL_SYSERR,
			    "%s", sqlite3_errmsg(db));

		for (mp = ohash_first(&htab, &idx);
				NULL != mp;
				mp = ohash_next(&htab, &idx)) {
			if (cur + 1 > maxres) {
				maxres += 1024;
				*res = mandoc_reallocarray(*res,
				    maxres, sizeof(struct manpage));
			}
			mpage = *res + cur;
			mpage->ipath = i;
			mpage->bits = mp->bits;
			mpage->sec = 10;
			mpage->form = mp->form;
			buildnames(search, mpage, db, s, mp->pageid,
			    paths->paths[i], mp->form);
			if (mpage->names != NULL) {
				mpage->output = TYPE_Nd & outbit ?
				    mp->desc : outbit ?
				    buildoutput(db, s2, mp->pageid, outbit) :
				    NULL;
				cur++;
			}
			free(mp);
		}

		sqlite3_finalize(s);
		sqlite3_finalize(s2);
		sqlite3_close(db);
		ohash_delete(&htab);

		/*
		 * In man(1) mode, prefer matches in earlier trees
		 * over matches in later trees.
		 */

		if (cur && search->firstmatch)
			break;
	}
	qsort(*res, cur, sizeof(struct manpage), manpage_compare);
	if (chdir_status && getcwd_status && chdir(buf) == -1)
		perror(buf);
	exprfree(e);
	free(sql);
	*sz = cur;
	return 1;
}

void
mansearch_free(struct manpage *res, size_t sz)
{
	size_t	 i;

	for (i = 0; i < sz; i++) {
		free(res[i].file);
		free(res[i].names);
		free(res[i].output);
	}
	free(res);
}

static int
manpage_compare(const void *vp1, const void *vp2)
{
	const struct manpage	*mp1, *mp2;
	int			 diff;

	mp1 = vp1;
	mp2 = vp2;
	return (diff = mp2->bits - mp1->bits) ? diff :
	    (diff = mp1->sec - mp2->sec) ? diff :
	    strcasecmp(mp1->names, mp2->names);
}

static void
buildnames(const struct mansearch *search, struct manpage *mpage,
		sqlite3 *db, sqlite3_stmt *s,
		uint64_t pageid, const char *path, int form)
{
	glob_t		 globinfo;
	char		*firstname, *newnames, *prevsec, *prevarch;
	const char	*oldnames, *sep1, *name, *sec, *sep2, *arch, *fsec;
	size_t		 i;
	int		 c, globres;

	mpage->file = NULL;
	mpage->names = NULL;
	firstname = prevsec = prevarch = NULL;
	i = 1;
	SQL_BIND_INT64(db, s, i, pageid);
	while (SQLITE_ROW == (c = sqlite3_step(s))) {

		/* Decide whether we already have some names. */

		if (NULL == mpage->names) {
			oldnames = "";
			sep1 = "";
		} else {
			oldnames = mpage->names;
			sep1 = ", ";
		}

		/* Fetch the next name, rejecting sec/arch mismatches. */

		sec = (const char *)sqlite3_column_text(s, 0);
		if (search->sec != NULL && strcasecmp(sec, search->sec))
			continue;
		arch = (const char *)sqlite3_column_text(s, 1);
		if (search->arch != NULL && *arch != '\0' &&
		    strcasecmp(arch, search->arch))
			continue;
		name = (const char *)sqlite3_column_text(s, 2);

		/* Remember the first section found. */

		if (9 < mpage->sec && '1' <= *sec && '9' >= *sec)
			mpage->sec = (*sec - '1') + 1;

		/* If the section changed, append the old one. */

		if (NULL != prevsec &&
		    (strcmp(sec, prevsec) ||
		     strcmp(arch, prevarch))) {
			sep2 = '\0' == *prevarch ? "" : "/";
			mandoc_asprintf(&newnames, "%s(%s%s%s)",
			    oldnames, prevsec, sep2, prevarch);
			free(mpage->names);
			oldnames = mpage->names = newnames;
			free(prevsec);
			free(prevarch);
			prevsec = prevarch = NULL;
		}

		/* Save the new section, to append it later. */

		if (NULL == prevsec) {
			prevsec = mandoc_strdup(sec);
			prevarch = mandoc_strdup(arch);
		}

		/* Append the new name. */

		mandoc_asprintf(&newnames, "%s%s%s",
		    oldnames, sep1, name);
		free(mpage->names);
		mpage->names = newnames;

		/* Also save the first file name encountered. */

		if (mpage->file != NULL)
			continue;

		if (form & FORM_SRC) {
			sep1 = "man";
			fsec = sec;
		} else {
			sep1 = "cat";
			fsec = "0";
		}
		sep2 = *arch == '\0' ? "" : "/";
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s",
		    path, sep1, sec, sep2, arch, name, fsec);
		if (access(mpage->file, R_OK) != -1)
			continue;

		/* Handle unusual file name extensions. */

		if (firstname == NULL)
			firstname = mpage->file;
		else
			free(mpage->file);
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.*",
		    path, sep1, sec, sep2, arch, name);
		globres = glob(mpage->file, 0, NULL, &globinfo);
		free(mpage->file);
		mpage->file = globres ? NULL :
		    mandoc_strdup(*globinfo.gl_pathv);
		globfree(&globinfo);
	}
	if (c != SQLITE_DONE)
		warnx("%s", sqlite3_errmsg(db));
	sqlite3_reset(s);

	/* If none of the files is usable, use the first name. */

	if (mpage->file == NULL)
		mpage->file = firstname;
	else if (mpage->file != firstname)
		free(firstname);

	/* Append one final section to the names. */

	if (prevsec != NULL) {
		sep2 = *prevarch == '\0' ? "" : "/";
		mandoc_asprintf(&newnames, "%s(%s%s%s)",
		    mpage->names, prevsec, sep2, prevarch);
		free(mpage->names);
		mpage->names = newnames;
		free(prevsec);
		free(prevarch);
	}
}

static char *
buildoutput(sqlite3 *db, sqlite3_stmt *s, uint64_t pageid, uint64_t outbit)
{
	char		*output, *newoutput;
	const char	*oldoutput, *sep1, *data;
	size_t		 i;
	int		 c;

	output = NULL;
	i = 1;
	SQL_BIND_INT64(db, s, i, pageid);
	SQL_BIND_INT64(db, s, i, outbit);
	while (SQLITE_ROW == (c = sqlite3_step(s))) {
		if (NULL == output) {
			oldoutput = "";
			sep1 = "";
		} else {
			oldoutput = output;
			sep1 = " # ";
		}
		data = (const char *)sqlite3_column_text(s, 1);
		mandoc_asprintf(&newoutput, "%s%s%s",
		    oldoutput, sep1, data);
		free(output);
		output = newoutput;
	}
	if (SQLITE_DONE != c)
		warnx("%s", sqlite3_errmsg(db));
	sqlite3_reset(s);
	return output;
}

/*
 * Implement substring match as an application-defined SQL function.
 * Using the SQL LIKE or GLOB operators instead would be a bad idea
 * because that would require escaping metacharacters in the string
 * being searched for.
 */
static void
sql_match(sqlite3_context *context, int argc, sqlite3_value **argv)
{

	assert(2 == argc);
	sqlite3_result_int(context, NULL != strcasestr(
	    (const char *)sqlite3_value_text(argv[1]),
	    (const char *)sqlite3_value_text(argv[0])));
}

/*
 * Implement regular expression match
 * as an application-defined SQL function.
 */
static void
sql_regexp(sqlite3_context *context, int argc, sqlite3_value **argv)
{

	assert(2 == argc);
	sqlite3_result_int(context, !regexec(
	    (regex_t *)sqlite3_value_blob(argv[0]),
	    (const char *)sqlite3_value_text(argv[1]),
	    0, NULL, 0));
}

static void
sql_append(char **sql, size_t *sz, const char *newstr, int count)
{
	size_t		 newsz;

	newsz = 1 < count ? (size_t)count : strlen(newstr);
	*sql = mandoc_realloc(*sql, *sz + newsz + 1);
	if (1 < count)
		memset(*sql + *sz, *newstr, (size_t)count);
	else
		memcpy(*sql + *sz, newstr, newsz);
	*sz += newsz;
	(*sql)[*sz] = '\0';
}

/*
 * Prepare the search SQL statement.
 */
static char *
sql_statement(const struct expr *e)
{
	char		*sql;
	size_t		 sz;
	int		 needop;

	sql = mandoc_strdup(e->equal ?
	    "SELECT desc, form, pageid, bits "
		"FROM mpages NATURAL JOIN names WHERE " :
	    "SELECT desc, form, pageid, 0 FROM mpages WHERE ");
	sz = strlen(sql);

	for (needop = 0; NULL != e; e = e->next) {
		if (e->and)
			sql_append(&sql, &sz, " AND ", 1);
		else if (needop)
			sql_append(&sql, &sz, " OR ", 1);
		if (e->open)
			sql_append(&sql, &sz, "(", e->open);
		sql_append(&sql, &sz,
		    TYPE_Nd & e->bits
		    ? (NULL == e->substr
			? "desc REGEXP ?"
			: "desc MATCH ?")
		    : TYPE_Nm == e->bits
		    ? (NULL == e->substr
			? "pageid IN (SELECT pageid FROM names "
			  "WHERE name REGEXP ?)"
			: e->equal
			? "name = ? "
			: "pageid IN (SELECT pageid FROM names "
			  "WHERE name MATCH ?)")
		    : (NULL == e->substr
			? "pageid IN (SELECT pageid FROM keys "
			  "WHERE key REGEXP ? AND bits & ?)"
			: "pageid IN (SELECT pageid FROM keys "
			  "WHERE key MATCH ? AND bits & ?)"), 1);
		if (e->close)
			sql_append(&sql, &sz, ")", e->close);
		needop = 1;
	}

	return sql;
}

/*
 * Compile a set of string tokens into an expression.
 * Tokens in "argv" are assumed to be individual expression atoms (e.g.,
 * "(", "foo=bar", etc.).
 */
static struct expr *
exprcomp(const struct mansearch *search, int argc, char *argv[])
{
	uint64_t	 mask;
	int		 i, toopen, logic, igncase, toclose;
	struct expr	*first, *prev, *cur, *next;

	first = cur = NULL;
	logic = igncase = toopen = toclose = 0;

	for (i = 0; i < argc; i++) {
		if (0 == strcmp("(", argv[i])) {
			if (igncase)
				goto fail;
			toopen++;
			toclose++;
			continue;
		} else if (0 == strcmp(")", argv[i])) {
			if (toopen || logic || igncase || NULL == cur)
				goto fail;
			cur->close++;
			if (0 > --toclose)
				goto fail;
			continue;
		} else if (0 == strcmp("-a", argv[i])) {
			if (toopen || logic || igncase || NULL == cur)
				goto fail;
			logic = 1;
			continue;
		} else if (0 == strcmp("-o", argv[i])) {
			if (toopen || logic || igncase || NULL == cur)
				goto fail;
			logic = 2;
			continue;
		} else if (0 == strcmp("-i", argv[i])) {
			if (igncase)
				goto fail;
			igncase = 1;
			continue;
		}
		next = exprterm(search, argv[i], !igncase);
		if (NULL == next)
			goto fail;
		if (NULL == first)
			first = next;
		else
			cur->next = next;
		prev = cur = next;

		/*
		 * Searching for descriptions must be split out
		 * because they are stored in the mpages table,
		 * not in the keys table.
		 */

		for (mask = TYPE_Nm; mask <= TYPE_Nd; mask <<= 1) {
			if (mask & cur->bits && ~mask & cur->bits) {
				next = mandoc_calloc(1,
				    sizeof(struct expr));
				memcpy(next, cur, sizeof(struct expr));
				prev->open = 1;
				cur->bits = mask;
				cur->next = next;
				cur = next;
				cur->bits &= ~mask;
			}
		}
		prev->and = (1 == logic);
		prev->open += toopen;
		if (cur != prev)
			cur->close = 1;

		toopen = logic = igncase = 0;
	}
	if ( ! (toopen || logic || igncase || toclose))
		return first;

fail:
	if (NULL != first)
		exprfree(first);
	return NULL;
}

static struct expr *
exprterm(const struct mansearch *search, char *buf, int cs)
{
	char		 errbuf[BUFSIZ];
	struct expr	*e;
	char		*key, *val;
	uint64_t	 iterbit;
	int		 i, irc;

	if ('\0' == *buf)
		return NULL;

	e = mandoc_calloc(1, sizeof(struct expr));

	if (search->argmode == ARG_NAME) {
		e->bits = TYPE_Nm;
		e->substr = buf;
		e->equal = 1;
		return e;
	}

	/*
	 * Separate macro keys from search string.
	 * If needed, request regular expression handling
	 * by setting e->substr to NULL.
	 */

	if (search->argmode == ARG_WORD) {
		e->bits = TYPE_Nm;
		e->substr = NULL;
#if HAVE_REWB_BSD
		mandoc_asprintf(&val, "[[:<:]]%s[[:>:]]", buf);
#elif HAVE_REWB_SYSV
		mandoc_asprintf(&val, "\\<%s\\>", buf);
#else
		mandoc_asprintf(&val,
		    "(^|[^a-zA-Z01-9_])%s([^a-zA-Z01-9_]|$)", buf);
#endif
		cs = 0;
	} else if ((val = strpbrk(buf, "=~")) == NULL) {
		e->bits = TYPE_Nm | TYPE_Nd;
		e->substr = buf;
	} else {
		if (val == buf)
			e->bits = TYPE_Nm | TYPE_Nd;
		if ('=' == *val)
			e->substr = val + 1;
		*val++ = '\0';
		if (NULL != strstr(buf, "arch"))
			cs = 0;
	}

	/* Compile regular expressions. */

	if (NULL == e->substr) {
		irc = regcomp(&e->regexp, val,
		    REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE));
		if (search->argmode == ARG_WORD)
			free(val);
		if (irc) {
			regerror(irc, &e->regexp, errbuf, sizeof(errbuf));
			warnx("regcomp: %s", errbuf);
			free(e);
			return NULL;
		}
	}

	if (e->bits)
		return e;

	/*
	 * Parse out all possible fields.
	 * If the field doesn't resolve, bail.
	 */

	while (NULL != (key = strsep(&buf, ","))) {
		if ('\0' == *key)
			continue;
		for (i = 0, iterbit = 1;
		     i < mansearch_keymax;
		     i++, iterbit <<= 1) {
			if (0 == strcasecmp(key,
			    mansearch_keynames[i])) {
				e->bits |= iterbit;
				break;
			}
		}
		if (i == mansearch_keymax) {
			if (strcasecmp(key, "any")) {
				free(e);
				return NULL;
			}
			e->bits |= ~0ULL;
		}
	}

	return e;
}

static void
exprfree(struct expr *p)
{
	struct expr	*pp;

	while (NULL != p) {
		pp = p->next;
		free(p);
		p = pp;
	}
}
@


1.62
log
@Without HAVE_ERR, don't try to include <err.h>, it probably isn't there.
In that case, the required prototypes are in "config.h".
Patch from Peter Bray <pdb_ml at yahoo dot com dot au>.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.61 2015/11/06 21:19:09 schwarze Exp $ */
d57 1
a57 1
		warnx("%s", sqlite3_errmsg((_db))); \
d62 1
a62 1
		warnx("%s", sqlite3_errmsg((_db))); \
d67 1
a67 1
		warnx("%s", sqlite3_errmsg((_db))); \
d265 2
a266 1
			warnx("%s", sqlite3_errmsg(db));
d316 2
a317 1
			warnx("%s", sqlite3_errmsg(db));
d324 2
a325 1
			warnx("%s", sqlite3_errmsg(db));
@


1.61
log
@In ./configure, select a RE syntax for word boundaries supported by libc;
issue reported by Svyatoslav Mishyn, Peter Bray, and Daniel Levai.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.60 2015/10/13 15:53:05 schwarze Exp $ */
d24 1
d26 1
@


1.60
log
@Reduce the amount of code by moving the three copies of the ohash
callback functions into one common place, preparing for the use of
ohash for some additional purposes.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.59 2015/10/11 21:12:55 schwarze Exp $ */
d769 1
d771 6
@


1.59
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, let's provide compatibility modules
for archaic systems (like commercial Solaris) that still don't have
them.  The compat module has an UCB Copyright (c) 1993...
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.58 2015/10/06 18:32:19 schwarze Exp $ */
a37 5
#if HAVE_OHASH
#include <ohash.h>
#else
#include "compat_ohash.h"
#endif
d45 1
a91 3
static	void		*hash_alloc(size_t, void *);
static	void		 hash_free(void *, void *);
static	void		*hash_calloc(size_t, size_t, void *);
a168 1
	struct ohash_info info;
a178 5
	info.calloc = hash_calloc;
	info.alloc = hash_alloc;
	info.free = hash_free;
	info.key_offset = offsetof(struct match, pageid);

d274 1
a274 2
		memset(&htab, 0, sizeof(struct ohash));
		ohash_init(&htab, 4, &info);
a841 21

static void *
hash_calloc(size_t nmemb, size_t sz, void *arg)
{

	return mandoc_calloc(nmemb, sz);
}

static void *
hash_alloc(size_t sz, void *arg)
{

	return mandoc_malloc(sz);
}

static void
hash_free(void *p, void *arg)
{

	free(p);
}
@


1.58
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.57 2015/04/01 12:48:33 schwarze Exp $ */
d24 1
d59 1
a59 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \
d64 1
a64 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \
d69 1
a69 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db))); \
d124 1
a124 1
			fprintf(stderr, "pagecache already enabled\n");
d144 1
a144 1
		fprintf(stderr, "pagecache: %s\n", sqlite3_errstr(c));
d147 1
a147 1
		fprintf(stderr, "pagecache missing\n");
d237 1
a237 2
				fprintf(stderr, "%s: getcwd: %s\n",
				    paths->paths[i], buf);
d254 1
a254 2
			fprintf(stderr, "%s/%s: %s\n",
			    paths->paths[i], MANDOC_DB, strerror(errno));
d276 1
a276 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d318 1
a318 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d327 1
a327 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d334 1
a334 1
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d515 1
a515 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d565 1
a565 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db));
d807 1
a807 1
			fprintf(stderr, "regcomp: %s\n", errbuf);
@


1.57
log
@Let man(1) and apropos(1) work even when the current directory
is unusable: Only change back to the current directory when the
directory was changed before and the next path is relative.
This is now more similar to what makewhatis(8) does.
Issue reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.56 2015/03/27 17:37:25 schwarze Exp $ */
d124 1
a124 1
			return((int)MANDOCLEVEL_BADARG);
d134 1
a134 1
			return((int)MANDOCLEVEL_SYSERR);
d141 1
a141 1
			return((int)MANDOCLEVEL_OK);
d147 1
a147 1
		return((int)MANDOCLEVEL_BADARG);
d153 1
a153 1
		return((int)MANDOCLEVEL_SYSERR);
d157 1
a157 1
	return((int)MANDOCLEVEL_OK);
d183 1
a183 1
		return(0);
d381 1
a381 1
	return(1);
d405 3
a407 3
	return(	(diff = mp2->bits - mp1->bits) ? diff :
		(diff = mp1->sec - mp2->sec) ? diff :
		strcasecmp(mp1->names, mp2->names));
d568 1
a568 1
	return(output);
d663 1
a663 1
	return(sql);
d746 1
a746 1
		return(first);
d751 1
a751 1
	return(NULL);
d764 1
a764 1
		return(NULL);
d772 1
a772 1
		return(e);
d810 1
a810 1
			return(NULL);
d815 1
a815 1
		return(e);
d837 1
a837 1
				return(NULL);
d843 1
a843 1
	return(e);
d862 1
a862 1
	return(mandoc_calloc(nmemb, sz));
d869 1
a869 1
	return(mandoc_malloc(sz));
@


1.56
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.55 2015/03/11 13:11:22 schwarze Exp $ */
a165 1
	int		 fd, rc, c, indexbit;
d179 6
d191 1
a191 2
	*sz = cur = maxres = 0;
	sql = NULL;
a192 8
	fd = -1;
	e = NULL;
	rc = 0;

	if (0 == argc)
		goto out;
	if (NULL == (e = exprcomp(search, argc, argv)))
		goto out;
d209 5
a213 4
	 * Save a descriptor to the current working directory.
	 * Since pathnames in the "paths" variable might be relative,
	 * and we'll be chdir()ing into them, we need to keep a handle
	 * on our current directory from which to start the chdir().
d216 5
a220 7
	if (NULL == getcwd(buf, PATH_MAX)) {
		perror("getcwd");
		goto out;
	} else if (-1 == (fd = open(buf, O_RDONLY, 0))) {
		perror(buf);
		goto out;
	}
d232 1
d234 11
a244 5
		if (-1 == fchdir(fd)) {
			perror(buf);
			free(*res);
			break;
		} else if (-1 == chdir(paths->paths[i])) {
d248 1
d376 2
a377 7
	rc = 1;
out:
	if (-1 != fd) {
		if (-1 == fchdir(fd))
			perror(buf);
		close(fd);
	}
d381 1
a381 1
	return(rc);
@


1.55
log
@When interpreting the -O argument as a macro name fails,
fall back to showing Nd rather than not showing anything.
Issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.54 2015/02/27 16:02:10 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d49 1
a49 1
#include "manpath.h"
@


1.54
log
@When man(1) and apropos(1) look for a file man1/foo.1 but it's unavailable,
fall back to glob(man1/foo.*), which is more like what old man(1) did.
Do this both for file names from the database and for fs_lookup().
This is relevant because some ports install files like man1/xset.1x.
Regression reported by patrick keshishian <pkeshish at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.53 2015/01/20 18:21:18 schwarze Exp $ */
a197 1
	outbit = 0;
d199 1
d209 2
a210 1
	}
@


1.53
log
@Make the man(1) and apropos(1) options -s and -S much less expensive:
Do not append an SQL clause looking into the large "keys" table.
Instead, filter the result of the SQL query in buildnames() where
equivalent data from the much smaller "mlinks" table is already
available for free.

This is relevant because man(1) uses the equivalent of "-S ${MACHINE}"
by default since main.c rev. 1.216, to make sure that manuals for
the current architecture are shown.  With many ports installed, this
patch can speed up man(1) by a factor of more than a hundred.

Slowness reported by Theo Buehler <theo at math dot ethz dot ch>, thanks!
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.52 2014/12/06 01:23:24 schwarze Exp $ */
d27 1
d416 2
a417 1
	char		*newnames, *prevsec, *prevarch;
d420 1
a420 1
	int		 c;
d424 1
a424 1
	prevsec = prevarch = NULL;
d499 16
d520 7
@


1.52
log
@When opening mandoc.db fails, tell the user in which directory.
Improving an unhelpful error message reported by millert@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.51 2014/11/27 01:58:21 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d88 2
a89 1
static	void		 buildnames(struct manpage *, sqlite3 *,
a99 2
static	struct expr	*exprspec(struct expr *, uint64_t,
				 const char *, const char *);
d345 1
a345 1
			buildnames(mpage, db, s, mp->pageid,
d347 7
a353 4
			mpage->output = TYPE_Nd & outbit ?
			    mp->desc : outbit ?
			    buildoutput(db, s2, mp->pageid, outbit) : NULL;

a354 1
			cur++;
d411 2
a412 1
buildnames(struct manpage *mpage, sqlite3 *db, sqlite3_stmt *s,
d437 1
a437 1
		/* Fetch the next name. */
d440 2
d443 3
d655 1
a655 2
	logic = igncase = toclose = 0;
	toopen = NULL != search->sec || NULL != search->arch;
d721 2
a722 11
	if (toopen || logic || igncase || toclose)
		goto fail;

	if (NULL != search->sec || NULL != search->arch)
		cur->close++;
	if (NULL != search->arch)
		cur = exprspec(cur, TYPE_arch, search->arch, "^(%s|any)$");
	if (NULL != search->sec)
		exprspec(cur, TYPE_sec, search->sec, "^%s$");

	return(first);
a730 23
exprspec(struct expr *cur, uint64_t key, const char *value,
		const char *format)
{
	char	 errbuf[BUFSIZ];
	char	*cp;
	int	 irc;

	mandoc_asprintf(&cp, format, value);
	cur->next = mandoc_calloc(1, sizeof(struct expr));
	cur = cur->next;
	cur->and = 1;
	cur->bits = key;
	if (0 != (irc = regcomp(&cur->regexp, cp,
	    REG_EXTENDED | REG_NOSUB | REG_ICASE))) {
		regerror(irc, &cur->regexp, errbuf, sizeof(errbuf));
		fprintf(stderr, "regcomp: %s\n", errbuf);
		cur->substr = value;
	}
	free(cp);
	return(cur);
}

static struct expr *
@


1.51
log
@Make makewhatis(8) understand .so links to .gz pages.
Drop the FORM_GZ annotation in the mpages table; it is conceptually wrong
because it ought to be in the mlinks table: An uncompressed .so link file
can point to a compressed manual page file and vice versa.
Besides, it is no longer needed because mparse_open() handles it all.
Sprinkle some KNF while here.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.50 2014/11/18 01:15:21 schwarze Exp $ */
d24 1
d250 2
a251 1
			perror(MANDOC_DB);
@


1.50
log
@In man(1) mode, prefer file name matches over .Dt name matches over
first .Nm entries over other NAME .Nm entries over SYNOPSIS .Nm entries.
For example, this makes sure "man ypbind" does not return yp(8).
Re-run "makewhatis" to profit from this change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.49 2014/11/11 19:04:55 schwarze Exp $ */
a412 1
	const char	*gzip;
d475 1
a475 1
		if (NULL != mpage->file)
d485 3
a487 7
		if (form & FORM_GZ)
			gzip = ".gz";
		else
			gzip = "";
		sep2 = '\0' == *arch ? "" : "/";
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s%s",
		    path, sep1, sec, sep2, arch, name, fsec, gzip);
d489 1
a489 1
	if (SQLITE_DONE != c)
d495 2
a496 2
	if (NULL != prevsec) {
		sep2 = '\0' == *prevarch ? "" : "/";
@


1.49
log
@In man(1) mode without -a, stop searching after the first manual tree
that contained at least one match in order to not prefer mdoc(1) from
ports over mdoc(7).  As a bonus, this results in a speedup.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.48 2014/09/03 18:09:14 schwarze Exp $ */
d82 1
d305 1
d341 1
d402 3
a404 2
	diff = mp1->sec - mp2->sec;
	return(diff ? diff : strcasecmp(mp1->names, mp2->names));
d599 4
a602 2
	sql = mandoc_strdup(
	    "SELECT desc, form, pageid FROM mpages WHERE ");
d622 1
a622 2
			? "pageid IN (SELECT pageid FROM names "
			  "WHERE name = ?)"
@


1.48
log
@If a manual page is installed gzip(1)ed, let makewhatis(8) take
note in mandoc.db(5), such that man(1) -w and apropos(1) -w can
report the correct filename.
This is a prerequisite for letting apropos -a and man support
gzip'ed manuals in the future, which doesn't work yet.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.47 2014/09/01 22:45:53 schwarze Exp $ */
d355 8
@


1.47
log
@In man(1) mode, change to the right directory before starting the parser,
just like traditional man(1) does, such that .so links have a chance to
work.  After this point, we don't need the current directory for anything
else before exit, so we don't need to worry about getting back and we can
safely ignore failure.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.46 2014/08/21 20:29:07 schwarze Exp $ */
d83 1
a83 1
	int		 form; /* 0 == catpage */
d401 1
d467 1
a467 1
		if (form) {
d474 4
d479 2
a480 2
		mandoc_asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s",
		    path, sep1, sec, sep2, arch, name, fsec);
@


1.46
log
@Bugfix: make whatis(1) case-insensitive again.
The traditional whatis(1) was case-insensitve and it's still documented
that way, but that apparently got broken with or after the switch.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.45 2014/08/17 03:24:47 schwarze Exp $ */
d338 1
@


1.45
log
@Fully integrate apropos(1) into mandoc(1).
Switch the argmode on the progname, including man(1).
Provide -f and -k options to switch the argmode.
Store the argmode inside struct search, generalizing the flags.
Derive the deftype from the argmode when needed instead of storing it.
Store the outkey inside struct search instead of passing it alone.
While here, get rid of the trailing blanks in Makefile.depend.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.44 2014/08/16 19:00:01 schwarze Exp $ */
d771 1
@


1.44
log
@Improve build system and autodetection.
* Make ./configure standalone, that's what people expect.
* Let people write a ./configure.local from scratch, not edit existing files.
* Autodetect wchar, sqlite3, and manpath and act accordingly.
* Autodetect the need for -L/usr/local/lib and -lutil.
* Get rid of config.h.p{re,ost}, let ./configure only write what's needed.
* Let ./configure write a Makefile.local snippet, that's quite flexible.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.43 2014/08/10 23:54:41 schwarze Exp $ */
a161 1
		const char *outkey,
d197 1
a197 1
	if (NULL != outkey) {
d201 1
a201 1
			if (0 == strcasecmp(outkey,
d369 13
d754 2
a755 2
	if (MANSEARCH_MAN & search->flags) {
		e->bits = search->deftype;
d762 3
a764 2
	 * Look for an '=' or '~' operator,
	 * unless forced to some fixed macro keys.
d767 6
a772 7
	if (MANSEARCH_WHATIS & search->flags)
		val = NULL;
	else
		val = strpbrk(buf, "=~");

	if (NULL == val) {
		e->bits = search->deftype;
a773 6

	/*
	 * Found an operator.
	 * Regexp search is requested by !e->substr.
	 */

d776 1
a776 1
			e->bits = search->deftype;
a785 5
	if (MANSEARCH_WHATIS & search->flags) {
		e->substr = NULL;
		mandoc_asprintf(&val, "[[:<:]]%s[[:>:]]", buf);
	}

d789 1
a789 1
		if (MANSEARCH_WHATIS & search->flags)
@


1.43
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.42 2014/08/09 14:24:53 schwarze Exp $ */
d35 1
a35 1
#ifdef HAVE_OHASH
@


1.42
log
@mmap(2) requires MAP_PRIVATE ^ MAP_SHARED for flags;
found by kristaps@@ on Mac OS X
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.41 2014/08/05 14:43:10 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
d21 2
@


1.41
log
@Absurdly, the return value of sqlite3_column_text()
is "const unsigned char *", which causes warnings with GCC on Linux.
Explicitly cast to "const char *" to avoid this.
Issue noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.40 2014/08/05 12:34:08 schwarze Exp $ */
d126 2
a127 1
		    PROT_READ | PROT_WRITE, MAP_ANON, -1, 0);
@


1.40
log
@If an old SQLite version doesn't provide SQLITE_DETERMINISTIC,
simply ignore it, as using it is merely an optimization.
Issue noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.39 2014/07/24 20:30:45 schwarze Exp $ */
d305 1
a305 1
				mp->desc = mandoc_strdup(
d409 3
a411 3
		sec = sqlite3_column_text(s, 0);
		arch = sqlite3_column_text(s, 1);
		name = sqlite3_column_text(s, 2);
d500 1
a500 1
		data = sqlite3_column_text(s, 1);
@


1.39
log
@Sort result pages first by section number, then by name.
By moving the sort from cgi.c to mansearch.c, we get two advantages:
Easier access to the data needed for sorting, in particular the section
number, and the apropos(1) command line utility profits as well.

Feature requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.38 2014/07/12 14:00:25 schwarze Exp $ */
d41 3
@


1.38
log
@Fix whatis(1) to correctly match words instead of any substrings.
While here, also provide an internal mode (MANSEARCH_MAN) to match
complete names, to be used by man.cgi(8).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.37 2014/06/20 02:24:40 schwarze Exp $ */
d97 1
d335 1
d352 1
d366 12
d410 5
@


1.37
log
@Merge from OpenBSD - Marc Espie improved the ohash interface:
* rename the halloc callback to calloc, provide overflow protection
* rename the hfree callback to free, drop the useless size argument
* prevent integer overflows in ohash_resize
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.36 2014/04/23 21:06:41 schwarze Exp $ */
d67 3
d71 1
a71 2
	const char	*substr;  /* to search for, if applicable */
	regex_t		 regexp;  /* compiled regexp, if applicable */
a74 1
	struct expr	*next;    /* next in sequence */
d565 3
d709 1
a709 1
	char		*key, *v;
d718 2
a719 3
	/*"whatis" mode uses an opaque string and default fields. */

	if (MANSEARCH_WHATIS & search->flags) {
d721 1
a721 1
		e->bits = search->deftype;
d726 2
a727 3
	 * If no =~ is specified, search with equality over names and
	 * descriptions.
	 * If =~ begins the phrase, use name and description fields.
d730 7
a736 1
	if (NULL == (v = strpbrk(buf, "=~"))) {
a737 4
		e->bits = search->deftype;
		return(e);
	} else if (v == buf)
		e->bits = search->deftype;
d739 11
a749 1
	if ('~' == *v++) {
d752 15
a766 2
		if (0 != (irc = regcomp(&e->regexp, v,
		    REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE)))) {
d772 4
a775 3
	} else
		e->substr = v;
	v[-1] = '\0';
@


1.36
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.35 2014/04/23 16:34:50 schwarze Exp $ */
d88 2
a89 2
static	void		 hash_free(void *, size_t, void *);
static	void		*hash_halloc(size_t, void *);
d174 1
a174 3
	memset(&info, 0, sizeof(struct ohash_info));

	info.halloc = hash_halloc;
d176 1
a176 1
	info.hfree = hash_free;
d791 1
a791 1
hash_halloc(size_t sz, void *arg)
d794 1
a794 1
	return(mandoc_calloc(1, sz));
d805 1
a805 1
hash_free(void *p, size_t sz, void *arg)
@


1.35
log
@improve SQL style: avoid "SELECT *", be explicit in what columns we want;
suggested by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.34 2014/04/20 16:46:05 schwarze Exp $ */
d331 2
a332 2
				*res = mandoc_realloc(*res,
				    maxres * sizeof(struct manpage));
d796 1
a796 1
	return(mandoc_calloc(sz, 1));
@


1.34
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.33 2014/04/17 19:20:01 schwarze Exp $ */
d313 2
a314 2
		    "SELECT * FROM mlinks WHERE pageid=?"
		    " ORDER BY sec, arch, name",
d320 2
a321 1
		    "SELECT * FROM keys WHERE pageid=? AND bits & ?",
d546 2
a547 1
	sql = mandoc_strdup("SELECT * FROM mpages WHERE ");
@


1.33
log
@Garbage collect one pair of needless parentheses in SQL code generation;
note this doesn't affect performance, SQLite generates the same byte code.
While here, make the calls to exprspec() easier to understand.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.32 2014/04/16 21:36:18 schwarze Exp $ */
d67 1
a67 1
	uint64_t 	 bits;    /* type-mask */
d90 1
a90 1
static	struct expr	*exprcomp(const struct mansearch *, 
d104 1
d239 1
a239 1
		} 
d241 2
a242 3
		c =  sqlite3_open_v2
			(MANDOC_DB, &db, 
			 SQLITE_OPEN_READONLY, NULL);
d291 3
a293 3
			idx = ohash_lookup_memory
				(&htab, (char *)&pageid,
				 sizeof(uint64_t), (uint32_t)pageid);
d312 1
a312 1
		c = sqlite3_prepare_v2(db, 
d330 2
a331 2
				*res = mandoc_realloc
					(*res, maxres * sizeof(struct manpage));
@


1.32
log
@Rename the mpages.id column to mpages.pageid.  There is no good reason
to call this kid by a different name here than in all other tables.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.31 2014/04/16 00:33:47 schwarze Exp $ */
d593 1
a593 1
	toopen = 1;
d662 6
a667 3
	cur->close++;
	cur = exprspec(cur, TYPE_arch, search->arch, "^(%s|any)$");
	exprspec(cur, TYPE_sec, search->sec, "^%s$");
a684 3
	if (NULL == value)
		return(cur);

@


1.31
log
@Pass the function flags SQLITE_UTF8 (because SQLITE_ANY is deprecated)
and SQLITE_DETERMINISTIC when creating deterministic functions;
best practice measure suggested by espie@@ and jeremy@@;
as expected by jeremy@@, no measurable effect on performance.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.30 2014/04/15 23:51:39 schwarze Exp $ */
d77 1
a77 1
	uint64_t	 id; /* identifier in database */
d159 1
a159 1
	int64_t		 id;
d178 1
a178 1
	info.key_offset = offsetof(struct match, id);
d290 1
a290 1
			id = sqlite3_column_int64(s, 2);
d292 2
a293 2
				(&htab, (char *)&id,
				 sizeof(uint64_t), (uint32_t)id);
d299 1
a299 1
			mp->id = id;
d335 1
a335 1
			buildnames(mpage, db, s, mp->id,
d339 1
a339 1
			    buildoutput(db, s2, mp->id, outbit) : NULL;
d365 1
a365 1
		uint64_t id, const char *path, int form)
d376 1
a376 1
	SQL_BIND_INT64(db, s, i, id);
d458 1
a458 1
buildoutput(sqlite3 *db, sqlite3_stmt *s, uint64_t id, uint64_t outbit)
d467 1
a467 1
	SQL_BIND_INT64(db, s, i, id);
d562 1
a562 1
			? "id IN (SELECT pageid FROM names "
d564 1
a564 1
			: "id IN (SELECT pageid FROM names "
d567 1
a567 1
			? "id IN (SELECT pageid FROM keys "
d569 1
a569 1
			: "id IN (SELECT pageid FROM keys "
@


1.30
log
@Oops, sorry, revert previous and commit the correct patch:
At the end of mansearch(), fchdir() back to where we started from.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.29 2014/04/15 23:48:51 schwarze Exp $ */
d256 2
a257 1
		    SQLITE_ANY, NULL, sql_match, NULL, NULL);
d260 2
a261 1
		    SQLITE_ANY, NULL, sql_regexp, NULL, NULL);
@


1.29
log
@At the end of mansearch(), fchdir() back to where we started from;
this is cleaner and helps to not scatter gmon.out files all over
the place when profiling.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.28 2014/04/11 15:46:52 schwarze Exp $ */
d213 1
a213 1
		perror(NULL);
a220 1
	printf("%s\n", sql);
d350 5
a355 2
	if (-1 != fd)
		close(fd);
@


1.28
log
@Further apropos(1) speed optimization was trickier than anticipated.
Contrary to what i initially thought, almost all time is now spent
inside sqlite3(3) routines, and i found no easy way calling less of them.
However, sqlite(3) spends substantial time in malloc(3), and even more
(twice that) in its immediate malloc wrapper, sqlite3MemMalloc(),
keeping track of all individual malloc chunk sizes.  Typically about
90% of the malloced memory is used for purposes of the pagecache.

By providing an mmap(3) MAP_ANON SQLITE_CONFIG_PAGECACHE, execution
time decreases by 20-25% for simple (Nd and/or Nm) queries, 10-20% for
non-NAME queries, and even apropos(1) resident memory size as reported
by top(1) decreases by 20% for simple and by 60% for non-NAME queries.
The new function, mansearch_setup(), spends no measurable time.

The pagesize chosen is optimal:
* Substantially smaller pages yield no gain at all.
* Larger pages provide no additional benefit and just waste memory.

The chosen number of pages in the cache is a compromise:
* For simple queries, a handful of pages would suffice to get the full
speed effect, at an apropos(1) resident memory size of about 2.0 MB.
* For non-NAME queries, a large pagecache with 2k pages (2.5 MB) might
gain a few more percent in speed, but at the expense of doubling the
apropos(1) resident memory size for *all* queries.
* The chosen number of 256 pages (330 kB) allows nearly full speed gain
for all queries at the price of a 15% resident memory size increase.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.27 2014/04/10 02:46:21 schwarze Exp $ */
d221 1
@


1.27
log
@Next speed optimization step for the new apropos(1).
Split manual names out of the common "keys" table into their
own "names" table.  This reduces standard apropos(1) search
times (i.e. searching for names and descriptions only) by
typically about 70% for the full /usr/share/man database.
(Yes, that multiplies with the previous optimization step,
so both together have reduced search times by a factor of
more than six.  I'm not done yet, expect more to come.)

Even with the minimal databases built with makewhatis(8) -Q,
this step still reduces search times by 15-20%.  For both cases,
database sizes and build times hardly change (+/-2%).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.26 2014/04/09 21:50:08 schwarze Exp $ */
d22 1
d105 47
@


1.26
log
@After careful gprof(1)ing of the new apropos(1), move the descriptions
back from the keys table to the mpages table:  I found a good way
to still use them in searches, without complication of the code.

On my notebook, this reduces typical apropos(1) search times by about 40%,
it reduces /usr/share/man database size by 6% in makewhatis(8) -Q mode
and by 2% in standard mode (less overhead storing pointers to mpages),
and it doesn't measurably change database build times (may even be
going down by a percent or so because less data is being copied
around in ohashes).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.25 2014/03/28 19:17:12 schwarze Exp $ */
d224 1
a224 1
			if (0 == (TYPE_Nd & ep->bits))
d507 6
d534 1
d536 1
a536 1
	struct expr	*first, *next, *cur;
d579 1
d587 15
a601 7
		if (TYPE_Nd & next->bits && ~TYPE_Nd & next->bits) {
			cur = mandoc_calloc(1, sizeof(struct expr));
			memcpy(cur, next, sizeof(struct expr));
			next->open = 1;
			next->bits = TYPE_Nd;
			next->next = cur;
			cur->bits &= ~TYPE_Nd;
d603 1
a603 4
		} else
			cur = next;
		next->and = (1 == logic);
		next->open += toopen;
@


1.25
log
@Properly initialize malloc(3)ed memory.
With this bug fix, partly unitialized memory could sometimes be
returned, sometimes causing crashes by bogus free(3)s in apropos(1).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.24 2014/03/23 12:11:18 schwarze Exp $ */
d77 1
d224 2
a225 1
			SQL_BIND_INT64(db, s, j, ep->bits);
d240 1
a240 1
			id = sqlite3_column_int64(s, 1);
d242 1
a242 1
				(&htab, (char *)&id, 
d250 4
a253 1
			mp->form = sqlite3_column_int(s, 0);
d287 2
a288 1
			mpage->output = outbit ?
d502 10
a511 5
		sql_append(&sql, &sz, NULL == e->substr ?
		    "id IN (SELECT pageid FROM keys "
		    "WHERE key REGEXP ? AND bits & ?)" :
		    "id IN (SELECT pageid FROM keys "
		    "WHERE key MATCH ? AND bits & ?)", 1);
d568 3
a570 3
		next->open = toopen;
		next->and = (1 == logic);
		if (NULL != first) {
d572 16
d589 2
a590 2
		} else
			cur = first = next;
@


1.24
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.23 2014/03/23 11:25:26 schwarze Exp $ */
d313 1
@


1.23
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.22 2014/03/17 16:31:44 schwarze Exp $ */
d341 2
a342 5
			if (-1 == asprintf(&newnames, "%s(%s%s%s)",
			    oldnames, prevsec, sep2, prevarch)) {
				perror(0);
				exit((int)MANDOCLEVEL_SYSERR);
			}
d359 2
a360 5
		if (-1 == asprintf(&newnames, "%s%s%s",
		    oldnames, sep1, name)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d377 2
a378 5
		if (-1 == asprintf(&mpage->file, "%s/%s%s%s%s/%s.%s",
		    path, sep1, sec, sep2, arch, name, fsec)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d388 2
a389 5
		if (-1 == asprintf(&newnames, "%s(%s%s%s)",
		    mpage->names, prevsec, sep2, prevarch)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d418 2
a419 5
		if (-1 == asprintf(&newoutput, "%s%s%s",
		    oldoutput, sep1, data)) {
			perror(0);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d591 1
a591 4
	if (-1 == asprintf(&cp, format, value)) {
		perror(0);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.22
log
@in apropos(1) output, sort names and avoid multiple section numbers
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.21 2014/01/19 23:09:30 schwarze Exp $ */
d42 1
@


1.21
log
@Always compare arch case-insensitively.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.20 2014/01/19 01:18:34 schwarze Exp $ */
d257 2
a258 1
		    "SELECT * FROM mlinks WHERE pageid=?",
d307 1
a307 1
	char		*newnames;
d313 1
d318 1
a318 1
		/* Assemble the list of names. */
d327 3
d333 30
a362 3
		sep2 = '\0' == *arch ? "" : "/";
		if (-1 == asprintf(&newnames, "%s%s%s(%s%s%s)",
		    oldnames, sep1, name, sec, sep2, arch)) {
d381 1
d391 15
@


1.20
log
@Get rid of the local keys table, use the new mansearch_const.c.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.19 2014/01/06 03:52:13 schwarze Exp $ */
d611 2
@


1.19
log
@Remove the redundant "file" column from the "mlinks" table.
The contents can easily be reconstructed from sec, arch, name, form.
Shrinks the database by another 3% in standard mode and 9% in -Q mode.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.18 2014/01/06 03:02:46 schwarze Exp $ */
d45 3
a78 51
struct	type {
	uint64_t	 bits;
	const char	*name;
};

static	const struct type types[] = {
	{ TYPE_An,  "An" },
	{ TYPE_Ar,  "Ar" },
	{ TYPE_At,  "At" },
	{ TYPE_Bsx, "Bsx" },
	{ TYPE_Bx,  "Bx" },
	{ TYPE_Cd,  "Cd" },
	{ TYPE_Cm,  "Cm" },
	{ TYPE_Dv,  "Dv" },
	{ TYPE_Dx,  "Dx" },
	{ TYPE_Em,  "Em" },
	{ TYPE_Er,  "Er" },
	{ TYPE_Ev,  "Ev" },
	{ TYPE_Fa,  "Fa" },
	{ TYPE_Fl,  "Fl" },
	{ TYPE_Fn,  "Fn" },
	{ TYPE_Fn,  "Fo" },
	{ TYPE_Ft,  "Ft" },
	{ TYPE_Fx,  "Fx" },
	{ TYPE_Ic,  "Ic" },
	{ TYPE_In,  "In" },
	{ TYPE_Lb,  "Lb" },
	{ TYPE_Li,  "Li" },
	{ TYPE_Lk,  "Lk" },
	{ TYPE_Ms,  "Ms" },
	{ TYPE_Mt,  "Mt" },
	{ TYPE_Nd,  "Nd" },
	{ TYPE_Nm,  "Nm" },
	{ TYPE_Nx,  "Nx" },
	{ TYPE_Ox,  "Ox" },
	{ TYPE_Pa,  "Pa" },
	{ TYPE_Rs,  "Rs" },
	{ TYPE_Sh,  "Sh" },
	{ TYPE_Ss,  "Ss" },
	{ TYPE_St,  "St" },
	{ TYPE_Sy,  "Sy" },
	{ TYPE_Tn,  "Tn" },
	{ TYPE_Va,  "Va" },
	{ TYPE_Va,  "Vt" },
	{ TYPE_Xr,  "Xr" },
	{ TYPE_sec, "sec" },
	{ TYPE_arch,"arch" },
	{ ~0ULL,    "any" },
	{ 0ULL, NULL }
};

d108 1
a108 1
	int		 fd, rc, c, ibit;
d110 1
a110 1
	uint64_t	 outbit;
d144 6
a149 3
		for (ibit = 0; types[ibit].bits; ibit++) {
			if (0 == strcasecmp(types[ibit].name, outkey)) {
				outbit = types[ibit].bits;
d581 2
a582 2
	size_t		 i;
	int		 irc;
d630 15
a644 7
		i = 0;
		while (types[i].bits && 
			strcasecmp(types[i].name, key))
			i++;
		if (0 == types[i].bits) {
			free(e);
			return(NULL);
a645 1
		e->bits |= types[i].bits;
@


1.18
log
@Drop Nd from the mpages table, it is still in the keys table.
This shrinks the database in standard mode by 3%, in -Q mode by 9%,
without loss of functionality.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.17 2014/01/05 04:13:52 schwarze Exp $ */
d128 2
a129 1
				sqlite3_stmt *, uint64_t, const char *);
d323 2
a324 1
			buildnames(mpage, db, s, mp->id, paths->paths[i]);
d349 1
a349 1
		uint64_t id, const char *path)
d352 1
a352 1
	const char	*oldnames, *sep1, *name, *sec, *sep2, *arch;
d370 3
a372 3
		sec = sqlite3_column_text(s, 1);
		arch = sqlite3_column_text(s, 2);
		name = sqlite3_column_text(s, 3);
d387 9
a395 2
		name = sqlite3_column_text(s, 0);
		if (-1 == asprintf(&mpage->file, "%s/%s", path, name)) {
@


1.17
log
@Remove the obsolete file name column from the mpages table.
This column wasn't helpful because one manpage can have multiple MLINKS.
Use the file name column in the mlinks table, instead.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.16 2014/01/05 03:25:51 schwarze Exp $ */
a72 1
	char		*desc; /* description of manpage */
d281 1
a281 1
			id = sqlite3_column_int64(s, 2);
d291 1
a291 3
			mp->desc = mandoc_strdup
				((char *)sqlite3_column_text(s, 0));
			mp->form = sqlite3_column_int(s, 1);
a320 1
			mpage->desc = mp->desc;
@


1.16
log
@Remove the obsolete sec and arch columns from the mpages table.
They were confusing because a manpage can have MLINKS in different
sections and architectures.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.15 2014/01/05 03:06:43 schwarze Exp $ */
a72 1
	char		*file; /* relative filepath of manpage */
d128 2
a129 1
static	char		*buildnames(sqlite3 *, sqlite3_stmt *, uint64_t);
d282 1
a282 1
			id = sqlite3_column_int64(s, 3);
d292 1
a292 1
			mp->file = mandoc_strdup
d294 1
a294 3
			mp->desc = mandoc_strdup
				((char *)sqlite3_column_text(s, 1));
			mp->form = sqlite3_column_int(s, 2);
a323 5
			if (-1 == asprintf(&mpage->file, "%s/%s",
			    paths->paths[i], mp->file)) {
				perror(0);
				exit((int)MANDOCLEVEL_SYSERR);
			}
d326 1
a326 1
			mpage->names = buildnames(db, s, mp->id);
a329 1
			free(mp->file);
d349 3
a351 2
static char *
buildnames(sqlite3 *db, sqlite3_stmt *s, uint64_t id)
d353 1
a353 1
	char		*names, *newnames;
d358 1
a358 1
	names = NULL;
d362 4
a365 1
		if (NULL == names) {
d369 1
a369 1
			oldnames = names;
d381 13
a393 2
		free(names);
		names = newnames;
a397 1
	return(names);
@


1.15
log
@Reimplement apropos -s NUM -S ARCH EXPR by internally converting it to
apropos \( EXPR \) -a 'sec~^NUM$' -a 'arch~^(ARCH|any)$'
in preparation for removal of sec and arch from the mpage table.

Almost no functional change except for the following bonus:
This also makes sure that for cross-section and cross-arch MLINKs,
all of the following work:
apropos -s 1 encrypt
apropos -s 8 encrypt
apropos -s 1 makekey
apropos -s 8 makekey

While here, print error messages about invalid regexps to stderr.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.14 2014/01/05 00:29:54 schwarze Exp $ */
d282 1
a282 1
			id = sqlite3_column_int64(s, 5);
d295 2
a296 2
				((char *)sqlite3_column_text(s, 3));
			mp->form = sqlite3_column_int(s, 4);
@


1.14
log
@Put section and architecture info into the keys table,
in preparation for removing them from the mpages table,
aiming for cleaner and more uniform interfaces.
Database growth is below 4%, part of which will be reclaimed.

As a bonus, this allows searches like:
./obj/apropos An=kettenis -a arch=ppc
./obj/apropos An=kettenis -a sec~[^4]
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.13 2014/01/04 23:43:53 schwarze Exp $ */
d138 2
d147 1
a147 2
static	char		*sql_statement(const struct expr *,
				const char *, const char *);
d215 1
a215 1
	sql = sql_statement(e, search->arch, search->sec);
a261 5
		if (NULL != search->arch)
			SQL_BIND_TEXT(db, s, j, search->arch);
		if (NULL != search->sec)
			SQL_BIND_TEXT(db, s, j, search->sec);

d479 1
a479 1
sql_statement(const struct expr *e, const char *arch, const char *sec)
a487 6
	if (NULL != arch)
		sql_append(&sql, &sz, "arch = ? AND ", 1);
	if (NULL != sec)
		sql_append(&sql, &sz, "sec = ? AND ", 1);
	sql_append(&sql, &sz, "(", 1);

a503 1
	sql_append(&sql, &sz, ")", 1);
d520 2
a521 1
	toopen = logic = igncase = toclose = 0;
d565 9
a573 2
	if ( ! (toopen || logic || igncase || toclose))
		return(first);
d581 29
d612 1
d616 1
d645 4
a648 2
		if (regcomp(&e->regexp, v,
		    REG_EXTENDED | REG_NOSUB | (cs ? 0 : REG_ICASE))) {
@


1.13
log
@New implementation of complex search criteria using \(, \), -a because
the old implementation got lost in the Berkeley to SQLite switch.
Note that this is not just feature creep, but required for upcoming
database format cleanup and simplification.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.12 2013/12/31 03:41:14 schwarze Exp $ */
d123 2
@


1.12
log
@Experimental feature to let apropos(1) show different keys than .Nd.
This really takes us beyond what grep -R /usr/*/man/ can do
because now you can search for pages by *one* criterion and then
display the contents of *another* macro from those pages, like in
$ apropos -O Ox Fa~wchar
to get an impression how long wide character handling is available.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.11 2013/12/31 02:42:29 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2013 Ingo Schwarze <schwarze@@openbsd.org>
d65 3
d137 2
d284 1
a284 1
			id = sqlite3_column_int64(s, 0);
d295 2
d298 1
a298 3
			mp->desc = mandoc_strdup
				((char *)sqlite3_column_text(s, 4));
			mp->form = sqlite3_column_int(s, 5);
d462 15
a478 2
 * We search for any of the words specified in our match expression.
 * We filter the per-doc AND expressions when collecting results.
a483 6
	const char	*substr = "(key MATCH ? AND bits & ?)";
	const char	*regexp = "(key REGEXP ? AND bits & ?)";
	const char	*andarch = "arch = ? AND ";
	const char	*andsec = "sec = ? AND ";
	size_t	 	 substrsz;
	size_t	 	 regexpsz;
d485 1
d487 1
a487 5
	sql = mandoc_strdup
		("SELECT pageid,bits,key,file,desc,form,sec,arch "
		 "FROM keys "
		 "INNER JOIN mpages ON mpages.id=keys.pageid "
		 "WHERE ");
a488 2
	substrsz = strlen(substr);
	regexpsz = strlen(regexp);
d490 21
a510 22
	if (NULL != arch) {
		sz += strlen(andarch) + 1;
		sql = mandoc_realloc(sql, sz);
		strlcat(sql, andarch, sz);
	}

	if (NULL != sec) {
		sz += strlen(andsec) + 1;
		sql = mandoc_realloc(sql, sz);
		strlcat(sql, andsec, sz);
	}

	sz += 2;
	sql = mandoc_realloc(sql, sz);
	strlcat(sql, "(", sz);

	for ( ; NULL != e; e = e->next) {
		sz += (NULL == e->substr ? regexpsz : substrsz) + 
			(NULL == e->next ? 3 : 5);
		sql = mandoc_realloc(sql, sz);
		strlcat(sql, NULL == e->substr ? regexp : substr, sz);
		strlcat(sql, NULL == e->next ? ");" : " OR ", sz);
d512 1
d525 1
a525 1
	int		 i, cs;
d529 1
d532 28
a559 10
		if (0 == strcmp("-i", argv[i])) {
			if (++i >= argc)
				return(NULL);
			cs = 0;
		} else
			cs = 1;
		next = exprterm(search, argv[i], cs);
		if (NULL == next) {
			exprfree(first);
			return(NULL);
d561 5
d571 1
d573 6
a578 2

	return(first);
@


1.11
log
@Split buildnames() out of mansearch(); the latter function is getting
too long and unwieldy, but will grow more code soon.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.10 2013/12/27 18:51:25 schwarze Exp $ */
d125 2
d143 3
a145 2
		const struct manpaths *paths, 
		int argc, char *argv[], 
d148 1
a148 1
	int		 fd, rc, c;
d150 1
d156 1
a156 1
	sqlite3_stmt	*s;
d182 10
d308 6
d331 2
d340 1
d391 35
@


1.10
log
@Change the mansearch() interface to use the mlinks table in the database
and return a list of names with sections, used by apropos(1) for display.
While here, improve uniformity of the interface by allocating the file
name dynamically, just like the names list and the description.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.9 2013/12/27 01:16:54 schwarze Exp $ */
d124 1
d148 1
a148 2
	char		*sql, *newnames;
	const char	*oldnames, *sep1, *name, *sec, *sep2, *arch;
a307 1
			mpage->names = NULL;
d310 1
a310 27

			j = 1;
			SQL_BIND_INT64(db, s, j, mp->id);
			while (SQLITE_ROW == (c = sqlite3_step(s))) {
				if (NULL == mpage->names) {
					oldnames = "";
					sep1 = "";
				} else {
					oldnames = mpage->names;
					sep1 = ", ";
				}
				sec = sqlite3_column_text(s, 1);
				arch = sqlite3_column_text(s, 2);
				name = sqlite3_column_text(s, 3);
				sep2 = '\0' == *arch ? "" : "/";
				if (-1 == asprintf(&newnames,
				    "%s%s%s(%s%s%s)", oldnames, sep1,
				    name, sec, sep2, arch)) {
					perror(0);
					exit((int)MANDOCLEVEL_SYSERR);
				}
				free(mpage->names);
				mpage->names = newnames;
			}
			if (SQLITE_DONE != c)
				fprintf(stderr, "%s\n", sqlite3_errmsg(db));
			sqlite3_reset(s);
d331 37
@


1.9
log
@Add an additional mlinks table to the database, redundant for now,
both because it contains nothing but a subset of the data of the
existing mpages table and because the relationship of mpage and mlink
entries is still 1:1.  But all that will eventually change.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.8 2013/10/20 00:03:05 schwarze Exp $ */
d147 3
a149 1
	char		*sql;
d287 6
a292 1
		sqlite3_close(db);
d302 37
a338 6
			strlcpy((*res)[cur].file, 
				paths->paths[i], PATH_MAX);
			strlcat((*res)[cur].file, "/", PATH_MAX);
			strlcat((*res)[cur].file, mp->file, PATH_MAX);
			(*res)[cur].desc = mp->desc;
			(*res)[cur].form = mp->form;
d343 3
@


1.8
log
@Fix another regression introduced when switching from DB to SQLite:
The ~ operator has to do regular expression search, not globbing.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.7 2013/10/19 20:43:13 schwarze Exp $ */
d366 1
a366 1
		("SELECT docid,bits,key,file,desc,form,sec,arch "
d368 1
a368 1
		 "INNER JOIN docs ON docs.id=keys.docid "
@


1.7
log
@Fix a regression introduced when switching from DB to SQLite:
The = operator has to do substring search, not word search.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.6 2013/06/05 02:00:26 schwarze Exp $ */
d26 1
d46 1
a46 1
	if (SQLITE_OK != sqlite3_bind_text \
d48 2
a49 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db)))
d51 1
a51 1
	if (SQLITE_OK != sqlite3_bind_int64 \
d53 7
a59 1
		fprintf(stderr, "%s\n", sqlite3_errmsg((_db)))
d62 4
a65 4
	int		 glob; /* is glob? */
	uint64_t 	 bits; /* type-mask */
	const char	*v; /* search value */
	struct expr	*next; /* next in sequence */
d130 1
a130 1
static	struct expr	*exprterm(const struct mansearch *, char *);
d133 2
d221 4
a224 1
		/* Define the SQL function for substring matching. */
d228 4
a231 4
		if (SQLITE_OK != c) {
			fprintf(stderr, "%s\n", sqlite3_errmsg(db));
			break;
		}
d244 4
a247 1
			SQL_BIND_TEXT(db, s, j, ep->v);
d334 15
d358 1
a358 1
	const char	*glob = "(key GLOB ? AND bits & ?)";
d362 1
a362 1
	size_t	 	 globsz;
d372 1
a372 1
	globsz = strlen(glob);
d391 1
a391 1
		sz += (e->glob ? globsz : substrsz) + 
d394 1
a394 1
		strlcat(sql, e->glob ? glob : substr, sz);
d409 1
a409 1
	int		 i;
d415 7
a421 1
		next = exprterm(search, argv[i]);
d437 1
a437 1
exprterm(const struct mansearch *search, char *buf)
d451 1
a451 1
		e->v = buf;
d463 1
a463 1
		e->v = buf;
d469 9
a477 3
	e->glob = '~' == *v;
	*v++ = '\0';
	e->v = v;
@


1.6
log
@Some places used PATH_MAX from <limits.h>, some MAXPATHLEN from <sys/param.h>.
Consistently use the PATH_MAX since it is specified by POSIX,
while MAXPATHLEN is not.
In preparation for using this at a few more places.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.5 2012/06/09 14:11:16 kristaps Exp $ */
d4 1
d123 2
d211 9
d302 16
d326 1
a327 1
	const char	*eq = "(key = ? AND bits & ?)";
d330 1
a331 1
	size_t	 	 eqsz;
d340 1
a341 1
	eqsz = strlen(eq);
d360 1
a360 1
		sz += (e->glob ? globsz : eqsz) + 
d363 1
a363 1
		strlcat(sql, e->glob ? glob : eq, sz);
@


1.5
log
@Merge whatis.1 into apropos.1 (and remove), add whatis bits to apropos
(via mansearch), and merge mandocdb.h into mansearch.h (and remove).
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.4 2012/06/09 11:00:13 kristaps Exp $ */
a20 2
#include <sys/param.h>

d24 1
d133 1
a133 1
	char		 buf[MAXPATHLEN];
d170 1
a170 1
	if (NULL == getcwd(buf, MAXPATHLEN)) {
d268 3
a270 3
				paths->paths[i], MAXPATHLEN);
			strlcat((*res)[cur].file, "/", MAXPATHLEN);
			strlcat((*res)[cur].file, mp->file, MAXPATHLEN);
@


1.4
log
@Add a compatibility interface for ohash.
This include's espie@@'s wholesale src/lib/libc/ohash directory from OpenBSD
into compat_ohash.c (with a single copyright/license notice at the top)
and src/include/ohash.h as compat_ohash.h.
The ohash_int.h part of compat_ohash.c has been changed only in that ohash.h
points to compat_ohash.h.
Added HAVE_OHASH test (test-ohash.c) to Makefile.
In mandocdb.c and mansearch.c, check HAVE_OHASH test for inclusion.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.3 2012/06/08 15:06:28 kristaps Exp $ */
a41 1
#include "mandocdb.h"
d119 2
a120 1
static	struct expr	*exprcomp(int, char *[]);
d122 1
a122 1
static	struct expr	*exprterm(char *);
d127 2
a128 2
mansearch(const struct manpaths *paths, 
		const char *arch, const char *sec,
d161 1
a161 1
	if (NULL == (e = exprcomp(argc, argv)))
d179 1
a179 1
	sql = sql_statement(e, arch, sec);
d214 4
a217 4
		if (NULL != arch)
			SQL_BIND_TEXT(db, s, j, arch);
		if (NULL != sec)
			SQL_BIND_TEXT(db, s, j, arch);
d349 1
a349 1
exprcomp(int argc, char *argv[])
d357 1
a357 1
		next = exprterm(argv[i]);
d373 1
a373 1
exprterm(char *buf)
d384 8
d400 1
a400 1
		e->bits = TYPE_Nm | TYPE_Nd;
d403 1
a403 1
		e->bits = TYPE_Nm | TYPE_Nd;
@


1.3
log
@Turn off sqlite3 synchronous mode when creating a new database.
This makes it run about 5x faster.
While here, wrap some sqlite3 statements in #defines to extract errors.
(Really, the warning/error/etc. macros should be functionified.)
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.2 2012/06/08 14:14:30 kristaps Exp $ */
d33 1
d35 3
@


1.2
log
@Allow mansearch to fail if invariancy (cwd) is violated.  Also be more
verbose if sqlite3 errors occur.
@
text
@d1 1
a1 1
/*	$Id: mansearch.c,v 1.1 2012/06/08 10:36:23 kristaps Exp $ */
d41 1
a41 1
#define	BIND_TEXT(_db, _s, _i, _v) \
d45 1
a45 1
#define	BIND_INT64(_db, _s, _i, _v) \
d211 1
a211 1
			BIND_TEXT(db, s, j, arch);
d213 1
a213 1
			BIND_TEXT(db, s, j, arch);
d216 2
a217 2
			BIND_TEXT(db, s, j, ep->v);
			BIND_INT64(db, s, j, ep->bits);
@


1.1
log
@Add a new mansearch.h interface, which replaces apropos_db.c
This is a much more minimal interface that stuffs all operations into
a single function.
It uses sqlite3 and ohash.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.46 2012/03/23 06:52:17 kristaps Exp $ */
d41 9
d128 1
a128 1
	int		 fd, rc;
d148 1
a148 1
	*sz = 0;
d153 1
a153 1
	cur = maxres = 0;
a186 1
			/* FIXME: will return success */
d195 3
a197 2
		rc =  sqlite3_open_v2
			(MANDOC_DB, &db, SQLITE_OPEN_READONLY, NULL);
d199 1
a199 1
		if (SQLITE_OK != rc) {
d206 3
a208 1
		sqlite3_prepare_v2(db, sql, -1, &s, NULL);
d211 1
a211 2
			sqlite3_bind_text
				(s, j++, arch, -1, SQLITE_STATIC);
d213 1
a213 2
			sqlite3_bind_text
				(s, j++, sec, -1, SQLITE_STATIC);
d216 2
a217 4
			sqlite3_bind_text
				(s, j++, ep->v, -1, SQLITE_STATIC);
			sqlite3_bind_int64
				(s, j++, ep->bits);
d231 1
a231 1
		while (SQLITE_ROW == sqlite3_step(s)) {
d250 3
d276 1
d283 1
a283 1
	return(1);
d299 2
a300 2
	const size_t	 globsz = 27;
	const size_t	 eqsz = 22;
d309 2
d317 1
@
