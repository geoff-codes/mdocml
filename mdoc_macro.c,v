head	1.206;
access;
symbols
	VERSION_1_13_3:1.183
	VERSION_1_13_2:1.157
	VERSION_1_12_4:1.141
	VERSION_1_13_1:1.139
	VERSION_1_12_3:1.125
	VERSION_1_12_2:1.122
	VERSION_1_12:1.141.0.2
	VERSION_1_12_1:1.115
	VERSION_1_12_0:1.111
	VERSION_1_11_7:1.110
	VERSION_1_11_6:1.110
	VERSION_1_11_5:1.109
	VERSION_1_11_4:1.109
	VERSION_1_11_3:1.109
	VERSION_1_11_2:1.109
	VERSION_1_11_1:1.106
	VERSION_1_10_10:1.103
	VERSION_1_10_9:1.99
	VERSION_1_10_8:1.99
	VERSION_1_10_7:1.98
	VERSION_1_10_6:1.94
	VERSION_1_10_5:1.93
	VERSION_1_10_5_PREPDF:1.93
	VERSION_1_10_4:1.92
	VERSION_1_10_3:1.82
	VERSION_1_10_2:1.80
	VERSION_1_10_1:1.79
	VERSION_1_9_24:1.58
	VERSION_1_9_25:1.61
	VERSION_1_9_23:1.52
	VERSION_1_9_22:1.49
	VERSION_1_9_21:1.46
	VERSION_1_9_20:1.46
	VERSION_1_9_19:1.42
	VERSION_1_9_18:1.42
	VERSION_1_9_17:1.42
	VERSION_1_9_16:1.42
	VERSION_1_9_15:1.42
	VERSION_1_9_15-pre2:1.40
	VERSION_1_9_15-pre1:1.39
	VERSION_1_9_14:1.38
	VERSION_1_9_13:1.38
	VERSION_1_9_12:1.38
	VERSION_1_9_11:1.37
	VERSION_1_9_10:1.37
	VERSION_1_9_9:1.36
	VERSION_1_9_8:1.36
	VERSION_1_9_7:1.36
	VERSION_1_9_6:1.36
	VERSION_1_9_5:1.36
	VERSION_1_9_2:1.33
	VERSION_1_9_1:1.33
	VERSION_1_9_0:1.30
	VERSION_1_8_5:1.27
	VERSION_1_8_4:1.27
	VERSION_1_8_3:1.25
	VERSION_1_8_2:1.24
	VERSION_1_8_1:1.23
	VERSION_1_8_0:1.19
	VERSION_1_7_24:1.18
	VERSION_1_7_23:1.17
	VERSION_1_7_22:1.14
	VERSION_1_7_21:1.14
	VERSION_1_7_20:1.14
	VERSION_1_7_19:1.14
	VERSION_1_7_17:1.12
	VERSION_1_7_16:1.12
	VERSION_1_7_15:1.12
	VERSION_1_7_14:1.9
	VERSION_1_7_13:1.8
	VERSION_1_7_12:1.6
	OPENBSD_CHECKIN:1.6
	VERSION_1_7_10:1.6
	VERSION_1_7_5:1.2;
locks; strict;
comment	@ * @;


1.206
date	2015.10.20.02.01.32;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2015.10.17.00.21.07;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2015.10.15.22.27.24;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2015.10.12.00.08.15;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2015.05.01.16.58.33;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2015.05.01.16.02.47;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2015.05.01.15.27.54;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2015.04.29.21.58.32;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2015.04.29.14.48.53;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2015.04.23.15.35.59;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2015.04.21.16.14.25;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2015.04.19.14.57.38;	author schwarze;	state Exp;
branches;
next	1.192;

1.192
date	2015.04.19.14.25.41;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2015.04.19.14.00.19;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2015.04.19.13.50.26;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2015.04.18.16.06.40;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2015.04.05.23.04.41;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2015.04.05.22.44.20;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2015.04.05.14.43.36;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2015.04.02.21.36.50;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2015.02.12.12.24.33;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2015.02.11.13.37.57;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2015.02.10.17.47.45;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2015.02.07.16.42.33;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2015.02.06.07.13.14;	author schwarze;	state Exp;
branches;
next	1.178;

1.178
date	2015.02.06.03.38.45;	author schwarze;	state Exp;
branches;
next	1.177;

1.177
date	2015.02.06.01.07.22;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2015.02.05.01.46.56;	author schwarze;	state Exp;
branches;
next	1.175;

1.175
date	2015.02.05.00.14.13;	author schwarze;	state Exp;
branches;
next	1.174;

1.174
date	2015.02.04.22.30.10;	author schwarze;	state Exp;
branches;
next	1.173;

1.173
date	2015.02.04.18.03.47;	author schwarze;	state Exp;
branches;
next	1.172;

1.172
date	2015.02.03.18.22.05;	author schwarze;	state Exp;
branches;
next	1.171;

1.171
date	2015.02.03.01.14.12;	author schwarze;	state Exp;
branches;
next	1.170;

1.170
date	2015.02.03.00.48.47;	author schwarze;	state Exp;
branches;
next	1.169;

1.169
date	2015.02.02.19.23.23;	author schwarze;	state Exp;
branches;
next	1.168;

1.168
date	2015.02.02.18.26.32;	author schwarze;	state Exp;
branches;
next	1.167;

1.167
date	2015.02.02.15.02.49;	author schwarze;	state Exp;
branches;
next	1.166;

1.166
date	2015.02.02.04.26.44;	author schwarze;	state Exp;
branches;
next	1.165;

1.165
date	2015.02.02.04.04.45;	author schwarze;	state Exp;
branches;
next	1.164;

1.164
date	2015.02.01.23.56.37;	author schwarze;	state Exp;
branches;
next	1.163;

1.163
date	2015.02.01.17.30.45;	author schwarze;	state Exp;
branches;
next	1.162;

1.162
date	2015.02.01.16.47.39;	author schwarze;	state Exp;
branches;
next	1.161;

1.161
date	2014.12.22.23.27.32;	author schwarze;	state Exp;
branches;
next	1.160;

1.160
date	2014.12.20.02.26.57;	author schwarze;	state Exp;
branches;
next	1.159;

1.159
date	2014.12.18.20.58.32;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2014.12.18.03.10.11;	author schwarze;	state Exp;
branches;
next	1.157;

1.157
date	2014.12.13.13.14.39;	author schwarze;	state Exp;
branches;
next	1.156;

1.156
date	2014.11.30.05.29.00;	author schwarze;	state Exp;
branches;
next	1.155;

1.155
date	2014.11.30.02.36.38;	author schwarze;	state Exp;
branches;
next	1.154;

1.154
date	2014.11.29.04.31.35;	author schwarze;	state Exp;
branches;
next	1.153;

1.153
date	2014.11.29.03.37.44;	author schwarze;	state Exp;
branches;
next	1.152;

1.152
date	2014.11.28.23.21.32;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2014.11.28.04.47.03;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2014.11.28.03.14.18;	author schwarze;	state Exp;
branches;
next	1.149;

1.149
date	2014.11.28.01.05.43;	author schwarze;	state Exp;
branches;
next	1.148;

1.148
date	2014.11.27.22.27.56;	author schwarze;	state Exp;
branches;
next	1.147;

1.147
date	2014.11.26.19.22.51;	author schwarze;	state Exp;
branches;
next	1.146;

1.146
date	2014.11.25.20.00.01;	author schwarze;	state Exp;
branches;
next	1.145;

1.145
date	2014.11.20.00.31.28;	author schwarze;	state Exp;
branches;
next	1.144;

1.144
date	2014.11.17.06.44.58;	author schwarze;	state Exp;
branches;
next	1.143;

1.143
date	2014.09.07.00.05.28;	author schwarze;	state Exp;
branches;
next	1.142;

1.142
date	2014.08.21.12.57.17;	author schwarze;	state Exp;
branches;
next	1.141;

1.141
date	2014.08.16.19.50.37;	author schwarze;	state Exp;
branches;
next	1.140;

1.140
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.139;

1.139
date	2014.08.01.17.27.44;	author schwarze;	state Exp;
branches;
next	1.138;

1.138
date	2014.07.30.17.06.26;	author schwarze;	state Exp;
branches;
next	1.137;

1.137
date	2014.07.07.21.36.20;	author schwarze;	state Exp;
branches;
next	1.136;

1.136
date	2014.07.04.16.12.08;	author schwarze;	state Exp;
branches;
next	1.135;

1.135
date	2014.07.02.20.19.11;	author schwarze;	state Exp;
branches;
next	1.134;

1.134
date	2014.07.02.11.43.20;	author schwarze;	state Exp;
branches;
next	1.133;

1.133
date	2014.07.02.08.21.39;	author schwarze;	state Exp;
branches;
next	1.132;

1.132
date	2014.07.02.03.48.07;	author schwarze;	state Exp;
branches;
next	1.131;

1.131
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.130;

1.130
date	2014.03.30.19.47.48;	author schwarze;	state Exp;
branches;
next	1.129;

1.129
date	2014.01.21.10.26.53;	author schwarze;	state Exp;
branches;
next	1.128;

1.128
date	2014.01.20.11.28.29;	author schwarze;	state Exp;
branches;
next	1.127;

1.127
date	2013.12.31.23.23.11;	author schwarze;	state Exp;
branches;
next	1.126;

1.126
date	2013.12.31.22.40.12;	author schwarze;	state Exp;
branches;
next	1.125;

1.125
date	2013.12.24.20.45.27;	author schwarze;	state Exp;
branches;
next	1.124;

1.124
date	2013.12.24.19.11.46;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2013.10.21.23.47.58;	author schwarze;	state Exp;
branches;
next	1.122;

1.122
date	2013.09.15.18.26.46;	author schwarze;	state Exp;
branches;
next	1.121;

1.121
date	2012.11.19.22.30.58;	author schwarze;	state Exp;
branches;
next	1.120;

1.120
date	2012.11.18.00.05.35;	author schwarze;	state Exp;
branches;
next	1.119;

1.119
date	2012.11.17.00.26.33;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2012.11.16.13.40.36;	author schwarze;	state Exp;
branches;
next	1.117;

1.117
date	2012.07.18.16.20.43;	author schwarze;	state Exp;
branches;
next	1.116;

1.116
date	2012.05.27.17.39.28;	author schwarze;	state Exp;
branches;
next	1.115;

1.115
date	2012.01.05.00.43.51;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2012.01.02.15.48.05;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2011.12.03.23.59.14;	author schwarze;	state Exp;
branches;
next	1.112;

1.112
date	2011.10.16.12.20.34;	author schwarze;	state Exp;
branches;
next	1.111;

1.111
date	2011.09.18.14.14.15;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2011.08.10.14.07.23;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2011.04.30.10.18.24;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.25.00.03.07;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2011.04.19.16.38.48;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2011.03.22.14.33.05;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2011.03.22.14.05.45;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2011.03.20.16.02.05;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2011.03.17.11.30.23;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2011.03.17.09.16.38;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.25.15.17.18;	author kristaps;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.12.17.00.07;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2010.12.15.23.39.40;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.06.11.01.19;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2010.11.30.13.04.14;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2010.11.29.13.02.47;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2010.10.01.21.51.13;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.26.20.22.28;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.18.17.00.26;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.04.22.04.04;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.02.10.53.28;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.01.22.35.54;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.01.21.12.00;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.01.15.38.56;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.01.14.28.12;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.30.04.05.02;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.29.19.45.06;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.29.19.24.14;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.29.19.20.38;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.27.15.52.41;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.26.16.07.08;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.19.20.46.28;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.31.23.49.16;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.31.22.39.55;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.31.15.42.09;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.31.11.52.06;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.31.10.28.04;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.30.22.56.02;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2010.05.30.21.50.23;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.30.21.41.46;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.30.21.28.30;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.29.18.47.54;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.26.09.35.35;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.15.08.54.04;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2010.05.15.06.48.13;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2010.05.15.04.47.38;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.14.14.09.13;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.14.13.31.20;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.14.12.55.22;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2010.05.13.11.34.45;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2010.05.13.06.22.11;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.09.10.17.02;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2010.05.08.07.30.19;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.07.06.05.38;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2010.05.07.05.54.09;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2010.05.07.05.48.29;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.07.05.39.35;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.07.05.34.56;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.06.07.17.51;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2010.04.05.08.45.29;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2010.04.05.08.38.37;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.31.08.04.57;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.31.07.42.04;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2010.03.31.07.13.53;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2010.03.30.08.24.01;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.30.06.52.08;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2010.03.29.19.45.42;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2010.03.29.19.28.04;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2010.02.17.19.28.11;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.30.08.42.20;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.01.17.14.29;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.01.13.17.58;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.26.17.05.44;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.24.05.52.13;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.20.17.24.57;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.16.20.49.06;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.16.14.40.56;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.20.08.59.12;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.19.14.09.33;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.19.11.58.32;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.13.11.43.24;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.29.08.52.24;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.29.08.46.06;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.25.16.03.03;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.24.12.17.25;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.21.15.53.47;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.19.21.26.27;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.19.09.17.42;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.19.08.28.48;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.17.12.08.08;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.07.17.10.56.57;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.07.12.16.34.16;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.07.11.47.17;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.07.09.29.15;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.06.13.04.52;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.06.09.21.24;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.17.19.02.26;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.16.19.45.51;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.12.09.18.00;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.11.20.02.37;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.11.19.56.14;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.10.20.18.43;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.04.12.19.19.57;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.04.02.06.51.44;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.03.31.13.50.19;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.03.27.14.56.15;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.03.27.13.44.24;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.03.23.15.41.09;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.03.23.14.22.11;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.206
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@/*	$Id: mdoc_macro.c,v 1.205 2015/10/17 00:21:07 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010, 2012-2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libmdoc.h"

static	void		blk_full(MACRO_PROT_ARGS);
static	void		blk_exp_close(MACRO_PROT_ARGS);
static	void		blk_part_exp(MACRO_PROT_ARGS);
static	void		blk_part_imp(MACRO_PROT_ARGS);
static	void		ctx_synopsis(MACRO_PROT_ARGS);
static	void		in_line_eoln(MACRO_PROT_ARGS);
static	void		in_line_argn(MACRO_PROT_ARGS);
static	void		in_line(MACRO_PROT_ARGS);
static	void		phrase_ta(MACRO_PROT_ARGS);

static	void		append_delims(struct roff_man *, int, int *, char *);
static	void		dword(struct roff_man *, int, int, const char *,
				enum mdelim, int);
static	int		find_pending(struct roff_man *, int, int, int,
				struct roff_node *);
static	int		lookup(struct roff_man *, int, int, int, const char *);
static	int		macro_or_word(MACRO_PROT_ARGS, int);
static	int		parse_rest(struct roff_man *, int, int, int *, char *);
static	int		rew_alt(int);
static	void		rew_elem(struct roff_man *, int);
static	void		rew_last(struct roff_man *, const struct roff_node *);
static	void		rew_pending(struct roff_man *,
				const struct roff_node *);

const	struct mdoc_macro __mdoc_macros[MDOC_MAX] = {
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ap */
	{ in_line_eoln, MDOC_PROLOGUE }, /* Dd */
	{ in_line_eoln, MDOC_PROLOGUE }, /* Dt */
	{ in_line_eoln, MDOC_PROLOGUE }, /* Os */
	{ blk_full, MDOC_PARSED | MDOC_JOIN }, /* Sh */
	{ blk_full, MDOC_PARSED | MDOC_JOIN }, /* Ss */
	{ in_line_eoln, 0 }, /* Pp */
	{ blk_part_imp, MDOC_PARSED | MDOC_JOIN }, /* D1 */
	{ blk_part_imp, MDOC_PARSED | MDOC_JOIN }, /* Dl */
	{ blk_full, MDOC_EXPLICIT }, /* Bd */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Ed */
	{ blk_full, MDOC_EXPLICIT }, /* Bl */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* El */
	{ blk_full, MDOC_PARSED | MDOC_JOIN }, /* It */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ad */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* An */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ar */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Cd */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Cm */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Dv */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Er */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ev */
	{ in_line_eoln, 0 }, /* Ex */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fa */
	{ in_line_eoln, 0 }, /* Fd */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fl */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fn */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ft */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ic */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* In */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Li */
	{ blk_full, MDOC_JOIN }, /* Nd */
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Op */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ot */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Pa */
	{ in_line_eoln, 0 }, /* Rv */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* St */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Va */
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Xr */
	{ in_line_eoln, MDOC_JOIN }, /* %A */
	{ in_line_eoln, MDOC_JOIN }, /* %B */
	{ in_line_eoln, MDOC_JOIN }, /* %D */
	{ in_line_eoln, MDOC_JOIN }, /* %I */
	{ in_line_eoln, MDOC_JOIN }, /* %J */
	{ in_line_eoln, 0 }, /* %N */
	{ in_line_eoln, MDOC_JOIN }, /* %O */
	{ in_line_eoln, 0 }, /* %P */
	{ in_line_eoln, MDOC_JOIN }, /* %R */
	{ in_line_eoln, MDOC_JOIN }, /* %T */
	{ in_line_eoln, 0 }, /* %V */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Ac */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Ao */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Aq */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* At */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Bc */
	{ blk_full, MDOC_EXPLICIT }, /* Bf */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Bo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Bq */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Bsx */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Bx */
	{ in_line_eoln, 0 }, /* Db */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Dc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Do */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Dq */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Ec */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Ef */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Em */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Eo */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Fx */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ms */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* No */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_IGNDELIM | MDOC_JOIN }, /* Ns */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Nx */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ox */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Pc */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_IGNDELIM }, /* Pf */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Po */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Pq */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Qc */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ql */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Qo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Qq */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Re */
	{ blk_full, MDOC_EXPLICIT }, /* Rs */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Sc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* So */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Sq */
	{ in_line_argn, 0 }, /* Sm */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Sx */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Sy */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Tn */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ux */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Xc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Xo */
	{ blk_full, MDOC_EXPLICIT | MDOC_CALLABLE }, /* Fo */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Fc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Oo */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Oc */
	{ blk_full, MDOC_EXPLICIT }, /* Bk */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_JOIN }, /* Ek */
	{ in_line_eoln, 0 }, /* Bt */
	{ in_line_eoln, 0 }, /* Hf */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fr */
	{ in_line_eoln, 0 }, /* Ud */
	{ in_line, 0 }, /* Lb */
	{ in_line_eoln, 0 }, /* Lp */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Lk */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Mt */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Brq */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_EXPLICIT | MDOC_JOIN }, /* Bro */
	{ blk_exp_close, MDOC_CALLABLE | MDOC_PARSED |
			 MDOC_EXPLICIT | MDOC_JOIN }, /* Brc */
	{ in_line_eoln, MDOC_JOIN }, /* %C */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Es */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* En */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Dx */
	{ in_line_eoln, MDOC_JOIN }, /* %Q */
	{ in_line_eoln, 0 }, /* br */
	{ in_line_eoln, 0 }, /* sp */
	{ in_line_eoln, 0 }, /* %U */
	{ phrase_ta, MDOC_CALLABLE | MDOC_PARSED | MDOC_JOIN }, /* Ta */
	{ in_line_eoln, MDOC_PROLOGUE }, /* ll */
};

const	struct mdoc_macro * const mdoc_macros = __mdoc_macros;


/*
 * This is called at the end of parsing.  It must traverse up the tree,
 * closing out open [implicit] scopes.  Obviously, open explicit scopes
 * are errors.
 */
void
mdoc_endparse(struct roff_man *mdoc)
{
	struct roff_node *n;

	/* Scan for open explicit scopes. */

	n = mdoc->last->flags & MDOC_VALID ?
	    mdoc->last->parent : mdoc->last;

	for ( ; n; n = n->parent)
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT)
			mandoc_msg(MANDOCERR_BLK_NOEND, mdoc->parse,
			    n->line, n->pos, mdoc_macronames[n->tok]);

	/* Rewind to the first. */

	rew_last(mdoc, mdoc->first);
	mdoc_state_reset(mdoc);
}

/*
 * Look up the macro at *p called by "from",
 * or as a line macro if from == TOKEN_NONE.
 */
static int
lookup(struct roff_man *mdoc, int from, int line, int ppos, const char *p)
{
	int	 res;

	if (mdoc->flags & MDOC_PHRASEQF) {
		mdoc->flags &= ~MDOC_PHRASEQF;
		return TOKEN_NONE;
	}
	if (from == TOKEN_NONE || mdoc_macros[from].flags & MDOC_PARSED) {
		res = mdoc_hash_find(p);
		if (res != TOKEN_NONE) {
			if (mdoc_macros[res].flags & MDOC_CALLABLE)
				return res;
			if (res != MDOC_br && res != MDOC_sp && res != MDOC_ll)
				mandoc_msg(MANDOCERR_MACRO_CALL,
				    mdoc->parse, line, ppos, p);
		}
	}
	return TOKEN_NONE;
}

/*
 * Rewind up to and including a specific node.
 */
static void
rew_last(struct roff_man *mdoc, const struct roff_node *to)
{

	if (to->flags & MDOC_VALID)
		return;

	while (mdoc->last != to) {
		mdoc_state(mdoc, mdoc->last);
		mdoc->last->flags |= MDOC_VALID | MDOC_ENDED;
		mdoc->last = mdoc->last->parent;
	}
	mdoc_state(mdoc, mdoc->last);
	mdoc->last->flags |= MDOC_VALID | MDOC_ENDED;
	mdoc->next = ROFF_NEXT_SIBLING;
}

/*
 * Rewind up to a specific block, including all blocks that broke it.
 */
static void
rew_pending(struct roff_man *mdoc, const struct roff_node *n)
{

	for (;;) {
		rew_last(mdoc, n);

		if (mdoc->last == n) {
			switch (n->type) {
			case ROFFT_HEAD:
				roff_body_alloc(mdoc, n->line, n->pos,
				    n->tok);
				return;
			case ROFFT_BLOCK:
				break;
			default:
				return;
			}
			if ( ! (n->flags & MDOC_BROKEN))
				return;
		} else
			n = mdoc->last;

		for (;;) {
			if ((n = n->parent) == NULL)
				return;

			if (n->type == ROFFT_BLOCK ||
			    n->type == ROFFT_HEAD) {
				if (n->flags & MDOC_ENDED)
					break;
				else
					return;
			}
		}
	}
}

/*
 * For a block closing macro, return the corresponding opening one.
 * Otherwise, return the macro itself.
 */
static int
rew_alt(int tok)
{
	switch (tok) {
	case MDOC_Ac:
		return MDOC_Ao;
	case MDOC_Bc:
		return MDOC_Bo;
	case MDOC_Brc:
		return MDOC_Bro;
	case MDOC_Dc:
		return MDOC_Do;
	case MDOC_Ec:
		return MDOC_Eo;
	case MDOC_Ed:
		return MDOC_Bd;
	case MDOC_Ef:
		return MDOC_Bf;
	case MDOC_Ek:
		return MDOC_Bk;
	case MDOC_El:
		return MDOC_Bl;
	case MDOC_Fc:
		return MDOC_Fo;
	case MDOC_Oc:
		return MDOC_Oo;
	case MDOC_Pc:
		return MDOC_Po;
	case MDOC_Qc:
		return MDOC_Qo;
	case MDOC_Re:
		return MDOC_Rs;
	case MDOC_Sc:
		return MDOC_So;
	case MDOC_Xc:
		return MDOC_Xo;
	default:
		return tok;
	}
}

static void
rew_elem(struct roff_man *mdoc, int tok)
{
	struct roff_node *n;

	n = mdoc->last;
	if (n->type != ROFFT_ELEM)
		n = n->parent;
	assert(n->type == ROFFT_ELEM);
	assert(tok == n->tok);
	rew_last(mdoc, n);
}

/*
 * If there is an open sub-block of the target requiring
 * explicit close-out, postpone closing out the target until
 * the rew_pending() call closing out the sub-block.
 */
static int
find_pending(struct roff_man *mdoc, int tok, int line, int ppos,
	struct roff_node *target)
{
	struct roff_node	*n;
	int			 irc;

	irc = 0;
	for (n = mdoc->last; n != NULL && n != target; n = n->parent) {
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
			continue;
		}
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
			irc = 1;
			n->flags = MDOC_BROKEN;
			if (target->type == ROFFT_HEAD)
				target->flags = MDOC_ENDED;
			else if ( ! (target->flags & MDOC_ENDED)) {
				mandoc_vmsg(MANDOCERR_BLK_NEST,
				    mdoc->parse, line, ppos,
				    "%s breaks %s", mdoc_macronames[tok],
				    mdoc_macronames[n->tok]);
				mdoc_endbody_alloc(mdoc, line, ppos,
				    tok, target, ENDBODY_NOSPACE);
			}
		}
	}
	return irc;
}

/*
 * Allocate a word and check whether it's punctuation or not.
 * Punctuation consists of those tokens found in mdoc_isdelim().
 */
static void
dword(struct roff_man *mdoc, int line, int col, const char *p,
		enum mdelim d, int may_append)
{

	if (d == DELIM_MAX)
		d = mdoc_isdelim(p);

	if (may_append &&
	    ! (mdoc->flags & (MDOC_SYNOPSIS | MDOC_KEEP | MDOC_SMOFF)) &&
	    d == DELIM_NONE && mdoc->last->type == ROFFT_TEXT &&
	    mdoc_isdelim(mdoc->last->string) == DELIM_NONE) {
		roff_word_append(mdoc, p);
		return;
	}

	roff_word_alloc(mdoc, line, col, p);

	/*
	 * If the word consists of a bare delimiter,
	 * flag the new node accordingly,
	 * unless doing so was vetoed by the invoking macro.
	 * Always clear the veto, it is only valid for one word.
	 */

	if (d == DELIM_OPEN)
		mdoc->last->flags |= MDOC_DELIMO;
	else if (d == DELIM_CLOSE &&
	    ! (mdoc->flags & MDOC_NODELIMC) &&
	    mdoc->last->parent->tok != MDOC_Fd)
		mdoc->last->flags |= MDOC_DELIMC;
	mdoc->flags &= ~MDOC_NODELIMC;
}

static void
append_delims(struct roff_man *mdoc, int line, int *pos, char *buf)
{
	char		*p;
	int		 la;

	if (buf[*pos] == '\0')
		return;

	for (;;) {
		la = *pos;
		if (mdoc_args(mdoc, line, pos, buf, TOKEN_NONE, &p) ==
		    ARGS_EOLN)
			break;
		dword(mdoc, line, la, p, DELIM_MAX, 1);

		/*
		 * If we encounter end-of-sentence symbols, then trigger
		 * the double-space.
		 *
		 * XXX: it's easy to allow this to propagate outward to
		 * the last symbol, such that `. )' will cause the
		 * correct double-spacing.  However, (1) groff isn't
		 * smart enough to do this and (2) it would require
		 * knowing which symbols break this behaviour, for
		 * example, `.  ;' shouldn't propagate the double-space.
		 */

		if (mandoc_eos(p, strlen(p)))
			mdoc->last->flags |= MDOC_EOS;
	}
}

/*
 * Parse one word.
 * If it is a macro, call it and return 1.
 * Otherwise, allocate it and return 0.
 */
static int
macro_or_word(MACRO_PROT_ARGS, int parsed)
{
	char		*p;
	int		 ntok;

	p = buf + ppos;
	ntok = TOKEN_NONE;
	if (*p == '"')
		p++;
	else if (parsed && ! (mdoc->flags & MDOC_PHRASELIT))
		ntok = lookup(mdoc, tok, line, ppos, p);

	if (ntok == TOKEN_NONE) {
		dword(mdoc, line, ppos, p, DELIM_MAX, tok == TOKEN_NONE ||
		    mdoc_macros[tok].flags & MDOC_JOIN);
		return 0;
	} else {
		if (mdoc_macros[tok].fp == in_line_eoln)
			rew_elem(mdoc, tok);
		mdoc_macro(mdoc, ntok, line, ppos, pos, buf);
		if (tok == TOKEN_NONE)
			append_delims(mdoc, line, pos, buf);
		return 1;
	}
}

/*
 * Close out block partial/full explicit.
 */
static void
blk_exp_close(MACRO_PROT_ARGS)
{
	struct roff_node *body;		/* Our own body. */
	struct roff_node *endbody;	/* Our own end marker. */
	struct roff_node *itblk;	/* An It block starting later. */
	struct roff_node *later;	/* A sub-block starting later. */
	struct roff_node *n;		/* Search back to our block. */
	struct roff_node *target;	/* For find_pending(). */

	int		 j, lastarg, maxargs, nl, pending;
	enum margserr	 ac;
	int		 atok, ntok;
	char		*p;

	nl = MDOC_NEWLINE & mdoc->flags;

	switch (tok) {
	case MDOC_Ec:
		maxargs = 1;
		break;
	case MDOC_Ek:
		mdoc->flags &= ~MDOC_KEEP;
		/* FALLTHROUGH */
	default:
		maxargs = 0;
		break;
	}

	/*
	 * Search backwards for beginnings of blocks,
	 * both of our own and of pending sub-blocks.
	 */

	atok = rew_alt(tok);
	body = endbody = itblk = later = NULL;
	for (n = mdoc->last; n; n = n->parent) {
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
			continue;
		}

		/* Remember the start of our own body. */

		if (n->type == ROFFT_BODY && atok == n->tok) {
			if (n->end == ENDBODY_NOT)
				body = n;
			continue;
		}

		if (n->type != ROFFT_BLOCK || n->tok == MDOC_Nm)
			continue;

		if (n->tok == MDOC_It) {
			itblk = n;
			continue;
		}

		if (atok == n->tok) {
			assert(body);

			/*
			 * Found the start of our own block.
			 * When there is no pending sub block,
			 * just proceed to closing out.
			 */

			if (later == NULL ||
			    (tok == MDOC_El && itblk == NULL))
				break;

			/*
			 * When there is a pending sub block, postpone
			 * closing out the current block until the
			 * rew_pending() closing out the sub-block.
			 * Mark the place where the formatting - but not
			 * the scope - of the current block ends.
			 */

			mandoc_vmsg(MANDOCERR_BLK_NEST, mdoc->parse,
			    line, ppos, "%s breaks %s",
			    mdoc_macronames[atok],
			    mdoc_macronames[later->tok]);

			endbody = mdoc_endbody_alloc(mdoc, line, ppos,
			    atok, body, ENDBODY_SPACE);

			if (tok == MDOC_El)
				itblk->flags |= MDOC_ENDED | MDOC_BROKEN;

			/*
			 * If a block closing macro taking arguments
			 * breaks another block, put the arguments
			 * into the end marker.
			 */

			if (maxargs)
				mdoc->next = ROFF_NEXT_CHILD;
			break;
		}

		/* Explicit blocks close out description lines. */

		if (n->tok == MDOC_Nd) {
			rew_last(mdoc, n);
			continue;
		}

		/* Breaking an open sub block. */

		n->flags |= MDOC_BROKEN;
		if (later == NULL)
			later = n;
	}

	if (body == NULL) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		if (later != NULL)
			later->flags &= ~MDOC_BROKEN;
		if (maxargs && endbody == NULL) {
			/*
			 * Stray .Ec without previous .Eo:
			 * Break the output line, keep the arguments.
			 */
			roff_elem_alloc(mdoc, line, ppos, MDOC_br);
			rew_elem(mdoc, MDOC_br);
		}
	} else if (endbody == NULL) {
		rew_last(mdoc, body);
		if (maxargs)
			mdoc_tail_alloc(mdoc, line, ppos, atok);
	}

	if ( ! (mdoc_macros[tok].flags & MDOC_PARSED)) {
		if (buf[*pos] != '\0')
			mandoc_vmsg(MANDOCERR_ARG_SKIP,
			    mdoc->parse, line, ppos,
			    "%s %s", mdoc_macronames[tok],
			    buf + *pos);
		if (endbody == NULL && n != NULL)
			rew_pending(mdoc, n);
		return;
	}

	if (endbody != NULL)
		n = endbody;

	ntok = TOKEN_NONE;
	for (j = 0; ; j++) {
		lastarg = *pos;

		if (j == maxargs && n != NULL)
			rew_last(mdoc, n);

		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_PUNCT || ac == ARGS_EOLN)
			break;

		ntok = ac == ARGS_QWORD ? TOKEN_NONE :
		    lookup(mdoc, tok, line, lastarg, p);

		if (ntok == TOKEN_NONE) {
			dword(mdoc, line, lastarg, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
		}

		if (n != NULL)
			rew_last(mdoc, n);
		mdoc->flags &= ~MDOC_NEWLINE;
		mdoc_macro(mdoc, ntok, line, lastarg, pos, buf);
		break;
	}

	if (n != NULL) {
		if (ntok != TOKEN_NONE && n->flags & MDOC_BROKEN) {
			target = n;
			do
				target = target->parent;
			while ( ! (target->flags & MDOC_ENDED));
			pending = find_pending(mdoc, ntok, line, ppos,
			    target);
		} else
			pending = 0;
		if ( ! pending)
			rew_pending(mdoc, n);
	}
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
in_line(MACRO_PROT_ARGS)
{
	int		 la, scope, cnt, firstarg, mayopen, nc, nl;
	int		 ntok;
	enum margserr	 ac;
	enum mdelim	 d;
	struct mdoc_arg	*arg;
	char		*p;

	nl = MDOC_NEWLINE & mdoc->flags;

	/*
	 * Whether we allow ignored elements (those without content,
	 * usually because of reserved words) to squeak by.
	 */

	switch (tok) {
	case MDOC_An:
	case MDOC_Ar:
	case MDOC_Fl:
	case MDOC_Mt:
	case MDOC_Nm:
	case MDOC_Pa:
		nc = 1;
		break;
	default:
		nc = 0;
		break;
	}

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);

	d = DELIM_NONE;
	firstarg = 1;
	mayopen = 1;
	for (cnt = scope = 0;; ) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);

		/*
		 * At the end of a macro line,
		 * opening delimiters do not suppress spacing.
		 */

		if (ac == ARGS_EOLN) {
			if (d == DELIM_OPEN)
				mdoc->last->flags &= ~MDOC_DELIMO;
			break;
		}

		/*
		 * The rest of the macro line is only punctuation,
		 * to be handled by append_delims().
		 * If there were no other arguments,
		 * do not allow the first one to suppress spacing,
		 * even if it turns out to be a closing one.
		 */

		if (ac == ARGS_PUNCT) {
			if (cnt == 0 && (nc == 0 || tok == MDOC_An))
				mdoc->flags |= MDOC_NODELIMC;
			break;
		}

		ntok = (ac == ARGS_QWORD || (tok == MDOC_Fn && !cnt)) ?
		    TOKEN_NONE : lookup(mdoc, tok, line, la, p);

		/*
		 * In this case, we've located a submacro and must
		 * execute it.  Close out scope, if open.  If no
		 * elements have been generated, either create one (nc)
		 * or raise a warning.
		 */

		if (ntok != TOKEN_NONE) {
			if (scope)
				rew_elem(mdoc, tok);
			if (nc && ! cnt) {
				mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
				rew_last(mdoc, mdoc->last);
			} else if ( ! nc && ! cnt) {
				mdoc_argv_free(arg);
				mandoc_msg(MANDOCERR_MACRO_EMPTY,
				    mdoc->parse, line, ppos,
				    mdoc_macronames[tok]);
			}
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
			if (nl)
				append_delims(mdoc, line, pos, buf);
			return;
		}

		/*
		 * Non-quote-enclosed punctuation.  Set up our scope, if
		 * a word; rewind the scope, if a delimiter; then append
		 * the word.
		 */

		d = ac == ARGS_QWORD ? DELIM_NONE : mdoc_isdelim(p);

		if (DELIM_NONE != d) {
			/*
			 * If we encounter closing punctuation, no word
			 * has been emitted, no scope is open, and we're
			 * allowed to have an empty element, then start
			 * a new scope.
			 */
			if ((d == DELIM_CLOSE ||
			     (d == DELIM_MIDDLE && tok == MDOC_Fl)) &&
			    !cnt && !scope && nc && mayopen) {
				mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
				scope = 1;
				cnt++;
				if (tok == MDOC_Nm)
					mayopen = 0;
			}
			/*
			 * Close out our scope, if one is open, before
			 * any punctuation.
			 */
			if (scope)
				rew_elem(mdoc, tok);
			scope = 0;
			if (tok == MDOC_Fn)
				mayopen = 0;
		} else if (mayopen && !scope) {
			mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			scope = 1;
			cnt++;
		}

		dword(mdoc, line, la, p, d,
		    MDOC_JOIN & mdoc_macros[tok].flags);

		/*
		 * If the first argument is a closing delimiter,
		 * do not suppress spacing before it.
		 */

		if (firstarg && d == DELIM_CLOSE && !nc)
			mdoc->last->flags &= ~MDOC_DELIMC;
		firstarg = 0;

		/*
		 * `Fl' macros have their scope re-opened with each new
		 * word so that the `-' can be added to each one without
		 * having to parse out spaces.
		 */
		if (scope && tok == MDOC_Fl) {
			rew_elem(mdoc, tok);
			scope = 0;
		}
	}

	if (scope)
		rew_elem(mdoc, tok);

	/*
	 * If no elements have been collected and we're allowed to have
	 * empties (nc), open a scope and close it out.  Otherwise,
	 * raise a warning.
	 */

	if ( ! cnt) {
		if (nc) {
			mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			rew_last(mdoc, mdoc->last);
		} else {
			mdoc_argv_free(arg);
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    line, ppos, mdoc_macronames[tok]);
		}
	}
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
blk_full(MACRO_PROT_ARGS)
{
	int		  la, nl, parsed;
	struct mdoc_arg	 *arg;
	struct roff_node *blk; /* Our own or a broken block. */
	struct roff_node *head; /* Our own head. */
	struct roff_node *body; /* Our own body. */
	struct roff_node *n;
	enum margserr	  ac, lac;
	char		 *p;

	nl = MDOC_NEWLINE & mdoc->flags;

	if (buf[*pos] == '\0' && (tok == MDOC_Sh || tok == MDOC_Ss)) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		return;
	}

	if ( ! (mdoc_macros[tok].flags & MDOC_EXPLICIT)) {

		/* Here, tok is one of Sh Ss Nm Nd It. */

		blk = NULL;
		for (n = mdoc->last; n != NULL; n = n->parent) {
			if (n->flags & MDOC_ENDED) {
				if ( ! (n->flags & MDOC_VALID))
					n->flags |= MDOC_BROKEN;
				continue;
			}
			if (n->type != ROFFT_BLOCK)
				continue;

			if (tok == MDOC_It && n->tok == MDOC_Bl) {
				if (blk != NULL) {
					mandoc_vmsg(MANDOCERR_BLK_BROKEN,
					    mdoc->parse, line, ppos,
					    "It breaks %s",
					    mdoc_macronames[blk->tok]);
					rew_pending(mdoc, blk);
				}
				break;
			}

			if (mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
				switch (tok) {
				case MDOC_Sh:
				case MDOC_Ss:
					mandoc_vmsg(MANDOCERR_BLK_BROKEN,
					    mdoc->parse, line, ppos,
					    "%s breaks %s",
					    mdoc_macronames[tok],
					    mdoc_macronames[n->tok]);
					rew_pending(mdoc, n);
					n = mdoc->last;
					continue;
				case MDOC_It:
					/* Delay in case it's astray. */
					blk = n;
					continue;
				default:
					break;
				}
				break;
			}

			/* Here, n is one of Sh Ss Nm Nd It. */

			if (tok != MDOC_Sh && (n->tok == MDOC_Sh ||
			    (tok != MDOC_Ss && (n->tok == MDOC_Ss ||
			     (tok != MDOC_It && n->tok == MDOC_It)))))
				break;

			/* Item breaking an explicit block. */

			if (blk != NULL) {
				mandoc_vmsg(MANDOCERR_BLK_BROKEN,
				    mdoc->parse, line, ppos,
				    "It breaks %s",
				    mdoc_macronames[blk->tok]);
				rew_pending(mdoc, blk);
				blk = NULL;
			}

			/* Close out prior implicit scopes. */

			rew_last(mdoc, n);
		}

		/* Skip items outside lists. */

		if (tok == MDOC_It && (n == NULL || n->tok != MDOC_Bl)) {
			mandoc_vmsg(MANDOCERR_IT_STRAY, mdoc->parse,
			    line, ppos, "It %s", buf + *pos);
			roff_elem_alloc(mdoc, line, ppos, MDOC_br);
			rew_elem(mdoc, MDOC_br);
			return;
		}
	}

	/*
	 * This routine accommodates implicitly- and explicitly-scoped
	 * macro openings.  Implicit ones first close out prior scope
	 * (seen above).  Delay opening the head until necessary to
	 * allow leading punctuation to print.  Special consideration
	 * for `It -column', which has phrase-part syntax instead of
	 * regular child nodes.
	 */

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);
	blk = mdoc_block_alloc(mdoc, line, ppos, tok, arg);
	head = body = NULL;

	/*
	 * Exception: Heads of `It' macros in `-diag' lists are not
	 * parsed, even though `It' macros in general are parsed.
	 */

	parsed = tok != MDOC_It ||
	    mdoc->last->parent->tok != MDOC_Bl ||
	    mdoc->last->parent->norm->Bl.type != LIST_diag;

	/*
	 * The `Nd' macro has all arguments in its body: it's a hybrid
	 * of block partial-explicit and full-implicit.  Stupid.
	 */

	if (tok == MDOC_Nd) {
		head = roff_head_alloc(mdoc, line, ppos, tok);
		rew_last(mdoc, head);
		body = roff_body_alloc(mdoc, line, ppos, tok);
	}

	if (tok == MDOC_Bk)
		mdoc->flags |= MDOC_KEEP;

	ac = ARGS_EOLN;
	for (;;) {

		/*
		 * If we are right after a tab character,
		 * do not parse the first word for macros.
		 */

		if (mdoc->flags & MDOC_PHRASEQN) {
			mdoc->flags &= ~MDOC_PHRASEQN;
			mdoc->flags |= MDOC_PHRASEQF;
		}

		la = *pos;
		lac = ac;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_EOLN) {
			if (lac != ARGS_PHRASE ||
			    ! (mdoc->flags & MDOC_PHRASEQF))
				break;

			/*
			 * This line ends in a tab; start the next
			 * column now, with a leading blank.
			 */

			if (body != NULL)
				rew_last(mdoc, body);
			body = roff_body_alloc(mdoc, line, ppos, tok);
			roff_word_alloc(mdoc, line, ppos, "\\&");
			break;
		}

		if (tok == MDOC_Bd || tok == MDOC_Bk) {
			mandoc_vmsg(MANDOCERR_ARG_EXCESS,
			    mdoc->parse, line, la, "%s ... %s",
			    mdoc_macronames[tok], buf + la);
			break;
		}
		if (tok == MDOC_Rs) {
			mandoc_vmsg(MANDOCERR_ARG_SKIP, mdoc->parse,
			    line, la, "Rs %s", buf + la);
			break;
		}
		if (ac == ARGS_PUNCT)
			break;

		/*
		 * Emit leading punctuation (i.e., punctuation before
		 * the ROFFT_HEAD) for non-phrase types.
		 */

		if (head == NULL &&
		    ac != ARGS_PHRASE &&
		    ac != ARGS_QWORD &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		/* Open a head if one hasn't been opened. */

		if (head == NULL)
			head = roff_head_alloc(mdoc, line, ppos, tok);

		if (ac == ARGS_PHRASE) {

			/*
			 * If we haven't opened a body yet, rewind the
			 * head; if we have, rewind that instead.
			 */

			rew_last(mdoc, body == NULL ? head : body);
			body = roff_body_alloc(mdoc, line, ppos, tok);

			/* Process to the tab or to the end of the line. */

			mdoc->flags |= MDOC_PHRASE;
			parse_rest(mdoc, TOKEN_NONE, line, &la, buf);
			mdoc->flags &= ~MDOC_PHRASE;

			/* There may have been `Ta' macros. */

			while (body->next != NULL)
				body = body->next;
			continue;
		}

		if (macro_or_word(mdoc, tok, line, la, pos, buf, parsed))
			break;
	}

	if (blk->flags & MDOC_VALID)
		return;
	if (head == NULL)
		head = roff_head_alloc(mdoc, line, ppos, tok);
	if (nl && tok != MDOC_Bd && tok != MDOC_Bl && tok != MDOC_Rs)
		append_delims(mdoc, line, pos, buf);
	if (body != NULL)
		goto out;
	if (find_pending(mdoc, tok, line, ppos, head))
		return;

	/* Close out scopes to remain in a consistent state. */

	rew_last(mdoc, head);
	body = roff_body_alloc(mdoc, line, ppos, tok);
out:
	if (mdoc->flags & MDOC_FREECOL) {
		rew_last(mdoc, body);
		rew_last(mdoc, blk);
		mdoc->flags &= ~MDOC_FREECOL;
	}
}

static void
blk_part_imp(MACRO_PROT_ARGS)
{
	int		  la, nl;
	enum margserr	  ac;
	char		 *p;
	struct roff_node *blk; /* saved block context */
	struct roff_node *body; /* saved body context */
	struct roff_node *n;

	nl = MDOC_NEWLINE & mdoc->flags;

	/*
	 * A macro that spans to the end of the line.  This is generally
	 * (but not necessarily) called as the first macro.  The block
	 * has a head as the immediate child, which is always empty,
	 * followed by zero or more opening punctuation nodes, then the
	 * body (which may be empty, depending on the macro), then zero
	 * or more closing punctuation nodes.
	 */

	blk = mdoc_block_alloc(mdoc, line, ppos, tok, NULL);
	rew_last(mdoc, roff_head_alloc(mdoc, line, ppos, tok));

	/*
	 * Open the body scope "on-demand", that is, after we've
	 * processed all our the leading delimiters (open parenthesis,
	 * etc.).
	 */

	for (body = NULL; ; ) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_EOLN || ac == ARGS_PUNCT)
			break;

		if (body == NULL && ac != ARGS_QWORD &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		if (body == NULL)
			body = roff_body_alloc(mdoc, line, ppos, tok);

		if (macro_or_word(mdoc, tok, line, la, pos, buf, 1))
			break;
	}
	if (body == NULL)
		body = roff_body_alloc(mdoc, line, ppos, tok);

	if (find_pending(mdoc, tok, line, ppos, body))
		return;

	rew_last(mdoc, body);
	if (nl)
		append_delims(mdoc, line, pos, buf);
	rew_pending(mdoc, blk);

	/* Move trailing .Ns out of scope. */

	for (n = body->child; n && n->next; n = n->next)
		/* Do nothing. */ ;
	if (n && n->tok == MDOC_Ns)
		mdoc_node_relink(mdoc, n);
}

static void
blk_part_exp(MACRO_PROT_ARGS)
{
	int		  la, nl;
	enum margserr	  ac;
	struct roff_node *head; /* keep track of head */
	char		 *p;

	nl = MDOC_NEWLINE & mdoc->flags;

	/*
	 * The opening of an explicit macro having zero or more leading
	 * punctuation nodes; a head with optional single element (the
	 * case of `Eo'); and a body that may be empty.
	 */

	roff_block_alloc(mdoc, line, ppos, tok);
	head = NULL;
	for (;;) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_PUNCT || ac == ARGS_EOLN)
			break;

		/* Flush out leading punctuation. */

		if (head == NULL && ac != ARGS_QWORD &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		if (head == NULL) {
			head = roff_head_alloc(mdoc, line, ppos, tok);
			if (tok == MDOC_Eo)  /* Not parsed. */
				dword(mdoc, line, la, p, DELIM_MAX, 0);
			rew_last(mdoc, head);
			roff_body_alloc(mdoc, line, ppos, tok);
			if (tok == MDOC_Eo)
				continue;
		}

		if (macro_or_word(mdoc, tok, line, la, pos, buf, 1))
			break;
	}

	/* Clean-up to leave in a consistent state. */

	if (head == NULL) {
		rew_last(mdoc, roff_head_alloc(mdoc, line, ppos, tok));
		roff_body_alloc(mdoc, line, ppos, tok);
	}
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
in_line_argn(MACRO_PROT_ARGS)
{
	struct mdoc_arg	*arg;
	char		*p;
	enum margserr	 ac;
	int		 ntok;
	int		 state; /* arg#; -1: not yet open; -2: closed */
	int		 la, maxargs, nl;

	nl = mdoc->flags & MDOC_NEWLINE;

	/*
	 * A line macro that has a fixed number of arguments (maxargs).
	 * Only open the scope once the first non-leading-punctuation is
	 * found (unless MDOC_IGNDELIM is noted, like in `Pf'), then
	 * keep it open until the maximum number of arguments are
	 * exhausted.
	 */

	switch (tok) {
	case MDOC_Ap:
	case MDOC_Ns:
	case MDOC_Ux:
		maxargs = 0;
		break;
	case MDOC_Bx:
	case MDOC_Es:
	case MDOC_Xr:
		maxargs = 2;
		break;
	default:
		maxargs = 1;
		break;
	}

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);

	state = -1;
	p = NULL;
	for (;;) {
		la = *pos;
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);

		if (ac == ARGS_WORD && state == -1 &&
		    ! (mdoc_macros[tok].flags & MDOC_IGNDELIM) &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		}

		if (state == -1 && tok != MDOC_In &&
		    tok != MDOC_St && tok != MDOC_Xr) {
			mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			state = 0;
		}

		if (ac == ARGS_PUNCT || ac == ARGS_EOLN) {
			if (abs(state) < 2 && tok == MDOC_Pf)
				mandoc_vmsg(MANDOCERR_PF_SKIP,
				    mdoc->parse, line, ppos, "Pf %s",
				    p == NULL ? "at eol" : p);
			break;
		}

		if (state == maxargs) {
			rew_elem(mdoc, tok);
			state = -2;
		}

		ntok = (ac == ARGS_QWORD || (tok == MDOC_Pf && state == 0)) ?
		    TOKEN_NONE : lookup(mdoc, tok, line, la, p);

		if (ntok != TOKEN_NONE) {
			if (state >= 0) {
				rew_elem(mdoc, tok);
				state = -2;
			}
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
			break;
		}

		if (ac == ARGS_QWORD ||
		    mdoc_macros[tok].flags & MDOC_IGNDELIM ||
		    mdoc_isdelim(p) == DELIM_NONE) {
			if (state == -1) {
				mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
				state = 1;
			} else if (state >= 0)
				state++;
		} else if (state >= 0) {
			rew_elem(mdoc, tok);
			state = -2;
		}

		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
	}

	if (state == -1) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		return;
	}

	if (state == 0 && tok == MDOC_Pf)
		append_delims(mdoc, line, pos, buf);
	if (state >= 0)
		rew_elem(mdoc, tok);
	if (nl)
		append_delims(mdoc, line, pos, buf);
}

static void
in_line_eoln(MACRO_PROT_ARGS)
{
	struct roff_node	*n;
	struct mdoc_arg		*arg;

	if ((tok == MDOC_Pp || tok == MDOC_Lp) &&
	    ! (mdoc->flags & MDOC_SYNOPSIS)) {
		n = mdoc->last;
		if (mdoc->next == ROFF_NEXT_SIBLING)
			n = n->parent;
		if (n->tok == MDOC_Nm)
			rew_last(mdoc, n->parent);
	}

	if (buf[*pos] == '\0' &&
	    (tok == MDOC_Fd || mdoc_macronames[tok][0] == '%')) {
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
		return;
	}

	mdoc_argv(mdoc, line, tok, &arg, pos, buf);
	mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
	if (parse_rest(mdoc, tok, line, pos, buf))
		return;
	rew_elem(mdoc, tok);
}

/*
 * The simplest argument parser available: Parse the remaining
 * words until the end of the phrase or line and return 0
 * or until the next macro, call that macro, and return 1.
 */
static int
parse_rest(struct roff_man *mdoc, int tok, int line, int *pos, char *buf)
{
	int		 la;

	for (;;) {
		la = *pos;
		if (mdoc_args(mdoc, line, pos, buf, tok, NULL) == ARGS_EOLN)
			return 0;
		if (macro_or_word(mdoc, tok, line, la, pos, buf, 1))
			return 1;
	}
}

static void
ctx_synopsis(MACRO_PROT_ARGS)
{

	if (~mdoc->flags & (MDOC_SYNOPSIS | MDOC_NEWLINE))
		in_line(mdoc, tok, line, ppos, pos, buf);
	else if (tok == MDOC_Nm)
		blk_full(mdoc, tok, line, ppos, pos, buf);
	else {
		assert(tok == MDOC_Vt);
		blk_part_imp(mdoc, tok, line, ppos, pos, buf);
	}
}

/*
 * Phrases occur within `Bl -column' entries, separated by `Ta' or tabs.
 * They're unusual because they're basically free-form text until a
 * macro is encountered.
 */
static void
phrase_ta(MACRO_PROT_ARGS)
{
	struct roff_node *body, *n;

	/* Make sure we are in a column list or ignore this macro. */

	body = NULL;
	for (n = mdoc->last; n != NULL; n = n->parent) {
		if (n->flags & MDOC_ENDED)
			continue;
		if (n->tok == MDOC_It && n->type == ROFFT_BODY)
			body = n;
		if (n->tok == MDOC_Bl)
			break;
	}

	if (n == NULL || n->norm->Bl.type != LIST_column) {
		mandoc_msg(MANDOCERR_TA_STRAY, mdoc->parse,
		    line, ppos, "Ta");
		return;
	}

	/* Advance to the next column. */

	rew_last(mdoc, body);
	roff_body_alloc(mdoc, line, ppos, MDOC_It);
	parse_rest(mdoc, TOKEN_NONE, line, pos, buf);
}
@


1.205
log
@Very tricky diff to fix macro interpretation and spacing around tabs
in .Bl -column; it took me more than a day to get this right.
Triggered by a loosely related bug report from tim@@.

The lesson for you is:  Use .Ta macros in .Bl -column, avoid tabs,
or you are in for surprises:  The last word before a tab is not
interpreted as a macro (unless there is a blank in between), the
first word after a tab isn't either (unless there is a blank in
between), and a blank after a tab causes a leading blank in the
respective output cell.  Yes, "blank", "tab", "blank tab" and "tab
blank" all have different semantics; if you write code relying on
that, good luck maintaining it afterwards...
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.204 2015/10/15 22:27:24 schwarze Exp $ */
d231 1
a265 1
	struct roff_node	*np;
d271 3
a273 10
		/*
		 * Save the parent here, because we may delete the
		 * mdoc->last node in the post-validation phase and reset
		 * it to mdoc->last->parent, causing a step in the closing
		 * out to be lost.
		 */
		np = mdoc->last->parent;
		mdoc_valid_post(mdoc);
		mdoc->last = np;
		assert(mdoc->last);
d275 2
a277 1
	mdoc_valid_post(mdoc);
@


1.204
log
@When blk_full() handles an .It line in .Bl -column and indirectly
calls phrase_ta() to handle a .Ta child macro, advance the body
pointer accordingly, such that a subsequent tab character rewinds
the right body block and doesn't fail an assertion.  That happened
when there was nothing between the .Ta and the tab character.
Bug reported by tim@@ some time ago.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.203 2015/10/12 00:08:15 schwarze Exp $ */
d242 4
d1037 1
a1037 1
	ac = ARGS_PEND;
d1039 11
d1054 2
a1055 1
			if (lac != ARGS_PPHRASE && lac != ARGS_PHRASE)
d1057 1
d1059 2
a1060 5
			 * This is necessary: if the last token on a
			 * line is a `Ta' or tab, then we'll get
			 * ARGS_EOLN, so we must be smart enough to
			 * reopen our scope if the last parse was a
			 * phrase or partial phrase.
d1062 1
d1066 1
d1069 1
a1089 1
		    ac != ARGS_PEND &&
a1090 1
		    ac != ARGS_PPHRASE &&
d1102 1
a1102 3
		if (ac == ARGS_PHRASE ||
		    ac == ARGS_PEND ||
		    ac == ARGS_PPHRASE) {
d1112 1
a1112 5
			/*
			 * Process phrases: set whether we're in a
			 * partial-phrase (this effects line handling)
			 * then call down into the phrase parser.
			 */
d1114 1
a1114 4
			if (ac == ARGS_PPHRASE)
				mdoc->flags |= MDOC_PPHRASE;
			if (ac == ARGS_PEND && lac == ARGS_PPHRASE)
				mdoc->flags |= MDOC_PPHRASE;
d1116 1
a1116 1
			mdoc->flags &= ~MDOC_PPHRASE;
@


1.203
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.202 2015/10/06 18:32:19 schwarze Exp $ */
d1111 5
@


1.202
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.201 2015/09/26 00:54:04 schwarze Exp $ */
a736 1
		/* FALLTHROUGH */
a737 1
		/* FALLTHROUGH */
a738 1
		/* FALLTHROUGH */
a739 1
		/* FALLTHROUGH */
a740 1
		/* FALLTHROUGH */
a943 1
					/* FALLTHROUGH */
a1285 1
		/* FALLTHROUGH */
a1286 1
		/* FALLTHROUGH */
a1290 1
		/* FALLTHROUGH */
a1291 1
		/* FALLTHROUGH */
@


1.201
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.200 2015/05/01 16:58:33 schwarze Exp $ */
d246 1
a246 1
				return(res);
d252 1
a252 1
	return(TOKEN_NONE);
d332 1
a332 1
		return(MDOC_Ao);
d334 1
a334 1
		return(MDOC_Bo);
d336 1
a336 1
		return(MDOC_Bro);
d338 1
a338 1
		return(MDOC_Do);
d340 1
a340 1
		return(MDOC_Eo);
d342 1
a342 1
		return(MDOC_Bd);
d344 1
a344 1
		return(MDOC_Bf);
d346 1
a346 1
		return(MDOC_Bk);
d348 1
a348 1
		return(MDOC_Bl);
d350 1
a350 1
		return(MDOC_Fo);
d352 1
a352 1
		return(MDOC_Oo);
d354 1
a354 1
		return(MDOC_Po);
d356 1
a356 1
		return(MDOC_Qo);
d358 1
a358 1
		return(MDOC_Rs);
d360 1
a360 1
		return(MDOC_So);
d362 1
a362 1
		return(MDOC_Xo);
d364 1
a364 1
		return(tok);
d416 1
a416 1
	return(irc);
d511 1
a511 1
		return(0);
d518 1
a518 1
		return(1);
d1429 1
a1429 1
			return(0);
d1431 1
a1431 1
			return(1);
@


1.200
log
@mdoc_valid_post() may indirectly call roff_node_unlink() which may
set ROFF_NEXT_CHILD, which is desirable for the final call to
mdoc_valid_post() - in case the target itself gets deleted, the
parse point may need this adjustment - but not for the intermediate
calls - if intermediate nodes get deleted, that mustn't clobber the
parse point.  So move setting ROFF_NEXT_SIBLING to the proper place
in rew_last().

This fixes the assertion failure in jsg@@'s afl test case 108/Apr27.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.199 2015/05/01 16:02:47 schwarze Exp $ */
a365 1
	/* NOTREACHED */
@


1.199
log
@Setting the "last" member of struct roff_node was done at an extremely
weird place.  Move it to the obviously correct place.
Surprisingly, this didn't cause any misformatting in the test suite
or in any base system manuals, but i cannot believe the code was
really correct for all conceivable input, and it would be very hard
to verify.  At the very least, it cannot have worked for man(7).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.198 2015/05/01 15:27:54 schwarze Exp $ */
a265 1
	mdoc->next = ROFF_NEXT_SIBLING;
d278 1
@


1.198
log
@Minor bug fix:  When .Pp rewinds .Nm, rewind the whole block,
not just the body.  In some unusual edge cases, this caused
the .Pp to become a sibling of the .Nm body inside the .Nm block.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.197 2015/04/29 21:58:32 schwarze Exp $ */
d261 1
a261 1
	struct roff_node *n, *np;
a275 1
		n = mdoc->last;
a277 1
		mdoc->last->last = n;
@


1.197
log
@If a block body gets broken, that's no good reason to extend the
scope of the end macro.  Instead, only keep the tail scope open if
the end macro macro calls an explicit macro and actually breaks
that.  This corrects syntax tree structure and fixes an assertion
found by jsg@@ with afl (test case 098/Apr27).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.196 2015/04/29 14:48:53 schwarze Exp $ */
d1402 1
a1402 1
			rew_last(mdoc, mdoc->last->parent);
@


1.196
log
@Do not mark a block with the MDOC_BROKEN flag if it merely contains
a mismatching explicit end macro without actually being broken.
Avoids a subsequent upward search for the non-existent breaker
ending up in a NULL pointer access; afl test case 005/Apr27 from jsg@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.195 2015/04/23 15:35:59 schwarze Exp $ */
d676 2
d705 1
a705 1
		if (n != mdoc->last && n->flags & MDOC_BROKEN) {
@


1.195
log
@Get rid of two empty wrapper functions.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.194 2015/04/21 16:14:25 schwarze Exp $ */
d647 2
@


1.194
log
@Avoid a use after free when the target node is deleted during validation.
Bug reported by jsg@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.193 2015/04/19 14:57:38 schwarze Exp $ */
d213 1
a213 1
mdoc_macroend(struct roff_man *mdoc)
@


1.193
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.192 2015/04/19 14:25:41 schwarze Exp $ */
d294 15
a308 12
		switch (n->type) {
		case ROFFT_HEAD:
			roff_body_alloc(mdoc, n->line, n->pos, n->tok);
			return;
		case ROFFT_BLOCK:
			break;
		default:
			return;
		}

		if ( ! (n->flags & MDOC_BROKEN))
			return;
@


1.192
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.191 2015/04/19 14:00:19 schwarze Exp $ */
d649 1
a649 1
			mdoc_elem_alloc(mdoc, line, ppos, MDOC_br, NULL);
d993 1
a993 1
			mdoc_elem_alloc(mdoc, line, ppos, MDOC_br, NULL);
d1226 1
a1226 1
	mdoc_block_alloc(mdoc, line, ppos, tok, NULL);
@


1.191
log
@Decouple the token code for "no request or macro" from the individual
high-level parsers to allow further unification of functions that
only need to recognize this code, but that don't care about different
high-level macrosets beyond that.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.190 2015/04/19 13:50:26 schwarze Exp $ */
d435 1
a435 1
		mdoc_word_append(mdoc, p);
d439 1
a439 1
	mdoc_word_alloc(mdoc, line, col, p);
@


1.190
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.189 2015/04/18 16:06:40 schwarze Exp $ */
d235 1
a235 1
 * or as a line macro if from == MDOC_MAX.
d242 1
a242 1
	if (from == MDOC_MAX || mdoc_macros[from].flags & MDOC_PARSED) {
d244 1
a244 1
		if (res != MDOC_MAX) {
d252 1
a252 1
	return(MDOC_MAX);
d468 2
a469 1
		if (mdoc_args(mdoc, line, pos, buf, MDOC_MAX, &p) == ARGS_EOLN)
d502 1
a502 1
	ntok = MDOC_MAX;
d508 2
a509 2
	if (ntok == MDOC_MAX) {
		dword(mdoc, line, ppos, p, DELIM_MAX, tok == MDOC_MAX ||
d516 1
a516 1
		if (tok == MDOC_MAX)
d681 1
a681 1
		ntok = ac == ARGS_QWORD ? MDOC_MAX :
d684 1
a684 1
		if (ntok == MDOC_MAX) {
d785 1
a785 1
		    MDOC_MAX : lookup(mdoc, tok, line, la, p);
d794 1
a794 1
		if (ntok != MDOC_MAX) {
d1111 1
a1111 1
			parse_rest(mdoc, MDOC_MAX, line, &la, buf);
d1341 1
a1341 1
		    MDOC_MAX : lookup(mdoc, tok, line, la, p);
d1343 1
a1343 1
		if (ntok != MDOC_MAX) {
d1477 1
a1477 1
	parse_rest(mdoc, MDOC_MAX, line, pos, buf);
@


1.189
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.188 2015/04/05 23:04:41 schwarze Exp $ */
d33 1
d296 1
a296 1
			mdoc_body_alloc(mdoc, n->line, n->pos, n->tok);
d1026 1
a1026 1
		head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1028 1
a1028 1
		body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1051 1
a1051 1
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1086 1
a1086 1
			head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1098 1
a1098 1
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1122 1
a1122 1
		head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1133 1
a1133 1
	body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1164 1
a1164 1
	rew_last(mdoc, mdoc_head_alloc(mdoc, line, ppos, tok));
d1185 1
a1185 1
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1191 1
a1191 1
		body = mdoc_body_alloc(mdoc, line, ppos, tok);
d1242 1
a1242 1
			head = mdoc_head_alloc(mdoc, line, ppos, tok);
d1246 1
a1246 1
			mdoc_body_alloc(mdoc, line, ppos, tok);
d1258 2
a1259 2
		rew_last(mdoc, mdoc_head_alloc(mdoc, line, ppos, tok));
		mdoc_body_alloc(mdoc, line, ppos, tok);
d1475 1
a1475 1
	mdoc_body_alloc(mdoc, line, ppos, MDOC_It);
@


1.188
log
@If a partial explicit block extending to the next input line follows
the end macro of a broken block, put all of it into the breaking block.
Needed for example by mutella(1).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.187 2015/04/05 22:44:20 schwarze Exp $ */
d45 2
a46 2
static	void		append_delims(struct mdoc *, int, int *, char *);
static	void		dword(struct mdoc *, int, int, const char *,
d48 1
a48 1
static	int		find_pending(struct mdoc *, int, int, int,
d50 1
a50 1
static	int		lookup(struct mdoc *, int, int, int, const char *);
d52 1
a52 1
static	int		parse_rest(struct mdoc *, int, int, int *, char *);
d54 4
a57 3
static	void		rew_elem(struct mdoc *, int);
static	void		rew_last(struct mdoc *, const struct roff_node *);
static	void		rew_pending(struct mdoc *, const struct roff_node *);
d212 1
a212 1
mdoc_macroend(struct mdoc *mdoc)
d237 1
a237 1
lookup(struct mdoc *mdoc, int from, int line, int ppos, const char *p)
d258 1
a258 1
rew_last(struct mdoc *mdoc, const struct roff_node *to)
d265 1
a265 1
	mdoc->next = MDOC_NEXT_SIBLING;
d287 1
a287 1
rew_pending(struct mdoc *mdoc, const struct roff_node *n)
d368 1
a368 1
rew_elem(struct mdoc *mdoc, int tok)
d386 1
a386 1
find_pending(struct mdoc *mdoc, int tok, int line, int ppos,
d423 1
a423 1
dword(struct mdoc *mdoc, int line, int col, const char *p,
d457 1
a457 1
append_delims(struct mdoc *mdoc, int line, int *pos, char *buf)
d621 1
a621 1
				mdoc->next = MDOC_NEXT_CHILD;
d1390 1
a1390 1
		if (mdoc->next == MDOC_NEXT_SIBLING)
d1416 1
a1416 1
parse_rest(struct mdoc *mdoc, int tok, int line, int *pos, char *buf)
@


1.187
log
@Reduce code duplication, no functional change:
Both partial and full implicit blocks can break explicit blocks.
Put the code to handle both cases into a common function.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.186 2015/04/05 14:43:36 schwarze Exp $ */
d530 1
d532 1
a532 1
	int		 j, lastarg, maxargs, nl;
d694 13
a706 2
	if (n != NULL)
		rew_pending(mdoc, n);
@


1.186
log
@Arguments to end macros of broken partial explicit blocks
must go inside the breaking block.  For example, in
.It Ic cmd Oo
.Ar optional_arg Oc Ar mandatory_arg
the mandatory_arg is still inside the .It block.
Used for example by mutella(1).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.185 2015/04/02 22:48:17 schwarze Exp $ */
d45 1
d47 3
a49 2
				 enum mdelim, int);
static	void		append_delims(struct mdoc *, int, int *, char *);
d380 38
d1113 1
a1113 20

	/*
	 * If there is an open (i.e., unvalidated) sub-block requiring
	 * explicit close-out, postpone switching the current block from
	 * head to body until the rew_pending() call closing out that
	 * sub-block.
	 */
	for (n = mdoc->last; n && n != head; n = n->parent) {
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
			continue;
		}
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
			n->flags = MDOC_BROKEN;
			head->flags = MDOC_ENDED;
		}
	}
	if (head->flags & MDOC_ENDED)
d1179 1
a1179 28
	/*
	 * If there is an open sub-block requiring explicit close-out,
	 * postpone closing out the current block until the
	 * rew_pending() call closing out the sub-block.
	 */

	for (n = mdoc->last; n && n != body && n != blk->parent;
	     n = n->parent) {
		if (n->flags & MDOC_ENDED) {
			if ( ! (n->flags & MDOC_VALID))
				n->flags |= MDOC_BROKEN;
			continue;
		}
		if (n->type == ROFFT_BLOCK &&
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT) {
			n->flags |= MDOC_BROKEN;
			if ( ! (body->flags & MDOC_ENDED)) {
				mandoc_vmsg(MANDOCERR_BLK_NEST,
				    mdoc->parse, line, ppos,
				    "%s breaks %s", mdoc_macronames[tok],
				    mdoc_macronames[n->tok]);
				mdoc_endbody_alloc(mdoc, line, ppos,
				    tok, body, ENDBODY_NOSPACE);
			}
		}
	}
	assert(n == body);
	if (body->flags & MDOC_ENDED)
@


1.185
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.184 2015/04/02 21:36:50 schwarze Exp $ */
d259 3
a261 1
	assert(to);
d630 2
a631 4
		if (j == maxargs && n != NULL) {
			rew_pending(mdoc, n);
			n = NULL;
		}
d646 2
a647 4
		if (n != NULL) {
			rew_pending(mdoc, n);
			n = NULL;
		}
@


1.184
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.183 2015/02/12 12:24:33 schwarze Exp $ */
d48 1
a48 2
static	enum mdoct	lookup(struct mdoc *, enum mdoct,
				int, int, const char *);
d50 5
a54 6
static	int		parse_rest(struct mdoc *, enum mdoct,
				int, int *, char *);
static	enum mdoct	rew_alt(enum mdoct);
static	void		rew_elem(struct mdoc *, enum mdoct);
static	void		rew_last(struct mdoc *, const struct mdoc_node *);
static	void		rew_pending(struct mdoc *, const struct mdoc_node *);
d211 1
a211 1
	struct mdoc_node *n;
d233 2
a234 2
static enum mdoct
lookup(struct mdoc *mdoc, enum mdoct from, int line, int ppos, const char *p)
d236 1
a236 1
	enum mdoct	 res;
d255 1
a255 1
rew_last(struct mdoc *mdoc, const struct mdoc_node *to)
d257 1
a257 1
	struct mdoc_node *n, *np;
d282 1
a282 1
rew_pending(struct mdoc *mdoc, const struct mdoc_node *n)
d320 2
a321 2
static enum mdoct
rew_alt(enum mdoct tok)
d363 1
a363 1
rew_elem(struct mdoc *mdoc, enum mdoct tok)
d365 1
a365 1
	struct mdoc_node *n;
d454 1
a454 1
	enum mdoct	 ntok;
d483 5
a487 5
	struct mdoc_node *body;		/* Our own body. */
	struct mdoc_node *endbody;	/* Our own end marker. */
	struct mdoc_node *itblk;	/* An It block starting later. */
	struct mdoc_node *later;	/* A sub-block starting later. */
	struct mdoc_node *n;		/* Search back to our block. */
d491 1
a491 1
	enum mdoct	 atok, ntok;
d665 1
a665 1
	enum mdoct	 ntok;
d849 4
a852 4
	struct mdoc_node *blk; /* Our own or a broken block. */
	struct mdoc_node *head; /* Our own head. */
	struct mdoc_node *body; /* Our own body. */
	struct mdoc_node *n;
d1115 3
a1117 3
	struct mdoc_node *blk; /* saved block context */
	struct mdoc_node *body; /* saved body context */
	struct mdoc_node *n;
d1208 1
a1208 1
	struct mdoc_node *head; /* keep track of head */
d1265 1
a1265 1
	enum mdoct	 ntok;
d1379 1
a1379 1
	struct mdoc_node	*n;
d1411 1
a1411 1
parse_rest(struct mdoc *mdoc, enum mdoct tok, int line, int *pos, char *buf)
d1446 1
a1446 1
	struct mdoc_node *body, *n;
@


1.183
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.182 2015/02/11 13:37:57 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d29 2
d32 1
a32 1
#include "mandoc.h"
a33 1
#include "libmandoc.h"
d221 1
a221 1
		if (n->type == MDOC_BLOCK &&
d291 1
a291 1
		case MDOC_HEAD:
d294 1
a294 1
		case MDOC_BLOCK:
d307 2
a308 2
			if (n->type == MDOC_BLOCK ||
			    n->type == MDOC_HEAD) {
d370 1
a370 1
	if (MDOC_ELEM != n->type)
d372 1
a372 1
	assert(MDOC_ELEM == n->type);
d391 1
a391 1
	    d == DELIM_NONE && mdoc->last->type == MDOC_TEXT &&
d526 1
a526 1
		if (n->type == MDOC_BODY && atok == n->tok) {
d532 1
a532 1
		if (n->type != MDOC_BLOCK || n->tok == MDOC_Nm)
d877 1
a877 1
			if (n->type != MDOC_BLOCK)
d1020 1
a1020 1
		 * the MDOC_HEAD) for non-phrase types.
d1090 1
a1090 1
		if (n->type == MDOC_BLOCK &&
d1175 1
a1175 1
		if (n->type == MDOC_BLOCK &&
d1456 1
a1456 1
		if (n->tok == MDOC_It && n->type == MDOC_BODY)
@


1.182
log
@explicit blocks close out .Nd; fixing data structure corruption
eventually leading to NULL pointer access;
found by jsg@@ with afl, text case #455.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.181 2015/02/10 17:47:45 schwarze Exp $ */
a49 2
static	void		make_pending(struct mdoc *, struct mdoc_node *,
				struct mdoc_node *, int, int);
d286 12
a297 1
	rew_last(mdoc, n);
d299 2
a300 2
	if (n->type != MDOC_BLOCK)
		return;
d302 12
a313 4
	while ((n = n->pending) != NULL) {
		rew_last(mdoc, n);
		if (n->type == MDOC_HEAD)
			mdoc_body_alloc(mdoc, n->line, n->pos, n->tok);
a376 72
 * We are trying to close the block *breaker,
 * but the child block *broken is still open.
 * Thus, postpone closing the *breaker
 * until the rew_pending() call closing *broken.
 */
static void
make_pending(struct mdoc *mdoc, struct mdoc_node *breaker,
	struct mdoc_node *broken, int line, int ppos)
{
	struct mdoc_node *n;

	mandoc_vmsg(MANDOCERR_BLK_NEST, mdoc->parse, line, ppos,
	    "%s breaks %s", mdoc_macronames[breaker->tok],
	    mdoc_macronames[broken->tok]);

	/*
	 * If the *broken block (Z) is already broken by a block (B)
	 * contained in the breaker (A), make the breaker pending
	 * on that inner breaker (B).  Graphically,
	 *
	 * breaker=[A! broken=n=[B!->A (old broken=)[Z->B B] A] Z]
	 *
	 * In these graphics, "->" indicates the "pending" pointer and
	 * "!" indicates the MDOC_BREAK flag.  Each of the cases gets
	 * one additional pointer (B->A) and one additional flag (A!).
	 */

	for (n = broken->parent; ; n = n->parent)
		if (n == broken->pending)
			broken = n;
		else if (n == breaker)
			break;

	/*
	 * Found the breaker.
	 *
	 * If another, outer breaker (X) is already pending on
	 * the *broken block (B), we must not clobber the link
	 * to the outer breaker, but make it pending on the new,
	 * now inner breaker (A).  Graphically,
	 *
	 * [X! n=breaker=[A!->X broken=[B(->X)->A X] A] B].
	 */

	if (broken->pending != NULL) {
		n = breaker;

		/*
		 * If the inner breaker (A) is already broken, too,
		 * it cannot take on the outer breaker (X) but must
		 * hand it on to its own breakers (Y).  Graphically,
		 *
		 * [X! n=[Y!->X breaker=[A!->Y Y] broken=[B(->X)->A X] A] B]
		 */

		while (n->pending)
			n = n->pending;
		n->pending = broken->pending;
	}

	/*
	 * Now we have reduced the situation to the simplest case:
	 * breaker=[A! broken=[B->A A] B].
	 */

	broken->pending = breaker;
	breaker->flags |= MDOC_BREAK;
	if (breaker->body != NULL)
		breaker->body->flags |= MDOC_BREAK;
}

/*
d517 3
a519 1
		if (n->flags & (MDOC_VALID | MDOC_BREAK))
d521 1
a555 7
			 */

			make_pending(mdoc, n, later, line, ppos);
			if (tok == MDOC_El)
				itblk->flags |= MDOC_BREAK;

			/*
d560 5
d568 3
d589 1
a589 5
		/*
		 * When finding an open sub block, remember the last
		 * open explicit block, or, in case there are only
		 * implicit ones, the first open implicit block.
		 */
d591 2
a592 2
		if (later == NULL ||
		    ! (mdoc_macros[later->tok].flags & MDOC_EXPLICIT))
d871 6
a876 2
			if (n->flags & (MDOC_VALID | MDOC_BREAK) ||
			    n->type != MDOC_BLOCK)
d878 1
d1084 5
d1090 3
a1092 4
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT &&
		    ! (n->flags & MDOC_VALID)) {
			n->pending = head;
			return;
d1095 2
d1169 5
d1175 10
a1184 6
		    mdoc_macros[n->tok].flags & MDOC_EXPLICIT &&
		    ! (n->flags & MDOC_VALID)) {
			make_pending(mdoc, blk, n, line, ppos);
			mdoc_endbody_alloc(mdoc, line, ppos,
			    tok, body, ENDBODY_NOSPACE);
			return;
d1188 3
d1453 1
a1453 1
		if (n->flags & (MDOC_VALID | MDOC_BREAK))
@


1.181
log
@Be more careful to not generate empty .In, .St, and .Xr nodes.
That could happen when their first argument was another called macro,
causing a NULL pointer access in .St validation found by jsg@@ with afl.

Make in_line_argn() easier to understand by using one state
variable rather than two.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.180 2015/02/07 16:42:33 schwarze Exp $ */
d633 7
@


1.180
log
@Closing a block validates it, which may end up deleting it,
so if we are in a loop over blocks, cleanly restart the loop
rather than risking use after free; found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.179 2015/02/06 07:13:14 schwarze Exp $ */
a1287 2
	int		 la, flushed, j, maxargs, nl;
	enum margserr	 ac;
d1290 1
d1292 2
d1327 1
a1328 1
	flushed = j = 0;
d1332 14
d1347 1
a1347 1
			if (j < 2 && tok == MDOC_Pf)
d1354 1
a1354 9
		if ( ! (mdoc_macros[tok].flags & MDOC_IGNDELIM) &&
		    ac != ARGS_QWORD && j == 0 &&
		    mdoc_isdelim(p) == DELIM_OPEN) {
			dword(mdoc, line, la, p, DELIM_OPEN, 0);
			continue;
		} else if (j == 0)
		       mdoc_elem_alloc(mdoc, line, ppos, tok, arg);

		if (j == maxargs && ! flushed) {
d1356 1
a1356 1
			flushed = 1;
d1359 1
a1359 1
		ntok = (ac == ARGS_QWORD || (tok == MDOC_Pf && j == 0)) ?
d1363 1
a1363 1
			if ( ! flushed)
d1365 2
a1366 1
			flushed = 1;
a1367 1
			j++;
d1371 9
a1379 3
		if ( ! (mdoc_macros[tok].flags & MDOC_IGNDELIM) &&
		    ac != ARGS_QWORD && ! flushed &&
		    mdoc_isdelim(p) != DELIM_NONE) {
d1381 1
a1381 1
			flushed = 1;
a1385 1
		j++;
d1388 4
a1391 9
	if (j == 0) {
		if (tok == MDOC_In || tok == MDOC_St || tok == MDOC_Xr) {
			mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
			    line, ppos, mdoc_macronames[tok]);
			return;
		}
		mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
		if (ac == ARGS_PUNCT && tok == MDOC_Pf)
			append_delims(mdoc, line, pos, buf);
d1393 4
a1396 1
	if ( ! flushed)
@


1.179
log
@Delete the legacy generic warning type MANDOCERR_ARGCWARN,
replacing the last instances by more specific warnings.
Improved functionality, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.178 2015/02/06 03:38:45 schwarze Exp $ */
d944 1
@


1.178
log
@better handle .Fo and .Fd without argument
better handle .Fo with more than one argument
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.177 2015/02/06 01:07:22 schwarze Exp $ */
d1406 2
a1407 1
	if (buf[*pos] == '\0' && tok == MDOC_Fd) {
d1409 1
a1409 1
		    line, ppos, "Fd");
@


1.177
log
@better handle .In .Sh .Ss .St .Xr without arguments
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.176 2015/02/05 01:46:56 schwarze Exp $ */
d1406 6
@


1.176
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.175 2015/02/05 00:14:13 schwarze Exp $ */
d907 6
d1376 5
@


1.175
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.174 2015/02/04 22:30:10 schwarze Exp $ */
d775 1
a775 1
			if (cnt == 0 && nc == 0)
@


1.174
log
@Discard excess head arguments for .Bd .Bl .Bk and delete hwarn_eq0().
Discard empty .Bk blocks.
Improve related diagnostics.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.173 2015/02/04 18:03:47 schwarze Exp $ */
a264 3
		if ( ! (mdoc->last->flags & MDOC_VALID))
			mdoc->last->lastline = to->lastline -
			    (mdoc->flags & MDOC_NEWLINE ? 1 : 0);
d578 1
a578 1
			if (n->end == ENDBODY_NOT) {
a579 2
				n->lastline = line;
			}
a591 1
			n->lastline = line;
@


1.173
log
@discard .Rs head arguments and improve .Rs diagnostics
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.172 2015/02/03 18:22:05 schwarze Exp $ */
d1045 6
d1114 1
a1114 1
	if (nl && tok != MDOC_Rs)
@


1.172
log
@Avoid closing out an explicit block twice when broken by .It
(assertion failure); regression found in jsg@@'s afl test case 847.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.171 2015/02/03 01:14:12 schwarze Exp $ */
a1029 2
		if (ac == ARGS_PUNCT)
			break;
d1045 7
d1108 1
a1108 1
	if (nl)
@


1.171
log
@Finally delete the kitchensink functions rew_sub() and rew_dohalt().
They were a maintenance and auditing nightmare because if you changed
one bit in there, stuff tended to break at seemingly unrelated places.
No functional change except getting rid of one bogus error message,
but minus 80 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.170 2015/02/03 00:48:47 schwarze Exp $ */
d970 1
@


1.170
log
@Bring .Pp/.Lp handling inside .Nm blocks closer to groff;
as a bonus, get rid of another call to rew_sub().
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.169 2015/02/02 19:23:23 schwarze Exp $ */
a33 7
enum	rew {	/* see rew_dohalt() */
	REWIND_NONE,
	REWIND_THIS,
	REWIND_MORE,
	REWIND_FORCE
};

a54 2
static	enum rew	rew_dohalt(enum mdoct, enum mdoc_type,
				const struct mdoc_node *);
a57 2
static	void		rew_sub(enum mdoc_type, struct mdoc *,
				enum mdoct, int, int);
a348 89
/*
 * Rewinding to tok, how do we have to handle *p?
 * REWIND_NONE: *p would delimit tok, but no tok scope is open
 *   inside *p, so there is no need to rewind anything at all.
 * REWIND_THIS: *p matches tok, so rewind *p and nothing else.
 * REWIND_MORE: *p is implicit, rewind it and keep searching for tok.
 * REWIND_FORCE: *p is explicit, but tok is full, force rewinding *p.
 */
static enum rew
rew_dohalt(enum mdoct tok, enum mdoc_type type,
		const struct mdoc_node *p)
{

	/*
	 * No matching token, no delimiting block, no broken block.
	 * This can happen when full implicit macros are called for
	 * the first time but try to rewind their previous
	 * instance anyway.
	 */
	if (MDOC_ROOT == p->type)
		return(REWIND_NONE);

	/*
	 * When starting to rewind, skip plain text
	 * and nodes that have already been rewound.
	 */
	if (p->type == MDOC_TEXT || p->flags & (MDOC_VALID | MDOC_BREAK))
		return(REWIND_MORE);

	/*
	 * The easiest case:  Found a matching token.
	 * This applies to both blocks and elements.
	 */
	tok = rew_alt(tok);
	if (tok == p->tok)
		return(type == p->type ? REWIND_THIS : REWIND_MORE);

	/*
	 * While elements do require rewinding for themselves,
	 * they never affect rewinding of other nodes.
	 */
	if (MDOC_ELEM == p->type)
		return(REWIND_MORE);

	/*
	 * Blocks delimited by our target token get REWIND_MORE.
	 * Blocks delimiting our target token get REWIND_NONE.
	 */
	switch (tok) {
	case MDOC_It:
		if (MDOC_BODY == p->type && MDOC_Bl == p->tok)
			return(REWIND_NONE);
		break;
	case MDOC_Nm:
		return(REWIND_NONE);
	case MDOC_Nd:
		/* FALLTHROUGH */
	case MDOC_Ss:
		if (MDOC_BODY == p->type && MDOC_Sh == p->tok)
			return(REWIND_NONE);
		/* FALLTHROUGH */
	case MDOC_Sh:
		if (MDOC_ROOT == p->parent->type)
			return(REWIND_THIS);
		if (MDOC_Nd == p->tok || MDOC_Ss == p->tok ||
		    MDOC_Sh == p->tok)
			return(REWIND_MORE);
		break;
	default:
		break;
	}

	/*
	 * Default block rewinding rules.
	 * In particular, let all blocks rewind Nm children.
	 * Do not warn again when closing a block,
	 * since closing the body already warned.
	 */
	if (MDOC_Nm == p->tok ||
	    MDOC_BLOCK == type || MDOC_BLOCK == p->type)
		return(REWIND_MORE);

	/*
	 * By default, closing out full blocks
	 * forces closing of broken explicit blocks.
	 */
	return (REWIND_FORCE);
}

a433 39
static void
rew_sub(enum mdoc_type t, struct mdoc *mdoc,
		enum mdoct tok, int line, int ppos)
{
	struct mdoc_node *n, *to;

	to = NULL;
	n = mdoc->last;
	while (n) {
		switch (rew_dohalt(tok, t, n)) {
		case REWIND_NONE:
			if (to == NULL)
				return;
			n = to;
			break;
		case REWIND_THIS:
			n->lastline = line -
			    (mdoc->flags & MDOC_NEWLINE &&
			     ! (mdoc_macros[tok].flags & MDOC_EXPLICIT));
			break;
		case REWIND_FORCE:
			mandoc_vmsg(MANDOCERR_BLK_BROKEN, mdoc->parse,
			    line, ppos, "%s breaks %s",
			    mdoc_macronames[tok],
			    mdoc_macronames[n->tok]);
			/* FALLTHROUGH */
		case REWIND_MORE:
			n->lastline = line -
			    (mdoc->flags & MDOC_NEWLINE ? 1 : 0);
			to = n;
			n = n->parent;
			continue;
		}
		break;
	}
	assert(n);
	rew_pending(mdoc, n);
}

d544 1
d548 1
a548 1
	int		 have_it, j, lastarg, maxargs, nl;
a571 1
	have_it = 0;
d573 1
a573 1
	body = endbody = later = NULL;
d592 1
a592 1
			have_it = 1;
d607 1
a607 1
			    (tok == MDOC_El && !have_it))
d617 2
d673 1
a673 1
		if (endbody == NULL)
d904 1
a904 1
	struct mdoc_node *blk; /* Our own block. */
d913 1
a913 1
	/* Skip items outside lists. */
d915 15
a929 4
	if (tok == MDOC_It) {
		for (n = mdoc->last; n; n = n->parent)
			if (n->tok == MDOC_Bl && n->type == MDOC_BLOCK &&
			    ! (n->flags & (MDOC_VALID | MDOC_BREAK)))
d931 49
a979 1
		if (n == NULL) {
a987 7
	/* Close out prior implicit scope. */

	if ( ! (mdoc_macros[tok].flags & MDOC_EXPLICIT)) {
		rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
		rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
	}

@


1.169
log
@Simplify and reindent make_pending().  No functional change
except that some error messages become less confusing.
Now the function is almost readable (but still requires
nineteen lines of comments for fourteen lines of code).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.168 2015/02/02 18:26:32 schwarze Exp $ */
d1462 2
a1463 1
	struct mdoc_arg	*arg;
d1465 8
a1472 2
	if (tok == MDOC_Pp)
		rew_sub(MDOC_BLOCK, mdoc, MDOC_Nm, line, ppos);
@


1.168
log
@Simplify: Do not call rew_dohalt() from make_pending(),
the calling macro handler already found the breaking block.
No functional change except tiny variations in error messages.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.167 2015/02/02 15:02:49 schwarze Exp $ */
d474 3
a476 1
	/* Iterate backwards, searching for the breaker. */
d478 11
a488 1
	for (n = broken->parent; ; n = n->parent) {
d490 2
a491 13
		/*
		 * If the *broken block (Z) is already broken and we
		 * encounter its breaker (B), make the tok block (A)
		 * pending on that inner breaker (B).
		 * Graphically, [A n=[B! broken=[Z->B B] tok=A] Z]
		 * becomes [A broken=[B! [Z->B B] tok=A] Z]
		 * and finally [A! [B!->A [Z->B B] A] Z].
		 * In these graphics, "->" indicates the "pending"
		 * pointer and "!" indicates the MDOC_BREAK flag.
		 * Each of the cases gets one additional pointer (B->A)
		 * and one additional flag (A!).
		 */
		if (n == broken->pending) {
d493 13
a505 2
			continue;
		}
d507 2
a508 2
		if (n != breaker)
			continue;
d511 5
a515 8
		 * Found the breaker.
		 * If another, outer breaker (X) is already pending on
		 * the *broken block (B), we must not clobber the link
		 * to the outer breaker, but make it pending on the
		 * new, now inner breaker (A).
		 * Graphically, [X! breaker=[A broken=[B->X X] tok=A] B]
		 * becomes [X! breaker=[A->X broken=[B X] tok=A] B]
		 * and finally [X! [A!->X [B->A X] A] B].
a516 2
		if (broken->pending) {
			struct mdoc_node *taker;
d518 9
a526 13
			/*
			 * If the inner breaker (A) is already broken,
			 * too, it cannot take on the outer breaker (X)
			 * but must hand it on to its own breakers (Y):
			 * [X! [Y! breaker=[A->Y Y] broken=[B->X X] tok=A] B]
			 * [X! take=[Y!->X brea=[A->Y Y] brok=[B X] tok=A] B]
			 * and finally [X! [Y!->X [A!->Y Y] [B->A X] A] B].
			 */
			taker = breaker;
			while (taker->pending)
				taker = taker->pending;
			taker->pending = broken->pending;
		}
d528 4
a531 14
		/*
		 * Now we have reduced the situation to the simplest
		 * case, which is just breaker=[A broken=[B tok=A] B]
		 * and becomes [A! [B->A A] B].
		 */
		broken->pending = breaker;
		breaker->flags |= MDOC_BREAK;
		if (breaker->body != NULL)
			breaker->body->flags |= MDOC_BREAK;
		mandoc_vmsg(MANDOCERR_BLK_NEST, mdoc->parse, line, ppos,
		    "%s breaks %s", mdoc_macronames[breaker->tok],
		    mdoc_macronames[broken->tok]);
		return;
	}
@


1.167
log
@Get rid of all remaining calls to rew_sub() where the target block
is known.  This only leaves three that do actual searching.
No functional change, minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.166 2015/02/02 04:26:44 schwarze Exp $ */
d57 2
a58 2
static	int		make_pending(struct mdoc_node *, enum mdoct,
				struct mdoc *, int, int);
d463 1
a463 1
 * We are trying to close a block identified by tok,
d465 1
a465 1
 * Thus, postpone closing the tok block
d468 3
a470 3
static int
make_pending(struct mdoc_node *broken, enum mdoct tok,
		struct mdoc *mdoc, int line, int ppos)
d472 1
a472 1
	struct mdoc_node *breaker;
d474 3
a476 5
	/*
	 * Iterate backwards, searching for the block matching tok,
	 * that is, the block breaking the *broken block.
	 */
	for (breaker = broken->parent; breaker; breaker = breaker->parent) {
d482 2
a483 2
		 * Graphically, [A breaker=[B! broken=[Z->B B] tok=A] Z]
		 * becomes breaker=[A broken=[B! [Z->B B] tok=A] Z]
d490 2
a491 2
		if (breaker == broken->pending) {
			broken = breaker;
d495 1
a495 1
		if (REWIND_THIS != rew_dohalt(tok, MDOC_BLOCK, breaker))
a496 2
		if (MDOC_BODY == broken->type)
			broken = broken->parent;
d535 1
a535 1
		    "%s breaks %s", mdoc_macronames[tok],
d537 1
a537 1
		return(1);
a538 6

	/*
	 * Found no matching block for tok.
	 * Are you trying to close a block that is not open?
	 */
	return(0);
d762 1
a762 1
			make_pending(later, tok, mdoc, line, ppos);
d1288 1
a1288 1
			make_pending(n, tok, mdoc, line, ppos);
@


1.166
log
@Get rid of all calls to rew_sub() in blk_exp_close(); only ten calls
remain in other functions.  As a bonus, this fixes an assertion failure
jsg@@ found some time ago with afl (test case 982) and improves minor
details in error reporting.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.165 2015/02/02 04:04:45 schwarze Exp $ */
d38 1
a38 3
	REWIND_FORCE,
	REWIND_LATER,
	REWIND_ERROR
a366 2
 * REWIND_LATER: *p is explicit and still open, postpone rewinding.
 * REWIND_ERROR: No tok block is open at all.
d380 1
a380 3
		return(MDOC_BLOCK == type &&
		    MDOC_EXPLICIT & mdoc_macros[tok].flags ?
		    REWIND_ERROR : REWIND_NONE);
d395 1
a395 2
		return(p->end ? REWIND_NONE :
		    type == p->type ? REWIND_THIS : REWIND_MORE);
a408 4
	case MDOC_Bl:
		if (MDOC_It == p->tok)
			return(REWIND_MORE);
		break;
a412 10
	/*
	 * XXX Badly nested block handling still fails badly
	 * when one block is breaking two blocks of the same type.
	 * This is an incomplete and extremely ugly workaround,
	 * required to let the OpenBSD tree build.
	 */
	case MDOC_Oo:
		if (MDOC_Op == p->tok)
			return(REWIND_MORE);
		break;
d434 1
a434 2
	 * In particular, always skip block end markers,
	 * and let all blocks rewind Nm children.
d438 2
a439 3
	if (ENDBODY_NOT != p->end || MDOC_Nm == p->tok ||
	    MDOC_BLOCK == type || (MDOC_BLOCK == p->type &&
	    ! (MDOC_EXPLICIT & mdoc_macros[tok].flags)))
d444 1
a444 3
	 * forces closing of broken explicit blocks,
	 * while closing out partial blocks
	 * allows delayed rewinding by default.
d446 1
a446 2
	return (&blk_full == mdoc_macros[tok].fp ?
	    REWIND_FORCE : REWIND_LATER);
d466 1
a466 1
 * until the rew_sub call closing *broken.
a582 10
		case REWIND_LATER:
			if (make_pending(n, tok, mdoc, line, ppos) ||
			    t != MDOC_BLOCK)
				return;
			/* FALLTHROUGH */
		case REWIND_ERROR:
			mandoc_msg(MANDOCERR_BLK_NOTOPEN,
			    mdoc->parse, line, ppos,
			    mdoc_macronames[tok]);
			return;
d767 3
a769 3
			 * When there is a pending sub block,
			 * postpone closing out the current block
			 * until the rew_sub() closing out the sub-block.
d827 2
a828 1
		rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
d1143 2
a1144 1
			rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d1178 1
a1178 2
			rew_sub(body ? MDOC_BODY : MDOC_HEAD,
			    mdoc, tok, line, ppos);
d1212 1
a1212 1
	 * head to body until the rew_sub() call closing out that
d1226 2
a1227 2
	rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
	mdoc_body_alloc(mdoc, line, ppos, tok);
d1230 2
a1231 2
		rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
		rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
d1289 2
a1290 2
	 * postpone closing out the current block
	 * until the rew_sub() call closing out the sub-block.
d1532 1
a1532 1
	struct mdoc_node *n;
d1536 10
a1545 4
	n = mdoc->last;
	while (n != NULL &&
	    (n->tok != MDOC_Bl || n->flags & (MDOC_VALID | MDOC_BREAK)))
		n = n->parent;
d1554 1
a1554 1
	rew_sub(MDOC_BODY, mdoc, MDOC_It, line, ppos);
@


1.165
log
@When a full block macro gets closed out by a mismatching
block closure macro it calls, do not attempt to open its body.
This can for example happen for (nonsensical) constructions like
.Fo
.Nm Fc
in the SYNOPSIS.  Fixing an assertion failure jsg@@ found with afl
some time ago (test case number 731).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.164 2015/02/01 23:56:37 schwarze Exp $ */
d68 1
d267 3
d278 3
d298 19
d562 2
d623 1
a623 11
	rew_last(mdoc, n);

	/*
	 * The current block extends an enclosing block.
	 * Now that the current block ends, close the enclosing block, too.
	 */
	while ((n = n->pending) != NULL) {
		rew_last(mdoc, n);
		if (n->type == MDOC_HEAD)
			mdoc_body_alloc(mdoc, n->line, n->pos, n->tok);
	}
d737 1
a737 1
	struct mdoc_node *n;		/* For searching backwards. */
d739 1
a739 1
	int		 flushed, have_it, j, lastarg, maxargs, nl;
d773 1
a773 1
			if (n->end == ENDBODY_NOT)
d775 2
d789 1
d815 1
a815 1
			mdoc_endbody_alloc(mdoc, line, ppos,
d821 1
a821 2
			 * into the end marker and remeber the
			 * end marker in order to close it out.
d824 1
a824 2
			if (maxargs) {
				endbody = mdoc->last;
a825 1
			}
d839 17
a855 1
	rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d867 2
a868 13
	if (maxargs && endbody == NULL) {
		if (n == NULL) {
			/*
			 * Stray .Ec without previous .Eo:
			 * Break the output line, ignore any arguments.
			 */
			mdoc_elem_alloc(mdoc, line, ppos, MDOC_br, NULL);
			rew_elem(mdoc, MDOC_br);
		} else
			mdoc_tail_alloc(mdoc, line, ppos, atok);
	}

	flushed = n == NULL;
d872 3
a874 6
		if (j == maxargs && ! flushed) {
			if (endbody == NULL)
				rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
			else
				rew_last(mdoc, endbody);
			flushed = 1;
d890 3
a892 6
		if ( ! flushed) {
			if (endbody == NULL)
				rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
			else
				rew_last(mdoc, endbody);
			flushed = 1;
d899 2
a900 6
	if ( ! flushed) {
		if (endbody == NULL)
			rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
		else
			rew_last(mdoc, endbody);
	}
d1343 1
a1343 12
	rew_last(mdoc, blk);

	/*
	 * The current block extends an enclosing block.
	 * Now that the current block ends, close the enclosing block, too.
	 */

	while ((blk = blk->pending) != NULL) {
		rew_last(mdoc, blk);
		if (blk->type == MDOC_HEAD)
			mdoc_body_alloc(mdoc, blk->line, blk->pos, blk->tok);
	}
@


1.164
log
@get rid of rew_sub() in blk_part_imp(); no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.163 2015/02/01 17:30:45 schwarze Exp $ */
d1080 3
a1082 2
	struct mdoc_node *head; /* save of head macro */
	struct mdoc_node *body; /* save of body macro */
d1122 1
a1122 1
	mdoc_block_alloc(mdoc, line, ppos, tok, arg);
d1222 2
@


1.163
log
@Simplify blk_part_exp(), no functional change.
* Replace calls to rew_sub() with rew_last() - two less out of 18.
* No need to keep track of the body, it's always opened right after
the head and never used for anything in this function.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.162 2015/02/01 16:47:39 schwarze Exp $ */
d1324 1
a1324 1
	rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d1327 12
a1338 1
	rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos);
@


1.162
log
@The function rew_sub() tries to rewind any all all kinds of blocks
and elements under any and all circumstances, even handling some
bad block nesting now and then.  Little surprisingly, this ends up
in excessive complexity and has caused many bugs in the past.
Start to slowly disentangle this mess by replacing calls to rew_sub()
immediately following mdoc_head_alloc() by the much simpler rew_last().
Gets rid of the first two rew_sub() calls out of twenty.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.161 2014/12/22 23:27:32 schwarze Exp $ */
a1342 1
	struct mdoc_node *body; /* keep track of body */
d1354 2
a1355 1
	for (head = body = NULL; ; ) {
a1364 1
			assert(NULL == body);
a1369 1
			assert(body == NULL);
d1371 1
a1371 11
		}

		/*
		 * `Eo' gobbles any data into the head, but most other
		 * macros just immediately close out and begin the body.
		 */

		if (body == NULL) {
			assert(head);
			/* No check whether it's a macro! */
			if (tok == MDOC_Eo)
d1373 2
a1374 2
			rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
			body = mdoc_body_alloc(mdoc, line, ppos, tok);
a1377 1
		assert(head != NULL && body != NULL);
d1385 2
a1386 5
	if (head == NULL)
		mdoc_head_alloc(mdoc, line, ppos, tok);

	if (body == NULL) {
		rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
@


1.161
log
@The code already pays attention not to close the same block twice.
Similarly, avoid having the same block break two other blocks.
In some situations, this could lead to an endless loop in rew_sub()
found by jsg@@ with afl.
Minimal example:  .Po Ao Pc Bo Pc Ac Bc
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.160 2014/12/20 02:26:57 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d1140 1
a1140 1
		rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
d1277 1
a1277 2
	mdoc_head_alloc(mdoc, line, ppos, tok);
	rew_sub(MDOC_HEAD, mdoc, tok, line, ppos);
@


1.160
log
@Fix two issues causing a class of assertion failures found by jsg@@ with afl.
1) rew_sub(): Make sure REWIND_MORE is acted upon even when followed by
REWIND_NONE.  This prevents .It from ending up inside other children of .Bl.
2) blk_exp_close(): Only allow extension of .Bl when it has at least
one .It.  Otherwise, a broken child block could be moved in front of
the .Bl, effectively resulting in a .Bl that ended before it began.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.159 2014/12/18 20:58:32 schwarze Exp $ */
d366 1
a366 1
	if (MDOC_TEXT == p->type || MDOC_VALID & p->flags)
d749 1
a749 1
		if (n->flags & MDOC_VALID)
@


1.159
log
@Don't let .Ta creep into an already-closed list; same as for .It.
Fixes an assertion found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.158 2014/12/18 03:10:11 schwarze Exp $ */
d553 1
a553 1
	struct mdoc_node *n;
d555 1
d560 4
a563 1
			return;
d578 1
d721 1
a721 1
	int		 j, lastarg, maxargs, flushed, nl;
d745 1
d762 6
d777 2
a778 1
			if (later == NULL)
d817 2
a818 4
		if (later &&
		    mdoc_macros[later->tok].flags & MDOC_EXPLICIT)
			continue;
		if (n->tok != MDOC_It)
@


1.158
log
@The code is already careful to not add items to lists that were
already closed.  In this respect, also consider lists closed
that have broken another block, their closure pending until the
end of the broken block.  This avoids syntax tree corruption
leading to a NULL pointer access found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.157 2014/12/13 13:14:39 schwarze Exp $ */
d1562 2
a1563 1
	while (n != NULL && n->tok != MDOC_Bl)
@


1.157
log
@Fix a regression found by Carsten dot Kunze at arcor dot de:
Do not show bogus quotes when .Bl -column phrases are quoted.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.156 2014/11/30 05:29:00 schwarze Exp $ */
d481 10
a490 6
		 * If the *broken block had already been broken before
		 * and we encounter its breaker, make the tok block
		 * pending on the inner breaker.
		 * Graphically, "[A breaker=[B broken=[C->B B] tok=A] C]"
		 * becomes "[A broken=[B [C->B B] tok=A] C]"
		 * and finally "[A [B->A [C->B B] A] C]".
d504 2
a505 2
		 * If another, outer breaker is already pending on
		 * the *broken block, we must not clobber the link
d507 4
a510 4
		 * new, now inner breaker.
		 * Graphically, "[A breaker=[B broken=[C->A A] tok=B] C]"
		 * becomes "[A breaker=[B->A broken=[C A] tok=B] C]"
		 * and finally "[A [B->A [C->B A] B] C]".
d516 6
a521 6
			 * If the breaker had also been broken before,
			 * it cannot take on the outer breaker itself,
			 * but must hand it on to its own breakers.
			 * Graphically, this is the following situation:
			 * "[A [B breaker=[C->B B] broken=[D->A A] tok=C] D]"
			 * "[A taker=[B->A breaker=[C->B B] [D->C A] C] D]"
d528 6
d535 1
d1081 2
a1082 2
			if (n->tok == MDOC_Bl &&
			    ! (n->flags & MDOC_VALID))
@


1.156
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.155 2014/11/30 02:36:38 schwarze Exp $ */
d675 1
a675 3
	if (mdoc->flags & MDOC_PHRASELIT)
		/* nothing */;
	else if (*p == '"')
d677 1
a677 1
	else if (parsed)
@


1.155
log
@warn about attempts to call non-callable macros;
inspired by a similar warning in the groff_mdoc(7) macros
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.154 2014/11/29 04:31:35 schwarze Exp $ */
d1399 1
a1399 1
	nl = MDOC_NEWLINE & mdoc->flags;
d1431 3
a1433 1
	for (flushed = j = 0; ; ) {
d1436 5
a1440 1
		if (ac == ARGS_PUNCT || ac == ARGS_EOLN)
d1442 1
d1457 2
a1458 2
		ntok = ac == ARGS_QWORD ? MDOC_MAX :
		    lookup(mdoc, tok, line, la, p);
d1481 1
a1481 1
	if (j == 0)
d1483 3
@


1.154
log
@Reduce code duplication by reusing the same argument parser
for in_line_eoln() macros and .Bl -column phrases.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.153 2014/11/29 03:37:44 schwarze Exp $ */
d56 2
a57 1
static	enum mdoct	lookup(enum mdoct, const char *);
d249 1
a249 1
lookup(enum mdoct from, const char *p)
d255 7
a261 2
		if (res != MDOC_MAX && mdoc_macros[res].flags & MDOC_CALLABLE)
			return(res);
d680 1
a680 1
		ntok = lookup(tok, p);
d841 2
a842 1
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);
d943 1
a943 1
		    MDOC_MAX : lookup(tok, p);
d1450 2
a1451 1
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);
@


1.153
log
@Provide a helper function macro_or_word() and use it to prune the
same chunk of argument parsing code out of five of the eight callback
functions.  The other three have too much special handling to
participate.
As a bonus, let lookup() and mdoc_args() deal with line macros and
retire the lookup_raw() helper and the mdoc_zargs() internal interface
function.
No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.152 2014/11/28 23:21:32 schwarze Exp $ */
d60 2
a61 1
static	void		phrase(struct mdoc *, int, int *, char *);
d1185 1
a1185 1
			phrase(mdoc, line, &la, buf);
a1476 1
	int		 la;
d1484 14
d1502 1
a1502 1
			break;
d1504 1
a1504 1
			return;
a1505 1
	rew_elem(mdoc, tok);
a1527 11
phrase(struct mdoc *mdoc, int line, int *pos, char *buf)
{
	int		 la;

	do
		la = *pos;
	while (mdoc_args(mdoc, line, pos, buf, MDOC_MAX, NULL) != ARGS_EOLN &&
	    !macro_or_word(mdoc, MDOC_MAX, line, la, pos, buf, 1));
}

static void
d1547 1
a1547 1
	phrase(mdoc, line, pos, buf);
@


1.152
log
@Fold the loop around mdoc_argv() into the function itself,
it was the same in all four cases.  As a bonus, get rid
of one enum type that was used for internal communication.
No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.151 2014/11/28 04:47:03 schwarze Exp $ */
d57 1
a57 1
static	enum mdoct	lookup_raw(const char *);
d60 1
a60 1
static	void		phrase(struct mdoc *, int, int, char *);
d243 2
a244 1
 * Look up a macro from within a subsequent context.
a248 12

	if ( ! (MDOC_PARSED & mdoc_macros[from].flags))
		return(MDOC_MAX);
	return(lookup_raw(p));
}

/*
 * Lookup a macro following the initial line macro.
 */
static enum mdoct
lookup_raw(const char *p)
{
d251 5
a255 4
	if (MDOC_MAX == (res = mdoc_hash_find(p)))
		return(MDOC_MAX);
	if (MDOC_CALLABLE & mdoc_macros[res].flags)
		return(res);
d626 1
a627 2
	enum margserr	 ac;
	char		*p;
d634 1
a634 2
		ac = mdoc_zargs(mdoc, line, pos, buf, &p);
		if (ac == ARGS_EOLN)
d656 34
d1050 1
a1050 1
	int		  la, nl, nparsed;
a1054 1
	enum mdoct	  ntok;
d1101 3
a1103 3
	nparsed = tok == MDOC_It &&
	    mdoc->last->parent->tok == MDOC_Bl &&
	    mdoc->last->parent->norm->Bl.type == LIST_diag;
d1184 1
a1184 1
			phrase(mdoc, line, la, buf);
d1189 1
a1189 5
		ntok = nparsed || ac == ARGS_QWORD ?
		    MDOC_MAX : lookup(tok, p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1190 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1230 1
	enum mdoct	  ntok;
d1273 1
a1273 4
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1274 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1317 1
	enum mdoct	  ntok;
d1365 1
a1365 3
		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);
		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1366 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1476 1
	enum margserr	 ac;
a1477 4
	char		*p;
	enum mdoct	 ntok;

	assert( ! (MDOC_PARSED & mdoc_macros[tok].flags));
a1484 2
	/* Parse argument terms. */

d1487 1
a1487 2
		ac = mdoc_args(mdoc, line, pos, buf, tok, &p);
		if (ac == ARGS_EOLN)
d1489 1
a1489 6

		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup(tok, p);

		if (ntok != MDOC_MAX) {
			rew_elem(mdoc, tok);
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
a1490 3
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
a1491 3

	/* Close out (no delimiters). */

d1515 1
a1515 1
phrase(struct mdoc *mdoc, int line, int ppos, char *buf)
d1517 1
a1517 4
	int		 la, pos;
	enum margserr	 ac;
	enum mdoct	 ntok;
	char		*p;
d1519 4
a1522 16
	for (pos = ppos; ; ) {
		la = pos;

		ac = mdoc_zargs(mdoc, line, &pos, buf, &p);
		if (ac == ARGS_EOLN)
			break;

		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup_raw(p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, &pos, buf);
			append_delims(mdoc, line, &pos, buf);
			return;
		}
		dword(mdoc, line, la, p, DELIM_MAX, 1);
	}
a1528 4
	int		  la;
	enum mdoct	  ntok;
	enum margserr	  ac;
	char		 *p;
d1545 1
a1545 17

	for (;;) {
		la = *pos;
		ac = mdoc_zargs(mdoc, line, pos, buf, &p);
		if (ac == ARGS_EOLN)
			break;

		ntok = ac == ARGS_QWORD ? MDOC_MAX : lookup_raw(p);

		if (ntok != MDOC_MAX) {
			mdoc_macro(mdoc, ntok, line, la, pos, buf);
			append_delims(mdoc, line, pos, buf);
			return;
		}
		dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags);
	}
@


1.151
log
@Simplify by making the mdoc parser callbacks void, and some cleanup;
no functional change, minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.150 2014/11/28 03:14:18 schwarze Exp $ */
a845 1
	enum margverr	 av;
d878 1
a878 9
	for (arg = NULL;; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}
a1034 1
	enum margverr	  av;
d1071 1
a1071 10
	for (arg = NULL;; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}

a1385 1
	enum margverr	 av;
d1420 1
a1420 9
	for (arg = NULL; ; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}
a1476 1
	enum margverr	 av;
d1486 1
a1486 14
	/* Parse macro arguments. */

	for (arg = NULL; ; ) {
		la = *pos;
		av = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
		if (av == ARGV_ARG)
			continue;
		if (av == ARGV_WORD)
			*pos = la;
		break;
	}

	/* Open element scope. */

@


1.150
log
@Simplify the code by making various mdoc parser helper functions void.
No functional change, minus 130 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.149 2014/11/28 01:05:43 schwarze Exp $ */
d43 9
a51 9
static	int		blk_full(MACRO_PROT_ARGS);
static	int		blk_exp_close(MACRO_PROT_ARGS);
static	int		blk_part_exp(MACRO_PROT_ARGS);
static	int		blk_part_imp(MACRO_PROT_ARGS);
static	int		ctx_synopsis(MACRO_PROT_ARGS);
static	int		in_line_eoln(MACRO_PROT_ARGS);
static	int		in_line_argn(MACRO_PROT_ARGS);
static	int		in_line(MACRO_PROT_ARGS);
static	int		phrase_ta(MACRO_PROT_ARGS);
d60 1
a60 1
static	int		phrase(struct mdoc *, int, int, char *);
d221 1
a221 1
int
d228 1
a228 1
	n = MDOC_VALID & mdoc->last->flags ?
d232 2
a233 2
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags)
a239 1
	return(1);
d670 1
a670 1
static int
d691 1
d701 1
d709 1
d726 1
d735 1
d742 1
d745 8
d765 1
d772 1
a779 1
		rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
d781 1
a781 1
		return(1);
a782 1
	rew_sub(MDOC_BODY, mdoc, tok, line, ppos);
a826 1

d828 1
a828 3

		if ( ! mdoc_macro(mdoc, ntok, line, lastarg, pos, buf))
			return(0);
a839 1
	return(1);
d842 1
a842 1
static int
d882 3
a884 2

		if (ARGV_WORD == av) {
d886 1
a886 9
			break;
		}
		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d943 1
a943 3

			if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
				return(0);
d946 1
a946 1
			return(1);
a1031 1
	return(1);
d1034 1
a1034 1
static int
d1061 1
a1061 1
			return(1);
d1084 3
a1086 2

		if (ARGV_WORD == av) {
d1088 1
a1088 10
			break;
		}

		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d1098 1
d1162 1
a1169 3

			/* Then allocate our body context. */

d1182 1
a1182 4

			if ( ! phrase(mdoc, line, la, buf))
				return(0);

d1190 3
a1192 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1194 2
a1195 4

		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		break;
d1202 1
a1202 4

	/* If we've already opened our body, exit now. */

	if (NULL != body)
d1212 3
a1214 3
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags &&
		    ! (MDOC_VALID & n->flags)) {
d1216 1
a1216 1
			return(1);
a1223 1

a1229 1
	return(1);
d1232 1
a1232 1
static int
d1281 3
a1283 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1285 2
a1286 4

		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		break;
a1287 3

	/* Clean-ups to leave in a consistent state. */

d1296 1
d1305 1
a1305 1
			return(1);
a1309 3

	/* Standard appending of delimiters. */

a1311 3

	/* Rewind scope, if applicable. */

a1319 2

	return(1);
d1322 1
a1322 1
static int
d1379 3
a1381 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1383 2
a1384 3
		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		break;
a1395 3

	/* Standard appending of delimiters. */

a1397 1
	return(1);
d1400 1
a1400 1
static int
d1443 3
a1445 2

		if (ARGV_WORD == av) {
d1447 1
a1447 10
			break;
		}

		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d1475 1
a1475 2
			if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
				return(0);
a1493 3

	/* Close out in a consistent state. */

a1497 1
	return(1);
d1500 1
a1500 1
static int
d1520 3
a1522 2

		if (ARGV_WORD == av) {
d1524 1
a1524 9
			break;
		}
		if (ARGV_EOLN == av)
			break;
		if (ARGV_ARG == av)
			continue;

		mdoc_argv_free(arg);
		return(0);
d1541 4
a1544 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1546 2
a1547 2
		rew_elem(mdoc, tok);
		return(mdoc_macro(mdoc, ntok, line, la, pos, buf));
a1552 1
	return(1);
d1555 1
a1555 1
static int
a1557 1
	int		 nl;
d1559 8
a1566 19
	nl = MDOC_NEWLINE & mdoc->flags;

	/* If we're not in the SYNOPSIS, go straight to in-line. */
	if ( ! (MDOC_SYNOPSIS & mdoc->flags))
		return(in_line(mdoc, tok, line, ppos, pos, buf));

	/* If we're a nested call, same place. */
	if ( ! nl)
		return(in_line(mdoc, tok, line, ppos, pos, buf));

	/*
	 * XXX: this will open a block scope; however, if later we end
	 * up formatting the block scope, then child nodes will inherit
	 * the formatting.  Be careful.
	 */
	if (MDOC_Nm == tok)
		return(blk_full(mdoc, tok, line, ppos, pos, buf));
	assert(MDOC_Vt == tok);
	return(blk_part_imp(mdoc, tok, line, ppos, pos, buf));
d1574 1
a1574 1
static int
d1591 4
a1594 3
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX, 1);
			continue;
d1596 1
a1596 5

		if ( ! mdoc_macro(mdoc, ntok, line, la, &pos, buf))
			return(0);
		append_delims(mdoc, line, &pos, buf);
		return(1);
a1597 2

	return(1);
d1600 1
a1600 1
static int
d1610 1
d1612 1
a1612 1
	while (NULL != n && MDOC_Bl != n->tok)
d1614 1
a1614 1
	if (NULL == n || LIST_column != n->norm->Bl.type) {
d1617 1
a1617 1
		return(1);
d1633 4
a1636 4
		if (ntok == MDOC_MAX) {
			dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags);
			continue;
d1638 2
a1639 5

		if ( ! mdoc_macro(mdoc, ntok, line, la, pos, buf))
			return(0);
		append_delims(mdoc, line, pos, buf);
		return(1);
a1640 2

	return(1);
@


1.149
log
@Simplify code by making mdoc validation handlers void.
No functional change, minus 90 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.148 2014/11/27 22:27:56 schwarze Exp $ */
d53 1
a53 1
static	int		dword(struct mdoc *, int, int, const char *,
d55 1
a55 2
static	int		append_delims(struct mdoc *,
				int, int *, char *);
d66 1
a66 1
static	int		rew_sub(enum mdoc_type, struct mdoc *,
d542 1
a542 1
static int
d552 1
a552 1
			return(1);
d555 2
a556 2
			    (MDOC_NEWLINE & mdoc->flags &&
			     ! (MDOC_EXPLICIT & mdoc_macros[tok].flags));
d566 1
a566 1
			    (MDOC_NEWLINE & mdoc->flags ? 1 : 0);
d571 2
a572 2
			    MDOC_BLOCK != t)
				return(1);
d578 1
a578 1
			return(1);
a581 1

d589 1
a589 1
	while (NULL != (n = n->pending)) {
d591 2
a592 3
		if (MDOC_HEAD == n->type &&
		    ! mdoc_body_alloc(mdoc, n->line, n->pos, n->tok))
			return(0);
a593 2

	return(1);
d600 1
a600 1
static int
d605 1
a605 1
	if (DELIM_MAX == d)
d609 3
a611 3
	    ! ((MDOC_SYNOPSIS | MDOC_KEEP | MDOC_SMOFF) & mdoc->flags) &&
	    DELIM_NONE == d && MDOC_TEXT == mdoc->last->type &&
	    DELIM_NONE == mdoc_isdelim(mdoc->last->string)) {
d613 1
a613 1
		return(1);
d616 1
a616 2
	if ( ! mdoc_word_alloc(mdoc, line, col, p))
		return(0);
a630 1

a631 2

	return(1);
d634 1
a634 1
static int
d641 2
a642 2
	if ('\0' == buf[*pos])
		return(1);
d647 1
a647 4

		if (ARGS_ERROR == ac)
			return(0);
		else if (ARGS_EOLN == ac)
a648 1

d662 1
a665 2

	return(1);
d704 1
a704 1
		if (MDOC_VALID & n->flags)
d708 2
a709 2
		if (MDOC_BODY == n->type && atok == n->tok) {
			if (ENDBODY_NOT == n->end)
d714 1
a714 1
		if (MDOC_BLOCK != n->type || MDOC_Nm == n->tok)
d724 1
a724 1
			if (NULL == later)
d738 2
a739 3
			if ( ! mdoc_endbody_alloc(mdoc, line, ppos,
			    atok, body, ENDBODY_SPACE))
				return(0);
d753 1
a753 1
		    MDOC_EXPLICIT & mdoc_macros[later->tok].flags)
d755 1
a755 1
		if (MDOC_It != n->tok)
d759 2
a760 2
	if ( ! (MDOC_PARSED & mdoc_macros[tok].flags)) {
		if ('\0' != buf[*pos])
d765 3
a767 3
		if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
			return(0);
		return(rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos));
d769 1
a769 3

	if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
		return(0);
d777 1
a777 3
			if ( ! mdoc_elem_alloc(mdoc, line, ppos,
			    MDOC_br, NULL))
				return(0);
d779 2
a780 2
		} else if ( ! mdoc_tail_alloc(mdoc, line, ppos, atok))
			return(0);
d788 3
a790 1
			if (endbody != NULL)
a791 2
			else if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
				return(0);
d796 1
a796 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_PUNCT == ac)
			break;
		if (ARGS_EOLN == ac)
d799 1
a799 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d801 3
a803 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, lastarg, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d808 3
a810 1
			if (endbody != NULL)
a811 2
			else if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
				return(0);
d823 3
a825 1
		if (endbody != NULL)
a826 2
		else if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
			return(0);
d828 3
a830 4

	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
a893 3
		if (ac == ARGS_ERROR)
			return(0);

d929 1
a929 1
		if (MDOC_MAX != ntok) {
d932 2
a933 4
			if (nc && 0 == cnt) {
				if ( ! mdoc_elem_alloc(mdoc,
				    line, ppos, tok, arg))
					return(0);
d935 1
a935 1
			} else if ( ! nc && 0 == cnt) {
d944 3
a946 3
			if ( ! nl)
				return(1);
			return(append_delims(mdoc, line, pos, buf));
d955 1
a955 1
		d = ARGS_QWORD == ac ? DELIM_NONE : mdoc_isdelim(p);
d967 1
a967 3
				if ( ! mdoc_elem_alloc(mdoc,
				    line, ppos, tok, arg))
					return(0);
d970 1
a970 1
				if (MDOC_Nm == tok)
d983 1
a983 2
			if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
				return(0);
d988 2
a989 3
		if ( ! dword(mdoc, line, la, p, d,
		    MDOC_JOIN & mdoc_macros[tok].flags))
			return(0);
d1005 1
a1005 1
		if (scope && MDOC_Fl == tok) {
d1020 9
a1028 8
	if (nc && 0 == cnt) {
		if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
			return(0);
		rew_last(mdoc, mdoc->last);
	} else if ( ! nc && 0 == cnt) {
		mdoc_argv_free(arg);
		mandoc_msg(MANDOCERR_MACRO_EMPTY, mdoc->parse,
		    line, ppos, mdoc_macronames[tok]);
d1030 3
a1032 4

	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
a1042 1
	enum mdoc_type	  mtt;
d1060 1
a1060 3
			if ( ! mdoc_elem_alloc(mdoc, line, ppos,
			    MDOC_br, NULL))
				return(0);
d1068 3
a1070 5
	if ( ! (MDOC_EXPLICIT & mdoc_macros[tok].flags)) {
		if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
			return(0);
		if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
			return(0);
d1100 1
a1100 3
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, arg))
		return(0);

d1107 3
a1109 3
	nparsed = MDOC_It == tok &&
	    MDOC_Bl == mdoc->last->parent->tok &&
	    LIST_diag == mdoc->last->parent->norm->Bl.type;
d1116 4
a1119 9
	if (MDOC_Nd == tok) {
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
			return(0);
		head = mdoc->last;
		if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			return(0);
		body = mdoc->last;
d1122 1
a1122 1
	if (MDOC_Bk == tok)
d1125 2
a1126 3
	ac = ARGS_ERROR;

	for ( ; ; ) {
d1128 1
a1128 2
		/* Initialise last-phrase-type with ARGS_PEND. */
		lac = ARGS_ERROR == ac ? ARGS_PEND : ac;
d1130 1
a1130 2

		if (ARGS_PUNCT == ac)
d1132 2
a1133 6

		if (ARGS_ERROR == ac)
			return(0);

		if (ARGS_EOLN == ac) {
			if (ARGS_PPHRASE != lac && ARGS_PHRASE != lac)
d1142 2
a1143 5
			if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
				return(0);
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
				return(0);
			body = mdoc->last;
d1152 7
a1158 8
		if (NULL == head &&
		    ARGS_PEND != ac &&
		    ARGS_PHRASE != ac &&
		    ARGS_PPHRASE != ac &&
		    ARGS_QWORD != ac &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1164 2
a1165 5
		if (NULL == head) {
			if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
				return(0);
			head = mdoc->last;
		}
d1167 3
a1169 3
		if (ARGS_PHRASE == ac ||
		    ARGS_PEND == ac ||
		    ARGS_PPHRASE == ac) {
d1175 2
a1176 3
			mtt = body ? MDOC_BODY : MDOC_HEAD;
			if ( ! rew_sub(mtt, mdoc, tok, line, ppos))
				return(0);
d1180 1
a1180 3
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
				return(0);
			body = mdoc->last;
d1188 1
a1188 1
			if (ARGS_PPHRASE == ac)
d1190 1
a1190 1
			if (ARGS_PEND == ac && ARGS_PPHRASE == lac)
d1200 1
a1200 1
		ntok = nparsed || ARGS_QWORD == ac ?
d1203 3
a1205 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1214 4
a1217 8
	if (NULL == head) {
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
			return(0);
		head = mdoc->last;
	}

	if (nl && ! append_delims(mdoc, line, pos, buf))
		return(0);
d1241 2
a1242 4
	if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
		return(0);
	if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
		return(0);
d1245 5
a1249 9
	if ( ! (MDOC_FREECOL & mdoc->flags))
		return(1);

	if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
		return(0);
	if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
		return(0);

	mdoc->flags &= ~MDOC_FREECOL;
d1275 3
a1277 9
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
		return(0);

	blk = mdoc->last;

	if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
		return(0);
	if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
		return(0);
d1288 1
a1288 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
			break;
		if (ARGS_PUNCT == ac)
d1291 3
a1293 4
		if (NULL == body && ARGS_QWORD != ac &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1297 2
a1298 5
		if (NULL == body) {
		       if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			       return(0);
			body = mdoc->last;
		}
d1300 1
a1300 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d1302 3
a1304 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1315 2
a1316 5
	if (NULL == body) {
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			return(0);
		body = mdoc->last;
	}
d1325 3
a1327 3
		if (MDOC_BLOCK == n->type &&
		    MDOC_EXPLICIT & mdoc_macros[n->tok].flags &&
		    ! (MDOC_VALID & n->flags)) {
d1329 2
a1330 3
			if ( ! mdoc_endbody_alloc(mdoc, line, ppos,
			    tok, body, ENDBODY_NOSPACE))
				return(0);
d1335 1
a1335 3

	if ( ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
		return(0);
d1339 2
a1340 2
	if (nl && ! append_delims(mdoc, line, pos, buf))
		return(0);
d1344 1
a1344 2
	if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
		return(0);
d1350 1
a1350 1
	if (n && MDOC_Ns == n->tok)
d1374 1
a1374 3
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
		return(0);

d1378 1
a1378 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_PUNCT == ac)
			break;
		if (ARGS_EOLN == ac)
d1383 2
a1384 2
		if (NULL == head && ARGS_QWORD != ac &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
d1386 1
a1386 2
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1390 3
a1392 5
		if (NULL == head) {
			assert(NULL == body);
			if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
				return(0);
			head = mdoc->last;
d1400 1
a1400 1
		if (NULL == body) {
d1403 5
a1407 11
			if (MDOC_Eo == tok)
				if ( ! dword(mdoc, line, la, p, DELIM_MAX, 0))
					return(0);

			if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
				return(0);
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
				return(0);
			body = mdoc->last;

			if (MDOC_Eo == tok)
d1410 1
d1412 4
a1415 8
		assert(NULL != head && NULL != body);

		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);

		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
a1417 1

d1425 2
a1426 3
	if (NULL == head)
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
			return(0);
d1428 3
a1430 5
	if (NULL == body) {
		if ( ! rew_sub(MDOC_HEAD, mdoc, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
			return(0);
d1435 3
a1437 3
	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
d1501 1
a1501 6

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_PUNCT == ac)
			break;
		if (ARGS_EOLN == ac)
d1504 4
a1507 5
		if ( ! (MDOC_IGNDELIM & mdoc_macros[tok].flags) &&
		    ARGS_QWORD != ac && 0 == j &&
		    DELIM_OPEN == mdoc_isdelim(p)) {
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN, 0))
				return(0);
d1509 2
a1510 3
		} else if (0 == j)
		       if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
			       return(0);
d1517 1
a1517 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d1519 1
a1519 1
		if (MDOC_MAX != ntok) {
d1529 3
a1531 4
		if ( ! (MDOC_IGNDELIM & mdoc_macros[tok].flags) &&
		    ARGS_QWORD != ac &&
		    ! flushed &&
		    DELIM_NONE != mdoc_isdelim(p)) {
d1536 2
a1537 3
		if ( ! dword(mdoc, line, la, p, DELIM_MAX,
		    MDOC_JOIN & mdoc_macros[tok].flags))
			return(0);
d1541 2
a1542 2
	if (0 == j && ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
	       return(0);
d1548 3
a1550 3
	if ( ! nl)
		return(1);
	return(append_delims(mdoc, line, pos, buf));
d1589 1
a1589 2
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
		return(0);
d1596 1
a1596 4

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
d1599 1
a1599 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d1601 3
a1603 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1659 1
a1659 4

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
d1662 1
a1662 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup_raw(p);
d1664 2
a1665 3
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX, 1))
				return(0);
d1671 2
a1672 1
		return(append_delims(mdoc, line, &pos, buf));
d1698 3
a1700 4
	if ( ! rew_sub(MDOC_BODY, mdoc, MDOC_It, line, ppos))
		return(0);
	if ( ! mdoc_body_alloc(mdoc, line, ppos, MDOC_It))
		return(0);
d1705 1
a1705 4

		if (ARGS_ERROR == ac)
			return(0);
		if (ARGS_EOLN == ac)
d1708 1
a1708 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup_raw(p);
d1710 3
a1712 4
		if (MDOC_MAX == ntok) {
			if ( ! dword(mdoc, line, la, p, DELIM_MAX,
			    MDOC_JOIN & mdoc_macros[tok].flags))
				return(0);
d1718 2
a1719 1
		return(append_delims(mdoc, line, pos, buf));
@


1.148
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.147 2014/11/26 19:22:51 schwarze Exp $ */
d65 2
a66 3
static	int		rew_elem(struct mdoc *, enum mdoct);
static	int		rew_last(struct mdoc *,
				const struct mdoc_node *);
d240 2
a241 1
	return(rew_last(mdoc, mdoc->first));
d271 1
a271 1
static int
a277 2


d286 1
a286 2
		if ( ! mdoc_valid_post(mdoc))
			return(0);
d292 1
a292 2

	return(mdoc_valid_post(mdoc));
d454 1
a454 1
static int
d464 1
a464 2

	return(rew_last(mdoc, n));
d585 1
a585 2
	if ( ! rew_last(mdoc, n))
		return(0);
d592 1
a592 2
		if ( ! rew_last(mdoc, n))
			return(0);
d797 1
a797 2
			if ( ! rew_elem(mdoc, MDOC_br))
				return(0);
d807 3
a809 2
			if ( ! (endbody != NULL ? rew_last(mdoc, endbody) :
			    rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos)))
d833 3
a835 2
			if ( ! (endbody != NULL ? rew_last(mdoc, endbody) :
			    rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos)))
d847 6
a852 3
	if ( ! flushed && ! (endbody != NULL ? rew_last(mdoc, endbody) :
	    rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos)))
		return(0);
d959 2
a960 2
			if (scope && ! rew_elem(mdoc, tok))
				return(0);
d965 1
a965 2
				if ( ! rew_last(mdoc, mdoc->last))
					return(0);
d1010 2
a1011 2
			if (scope && ! rew_elem(mdoc, tok))
				return(0);
d1041 1
a1041 2
			if ( ! rew_elem(mdoc, tok))
				return(0);
d1046 2
a1047 2
	if (scope && ! rew_elem(mdoc, tok))
		return(0);
d1058 1
a1058 2
		if ( ! rew_last(mdoc, mdoc->last))
			return(0);
d1099 2
a1100 1
			return(rew_elem(mdoc, MDOC_br));
d1641 1
a1641 2
			if ( ! rew_elem(mdoc, tok))
				return(0);
d1648 2
a1649 2
			if ( ! flushed && ! rew_elem(mdoc, tok))
				return(0);
d1661 1
a1661 2
			if ( ! rew_elem(mdoc, tok))
				return(0);
d1676 2
a1677 2
	if ( ! flushed && ! rew_elem(mdoc, tok))
		return(0);
d1741 1
a1741 3

		if ( ! rew_elem(mdoc, tok))
			return(0);
d1747 2
a1748 1
	return(rew_elem(mdoc, tok));
@


1.147
log
@The .Sm macro accepts at most one argument;
fixing an assertion failure found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.146 2014/11/25 20:00:01 schwarze Exp $ */
d696 1
d723 1
a723 1
	body = later = NULL;
d762 4
d795 12
a806 2
	if (NULL == later && maxargs > 0)
		if ( ! mdoc_tail_alloc(mdoc, line, ppos, rew_alt(tok)))
d808 1
d810 2
a811 1
	for (flushed = j = 0; ; j++) {
d815 2
a816 1
			if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
d840 2
a841 1
			if ( ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
d853 2
a854 1
	if ( ! flushed && ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
@


1.146
log
@Do not access a NULL pointer when a section has no body,
which can for example happen for .Sh Xo .Sh without .Xc.
Crash found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.145 2014/11/20 00:31:28 schwarze Exp $ */
d174 1
a174 1
	{ in_line_eoln, 0 }, /* Sm */
@


1.145
log
@Fix two minibugs reported by Thomas Klausner <wiz at NetBSD>:
1. The first argument of .Fn is not supposed to be parsed.
2. The .Fn macro is not supposed to reopen its scope after punctuation.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.144 2014/11/17 06:44:58 schwarze Exp $ */
d440 2
d444 1
a444 1
	    (MDOC_BLOCK == p->type &&
@


1.144
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.143 2014/09/07 00:05:28 schwarze Exp $ */
d929 2
a930 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
d995 2
@


1.143
log
@Allow .ll in the prologue; Daniel Levai reports Slackware Linux uses this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.142 2014/08/21 12:57:17 schwarze Exp $ */
d150 1
a150 2
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED |
			MDOC_IGNDELIM | MDOC_JOIN }, /* No */
a628 3
	if (DELIM_OPEN == d)
		mdoc->last->flags |= MDOC_DELIMO;

d630 4
a633 7
	 * Closing delimiters only suppress the preceding space
	 * when they follow something, not when they start a new
	 * block or element, and not when they follow `No'.
	 *
	 * XXX	Explicitly special-casing MDOC_No here feels
	 *	like a layering violation.  Find a better way
	 *	and solve this in the code related to `No'!
d636 4
a639 2
	else if (DELIM_CLOSE == d && mdoc->last->prev &&
	    mdoc->last->prev->tok != MDOC_No &&
d643 2
d843 1
a843 1
	int		 la, scope, cnt, mayopen, nc, nl;
d894 2
d901 1
a901 1
		if (ARGS_ERROR == ac)
d903 9
a911 1
		if (ARGS_EOLN == ac)
d913 13
a925 1
		if (ARGS_PUNCT == ac)
d927 1
d972 1
a972 1
			 * has been omitted, no scope is open, and we're
d978 1
a978 2
			    (nc || tok == MDOC_Li) &&
			    !scope && !cnt && mayopen) {
d984 1
a984 1
				if (MDOC_Li == tok || MDOC_Nm == tok)
d1006 9
a1563 2
	case MDOC_No:
		/* FALLTHROUGH */
@


1.142
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.141 2014/08/16 19:50:37 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d213 1
a213 1
	{ in_line_eoln, 0 }, /* ll */
@


1.141
log
@If a stray .It follows .El, we are no longer in the list,
even though the list is still the last processed macro.
This fixes a regression introduced in mdoc_macro.c rev. 1.138:
Ulrich Spoerlein <uqs at FreeBSD> reports that various of their
kernel manuals trigger assertions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.140 2014/08/10 23:54:41 schwarze Exp $ */
d846 1
a846 1
	int		 la, scope, cnt, nc, nl;
d897 1
d954 1
a954 3
			 * a new scope.  `Ar', `Fl', and `Li', only do
			 * this once per invocation.  There may be more
			 * of these (all of them?).
d956 4
a959 2
			if (0 == cnt && (nc || MDOC_Li == tok) &&
			    DELIM_CLOSE == d && ! scope) {
a962 3
				if (MDOC_Ar == tok || MDOC_Li == tok ||
				    MDOC_Fl == tok)
					cnt++;
d964 3
d975 1
a975 1
		} else if ( ! scope) {
d979 1
a981 3
		if (DELIM_NONE == d)
			cnt++;

@


1.140
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.139 2014/08/01 17:27:44 schwarze Exp $ */
d1044 2
a1045 1
			if (n->tok == MDOC_Bl)
@


1.139
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.138 2014/07/30 17:06:26 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
d19 2
a20 1
#endif
@


1.138
log
@Get rid of the useless FATAL error "child violates parent syntax".
When finding items outside lists, simply skip them and throw an ERROR.
Handle subsections before the first section instead of bailing out.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.137 2014/07/07 21:36:20 schwarze Exp $ */
d1788 1
a1788 1
		    line, ppos, NULL);
@


1.137
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.136 2014/07/04 16:12:08 schwarze Exp $ */
d427 2
d1040 16
@


1.136
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.135 2014/07/02 20:19:11 schwarze Exp $ */
d237 2
a238 1
			mdoc_nmsg(mdoc, n, MANDOCERR_SCOPEEXIT);
d532 1
a532 1
		mandoc_vmsg(MANDOCERR_BLOCK_NEST, mdoc->parse, line, ppos,
d562 1
a562 1
			mandoc_vmsg(MANDOCERR_SCOPEBROKEN, mdoc->parse,
d578 3
a580 1
			mdoc_pmsg(mdoc, line, ppos, MANDOCERR_NOSCOPE);
d1769 2
a1770 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_STRAYTA);
@


1.135
log
@Improve and test the messages about empty macros,
in particular reporting the macro names involved.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.134 2014/07/02 11:43:20 schwarze Exp $ */
d772 6
a777 5
	if ( ! (MDOC_CALLABLE & mdoc_macros[tok].flags)) {
		/* FIXME: do this in validate */
		if (buf[*pos])
			mdoc_pmsg(mdoc, line, ppos, MANDOCERR_ARGSLOST);

@


1.134
log
@Clean up warnings related to macros and nesting.
* Hierarchical naming of enum mandocerr items.
* Improve the wording to make it comprehensible.
* Mention the offending macro.
* Garbage collect one chunk of ancient, long unreachable code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.133 2014/07/02 08:21:39 schwarze Exp $ */
d922 3
a924 2
				mdoc_pmsg(mdoc, line, ppos,
				    MANDOCERR_MACROEMPTY);
d1009 2
a1010 1
		mdoc_pmsg(mdoc, line, ppos, MANDOCERR_MACROEMPTY);
@


1.133
log
@Fix the column numbers associated with in_line_argn() macros;
this bug is more than four years old, introduced by kristaps@@
in mdocml.bsd.lv rev. 1.46, March 30, 2010.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.132 2014/07/02 03:48:07 schwarze Exp $ */
d531 1
a531 1
		mandoc_vmsg(MANDOCERR_SCOPENEST, mdoc->parse, line, ppos,
d1357 1
d1359 1
a1359 11
	/*
	 * If we can't rewind to our body, then our scope has already
	 * been closed by another macro (like `Oc' closing `Op').  This
	 * is ugly behaviour nodding its head to OpenBSD's overwhelming
	 * crufty use of `Op' breakage.
	 */
	if (n != body)
		mandoc_vmsg(MANDOCERR_SCOPENEST, mdoc->parse, line,
		    ppos, "%s broken", mdoc_macronames[tok]);

	if (n && ! rew_sub(MDOC_BODY, mdoc, tok, line, ppos))
d1369 1
a1369 1
	if (n && ! rew_sub(MDOC_BLOCK, mdoc, tok, line, ppos))
@


1.132
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.131 2014/04/20 16:46:05 schwarze Exp $ */
d1576 1
a1576 1
		       if ( ! mdoc_elem_alloc(mdoc, line, la, tok, arg))
d1612 1
a1612 1
	if (0 == j && ! mdoc_elem_alloc(mdoc, line, la, tok, arg))
@


1.131
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.130 2014/03/30 19:47:48 schwarze Exp $ */
a50 1
static	int		obsolete(MACRO_PROT_ARGS);
d106 1
a106 1
	{ obsolete, 0 }, /* Ot */
d193 1
a193 1
	{ obsolete, 0 }, /* Fr */
d205 2
a206 2
	{ obsolete, 0 }, /* Es */
	{ obsolete, 0 }, /* En */
d1530 2
a1718 8
static int
obsolete(MACRO_PROT_ARGS)
{

	mdoc_pmsg(mdoc, line, ppos, MANDOCERR_MACROOBS);
	return(1);
}

@


1.130
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.129 2014/01/21 10:26:53 schwarze Exp $ */
d43 10
a52 10
static	int	  	blk_full(MACRO_PROT_ARGS);
static	int	  	blk_exp_close(MACRO_PROT_ARGS);
static	int	  	blk_part_exp(MACRO_PROT_ARGS);
static	int	  	blk_part_imp(MACRO_PROT_ARGS);
static	int	  	ctx_synopsis(MACRO_PROT_ARGS);
static	int	  	in_line_eoln(MACRO_PROT_ARGS);
static	int	  	in_line_argn(MACRO_PROT_ARGS);
static	int	  	in_line(MACRO_PROT_ARGS);
static	int	  	obsolete(MACRO_PROT_ARGS);
static	int	  	phrase_ta(MACRO_PROT_ARGS);
d56 1
a56 1
static	int	  	append_delims(struct mdoc *, 
d62 3
a64 3
static	int	  	phrase(struct mdoc *, int, int, char *);
static	enum mdoct 	rew_alt(enum mdoct);
static	enum rew  	rew_dohalt(enum mdoct, enum mdoc_type, 
d66 2
a67 2
static	int	  	rew_elem(struct mdoc *, enum mdoct);
static	int	  	rew_last(struct mdoc *, 
d69 1
a69 1
static	int	  	rew_sub(enum mdoc_type, struct mdoc *, 
d233 1
a233 1
			mdoc->last->parent : mdoc->last;
a244 1

a256 1

a271 1

d280 1
a280 1
	/* LINTED */
a299 1

d308 1
a308 1
	case (MDOC_Ac):
d310 1
a310 1
	case (MDOC_Bc):
d312 1
a312 1
	case (MDOC_Brc):
d314 1
a314 1
	case (MDOC_Dc):
d316 1
a316 1
	case (MDOC_Ec):
d318 1
a318 1
	case (MDOC_Ed):
d320 1
a320 1
	case (MDOC_Ef):
d322 1
a322 1
	case (MDOC_Ek):
d324 1
a324 1
	case (MDOC_El):
d326 1
a326 1
	case (MDOC_Fc):
d328 1
a328 1
	case (MDOC_Oc):
d330 1
a330 1
	case (MDOC_Pc):
d332 1
a332 1
	case (MDOC_Qc):
d334 1
a334 1
	case (MDOC_Re):
d336 1
a336 1
	case (MDOC_Sc):
d338 1
a338 1
	case (MDOC_Xc):
a345 1

d357 1
a357 1
rew_dohalt(enum mdoct tok, enum mdoc_type type, 
d373 1
a373 1
	 * When starting to rewind, skip plain text 
d397 1
a397 1
	 * Blocks delimiting our target token get REWIND_NONE. 
d400 1
a400 1
	case (MDOC_Bl):
d404 1
a404 1
	case (MDOC_It):
d414 1
a414 1
	case (MDOC_Oo):
d418 1
a418 1
	case (MDOC_Nm):
d420 1
a420 1
	case (MDOC_Nd):
d422 1
a422 1
	case (MDOC_Ss):
d426 1
a426 1
	case (MDOC_Sh):
a454 1

a468 1

d533 2
a534 2
				"%s breaks %s", mdoc_macronames[tok],
				mdoc_macronames[broken->tok]);
a544 1

d546 1
a546 1
rew_sub(enum mdoc_type t, struct mdoc *mdoc, 
d554 1
a554 1
		case (REWIND_NONE):
d556 1
a556 1
		case (REWIND_THIS):
d561 5
a565 5
		case (REWIND_FORCE):
			mandoc_vmsg(MANDOCERR_SCOPEBROKEN, mdoc->parse, 
					line, ppos, "%s breaks %s", 
					mdoc_macronames[tok],
					mdoc_macronames[n->tok]);
d567 1
a567 1
		case (REWIND_MORE):
d572 1
a572 1
		case (REWIND_LATER):
d577 1
a577 1
		case (REWIND_ERROR):
d611 1
a611 1
	
d640 2
a641 2
			mdoc->last->prev->tok != MDOC_No &&
			mdoc->last->parent->tok != MDOC_Fd)
a685 1

d687 1
a687 1
 * Close out block partial/full explicit.  
d696 1
a696 1
	int	 	 j, lastarg, maxargs, flushed, nl;
d704 1
a704 1
	case (MDOC_Ec):
d707 1
a707 1
	case (MDOC_Ek):
d744 1
a744 1
			/* 
d775 1
a775 1
		if (buf[*pos]) 
d786 1
a786 1
	if (NULL == later && maxargs > 0) 
a837 1

d857 1
a857 1
	case (MDOC_An):
d859 1
a859 1
	case (MDOC_Ar):
d861 1
a861 1
	case (MDOC_Fl):
d863 1
a863 1
	case (MDOC_Mt):
d865 1
a865 1
	case (MDOC_Nm):
d867 1
a867 1
	case (MDOC_Pa):
d882 1
a882 1
		} 
d905 1
a905 1
		/* 
d916 2
a917 2
				if ( ! mdoc_elem_alloc(mdoc, line,
						ppos, tok, arg))
d924 1
a924 1
					MANDOCERR_MACROEMPTY);
d932 1
a932 1
		} 
d934 1
a934 1
		/* 
d937 1
a937 1
		 * the word. 
d951 4
a954 4
			if (0 == cnt && (nc || MDOC_Li == tok) && 
					DELIM_CLOSE == d && ! scope) {
				if ( ! mdoc_elem_alloc(mdoc, line,
						ppos, tok, arg))
d956 2
a957 2
				if (MDOC_Ar == tok || MDOC_Li == tok || 
						MDOC_Fl == tok)
a1016 1

d1058 1
a1058 1
		} 
d1079 2
a1080 2
		MDOC_Bl == mdoc->last->parent->tok &&
		LIST_diag == mdoc->last->parent->norm->Bl.type;
d1133 1
a1133 1
		/* 
d1138 6
a1143 6
		if (NULL == head && 
				ARGS_PEND != ac &&
				ARGS_PHRASE != ac &&
				ARGS_PPHRASE != ac &&
				ARGS_QWORD != ac &&
				DELIM_OPEN == mdoc_isdelim(p)) {
d1157 3
a1159 3
		if (ARGS_PHRASE == ac || 
				ARGS_PEND == ac ||
				ARGS_PPHRASE == ac) {
d1168 1
a1168 1
			
d1193 2
a1194 2
		ntok = nparsed || ARGS_QWORD == ac ? 
			MDOC_MAX : lookup(tok, p);
d1213 1
a1213 1
	
d1229 3
a1231 3
		if (MDOC_BLOCK == n->type && 
				MDOC_EXPLICIT & mdoc_macros[n->tok].flags &&
				! (MDOC_VALID & n->flags)) {
a1256 1

d1307 1
a1307 1
				DELIM_OPEN == mdoc_isdelim(p)) {
d1347 1
a1347 1
			n = n->parent) {
d1359 1
a1359 1
	/* 
d1366 2
a1367 2
		mandoc_vmsg(MANDOCERR_SCOPENEST, mdoc->parse, line, ppos, 
				"%s broken", mdoc_macronames[tok]);
a1391 1

d1411 1
a1411 1
		return(0); 
d1427 1
a1427 1
				DELIM_OPEN == mdoc_isdelim(p)) {
a1498 2

/* ARGSUSED */
d1520 1
a1520 1
	case (MDOC_Ap):
d1522 1
a1522 1
	case (MDOC_No):
d1524 1
a1524 1
	case (MDOC_Ns):
d1526 1
a1526 1
	case (MDOC_Ux):
d1529 1
a1529 1
	case (MDOC_Bx):
d1531 1
a1531 1
	case (MDOC_Xr):
d1546 1
a1546 1
		} 
d1568 3
a1570 3
		if ( ! (MDOC_IGNDELIM & mdoc_macros[tok].flags) && 
				ARGS_QWORD != ac && 0 == j && 
				DELIM_OPEN == mdoc_isdelim(p)) {
d1597 3
a1599 3
				ARGS_QWORD != ac &&
				! flushed &&
				DELIM_NONE != mdoc_isdelim(p)) {
a1622 1

d1648 1
a1648 1
		if (ARGV_EOLN == av) 
a1691 2

/* ARGSUSED */
a1717 2

/* ARGSUSED */
a1725 1

a1764 2

/* ARGSUSED */
@


1.129
log
@Treat the line after .Cd as a single argument.
This doesn't hurt normal manual display
and makes the mandocdb(8) database more useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.128 2014/01/20 11:28:29 schwarze Exp $ */
d214 1
@


1.128
log
@Keep words after .Ic together in a single argument.
This doesn't hurt normal manual display
and makes the mandocdb(8) database more useful.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.127 2013/12/31 23:23:11 schwarze Exp $ */
d90 1
a90 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Cd */
@


1.127
log
@Simplify: Remove an unused argument from the mandoc_eos() function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.126 2013/12/31 22:40:12 schwarze Exp $ */
d101 1
a101 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ic */
@


1.126
log
@Do not trigger end-of-sentence spacing by trailing punctuation
at the end of partial implicit macros.  Prodded by jmc@@.

Actually, this is a revert of rev. 1.64 Fri May 14 14:09:13 2010 UTC
by kristaps@@, with this original commit message:
"Block-implicit macros now up-propogate end-of-sentence spacing.
NOTE: GROFF IS NOT SMART ENOUGH TO DO THIS."
Please speak after me: Then why the hell should we?

We already weakened this in rev. 1.93 Sun Jul 18 17:00:26 2010 UTC,
but that weakening was insufficient.  Let's take it out completely.

Admittedly, there are two places in OpenBSD base where what Kristaps
did make the output nicer, in calloc(3) and in fish(6).  But both are
atypical.  There are 18 other places where this revert makes the
output nicer, the typical case being:
"Mail status is shown as ``No Mail.''  if there is no mail."
You do *not* want the EOS spacing after ``No Mail.'' in that sentence.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.125 2013/12/24 20:45:27 schwarze Exp $ */
d686 1
a686 1
		if (mandoc_eos(p, strlen(p), 0))
@


1.125
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.124 2013/12/24 19:11:46 schwarze Exp $ */
a1351 19
	for (n = body->child; n && n->next; n = n->next)
		/* Do nothing. */ ;
	
	/* 
	 * End of sentence spacing: if the last node is a text node and
	 * has a trailing period, then mark it as being end-of-sentence.
	 */

	if (n && MDOC_TEXT == n->type && n->string)
		if (mandoc_eos(n->string, strlen(n->string), 1))
			n->flags |= MDOC_EOS;

	/* Up-propagate the end-of-space flag. */

	if (n && (MDOC_EOS & n->flags)) {
		body->flags |= MDOC_EOS;
		body->parent->flags |= MDOC_EOS;
	}

@


1.124
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.123 2013/10/21 23:47:58 schwarze Exp $ */
d716 1
a716 2
		if ( ! (MDOC_SYNOPSIS & mdoc->flags))
			mdoc->flags &= ~MDOC_KEEP;
@


1.123
log
@There are three kinds of input lines: text lines, macros taking
positional arguments (like Dt Fn Xr) and macros taking text as
arguments (like Nd Sh Em %T An).  In the past, even the latter put
each word of their arguments into its own MDOC_TEXT node; instead,
concatenate arguments unless delimiters, keeps or spacing mode
prevent that.  Regarding mandoc(1), this is internal refactoring,
no output change intended.

Regarding mandocdb(8), this fixes yet another regression introduced
when switching from DB to SQLite: The ability to search for strings
crossing word boundaries was lost and is hereby restored.  At the
same time, database sizes and build times are both reduced by a bit
more than 5% each.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.122 2013/09/15 18:26:46 schwarze Exp $ */
d564 3
d575 2
@


1.122
log
@Block closing macros do not allocate a new node but finish an existing
one, so they miss the clearing of MDOC_NEWLINE in mdoc.c, node_alloc().
Consequently, MDOC_NEWLINE must be cleared before processing the next
macro on the same line.
This fixes horizontal spacing for input lines beginning like .Oc Ns ...

Issue found by Franco Fichtner <franco at lastsummer dot de>
while working on DragonFly mandoc integration.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.121 2012/11/19 22:30:58 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d54 2
a55 2
static	int		dword(struct mdoc *, int, int, 
				const char *, enum mdelim);
d73 1
a73 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ap */
d77 5
a81 5
	{ blk_full, MDOC_PARSED }, /* Sh */
	{ blk_full, MDOC_PARSED }, /* Ss */ 
	{ in_line_eoln, 0 }, /* Pp */ 
	{ blk_part_imp, MDOC_PARSED }, /* D1 */
	{ blk_part_imp, MDOC_PARSED }, /* Dl */
d83 1
a83 1
	{ blk_exp_close, MDOC_EXPLICIT }, /* Ed */
d85 4
a88 4
	{ blk_exp_close, MDOC_EXPLICIT }, /* El */
	{ blk_full, MDOC_PARSED }, /* It */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ad */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* An */
d92 3
a94 3
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Dv */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Er */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ev */ 
d96 2
a97 2
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fa */ 
	{ in_line_eoln, 0 }, /* Fd */ 
d99 3
a101 3
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Fn */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ft */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Ic */ 
d103 3
a105 3
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Li */
	{ blk_full, 0 }, /* Nd */ 
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */ 
d110 1
a110 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* St */ 
d112 1
a112 1
	{ ctx_synopsis, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */ 
d114 5
a118 5
	{ in_line_eoln, 0 }, /* %A */
	{ in_line_eoln, 0 }, /* %B */
	{ in_line_eoln, 0 }, /* %D */
	{ in_line_eoln, 0 }, /* %I */
	{ in_line_eoln, 0 }, /* %J */
d120 1
a120 1
	{ in_line_eoln, 0 }, /* %O */
d122 2
a123 2
	{ in_line_eoln, 0 }, /* %R */
	{ in_line_eoln, 0 }, /* %T */
d125 5
a129 3
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Ac */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Ao */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Aq */
d131 6
a136 4
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Bc */
	{ blk_full, MDOC_EXPLICIT }, /* Bf */ 
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Bo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Bq */
d140 8
a147 6
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Dc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Do */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Dq */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Ec */
	{ blk_exp_close, MDOC_EXPLICIT }, /* Ef */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Em */ 
d151 4
a154 2
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_IGNDELIM }, /* No */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED | MDOC_IGNDELIM }, /* Ns */
d157 2
a158 1
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Pc */
d160 10
a169 7
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Po */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Pq */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Qc */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Ql */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Qo */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Qq */
	{ blk_exp_close, MDOC_EXPLICIT }, /* Re */
d171 5
a175 3
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Sc */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* So */
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Sq */
d177 2
a178 2
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Sx */
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Sy */
d180 1
a180 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ux */
d183 7
a189 4
	{ blk_full, MDOC_EXPLICIT | MDOC_CALLABLE }, /* Fo */ 
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Fc */ 
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Oo */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Oc */
d191 1
a191 1
	{ blk_exp_close, MDOC_EXPLICIT }, /* Ek */
d197 9
a205 7
	{ in_line_eoln, 0 }, /* Lp */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Lk */ 
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Mt */ 
	{ blk_part_imp, MDOC_CALLABLE | MDOC_PARSED }, /* Brq */
	{ blk_part_exp, MDOC_CALLABLE | MDOC_PARSED | MDOC_EXPLICIT }, /* Bro */
	{ blk_exp_close, MDOC_EXPLICIT | MDOC_CALLABLE | MDOC_PARSED }, /* Brc */
	{ in_line_eoln, 0 }, /* %C */
d209 1
a209 1
	{ in_line_eoln, 0 }, /* %Q */
d213 1
a213 1
	{ phrase_ta, MDOC_CALLABLE | MDOC_PARSED }, /* Ta */
d610 2
a611 2
dword(struct mdoc *mdoc, int line, 
		int col, const char *p, enum mdelim d)
d617 8
d668 1
a668 1
		dword(mdoc, line, la, p, DELIM_MAX);
d710 3
d815 2
a816 1
			if ( ! dword(mdoc, line, lastarg, p, DELIM_MAX))
d982 2
a983 1
		if ( ! dword(mdoc, line, la, p, d))
d1102 4
a1105 1
	} 
d1150 1
a1150 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1203 2
a1204 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1315 1
a1315 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1318 1
a1318 1
		} 
d1329 2
a1330 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1456 1
a1456 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1459 1
a1459 1
		} 
d1477 1
a1477 1
				if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1495 2
a1496 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1600 1
a1600 1
			if ( ! dword(mdoc, line, la, p, DELIM_OPEN))
d1634 2
a1635 1
		if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1706 2
a1707 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1787 1
a1787 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
d1838 2
a1839 1
			if ( ! dword(mdoc, line, la, p, DELIM_MAX))
@


1.121
log
@Do not crash on stray .Ta macros found outside column lists.
Problem reported by jmc@@, thanks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.120 2012/11/18 00:05:35 schwarze Exp $ */
d795 3
@


1.120
log
@Fix four small whitespace issues related to trailing punctuation
reported by Nicolas Joly <njoly at pasteur dot fr>:

- add EOS spacing after trailing punctuation after .Cd, .Fc, and .Lb
- suppress spacing before trailing punctuation after .Fd

Add the remaining issues from the same report to the TODO file.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.119 2012/11/17 00:26:33 schwarze Exp $ */
d1762 1
d1768 8
a1775 4
	/*
	 * FIXME: this is overly restrictive: if the `Ta' is unexpected,
	 * it should simply error out with ARGSLOST.
	 */
d1777 1
@


1.119
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.118 2012/11/16 13:40:36 schwarze Exp $ */
d615 2
a616 1
			mdoc->last->prev->tok != MDOC_No)
@


1.118
log
@Fix a crash triggered by .Bl -tag .It Xo .El .Sh found by florian@@.

* When allocating a body end marker, copy the pointer to the normalized
block information from the body block, avoiding the risk of subsequent
null pointer derefence.
* When inserting the body end marker into the syntax tree, do not try to
copy that pointer from the parent block, because not being a direkt child
of the block it belongs to is the whole point of a body end marker.
* Even non-callable blocks (like Bd and Bl) can break other blocks;
when this happens, postpone closing them out in the usual way.

Completed and tested at the OpenBSD impromptu Coimbra hackathon (c2k12).
Thanks to Pedro Almeida and the Laborat'orio de Computa,c~ao Avan,cada
da Universidade de Coimbra (http://www.uc.pt/lca) for their hospitality!
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.117 2012/07/18 16:20:43 schwarze Exp $ */
d206 1
a206 1
mdoc_macroend(struct mdoc *m)
d212 2
a213 1
	n = MDOC_VALID & m->last->flags ?  m->last->parent : m->last;
d218 1
a218 1
			mdoc_nmsg(m, n, MANDOCERR_SCOPEEXIT);
d222 1
a222 1
	return(rew_last(m, m->first));
d267 2
a268 2
		 * m->last node in the post-validation phase and reset
		 * it to m->last->parent, causing a step in the closing
d464 1
a464 1
		struct mdoc *m, int line, int ppos)
d519 1
a519 1
		mandoc_vmsg(MANDOCERR_SCOPENEST, m->parse, line, ppos,
d534 1
a534 1
rew_sub(enum mdoc_type t, struct mdoc *m, 
d539 1
a539 1
	n = m->last;
d547 1
a547 1
			mandoc_vmsg(MANDOCERR_SCOPEBROKEN, m->parse, 
d556 1
a556 1
			if (make_pending(n, tok, m, line, ppos) ||
d561 1
a561 1
			mdoc_pmsg(m, line, ppos, MANDOCERR_NOSCOPE);
d568 1
a568 1
	if ( ! rew_last(m, n))
d576 1
a576 1
		if ( ! rew_last(m, n))
d579 1
a579 1
		    ! mdoc_body_alloc(m, n->line, n->pos, n->tok))
d591 1
a591 1
dword(struct mdoc *m, int line, 
d598 1
a598 1
	if ( ! mdoc_word_alloc(m, line, col, p))
d602 1
a602 1
		m->last->flags |= MDOC_DELIMO;
d614 3
a616 3
	else if (DELIM_CLOSE == d && m->last->prev &&
			m->last->prev->tok != MDOC_No)
		m->last->flags |= MDOC_DELIMC;
d622 1
a622 1
append_delims(struct mdoc *m, int line, int *pos, char *buf)
d633 1
a633 1
		ac = mdoc_zargs(m, line, pos, buf, &p);
d640 1
a640 1
		dword(m, line, la, p, DELIM_MAX);
d654 1
a654 1
			m->last->flags |= MDOC_EOS;
d676 1
a676 1
	nl = MDOC_NEWLINE & m->flags;
d693 1
a693 1
	for (n = m->last; n; n = n->parent) {
d722 1
a722 1
			make_pending(later, tok, m, line, ppos);
d728 1
a728 1
			if ( ! mdoc_endbody_alloc(m, line, ppos,
d749 1
a749 1
			mdoc_pmsg(m, line, ppos, MANDOCERR_ARGSLOST);
d751 1
a751 1
		if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d753 1
a753 1
		return(rew_sub(MDOC_BLOCK, m, tok, line, ppos));
d756 1
a756 1
	if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d760 1
a760 1
		if ( ! mdoc_tail_alloc(m, line, ppos, rew_alt(tok)))
d767 1
a767 1
			if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d772 1
a772 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d784 1
a784 1
			if ( ! dword(m, line, lastarg, p, DELIM_MAX))
d790 1
a790 1
			if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d794 1
a794 1
		if ( ! mdoc_macro(m, ntok, line, lastarg, pos, buf))
d799 1
a799 1
	if ( ! flushed && ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d804 1
a804 1
	return(append_delims(m, line, pos, buf));
d819 1
a819 1
	nl = MDOC_NEWLINE & m->flags;
d847 1
a847 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d864 1
a864 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d883 1
a883 1
			if (scope && ! rew_elem(m, tok))
d886 2
a887 1
				if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d889 1
a889 1
				if ( ! rew_last(m, m->last))
d893 2
a894 1
				mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY);
d897 1
a897 1
			if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d901 1
a901 1
			return(append_delims(m, line, pos, buf));
d923 2
a924 1
				if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d935 1
a935 1
			if (scope && ! rew_elem(m, tok))
d939 1
a939 1
			if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d947 1
a947 1
		if ( ! dword(m, line, la, p, d))
d956 1
a956 1
			if ( ! rew_elem(m, tok))
d962 1
a962 1
	if (scope && ! rew_elem(m, tok))
d972 1
a972 1
		if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d974 1
a974 1
		if ( ! rew_last(m, m->last))
d978 1
a978 1
		mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY);
d983 1
a983 1
	return(append_delims(m, line, pos, buf));
d1001 1
a1001 1
	nl = MDOC_NEWLINE & m->flags;
d1006 1
a1006 1
		if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1008 1
a1008 1
		if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d1023 1
a1023 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d1039 1
a1039 1
	if ( ! mdoc_block_alloc(m, line, ppos, tok, arg))
d1049 2
a1050 2
		MDOC_Bl == m->last->parent->tok &&
		LIST_diag == m->last->parent->norm->Bl.type;
d1058 1
a1058 1
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1060 2
a1061 2
		head = m->last;
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1063 1
a1063 1
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1065 1
a1065 1
		body = m->last;
d1074 1
a1074 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1092 1
a1092 1
			if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1094 1
a1094 1
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1096 1
a1096 1
			body = m->last;
d1111 1
a1111 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1119 1
a1119 1
			if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1121 1
a1121 1
			head = m->last;
d1133 1
a1133 1
			if ( ! rew_sub(mtt, m, tok, line, ppos))
d1138 1
a1138 1
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1140 1
a1140 1
			body = m->last;
d1149 1
a1149 1
				m->flags |= MDOC_PPHRASE;
d1151 1
a1151 1
				m->flags |= MDOC_PPHRASE;
d1153 1
a1153 1
			if ( ! phrase(m, line, la, buf))
d1156 1
a1156 1
			m->flags &= ~MDOC_PPHRASE;
d1164 1
a1164 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1169 1
a1169 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1175 1
a1175 1
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1177 1
a1177 1
		head = m->last;
d1180 1
a1180 1
	if (nl && ! append_delims(m, line, pos, buf))
d1194 1
a1194 1
	for (n = m->last; n && n != head; n = n->parent) {
d1205 1
a1205 1
	if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1207 1
a1207 1
	if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1211 1
a1211 1
	if ( ! (MDOC_FREECOL & m->flags))
d1214 1
a1214 1
	if ( ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1216 1
a1216 1
	if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d1219 1
a1219 1
	m->flags &= ~MDOC_FREECOL;
d1235 1
a1235 1
	nl = MDOC_NEWLINE & m->flags;
d1246 1
a1246 1
	if ( ! mdoc_block_alloc(m, line, ppos, tok, NULL))
d1249 1
a1249 1
	blk = m->last;
d1251 1
a1251 1
	if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1253 1
a1253 1
	if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1264 1
a1264 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1275 1
a1275 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1281 1
a1281 1
		       if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1283 1
a1283 1
			body = m->last;
d1289 1
a1289 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1294 1
a1294 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1302 1
a1302 1
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1304 1
a1304 1
		body = m->last;
d1331 2
a1332 1
	for (n = m->last; n && n != body && n != blk->parent; n = n->parent) {
d1336 2
a1337 2
			make_pending(n, tok, m, line, ppos);
			if ( ! mdoc_endbody_alloc(m, line, ppos,
d1351 1
a1351 1
		mandoc_vmsg(MANDOCERR_SCOPENEST, m->parse, line, ppos, 
d1354 1
a1354 1
	if (n && ! rew_sub(MDOC_BODY, m, tok, line, ppos))
d1359 1
a1359 1
	if (nl && ! append_delims(m, line, pos, buf))
d1364 1
a1364 1
	if (n && ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
d1372 1
a1372 1
		mdoc_node_relink(m, n);
d1388 1
a1388 1
	nl = MDOC_NEWLINE & m->flags;
d1396 1
a1396 1
	if ( ! mdoc_block_alloc(m, line, ppos, tok, NULL))
d1401 1
a1401 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1415 1
a1415 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1422 1
a1422 1
			if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1424 1
a1424 1
			head = m->last;
d1436 1
a1436 1
				if ( ! dword(m, line, la, p, DELIM_MAX))
d1439 1
a1439 1
			if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1441 1
a1441 1
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1443 1
a1443 1
			body = m->last;
d1454 1
a1454 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1459 1
a1459 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1467 1
a1467 1
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
d1471 1
a1471 1
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
d1473 1
a1473 1
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
d1481 1
a1481 1
	return(append_delims(m, line, pos, buf));
d1496 1
a1496 1
	nl = MDOC_NEWLINE & m->flags;
d1528 1
a1528 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d1546 1
a1546 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1558 1
a1558 1
			if ( ! dword(m, line, la, p, DELIM_OPEN))
d1562 1
a1562 1
		       if ( ! mdoc_elem_alloc(m, line, la, tok, arg))
d1566 1
a1566 1
			if ( ! rew_elem(m, tok))
d1574 1
a1574 1
			if ( ! flushed && ! rew_elem(m, tok))
d1577 1
a1577 1
			if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1587 1
a1587 1
			if ( ! rew_elem(m, tok))
d1592 1
a1592 1
		if ( ! dword(m, line, la, p, DELIM_MAX))
d1597 1
a1597 1
	if (0 == j && ! mdoc_elem_alloc(m, line, la, tok, arg))
d1602 1
a1602 1
	if ( ! flushed && ! rew_elem(m, tok))
d1606 1
a1606 1
	return(append_delims(m, line, pos, buf));
d1623 1
a1623 1
		rew_sub(MDOC_BLOCK, m, MDOC_Nm, line, ppos);
d1629 1
a1629 1
		av = mdoc_argv(m, line, tok, &arg, pos, buf);
d1646 1
a1646 1
	if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
d1653 1
a1653 1
		ac = mdoc_args(m, line, pos, buf, tok, &p);
d1663 1
a1663 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1668 1
a1668 1
		if ( ! rew_elem(m, tok))
d1670 1
a1670 1
		return(mdoc_macro(m, ntok, line, la, pos, buf));
d1675 1
a1675 1
	return(rew_elem(m, tok));
d1685 1
a1685 1
	nl = MDOC_NEWLINE & m->flags;
d1688 2
a1689 2
	if ( ! (MDOC_SYNOPSIS & m->flags))
		return(in_line(m, tok, line, ppos, pos, buf));
d1693 1
a1693 1
		return(in_line(m, tok, line, ppos, pos, buf));
d1701 1
a1701 1
		return(blk_full(m, tok, line, ppos, pos, buf));
d1703 1
a1703 1
	return(blk_part_imp(m, tok, line, ppos, pos, buf));
d1712 1
a1712 1
	mdoc_pmsg(m, line, ppos, MANDOCERR_MACROOBS);
d1723 1
a1723 1
phrase(struct mdoc *m, int line, int ppos, char *buf)
d1733 1
a1733 1
		ac = mdoc_zargs(m, line, &pos, buf, &p);
d1743 1
a1743 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1748 1
a1748 1
		if ( ! mdoc_macro(m, ntok, line, la, &pos, buf))
d1750 1
a1750 1
		return(append_delims(m, line, &pos, buf));
d1771 1
a1771 1
	if ( ! rew_sub(MDOC_BODY, m, MDOC_It, line, ppos))
d1773 1
a1773 1
	if ( ! mdoc_body_alloc(m, line, ppos, MDOC_It))
d1778 1
a1778 1
		ac = mdoc_zargs(m, line, pos, buf, &p);
d1788 1
a1788 1
			if ( ! dword(m, line, la, p, DELIM_MAX))
d1793 1
a1793 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1795 1
a1795 1
		return(append_delims(m, line, pos, buf));
@


1.117
log
@Let a trailing .Ns macro take effect
even on an input line containing a partial implicit macro.

Fixes horizontal spacing in vi(1), ddb(4), and ppp(8).

OpenBSD rev. 1.74.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.116 2012/05/27 17:39:28 schwarze Exp $ */
d741 1
a741 1
		if (MDOC_CALLABLE & mdoc_macros[n->tok].flags)
@


1.116
log
@update Copyright years according to the CVS logs; no code change
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.115 2012/01/05 00:43:51 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d1362 7
@


1.115
log
@Fix previous such that all .It HEADs are unparsed,
not just the first one in each -diag list.
While here, drop the needless if-statement
and choose a more precise wording for the comment.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.114 2012/01/02 15:48:05 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.114
log
@`-diag' lists aren't parsed, unlike other list types.  This fixes a TODO
entry raised by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.113 2011/12/03 23:59:14 schwarze Exp $ */
a996 10
	/*
	 * Exception: `-diag' lists are not parsed, but lists in general
	 * are parsed.
	 */
	nparsed = 0;
	if (MDOC_It == tok && NULL != m->last &&
			MDOC_Bl == m->last->tok &&
			LIST_diag == m->last->norm->Bl.type)
		nparsed = 1;

d1041 8
@


1.113
log
@Remove an OpenBSD-specific tweak regarding .Xr spacing and make it
compatible with groff-1.21.  This tweak was originally added for
compatibility with groff-1.15, which is no longer needed.

ok jmc@@ kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.112 2011/10/16 12:20:34 schwarze Exp $ */
a230 1
	/* FIXME: make -diag lists be un-PARSED. */
d986 1
a986 1
	int		  la, nl;
d997 10
d1158 2
a1159 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup(tok, p);
@


1.112
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.111 2011/09/18 14:14:15 schwarze Exp $ */
a1571 16
		/* 
		 * XXX: this is a hack to work around groff's ugliness
		 * as regards `Xr' and extraneous arguments.  It should
		 * ideally be deprecated behaviour, but because this is
		 * code is no here, it's unlikely to be removed.
		 */

#ifdef __OpenBSD__
		if (MDOC_Xr == tok && j == maxargs) {
			if ( ! mdoc_elem_alloc(m, line, la, MDOC_Ns, NULL))
				return(0);
			if ( ! rew_elem(m, MDOC_Ns))
				return(0);
		}
#endif

@


1.111
log
@forgotten Copyright bumps; no code change
found while syncing to OpenBSD
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.110 2011/08/10 14:07:23 kristaps Exp $ */
d1446 1
a1446 1
	if (NULL == head) {
a1448 2
		head = m->last;
	}
a1454 1
		body = m->last;
@


1.110
log
@Allow `Sx' and `Ss' to have child nodes.  Fixes manuals in NetBSD.
Originally pointed out by joerg@@ then again by Thomas Klausner by way of
Nicolas Joy.  Note: don't use these constructions as you can't link to
the sections with `Sx'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.109 2011/04/30 10:18:24 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.109
log
@No code change: fixing spelling errors.  From a patch by uqs@@.  Thanks!
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.108 2011/04/25 00:03:07 schwarze Exp $ */
d77 2
a78 2
	{ blk_full, 0 }, /* Sh */
	{ blk_full, 0 }, /* Ss */ 
@


1.108
log
@Closing delimiters only suppress spacing when they follow something.
Fixing a regression introduced in rev. 1.105.
ok and prodding for comments kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.107 2011/04/19 16:38:48 kristaps Exp $ */
d646 1
a646 1
		 * XXX: it's easy to allow this to propogate outward to
d651 1
a651 1
		 * example, `.  ;' shouldn't propogate the double-space.
d1010 1
a1010 1
	 * This routine accomodates implicitly- and explicitly-scoped
d1307 1
a1307 1
	/* Up-propogate the end-of-space flag. */
@


1.107
log
@Clean up parsing of delimiters in -mdoc.  First, remove the "dowarn"
variable from mandoc_getarg() so that it prints the warning every time.
Then, remove the warning from args_checkpunct().  This way, warnings
are being posted at the correct time.  This makes the flag argument to
mdoc_zargs() superfluous, so make it be zero when it's invoked.  Finally,
move the args() flags into mdoc_argv.c and make them enums.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.106 2011/03/22 14:33:05 kristaps Exp $ */
d603 13
a615 1
	else if (DELIM_CLOSE == d)
@


1.106
log
@libmdoc.h and libman.h were including mdoc.h and man.h, respectively.
Don't have them do that (includes in header files = faugh), and have
individual files directly include these files.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.105 2011/03/22 14:05:45 kristaps Exp $ */
d621 1
a621 1
		ac = mdoc_zargs(m, line, pos, buf, ARGS_NOWARN, &p);
d1720 1
a1720 1
		ac = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1765 1
a1765 1
		ac = mdoc_zargs(m, line, pos, buf, 0, &p);
@


1.105
log
@Move mandoc_isdelim() back into libmdoc.h.  This fixes an unreported
error where (1) -man pages were punctuating delimiters (e.g., `.B a ;')
and where (2) standalone punctuation in -mdoc or -man (e.g., ";" on its
own line) would also be punctuated.  This introduces a small amount of
complexity of mdoc_{html,term}.c must manage their own spacing with
running print_word() or print_text().  The check for delimiting now
happens in mdoc_macro.c's dword().
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.104 2011/03/20 16:02:05 kristaps Exp $ */
d29 1
@


1.104
log
@Consolidate messages.  Have all parse-time messages (in libmdoc,
libroff, etc., etc.) route into mandoc_msg() and mandoc_vmsg(), for the
time being in libmandoc.h.  This requires struct mparse to be passed
into the allocation routines instead of mandocmsg and a void pointer.
Then, move some of the functionality of the old mmsg() into read.c's
mparse_mmsg() (check against wlevel and setting of file_status) and use
main.c's mmsg() as simply a printing tool.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.103 2011/03/17 11:30:23 kristaps Exp $ */
d53 2
d585 22
d627 1
a627 3
		assert(DELIM_NONE != mandoc_isdelim(p));
		if ( ! mdoc_word_alloc(m, line, la, p))
			return(0);
d771 1
a771 1
			if ( ! mdoc_word_alloc(m, line, lastarg, p))
d895 1
a895 1
		d = ARGS_QWORD == ac ? DELIM_NONE : mandoc_isdelim(p);
d930 2
a931 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1086 2
a1087 2
				DELIM_OPEN == mandoc_isdelim(p)) {
			if ( ! mdoc_word_alloc(m, line, la, p))
d1139 1
a1139 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1249 2
a1250 2
		    DELIM_OPEN == mandoc_isdelim(p)) {
			if ( ! mdoc_word_alloc(m, line, la, p))
d1264 1
a1264 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1380 1
a1380 1
		    DELIM_OPEN == mandoc_isdelim(p)) {
d1382 1
a1382 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1403 1
a1403 1
				if ( ! mdoc_word_alloc(m, line, la, p))
d1421 1
a1421 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1526 3
a1528 3
				ARGS_QWORD != ac &&
				0 == j && DELIM_OPEN == mandoc_isdelim(p)) {
			if ( ! mdoc_word_alloc(m, line, la, p))
d1556 1
a1556 1
				DELIM_NONE != mandoc_isdelim(p)) {
d1578 1
a1578 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1649 1
a1649 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1729 1
a1729 1
			if ( ! mdoc_word_alloc(m, line, la, p))
d1774 1
a1774 1
			if ( ! mdoc_word_alloc(m, line, la, p))
@


1.103
log
@Clean-up in libmdoc: fix last checks for mdoc_*msg return value, then
make mdoc_vmsg not return an int.  libmdoc is now completely clean of
return-value checks from the message subsystem.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.102 2011/03/17 09:16:38 kristaps Exp $ */
d516 3
a518 3
		mdoc_vmsg(m, MANDOCERR_SCOPENEST, line, ppos,
		    "%s breaks %s", mdoc_macronames[tok],
		    mdoc_macronames[broken->tok]);
d544 4
a547 3
			mdoc_vmsg(m, MANDOCERR_SCOPEBROKEN, line, ppos,
			    "%s breaks %s", mdoc_macronames[tok],
			    mdoc_macronames[n->tok]);
d1302 1
a1302 1
		mdoc_vmsg(m, MANDOCERR_SCOPENEST, line, ppos, 
@


1.102
log
@Move mdoc_isdelim() into mandoc.h as mandoc_isdelim().  This allows the
removal of manual delimiter checks in html.c and term.c.  Finally, add
the escaped period as a closing delimiter, removing a TODO to this
effect.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.101 2011/01/25 15:17:18 kristaps Exp $ */
d713 1
a713 2
			if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_ARGSLOST))
				return(0);
d856 1
a856 2
				if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY))
					return(0);
d858 1
d938 1
a938 2
		if ( ! mdoc_pmsg(m, line, ppos, MANDOCERR_MACROEMPTY))
			return(0);
d1300 3
a1302 3
	if (n != body && ! mdoc_vmsg(m, MANDOCERR_SCOPENEST,
	    line, ppos, "%s broken", mdoc_macronames[tok]))
		return(0);
d1674 2
a1675 1
	return(mdoc_pmsg(m, line, ppos, MANDOCERR_MACROOBS));
@


1.101
log
@Have `Bx' accept two arguments, not just one, and join these arguments
with "xxBSD-yy"
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.100 2011/01/12 17:00:07 kristaps Exp $ */
d602 1
a602 1
		assert(DELIM_NONE != mdoc_isdelim(p));
d873 1
a873 1
		d = ARGS_QWORD == ac ? DELIM_NONE : mdoc_isdelim(p);
d1064 1
a1064 1
				DELIM_OPEN == mdoc_isdelim(p)) {
d1227 1
a1227 1
		    DELIM_OPEN == mdoc_isdelim(p)) {
d1358 1
a1358 1
		    DELIM_OPEN == mdoc_isdelim(p)) {
d1505 1
a1505 1
				0 == j && DELIM_OPEN == mdoc_isdelim(p)) {
d1534 1
a1534 1
				DELIM_NONE != mdoc_isdelim(p)) {
@


1.100
log
@Incorporate same fix for -man post-validation deletion of nodes.  This
isn't known to cause any problems, but better safe than sorry.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.99 2010/12/15 23:39:40 kristaps Exp $ */
d1464 2
@


1.99
log
@Add a "last child" member of struct mdoc_node.

Remove `Pp' or `Lp' if it is the FIRST or LAST child of an `Sh' or `Sh' body.

Make "skipping paragraph" be an error, not a warning, as information (an
invoked macro) is ignored.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.98 2010/12/06 11:01:19 kristaps Exp $ */
d255 1
a255 1
	struct mdoc_node *n;
d262 7
d272 1
a272 1
		mdoc->last = mdoc->last->parent;
@


1.98
log
@Merge schwarze@@'s relaxation of scope-breaking rules: allow implicit
ending of scopes and drop stray scope-endings.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.97 2010/11/30 13:04:14 kristaps Exp $ */
d255 1
d264 1
d267 1
@


1.97
log
@mdoc_action.c is no more.  Attic it and remove it from the Makefile.
Remove references to MDOC_ACTED (it was only assertions) and the pre-
and post-action functions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.96 2010/11/29 13:02:47 kristaps Exp $ */
d37 1
d324 1
d418 4
a421 1
	 * Partial blocks allow delayed rewinding by default.
d423 2
a424 8
	if (&blk_full != mdoc_macros[tok].fp)
		return (REWIND_LATER);

	/*
	 * Full blocks can only be rewound when matching
	 * or when there is an explicit rule.
	 */
	return(REWIND_ERROR);
a514 1
	 * XXX Make this non-fatal.
a515 1
	mdoc_pmsg(m, line, ppos, MANDOCERR_SYNTNOSCOPE);
d533 5
d542 4
a545 1
			return(make_pending(n, tok, m, line, ppos));
d547 2
a548 5
			/* XXX Make this non-fatal. */
			mdoc_vmsg(m, MANDOCERR_SCOPEFATAL, line, ppos,
			    "%s cannot break %s", mdoc_macronames[tok],
			    mdoc_macronames[n->tok]);
			return 0;
d676 1
a676 2
			if ( ! make_pending(later, tok, m, line, ppos))
				return(0);
d1278 1
a1278 2
			if ( ! make_pending(n, tok, m, line, ppos))
				return(0);
@


1.96
log
@Move `Mt', `Ar', and `Li' handling from mdoc_action.c into mdoc_validate.c.

Clarify that `Mt' gets a default `~' (as per groff 1.20) and document it
in mdoc.7.

Made `Lk' be removed in mdoc_macro.c if it has no arguments.  This fixes
segfaults in mdoc_{term,html}.c that nobody's managed to raise yet.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.95 2010/10/01 21:51:13 schwarze Exp $ */
a261 2
		if ( ! mdoc_action_post(mdoc))
			return(0);
d266 1
a266 3
	if ( ! mdoc_valid_post(mdoc))
		return(0);
	return(mdoc_action_post(mdoc));
d695 1
a695 2
		if (MDOC_CALLABLE & mdoc_macros[n->tok].flags) {
			assert( ! (MDOC_ACTED & n->flags));
a696 1
		}
a1139 1
			assert( ! (MDOC_ACTED & n->flags));
a1276 1
			assert( ! (MDOC_ACTED & n->flags));
@


1.95
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.94 2010/09/26 20:22:28 schwarze Exp $ */
d793 1
a793 1
	case (MDOC_Lk):
@


1.94
log
@If an explicit scope is still open at the end of an input file,
report an ERROR:  We can still render the page by just closing
the open scope, but it is likely that information will be missing
or document structure mangled.
Before, man(7) only reported a WARNING (which is dangerous because
we cannot be sure rendering is correct) and mdoc(7) ran into FATAL
(which is too drastic, there is no reason not to show what we have).
"looks good" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.93 2010/07/18 17:00:26 schwarze Exp $ */
d141 2
a142 2
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* No */
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ns */
@


1.93
log
@Text ending in a full stop, exclamation mark or question mark
should not flag the end of a sentence if:

1) The punctuation is followed by closing delimiters
and not preceded by alphanumeric characters, like in
"There is no full stop (.) in this sentence"

or

2) The punctuation is a child of a macro
and not preceded by alphanumeric characters, like in
"There is no full stop
.Pq \&.
in this sentence"

"looks fine" to kristaps@@; tested by jmc@@ and sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.92 2010/07/04 22:04:04 schwarze Exp $ */
d210 4
a213 8
	for ( ; n; n = n->parent) {
		if (MDOC_BLOCK != n->type)
			continue;
		if ( ! (MDOC_EXPLICIT & mdoc_macros[n->tok].flags))
			continue;
		mdoc_nmsg(m, n, MANDOCERR_SYNTSCOPE);
		return(0);
	}
@


1.92
log
@Assert my copyright, making it explicit that i'm granting the same license
on those parts of the code and text that i have written as Kristaps is.
"fine with me" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.91 2010/07/02 10:53:28 kristaps Exp $ */
d613 1
a613 1
		if (mandoc_eos(p, strlen(p)))
d1269 1
a1269 1
		if (mandoc_eos(n->string, strlen(n->string)))
@


1.91
log
@Lint fixes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.90 2010/07/01 22:35:54 schwarze Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.90
log
@In the mdoc(7) parser, inspect roff registers early such that all parts
of the parser can use the resulting cues.  In particular, this allows
to use .nr nS to force SYNOPSIS-style .Nm indentation outside the
SYNOPSIS as needed by ifconfig(8).

To actually make this useable, .Pp must rewind .Nm, or the rest of the
section would end up indented.  Implement a quick hack for now,
a generic solution can be designed later.

ok kristaps@@ and tested by sobrado@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.89 2010/07/01 21:12:00 schwarze Exp $ */
d37 1
a37 1
	REWIND_ERROR,
@


1.89
log
@Correct handling of trailing punctuation in MDOC_DELIM blk_full HEADs.
The bug was uncovered by SYNOPSIS .Nm as this happened to be the first
block with this particular combination of properties.
Found the hard way by kristaps@@ in NetBSD gcc-contrib(1),
fix by me.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.88 2010/07/01 15:38:56 schwarze Exp $ */
d1585 3
d1651 1
a1651 1
	if (SEC_SYNOPSIS != m->lastsec)
@


1.88
log
@Improve .Nm indentation in the SYNOPSIS;
kristaps@@ will do the missing HTML part soon.
"looks nicer" jmc@@
"seems perfect to me" sobrado@@
"slap it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.87 2010/07/01 14:28:12 kristaps Exp $ */
d1028 3
@


1.87
log
@p->end is an enum: treat it as such.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.86 2010/06/30 04:05:02 schwarze Exp $ */
d100 1
a100 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Nm */ 
d395 2
d414 2
a415 1
	 * In particular, always skip block end markers.
d417 2
a418 1
	if (ENDBODY_NOT != p->end || (MDOC_BLOCK == p->type &&
d514 3
a516 2
		mdoc_vmsg(m, MANDOCERR_SCOPE, line, ppos, "%s breaks %s",
		    mdoc_macronames[tok], mdoc_macronames[broken->tok]);
d550 3
a552 1
			mdoc_pmsg(m, line, ppos, MANDOCERR_SYNTNOSCOPE);
d663 1
a663 1
		if (MDOC_BLOCK != n->type)
d1300 2
a1301 2
	if (n != body && ! mdoc_vmsg(m, MANDOCERR_SCOPE, line, ppos,
	    "%s broken", mdoc_macronames[tok]))
d1657 3
a1659 1

@


1.86
log
@Closing of full blocks (Bd Bf Bk Bl It Fo Nd Rs Sh Ss) may never be
delayed: It must either succeed right away or fail outright.
As noticed by Kristaps, neglecting to fail properly when required
could make invalid input screw up the syntax tree and ultimately
trigger assertions in other, unrelated parts of the program.
This fix tested by and OK by kristaps@@.
While here, comment the rather tricky function rew_dohalt().
This function will probably need more tweaks later on.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.85 2010/06/29 19:45:06 schwarze Exp $ */
d414 1
a414 1
	if (p->end || (MDOC_BLOCK == p->type &&
d651 1
a651 1
			if ( ! n->end)
@


1.85
log
@fix a typo in the function declaration;
seems like gcc3 didn't catch it :-(
thanks to thib@@ and kristaps@@ for reporting
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.48 2010/06/29 18:01:10 schwarze Exp $ */
d338 6
d348 5
d356 4
d365 4
d372 4
d410 19
a428 3
	return(p->end || (MDOC_BLOCK == p->type &&
	    ! (MDOC_EXPLICIT & mdoc_macros[tok].flags)) ?
	    REWIND_MORE : REWIND_LATER);
@


1.84
log
@Considerably simplify block rewind rules; no functional change intended.
* Let rew_alt() always succeed, obsoleting tons of case statements.
* Merge rew_dobreak() into rew_dohalt().
* Encode all rewinding cases uniformly in terms of "enum rew".
Required because i'm too dumb to get SYNOPSIS .Nm rewinding right
without cleaning this up first.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.83 2010/06/29 19:20:38 schwarze Exp $ */
d55 1
a55 1
static	int		make_pending(struct mdoc_node *, enum mdoc_type,
@


1.83
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.82 2010/06/27 15:52:41 kristaps Exp $ */
d32 6
a37 4
enum	rew {
	REWIND_REWIND,
	REWIND_NOHALT,
	REWIND_HALT
a58 2
static	int	  	rew_dobreak(enum mdoct, 
				const struct mdoc_node *);
d278 2
a279 2
 * Return the opening macro of a closing one, e.g., `Ec' has `Eo' as its
 * matching pair.
d318 1
a318 1
		break;
a319 1
	abort();
d324 8
a331 5
/* 
 * Rewind rules.  This indicates whether to stop rewinding
 * (REWIND_HALT) without touching our current scope, stop rewinding and
 * close our current scope (REWIND_REWIND), or continue (REWIND_NOHALT).
 * The scope-closing and so on occurs in the various rew_* routines.
d339 13
a351 3
		return(REWIND_HALT);
	if (MDOC_VALID & p->flags)
		return(REWIND_NOHALT);
d354 3
a356 30
	case (MDOC_Aq):
		/* FALLTHROUGH */
	case (MDOC_Bq):
		/* FALLTHROUGH */
	case (MDOC_Brq):
		/* FALLTHROUGH */
	case (MDOC_D1):
		/* FALLTHROUGH */
	case (MDOC_Dl):
		/* FALLTHROUGH */
	case (MDOC_Dq):
		/* FALLTHROUGH */
	case (MDOC_Op):
		/* FALLTHROUGH */
	case (MDOC_Pq):
		/* FALLTHROUGH */
	case (MDOC_Ql):
		/* FALLTHROUGH */
	case (MDOC_Qq):
		/* FALLTHROUGH */
	case (MDOC_Sq):
		/* FALLTHROUGH */
	case (MDOC_Vt):
		assert(MDOC_TAIL != type);
		if (tok != p->tok)
			break;
		if (p->end)
			return(REWIND_HALT);
		if (type == p->type)
			return(REWIND_REWIND);
a358 3
		assert(MDOC_TAIL != type);
		if (type == p->type && tok == p->tok)
			return(REWIND_REWIND);
d360 1
a360 1
			return(REWIND_HALT);
d362 9
a370 3
	case (MDOC_Sh):
		if (type == p->type && tok == p->tok)
			return(REWIND_REWIND);
a374 3
		assert(MDOC_TAIL != type);
		if (type == p->type && tok == p->tok)
			return(REWIND_REWIND);
d376 1
a376 58
			return(REWIND_HALT);
		break;
	case (MDOC_Ao):
		/* FALLTHROUGH */
	case (MDOC_Bd):
		/* FALLTHROUGH */
	case (MDOC_Bf):
		/* FALLTHROUGH */
	case (MDOC_Bk):
		/* FALLTHROUGH */
	case (MDOC_Bl):
		/* FALLTHROUGH */
	case (MDOC_Bo):
		/* FALLTHROUGH */
	case (MDOC_Bro):
		/* FALLTHROUGH */
	case (MDOC_Do):
		/* FALLTHROUGH */
	case (MDOC_Eo):
		/* FALLTHROUGH */
	case (MDOC_Fo):
		/* FALLTHROUGH */
	case (MDOC_Oo):
		/* FALLTHROUGH */
	case (MDOC_Po):
		/* FALLTHROUGH */
	case (MDOC_Qo):
		/* FALLTHROUGH */
	case (MDOC_Rs):
		/* FALLTHROUGH */
	case (MDOC_So):
		/* FALLTHROUGH */
	case (MDOC_Xo):
		if (tok != p->tok)
			break;
		if (p->end)
			return(REWIND_HALT);
		if (type == p->type)
			return(REWIND_REWIND);
		break;
	/* Multi-line explicit scope close. */
	case (MDOC_Ac):
		/* FALLTHROUGH */
	case (MDOC_Bc):
		/* FALLTHROUGH */
	case (MDOC_Brc):
		/* FALLTHROUGH */
	case (MDOC_Dc):
		/* FALLTHROUGH */
	case (MDOC_Ec):
		/* FALLTHROUGH */
	case (MDOC_Ed):
		/* FALLTHROUGH */
	case (MDOC_Ek):
		/* FALLTHROUGH */
	case (MDOC_El):
		/* FALLTHROUGH */
	case (MDOC_Fc):
a377 54
	case (MDOC_Ef):
		/* FALLTHROUGH */
	case (MDOC_Oc):
		/* FALLTHROUGH */
	case (MDOC_Pc):
		/* FALLTHROUGH */
	case (MDOC_Qc):
		/* FALLTHROUGH */
	case (MDOC_Re):
		/* FALLTHROUGH */
	case (MDOC_Sc):
		/* FALLTHROUGH */
	case (MDOC_Xc):
		if (rew_alt(tok) != p->tok)
			break;
		if (p->end)
			return(REWIND_HALT);
		if (type == p->type)
			return(REWIND_REWIND);
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	return(REWIND_NOHALT);
}


/*
 * See if we can break an encountered scope (the rew_dohalt has returned
 * REWIND_NOHALT). 
 */
static int
rew_dobreak(enum mdoct tok, const struct mdoc_node *p)
{

	assert(MDOC_ROOT != p->type);
	if (MDOC_ELEM == p->type)
		return(1);
	if (MDOC_TEXT == p->type)
		return(1);
	if (MDOC_VALID & p->flags)
		return(1);
	if (MDOC_BODY == p->type && p->end)
		return(1);

	switch (tok) {
	case (MDOC_It):
		return(MDOC_It == p->tok);
	case (MDOC_Nd):
		return(MDOC_Nd == p->tok);
	case (MDOC_Ss):
		return(MDOC_Ss == p->tok);
d379 3
a381 12
		if (MDOC_Nd == p->tok)
			return(1);
		if (MDOC_Ss == p->tok)
			return(1);
		return(MDOC_Sh == p->tok);
	case (MDOC_El):
		if (MDOC_It == p->tok)
			return(1);
		break;
	case (MDOC_Oc):
		if (MDOC_Op == p->tok)
			return(1);
d387 3
a389 6
	if (MDOC_EXPLICIT & mdoc_macros[tok].flags) 
		return(p->tok == rew_alt(tok));
	else if (MDOC_BLOCK == p->type)
		return(1);

	return(tok == p->tok);
d439 1
a439 1
		if (REWIND_REWIND != rew_dohalt(tok, MDOC_BLOCK, breaker))
d479 1
a479 1
	 * Report failure and abort the parser.
d485 1
a490 1
	enum rew	  c;
d492 14
a505 9
	/* LINTED */
	for (n = m->last; n; n = n->parent) {
		c = rew_dohalt(tok, t, n);
		if (REWIND_HALT == c) {
			if (n->end || MDOC_BLOCK != t)
				return(1);
			if ( ! (MDOC_EXPLICIT & mdoc_macros[tok].flags))
				return(1);
			/* FIXME: shouldn't raise an error */
d507 1
a507 1
			return(0);
d509 1
a509 5
		if (REWIND_REWIND == c)
			break;
		else if (rew_dobreak(tok, n))
			continue;
		return(make_pending(n, tok, m, line, ppos));
@


1.82
log
@Downstream maintainers: this removes UGLY!  I don't want diverging
functionality and UGLY works quite well thanks to schwarze@@'s careful
attention.

This also backs out function-prototype changes for struct regset,
instead stuffing a pointer to the regset directly into struct
mdoc/man/roff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.81 2010/06/26 16:07:08 kristaps Exp $ */
d53 2
a65 2
static	int	  	swarn(struct mdoc *, enum mdoc_type, int, 
				int, const struct mdoc_node *);
a194 47
static int
swarn(struct mdoc *mdoc, enum mdoc_type type, 
		int line, int pos, const struct mdoc_node *p)
{
	const char	*n, *t, *tt;
	enum mandocerr	 ec;

	n = t = "<root>";
	tt = "block";

	switch (type) {
	case (MDOC_BODY):
		tt = "multi-line";
		break;
	case (MDOC_HEAD):
		tt = "line";
		break;
	default:
		break;
	}

	switch (p->type) {
	case (MDOC_BLOCK):
		n = mdoc_macronames[p->tok];
		t = "block";
		break;
	case (MDOC_BODY):
		n = mdoc_macronames[p->tok];
		t = "multi-line";
		break;
	case (MDOC_HEAD):
		n = mdoc_macronames[p->tok];
		t = "line";
		break;
	default:
		break;
	}

	ec = (MDOC_IGN_SCOPE & mdoc->pflags) ?
		MANDOCERR_SCOPE : MANDOCERR_SYNTSCOPE;

	return(mdoc_vmsg(mdoc, ec, line, pos, 
				"%s scope breaks %s of %s", 
				tt, t, n));
}


d366 5
a370 1
		if (type == p->type && tok == p->tok)
d424 5
a428 1
		if (type == p->type && tok == p->tok)
d463 5
a467 1
		if (type == p->type && rew_alt(tok) == p->tok)
d494 2
d546 77
d634 1
a634 1
			if (MDOC_BLOCK != t)
d646 1
a646 2
		if ( ! swarn(m, t, line, ppos, n))
			return(0);
d654 2
a655 3
	 * The current block extends an enclosing block beyond a line
	 * break.  Now that the current block ends, close the enclosing
	 * block, too.
d657 1
a657 2
	if (NULL != (n = n->pending)) {
		assert(MDOC_HEAD == n->type);
d660 2
a661 1
		if ( ! mdoc_body_alloc(m, n->line, n->pos, n->tok))
d717 4
d723 1
a723 1
	enum mdoct	 ntok;
d737 62
d813 1
a813 1
	if (maxargs > 0) 
d1366 19
a1389 2
	 *
	 * FIXME - this should be ifdef'd OpenBSD?
d1391 2
a1392 5
	for (n = m->last; n; n = n->parent)
		if (body == n)
			break;

	if (NULL == n && ! mdoc_nmsg(m, body, MANDOCERR_SCOPE))
d1395 1
a1395 1
	if (n && ! rew_last(m, body))
d1405 1
a1405 1
	if (n && ! rew_last(m, blk))
@


1.81
log
@Mechanical diff allowing the const struct regset to propogate through
libman and libmdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.80 2010/06/19 20:46:28 kristaps Exp $ */
d53 1
a53 3
static	int	  	phrase(struct mdoc *, 
				const struct regset *,
				int, int, char *);
a609 1
#ifdef	UGLY
a621 1
#endif
d740 1
a740 1
		if ( ! mdoc_macro(m, regs, ntok, line, lastarg, pos, buf))
d841 1
a841 1
			if ( ! mdoc_macro(m, regs, ntok, line, la, pos, buf))
a936 1
#ifdef	UGLY
a937 1
#endif
d1085 1
a1085 1
			if ( ! phrase(m, regs, line, la, buf))
d1100 1
a1100 1
		if ( ! mdoc_macro(m, regs, ntok, line, la, pos, buf))
a1118 1
#ifdef	UGLY
a1133 1
#endif
d1226 1
a1226 1
		if ( ! mdoc_macro(m, regs, ntok, line, la, pos, buf))
d1371 1
a1371 1
		if ( ! mdoc_macro(m, regs, ntok, line, la, pos, buf))
d1490 1
a1490 1
			if ( ! mdoc_macro(m, regs, ntok, line, la, pos, buf))
d1596 1
a1596 1
		return(mdoc_macro(m, regs, ntok, line, la, pos, buf));
d1615 1
a1615 1
		return(in_line(m, regs, tok, line, ppos, pos, buf));
d1619 1
a1619 1
		return(in_line(m, regs, tok, line, ppos, pos, buf));
d1627 1
a1627 1
	return(blk_part_imp(m, regs, tok, line, ppos, pos, buf));
d1646 1
a1646 2
phrase(struct mdoc *m, const struct regset *regs,
		int line, int ppos, char *buf)
d1671 1
a1671 1
		if ( ! mdoc_macro(m, regs, ntok, line, la, &pos, buf))
d1716 1
a1716 1
		if ( ! mdoc_macro(m, regs, ntok, line, la, pos, buf))
@


1.80
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.79 2010/05/31 23:49:16 kristaps Exp $ */
d53 3
a55 1
static	int	  	phrase(struct mdoc *, int, int, char *);
d744 1
a744 1
		if ( ! mdoc_macro(m, ntok, line, lastarg, pos, buf))
d845 1
a845 1
			if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1091 1
a1091 1
			if ( ! phrase(m, line, la, buf))
d1106 1
a1106 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1234 1
a1234 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1379 1
a1379 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1498 1
a1498 1
			if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
d1604 1
a1604 1
		return(mdoc_macro(m, ntok, line, la, pos, buf));
d1623 1
a1623 1
		return(in_line(m, tok, line, ppos, pos, buf));
d1627 1
a1627 1
		return(in_line(m, tok, line, ppos, pos, buf));
d1635 1
a1635 1
	return(blk_part_imp(m, tok, line, ppos, pos, buf));
d1654 2
a1655 1
phrase(struct mdoc *m, int line, int ppos, char *buf)
d1680 1
a1680 1
		if ( ! mdoc_macro(m, ntok, line, la, &pos, buf))
d1725 1
a1725 1
		if ( ! mdoc_macro(m, ntok, line, la, pos, buf))
@


1.79
log
@Lint fixes (noops).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.78 2010/05/31 22:39:55 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.78
log
@Remove now-superfluous check on `Ta' context.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.77 2010/05/31 15:42:09 kristaps Exp $ */
d1686 1
a1692 1
	struct mdoc_node *n;
a1699 1
	n = m->last;
@


1.77
log
@Add ability to interpret initial free-form lines as part of a `Bl
-column' up until the first `It'.  This is UGLY and should have all
sorts of warnings, and will.  On the one hand, it fits with groff's
notion of tabs and tab-spaces.  On the other hand, it's not really
"free-form" text any more.  Note that this does not yet accomodate for
macros coming on these lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.76 2010/05/31 11:52:06 kristaps Exp $ */
a1702 20

	/* 
	 * FIXME: this is necessary in bogus constructions like
	 *  .Bl -column foo bar
	 *  .Sy foo Ta bar
	 * It is, however, an ugly way to do it.
	 *
	 * XXX; remove this when the above construct builds an implied
	 * `It' marker.
	 */ 
	if (NULL == m->last || 
			MDOC_BODY != m->last->type ||
			MDOC_It != m->last->tok ||
			NULL == m->last->parent->parent ||
			MDOC_Bl != m->last->parent->parent->tok ||
			LIST_column != m->last->parent->parent->data.list) {
		swarn(m, tok, line, ppos, n);
		return(0);
	}

@


1.76
log
@`Ta' scope-checks need to be more specific (until implicit `It' handling
comes into play).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.75 2010/05/31 10:28:04 kristaps Exp $ */
d1121 1
a1121 1
		return(1);
d1148 10
@


1.75
log
@Remove enum mdocargerr from phrase() (unused).

Add `Ta' macro, which is basically a NULL case everywhere but in
mdoc_macro.c, where it closes out an existing `It' body scope and opens
a new one, then continues parsing as in phrase() (TODO: merge these
two?).

Fix where scope-breaking was silently just dying instead of printing an
error.

Fix where trailing `Ta' or tab weren't creating a new MDOC_BODY context.

We now support arbitrarily complex `It' contents for `Bl -column'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.74 2010/05/30 22:56:02 kristaps Exp $ */
d1705 4
a1708 1
			MDOC_It != m->last->tok) {
@


1.74
log
@Migrate `Bl -column' phrases to be MDOC_BODY instead of MDOC_HEAD.  This
will make it easy for re-entrant parsing of `Ta' macros to fit in with
standard closure rules.

Added some more regressions for `Bl -column'.  Note that one should
fail, as documented in the TODO file.

Recorded change of AST BNF in mdoc.3.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.73 2010/05/30 21:50:23 kristaps Exp $ */
d47 1
d53 1
a53 2
static	int	  	phrase(struct mdoc *, int, int, 
				char *, enum margserr);
d189 1
d200 1
a200 1
	int		 rc;
d233 2
a234 2
	rc = mdoc_vmsg(mdoc, MANDOCERR_SCOPE, line, pos,
			"%s scope breaks %s of %s", tt, t, n);
d236 3
a238 2
	/* FIXME: logic should be in driver. */
	return(MDOC_IGN_SCOPE & mdoc->pflags ? rc : 0);
d1011 2
a1012 2
		/* Initialise last-phrase-type with ARGS_PHRASE. */
		lac = ARGS_ERROR == ac ? ARGS_PHRASE : ac;
d1017 16
a1032 1
		if (ARGS_EOLN == ac)
d1034 1
d1089 1
a1089 4
			if (ARGS_PEND == ac) {
				if ( ! phrase(m, line, la, buf, lac))
					return(0);
			} else if ( ! phrase(m, line, la, buf, ac))
d1642 1
a1642 1
phrase(struct mdoc *m, int line, int ppos, char *buf, enum margserr ac)
d1645 1
a1645 1
	enum margserr	 aac;
a1648 2
	assert(ARGS_PHRASE == ac || ARGS_PPHRASE == ac);

d1652 1
a1652 1
		aac = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1654 1
a1654 1
		if (ARGS_ERROR == aac)
d1656 1
a1656 1
		if (ARGS_EOLN == aac)
d1659 1
a1659 1
		ntok = ARGS_QWORD == aac ? MDOC_MAX : lookup_raw(p);
d1676 61
@


1.73
log
@Final word on lac/ac.  Document flow as it relates to phrasing, as I'll
be changing this around and want a record in CVS of what was happening
beforehand.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.72 2010/05/30 21:41:46 kristaps Exp $ */
d940 1
d1034 1
a1034 4
		/* 
		 * Open a head if one hasn't been opened. Re-open head
		 * for phrases. 
		 */
d1036 1
a1036 4
		if (NULL == head || 
				ARGS_PEND == ac ||
				ARGS_PHRASE == ac || 
				ARGS_PPHRASE == ac) {
d1046 15
d1065 1
a1077 5

			/* Close out active phrase. */

			if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
				return(0);
@


1.72
log
@Obvious fix to last patch: have ARGS_PEND also be flagged for phrase()
handling.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.71 2010/05/30 21:28:30 kristaps Exp $ */
a1004 1
	lac = ARGS_PHRASE;
d1008 2
a1009 1
		lac = ac;
d1017 4
a1020 1
		/* Don't emit leading punct. for phrases. */
d1033 4
a1036 1
		/* Always re-open head for phrases. */
d1050 5
d1068 2
@


1.71
log
@First in several iterative patches in getting complex -column lists
supported (which works but is tricky enough that it should be broken
down into digestable parts).  This simply moves around the propogation
of ARGS_PEND into one recognised by phrase().

Added a few regressions for simple -column lists.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.70 2010/05/29 18:47:54 kristaps Exp $ */
d1041 3
a1043 1
		if (ARGS_PHRASE == ac || ARGS_PPHRASE == ac) {
@


1.70
log
@Commit of patch floated on discuss@@ a few days ago: if an in_line scope
has not been opened and closing punctuation is encountered AND the macro
is marked as accepting no-content (or `Li'), then open an empty scope.

Added regression tests for `Fl' and `Li' testing this behaviour.

Also, squeeze hyph0.in tests into the last characters of each line so
that groff doesn't hyphenate and break the test.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.69 2010/05/26 09:35:35 kristaps Exp $ */
d1005 1
a1016 7
		if (ARGS_PEND == ac) {
			if (ARGS_PPHRASE == lac)
				ac = ARGS_PPHRASE;
			else
				ac = ARGS_PHRASE;
		}

d1020 1
d1033 1
d1044 7
a1050 1
			if ( ! phrase(m, line, la, buf, ac))
d1052 1
d1054 1
@


1.69
log
@Fixed `Lb' to be in_line (reported by Ulrich Spoerlein).

Added `Lb' documentation to mdoc.7.

Removed harmless but superfluous pre_lb check (was just NULL entries).

Added regressions for `Lb' (NOTE that these will only run on new groff,
as old groff doesn't support `Lb' at all).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.68 2010/05/17 22:11:42 kristaps Exp $ */
d757 1
a757 1
	int		 la, lastpunct, cnt, nc, nl;
d808 1
a808 1
	for (cnt = 0, lastpunct = 1;; ) {
d829 1
a829 1
			if (0 == lastpunct && ! rew_elem(m, tok))
d856 23
a878 2
		if (ARGS_QWORD != ac && DELIM_NONE != d) {
			if (0 == lastpunct && ! rew_elem(m, tok))
d880 2
a881 2
			lastpunct = 1;
		} else if (lastpunct) {
d884 1
a884 1
			lastpunct = 0;
d897 1
a897 1
		if (0 == lastpunct && MDOC_Fl == tok) {
d900 1
a900 1
			lastpunct = 1;
d904 1
a904 1
	if (0 == lastpunct && ! rew_elem(m, tok))
@


1.68
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.67 2010/05/15 08:54:04 schwarze Exp $ */
d174 1
a174 1
	{ in_line_eoln, 0 }, /* Lb */
@


1.67
log
@Distinguish OPEN, MIDDLE and CLOSE delimiters (using an enum).
Only OPEN are drawn before the beginning of a macro;
this is new, before this, MIDDLE ('|') were drawn in front, too.
Only CLOSE are pushed after the end of a macro (as before).
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.66 2010/05/15 06:48:13 kristaps Exp $ */
d28 1
d199 1
d232 5
a236 7
	if ( ! (MDOC_IGN_SCOPE & mdoc->pflags))
		return(mdoc_verr(mdoc, line, pos, 
				"%s scope breaks %s scope of %s", 
				tt, t, n));
	return(mdoc_vwarn(mdoc, line, pos, 
				"%s scope breaks %s scope of %s", 
				tt, t, n));
d259 2
a260 1
		return(mdoc_nerr(m, n, EOPEN));
d592 3
a594 1
			return(mdoc_perr(m, line, ppos, ENOCTX));
d692 1
d694 1
a694 1
			if ( ! mdoc_pwarn(m, line, ppos, ENOLINE))
d838 1
a838 1
				if ( ! mdoc_pwarn(m, line, ppos, EIGNE))
d899 1
a899 1
		if ( ! mdoc_pwarn(m, line, ppos, EIGNE))
d1205 1
a1205 1
	if (NULL == n && ! mdoc_nwarn(m, body, EIMPBRK))
d1571 1
a1571 1
	return(mdoc_pwarn(m, line, ppos, EOBS));
@


1.66
log
@More EOS: append_delims() fitted with EOS detection, so ANY macro with appended delimiters will properly EOS.
Fixed mandoc_eos() to accept sentence punctuation followed by close-delim buffers.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.65 2010/05/15 04:47:38 kristaps Exp $ */
d643 1
a643 1
		assert(mdoc_isdelim(p));
d753 1
a753 1
	int		 la, lastpunct, cnt, d, nc, nl;
d757 1
d850 1
a850 1
		d = ARGS_QWORD == ac ? 0 : mdoc_isdelim(p);
d852 1
a852 1
		if (ARGS_QWORD != ac && d) {
d862 1
a862 1
		if ( ! d)
d1004 1
a1004 1
				1 == mdoc_isdelim(p)) {
d1137 1
a1137 1
				1 == mdoc_isdelim(p)) {
d1256 1
a1256 1
				1 == mdoc_isdelim(p)) {
d1401 1
a1401 1
				0 == j && 1 == mdoc_isdelim(p)) {
d1429 2
a1430 1
				! flushed && mdoc_isdelim(p)) {
@


1.65
log
@More `Bl -column' dancing: It children also inherit in-phrase flags (noted by Ingo Schwarze).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.64 2010/05/14 14:09:13 kristaps Exp $ */
d625 1
a625 1
append_delims(struct mdoc *mdoc, int line, int *pos, char *buf)
d627 1
a627 1
	int		 lastarg;
d631 1
a631 1
	if (0 == buf[*pos])
d635 2
a636 2
		lastarg = *pos;
		ac = mdoc_zargs(mdoc, line, pos, buf, ARGS_NOWARN, &p);
d642 1
d644 1
a644 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d646 14
@


1.64
log
@Block-implicit macros now up-propogate end-of-sentence spacing.  NOTE: GROFF IS NOT SMART ENOUGH TO DO THIS.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.63 2010/05/14 13:31:20 kristaps Exp $ */
d975 7
a986 1
				ARGS_PEND != ac &&
a997 1
				ARGS_PEND == ac || 
d1004 3
a1006 14
		if (ARGS_PHRASE == ac || 
				ARGS_PEND == ac ||
				ARGS_PPHRASE == ac) {
			/*
			 * Special treatment for the last phrase.  A
			 * prior ARGS_PHRASE gets is handled as a
			 * regular ARGS_PHRASE, but a prior ARGS_PPHRASE
			 * has special handling.
			 */
			if (ARGS_PEND == ac && ARGS_ERROR == lac)
				ac = ARGS_PHRASE;
			else if (ARGS_PEND == ac && ARGS_PHRASE == lac)
				ac = ARGS_PHRASE;

d1009 1
d1567 1
a1567 3
	assert(ARGS_PHRASE == ac || 
			ARGS_PEND == ac ||
			ARGS_PPHRASE == ac);
d1572 1
a1572 1
		aac = mdoc_zargs(m, line, &pos, buf, ARGS_PPHRASED, &p);
d1579 1
a1579 2
		ntok = ARGS_QWORD == aac || ARGS_PEND == ac ? 
			MDOC_MAX : lookup_raw(p);
@


1.63
log
@Removed remaining "1 == ppos" invocations.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.62 2010/05/14 12:55:22 kristaps Exp $ */
d29 1
d1159 19
@


1.62
log
@Proper handling of quoted tab-separated column lists.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.61 2010/05/13 11:34:45 kristaps Exp $ */
d891 1
a891 1
	int		  la;
d903 2
d1038 1
a1038 1
	if (1 == ppos && ! append_delims(m, line, pos, buf))
d1078 1
a1078 1
	int		  la;
d1086 2
d1163 2
d1178 1
a1178 1
	if (1 == ppos && ! append_delims(m, line, pos, buf))
@


1.61
log
@Lint fix.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.60 2010/05/13 06:22:11 kristaps Exp $ */
d51 1
a51 1
				char *, enum margserr, int);
d891 1
a891 1
	int		  la, pcnt;
d962 1
a962 1
	for (pcnt = 0; ; ) {
d1010 1
a1010 1
			if ( ! phrase(m, line, la, buf, ac, pcnt++))
d1539 1
a1539 2
phrase(struct mdoc *m, int line, int ppos, char *buf, 
		enum margserr ac, int count)
a1549 3
	if (count && ARGS_PPHRASE == ac)
		return(mdoc_word_alloc(m, line, ppos, &buf[ppos]));

d1553 1
a1553 2
		/* Note: no calling context! */
		aac = mdoc_zargs(m, line, &pos, buf, 0, &p);
@


1.60
log
@Fixed bug in -Thtml -mdoc where `Lb' would line-break in LIBRARY section.
Fixed assumption that parse-point == 1 equates to beginning of line (false if whitespace separates macro and control character).
Fixed line-break for non-first-macro in several SYNOPSIS macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.59 2010/05/09 10:17:02 kristaps Exp $ */
d1294 1
@


1.59
log
@Introduce ARGS_PEND for `It -column' end-of-line special casing.
Initial rules for insane `It -column' tabsep handling.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.58 2010/05/08 07:30:19 kristaps Exp $ */
d656 1
a656 1
	int	 	 j, lastarg, maxargs, flushed;
d661 2
d728 1
a728 1
	if (ppos > 1)
d737 1
a737 1
	int		 la, lastpunct, cnt, d, nc;
d744 2
d822 1
a822 1
			if (ppos > 1)
d882 1
a882 1
	if (ppos > 1)
d1187 1
a1187 1
	int		  la;
d1194 2
d1288 1
a1288 1
	if (ppos > 1)
a1289 1

d1297 1
a1297 1
	int		 la, flushed, j, maxargs;
d1304 2
d1425 1
a1425 2

	if (ppos > 1)
d1501 3
d1510 1
a1510 1
	if (ppos > 1)
@


1.58
log
@Lint fixes (type-safety for enums via -cefuh).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.57 2010/05/07 06:05:38 kristaps Exp $ */
d50 2
a51 1
static	int	  	phrase(struct mdoc *, int, int, char *);
d887 1
a887 1
	int		  la;
d895 1
a895 1
	enum margserr	  ac;
d956 3
a958 1
	for (;;) {
d960 1
d970 2
a971 1
		if (NULL == head && ARGS_PHRASE != ac &&
d973 1
d983 3
a985 1
		if (NULL == head || ARGS_PHRASE == ac || 
d992 15
a1006 2
		if (ARGS_PHRASE == ac || ARGS_PPHRASE == ac) {
			if ( ! phrase(m, line, la, buf))
d1529 2
a1530 1
phrase(struct mdoc *m, int line, int ppos, char *buf)
d1533 1
a1533 1
	enum margserr	 ac;
d1537 7
d1548 1
a1548 1
		ac = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1550 1
a1550 1
		if (ARGS_ERROR == ac)
d1552 1
a1552 1
		if (ARGS_EOLN == ac)
d1555 2
a1556 1
		ntok = ARGS_QWORD == ac ? MDOC_MAX : lookup_raw(p);
@


1.57
log
@Initial ARGS_PPHRASE (partial phrase) framework.
Running tally of changes in index.sgml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.56 2010/05/07 05:54:09 kristaps Exp $ */
d48 1
a48 1
static	enum mdoct	lookup(int, const char *);
d270 1
a270 1
lookup(int from, const char *p)
d286 1
a286 1
	int		 res;
@


1.56
log
@enum-ised mdoc_argv() return (better return-value safety).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.55 2010/05/07 05:48:29 kristaps Exp $ */
a634 1
		assert(ARGS_PHRASE != ac);
d967 1
d977 2
a978 1
		if (NULL == head || ARGS_PHRASE == ac) {
d984 1
a984 1
		if (ARGS_PHRASE == ac) {
a1087 2
		assert(ARGS_PHRASE != ac);

a1188 2
		assert(ARGS_PHRASE != ac);

@


1.55
log
@margerr -> margserr (getting ready for margverr).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.54 2010/05/07 05:39:35 kristaps Exp $ */
d735 2
a736 1
	int		 la, lastpunct, c, cnt, d, nc;
d768 1
a768 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d770 1
a770 1
		if (ARGV_WORD == c) {
d774 1
a774 1
		if (ARGV_EOLN == c)
d776 1
a776 1
		if (ARGV_ARG == c)
d887 1
a887 1
	int		  c, la;
d896 1
d919 1
a919 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d921 1
a921 1
		if (ARGV_WORD == c) {
d926 1
a926 1
		if (ARGV_EOLN == c)
d928 1
a928 1
		if (ARGV_ARG == c)
d1274 1
a1274 1
	int		 la, flushed, j, c, maxargs;
d1276 1
d1309 1
a1309 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d1311 1
a1311 1
		if (ARGV_WORD == c) {
d1316 1
a1316 1
		if (ARGV_EOLN == c)
d1318 1
a1318 1
		if (ARGV_ARG == c)
d1410 1
a1410 1
	int		 c, la;
d1412 1
d1423 1
a1423 1
		c = mdoc_argv(m, line, tok, &arg, pos, buf);
d1425 1
a1425 1
		if (ARGV_WORD == c) {
d1429 1
a1429 1
		if (ARGV_EOLN == c) 
d1431 1
a1431 1
		if (ARGV_ARG == c)
@


1.54
log
@Protection against running lookup() against quoted words.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.53 2010/05/07 05:34:56 kristaps Exp $ */
d626 1
a626 1
	enum margerr	 ac;
d657 1
a657 1
	enum margerr	 ac;
d737 1
a737 1
	enum margerr	 ac;
d894 1
a894 1
	enum margerr	  ac;
d1050 1
a1050 1
	enum margerr	  ac;
d1162 1
a1162 1
	enum margerr	  ac;
d1273 1
a1273 1
	enum margerr	 ac;
d1408 1
a1408 1
	enum margerr	 ac;
d1510 1
a1510 1
	enum margerr	 ac;
@


1.53
log
@Wrangle mdoc_args() and mdoc_zargs() to use enum return type.
Fixed lookup() and lookup_raw() to correctly use enum type.
Quashed in_line_argn() bug (not reported, but there) where mixing return values.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.52 2010/04/06 07:17:51 kristaps Exp $ */
d705 4
a708 7
		if (MDOC_MAX != (ntok = lookup(tok, p))) {
			if ( ! flushed) {
				if ( ! rew_sub(MDOC_BLOCK, m, tok, line, ppos))
					return(0);
				flushed = 1;
			}
			if ( ! mdoc_macro(m, ntok, line, lastarg, pos, buf))
d710 2
a711 2
			break;
		} 
d713 6
a718 1
		if ( ! mdoc_word_alloc(m, line, lastarg, p))
d720 1
a792 2
		/* Quoted words shouldn't be looked-up. */

d989 3
a991 1
		if (MDOC_MAX == (ntok = lookup(tok, p))) {
d1107 3
a1109 1
		if (MDOC_MAX == (ntok = lookup(tok, p))) {
d1231 3
a1233 1
		if (MDOC_MAX == (ntok = lookup(tok, p))) {
d1349 3
a1351 1
		if (MDOC_MAX != (ntok = lookup(tok, p))) {
@


1.52
log
@Fix mdoc bug found by Claus Assmann: `Pf' should be callable.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.51 2010/04/05 08:45:29 kristaps Exp $ */
d36 27
a62 27
static	int	  ctx_synopsis(MACRO_PROT_ARGS);
static	int	  obsolete(MACRO_PROT_ARGS);
static	int	  blk_part_exp(MACRO_PROT_ARGS);
static	int	  in_line_eoln(MACRO_PROT_ARGS);
static	int	  in_line_argn(MACRO_PROT_ARGS);
static	int	  in_line(MACRO_PROT_ARGS);
static	int	  blk_full(MACRO_PROT_ARGS);
static	int	  blk_exp_close(MACRO_PROT_ARGS);
static	int	  blk_part_imp(MACRO_PROT_ARGS);

static	int	  phrase(struct mdoc *, int, int, char *);
static	enum rew  rew_dohalt(enum mdoct, enum mdoc_type, 
			const struct mdoc_node *);
static	enum mdoct rew_alt(enum mdoct);
static	int	  rew_dobreak(enum mdoct, const struct mdoc_node *);
static	int	  rew_elem(struct mdoc *, enum mdoct);
static	int	  rew_sub(enum mdoc_type, struct mdoc *, 
			enum mdoct, int, int);
static	int	  rew_last(struct mdoc *, 
			const struct mdoc_node *);
static	int	  append_delims(struct mdoc *, int, int *, char *);
static	int	  lookup(int, const char *);
static	int	  lookup_raw(const char *);
static	int	  swarn(struct mdoc *, enum mdoc_type, int, int, 
			const struct mdoc_node *);

/* Central table of library: who gets parsed how. */
d269 1
a269 1
static int
d283 1
a283 1
static int
d625 2
a626 1
	int		 c, lastarg;
d634 2
a635 2
		c = mdoc_zargs(mdoc, line, pos, buf, ARGS_NOWARN, &p);
		assert(ARGS_PHRASE != c);
d637 1
a637 1
		if (ARGS_ERROR == c)
d639 1
a639 1
		else if (ARGS_EOLN == c)
d656 3
a658 1
	int	 	 j, c, lastarg, maxargs, flushed;
d696 1
a696 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d698 1
a698 1
		if (ARGS_ERROR == c)
d700 1
a700 1
		if (ARGS_PUNCT == c)
d702 1
a702 1
		if (ARGS_EOLN == c)
d705 1
a705 1
		if (MDOC_MAX != (c = lookup(tok, p))) {
d711 1
a711 1
			if ( ! mdoc_macro(m, c, line, lastarg, pos, buf))
d732 5
a736 3
	int		  la, lastpunct, c, w, cnt, d, nc;
	struct mdoc_arg	 *arg;
	char		 *p;
d781 1
a781 1
		w = mdoc_args(m, line, pos, buf, tok, &p);
d783 1
a783 1
		if (ARGS_ERROR == w)
d785 1
a785 1
		if (ARGS_EOLN == w)
d787 1
a787 1
		if (ARGS_PUNCT == w)
d792 1
a792 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(tok, p);
d801 1
a801 1
		if (MDOC_MAX != c) {
d814 1
a814 2
			c = mdoc_macro(m, c, line, la, pos, buf);
			if (0 == c)
d827 1
a827 1
		d = ARGS_QWORD == w ? 0 : mdoc_isdelim(p);
d829 1
a829 1
		if (ARGS_QWORD != w && d) {
d892 2
d955 1
a955 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d957 1
a957 1
		if (ARGS_ERROR == c)
d959 1
a959 1
		if (ARGS_EOLN == c)
d964 2
a965 2
		if (NULL == head && ARGS_PHRASE != c &&
				ARGS_QWORD != c &&
d974 1
a974 1
		if (NULL == head || ARGS_PHRASE == c) {
d980 1
a980 1
		if (ARGS_PHRASE == c) {
d988 2
a989 3
		c = lookup(tok, p);
		if (MDOC_MAX != c) {
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d991 1
a991 1
			break;
d993 2
a994 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d996 1
a996 1

d1045 3
a1047 1
	int		  la, c;
d1080 1
a1080 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d1082 1
a1082 1
		assert(ARGS_PHRASE != c);
d1084 1
a1084 1
		if (ARGS_ERROR == c)
d1086 1
a1086 1
		if (ARGS_EOLN == c)
d1088 1
a1088 1
		if (ARGS_PUNCT == c)
d1091 1
a1091 1
		if (NULL == body && ARGS_QWORD != c &&
d1104 2
a1105 2
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1107 2
a1108 2
			break;
		} 
d1110 1
a1110 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1112 1
d1156 2
a1157 1
	int		  la, c;
d1161 1
d1174 1
a1174 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d1176 1
a1176 1
		if (ARGS_ERROR == c)
d1178 1
a1178 1
		if (ARGS_PUNCT == c)
d1180 1
a1180 1
		if (ARGS_EOLN == c)
d1183 1
a1183 1
		assert(ARGS_PHRASE != c);
d1187 1
a1187 1
		if (NULL == head && ARGS_QWORD != c &&
d1226 2
a1227 2
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1229 1
a1229 1
			break;
d1232 1
a1232 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1234 1
d1265 5
a1269 3
	int		  la, flushed, j, c, maxargs;
	struct mdoc_arg	 *arg;
	char		 *p;
d1317 1
a1317 1
		c = mdoc_args(m, line, pos, buf, tok, &p);
d1319 1
a1319 1
		if (ARGS_ERROR == c)
d1321 1
a1321 1
		if (ARGS_PUNCT == c)
d1323 1
a1323 1
		if (ARGS_EOLN == c)
d1327 1
a1327 1
				ARGS_QWORD != c &&
d1342 1
a1342 1
		if (MDOC_MAX != (c = lookup(tok, p))) {
d1346 1
a1346 1
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1353 1
a1353 1
				ARGS_QWORD != c &&
d1398 5
a1402 3
	int		  c, w, la;
	struct mdoc_arg	 *arg;
	char		 *p;
d1434 1
a1434 1
		w = mdoc_args(m, line, pos, buf, tok, &p);
d1436 1
a1436 1
		if (ARGS_ERROR == w)
d1438 1
a1438 1
		if (ARGS_EOLN == w)
d1441 1
a1441 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(tok, p);
d1443 2
a1444 2
		if (MDOC_MAX != c) {
			if ( ! rew_elem(m, tok))
d1446 2
a1447 2
			return(mdoc_macro(m, c, line, la, pos, buf));
		} 
d1449 1
a1449 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1451 1
d1500 4
a1503 2
	int		  c, w, la, pos;
	char		 *p;
d1509 1
a1509 1
		w = mdoc_zargs(m, line, &pos, buf, 0, &p);
d1511 1
a1511 1
		if (ARGS_ERROR == w)
d1513 1
a1513 1
		if (ARGS_EOLN == w)
d1516 1
a1516 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup_raw(p);
d1518 2
a1519 2
		if (MDOC_MAX != c) {
			if ( ! mdoc_macro(m, c, line, la, &pos, buf))
d1521 2
a1522 2
			return(append_delims(m, line, &pos, buf));
		} 
d1524 1
a1524 1
		if ( ! mdoc_word_alloc(m, line, la, p))
d1526 1
@


1.51
log
@Enum-ised REWIND return values.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.50 2010/04/05 08:38:37 kristaps Exp $ */
d142 1
a142 1
	{ in_line_argn, MDOC_PARSED | MDOC_IGNDELIM }, /* Pf */
@


1.50
log
@Tentative fix of quoted punctuation issue noted by Jason McIntyre, e.g., `Li "!"' rendering the "!" outside of scope.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.49 2010/03/31 08:04:57 kristaps Exp $ */
d30 5
a34 3
#define	REWIND_REWIND	(1 << 0)
#define	REWIND_NOHALT	(1 << 1)
#define	REWIND_HALT	(1 << 2)
d47 1
a47 1
static	int	  rew_dohalt(enum mdoct, enum mdoc_type, 
d373 1
a373 1
static int 
d579 1
a579 1
	int		  c;
@


1.49
log
@Fixed fatal bug in Xo/Xc patch that caused segfaults with last-child explicit-scope macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.48 2010/03/31 07:42:04 kristaps Exp $ */
d821 1
a821 1
		d = mdoc_isdelim(p);
d957 1
d1081 2
a1082 1
		if (NULL == body && 1 == mdoc_isdelim(p)) {
d1174 2
a1175 1
		if (NULL == head && 1 == mdoc_isdelim(p)) {
d1311 1
d1337 1
@


1.48
log
@Re-adjusting UGLY tags.
Fixed removed assignment of type.
Removed superfluous checks of mdoc_argflags (from days when comments were a macro tag).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.47 2010/03/31 07:13:53 kristaps Exp $ */
d882 1
d927 1
a927 1
	head = NULL;
d942 1
d999 1
a999 1
	/* See notes on `Nd' hybrid, above. */
d1001 1
a1001 1
	if (MDOC_Nd == tok)
d1006 4
a1009 3
	 * If there is an open sub-block requiring explicit close-out,
	 * postpone switching the current block from head to body until
	 * the rew_sub() call closing out that sub-block.
d1012 4
a1015 2
		if (MDOC_EXPLICIT & mdoc_macros[n->tok].flags && 
				MDOC_BLOCK == n->type) {
@


1.47
log
@Macro types enum-ated (enum mdoct) (for easier debugging in gdb of "tok" values).
Initial check-in of Ingo Schwarze's patch for Xo/Xc handling (in blocks ifdef'd "UGLY").
Put Oc-close-Op parts into UGLY ifdef blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.46 2010/03/30 08:24:01 kristaps Exp $ */
a540 1
#ifdef UGLY
a542 1
#endif
d882 1
d884 1
a1104 1
#ifdef	UGLY
a1113 1
#endif
@


1.46
log
@Modified in_line_eoln() to handle leading punctuation.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.45 2010/03/30 06:52:08 kristaps Exp $ */
d45 1
a45 1
static	int	  rew_dohalt(int, enum mdoc_type, 
d47 3
a49 3
static	int	  rew_alt(int);
static	int	  rew_dobreak(int, const struct mdoc_node *);
static	int	  rew_elem(struct mdoc *, int);
d51 1
a51 1
			int, int, int);
d321 2
a322 2
static int
rew_alt(int tok)
d372 2
a373 1
rew_dohalt(int tok, enum mdoc_type type, const struct mdoc_node *p)
d512 1
a512 1
rew_dobreak(int tok, const struct mdoc_node *p)
d541 1
a541 1
		/* XXX - experimental! */
d544 1
d560 1
a560 1
rew_elem(struct mdoc *mdoc, int tok)
d576 1
a576 1
		int tok, int line, int ppos)
d600 19
a618 1
	return(rew_last(m, n));
d884 1
d1002 15
d1105 1
d1110 1
a1110 1
	 * crufty use of `Op' breakage.  XXX: DEPRECATE.
a1111 1

d1115 1
@


1.45
log
@Last remaining bits for leading-punctuation in blk_exp().
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.44 2010/03/29 19:45:42 kristaps Exp $ */
d1212 7
a1218 1
	/* Fixed maximum arguments per macro, if applicable. */
d1238 1
a1238 3
	/* Macro argument processing. */

	for (arg = NULL;; ) {
d1256 1
a1256 8
	/* Open the element scope. */

	if ( ! mdoc_elem_alloc(m, line, ppos, tok, arg))
		return(0);

	/* Process element arguments. */

	for (flushed = j = 0; ; j++) {
a1257 7

		if (j == maxargs && ! flushed) {
			if ( ! rew_elem(m, tok))
				return(0);
			flushed = 1;
		}

d1267 15
d1288 1
d1306 1
d1308 1
a1308 1
			if ( ! mdoc_elem_alloc(m, line, ppos, MDOC_Ns, NULL))
d1313 1
d1317 1
d1320 4
a1323 1
	/* Close out and append delimiters. */
@


1.44
log
@Fixed segfault with accidentally-munged tree.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.43 2010/03/29 19:28:04 kristaps Exp $ */
d717 1
a838 1
	 *
d840 1
d861 1
a861 1
	int		  c, lastarg, reopen, dohead;
d863 1
d866 1
a866 15
	/* 
	 * Whether to process a block-head section.  If this is
	 * non-zero, then a head will be opened for all line arguments.
	 * If not, then the head will always be empty and only a body
	 * will be opened, which will stay open at the eoln.
	 */

	switch (tok) {
	case (MDOC_Nd):
		dohead = 0;
		break;
	default:
		dohead = 1;
		break;
	}
d875 9
d885 1
a885 1
		lastarg = *pos;
d889 1
a889 1
			*pos = lastarg;
a903 2
	if ( ! mdoc_head_alloc(m, line, ppos, tok))
		return(0);
d905 1
a905 7
	if ('\0' == buf[*pos]) {
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
			return(0);
		return(1);
	}
d907 4
a910 1
	/* Immediately close out head and enter body, if applicable. */
d912 4
a915 1
	if (0 == dohead) {
d922 2
a923 2
	for (reopen = 0;; ) {
		lastarg = *pos;
d930 18
d949 1
a949 9
			assert(dohead);
			if (reopen && ! mdoc_head_alloc(m, line, ppos, tok))
				return(0);
			/*
			 * Phrases are self-contained macro phrases used
			 * in the columnar output of a macro. They need
			 * special handling.
			 */
			if ( ! phrase(m, line, lastarg, buf))
a952 2

			reopen = 1;
d956 3
a958 2
		if (MDOC_MAX == (c = lookup(tok, p))) {
			if ( ! mdoc_word_alloc(m, line, lastarg, p))
d960 6
a965 2
			continue;
		} 
d967 2
a968 1
		if ( ! mdoc_macro(m, c, line, lastarg, pos, buf))
d970 1
a970 1
		break;
d976 3
a978 2
	/* If the body's already open, then just return. */
	if (0 == dohead) 
d981 2
d1039 1
a1039 1
		if (1 == mdoc_isdelim(p) && NULL == body) {
d1132 1
a1132 1
		if (1 == mdoc_isdelim(p) && NULL == head) {
@


1.43
log
@Integrate Ingo Schwarze's patch for mdoc_iscdelim() (tri-state for opening and closing macro punctuation).
Modify blk_part_exp() to correctly handle leading punctuation before HEAD.
Significantly clean up and document blk_part_exp().
Modify blk_part_imp() for to correctly handle leading punctuation before HEAD.
Significantly clean up and document blk_part_imp().
Integrate Ingo Schwarze's patch for args() (using new mdoc_iscdelim() format).
Documented bad `Ec' handling for later work in mdoc_term.c/mdoc_html.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.42 2010/02/17 19:28:11 kristaps Exp $ */
d907 2
d910 1
a910 3
	if (0 == buf[*pos]) {
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
			return(0);
a917 3
	if ( ! mdoc_head_alloc(m, line, ppos, tok))
		return(0);

d1051 5
a1055 4
	if (NULL == body && ! mdoc_body_alloc(m, line, ppos, tok))
		return(0);

	body = m->last;
@


1.42
log
@Made `Xr' compatible with groff calling conventions where arguments following the
trailing section are implicitly `Ns'd.  Based on a patch submitted by Ingo Schwarze.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.41 2010/01/30 08:42:20 kristaps Exp $ */
d988 3
a990 1
	struct mdoc_node *blk, *body, *n;
d992 8
a999 1
	/* If applicable, close out prior scopes. */
d1003 1
a1003 1
	/* Saved for later close-out. */
d1005 1
a1009 4
	if ( ! mdoc_body_alloc(m, line, ppos, tok))
		return(0);
	/* Saved for later close-out. */
	body = m->last;
d1011 5
a1015 1
	/* Body argument processing. */
d1017 1
a1017 1
	for (;;) {
d1020 1
d1025 2
a1028 2
		if (ARGS_EOLN == c)
			break;
d1030 1
a1030 1
		if (MDOC_MAX == (c = lookup(tok, p))) {
d1036 13
a1048 1
		if ( ! mdoc_macro(m, c, line, la, pos, buf))
a1049 1
		break;
d1052 7
d1063 1
a1063 1
	 * crufty use of `Op' breakage--XXX, deprecate in time.
d1065 1
d1069 1
d1072 1
d1093 3
a1095 1
	int		  la, flushed, j, c, maxargs;
d1098 5
a1102 12
	/* Number of head arguments.  Only `Eo' has these, */

	switch (tok) {
	case (MDOC_Eo):
		maxargs = 1;
		break;
	default:
		maxargs = 0;
		break;
	}

	/* Begin the block scope. */
d1107 1
a1107 23
	/* 
	 * If no head arguments, open and then close out a head, noting
	 * that we've flushed our terms.  `flushed' means that we've
	 * flushed out the head and the body is open.
	 */

	if (0 == maxargs) {
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
			return(0);
		if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
			return(0);
		if ( ! mdoc_body_alloc(m, line, ppos, tok))
			return(0);
		flushed = 1;
	} else {
		if ( ! mdoc_head_alloc(m, line, ppos, tok))
			return(0);
		flushed = 0;
	}

	/* Process the head/head+body line arguments. */

	for (j = 0; ; j++) {
a1108 8
		if (j == maxargs && ! flushed) {
			if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
				return(0);
			flushed = 1;
			if ( ! mdoc_body_alloc(m, line, ppos, tok))
				return(0);
		}

a1109 1
		assert(ARGS_PHRASE != c);
d1118 14
a1131 9
		if (MDOC_MAX != (c = lookup(tok, p))) {
			if ( ! flushed) {
				if ( ! rew_sub(MDOC_HEAD, m, tok, line, ppos))
					return(0);
				flushed = 1;
				if ( ! mdoc_body_alloc(m, line, ppos, tok))
					return(0);
			}
			if ( ! mdoc_macro(m, c, line, la, pos, buf))
d1133 1
a1133 1
			break;
d1136 12
a1147 1
		if ( ! flushed && mdoc_isdelim(p)) {
a1149 1
			flushed = 1;
d1152 4
d1157 9
a1165 1
	
d1170 1
a1170 1
	/* Close the head and open the body, if applicable. */
d1172 7
a1178 1
	if ( ! flushed) {
d1183 1
d1190 1
d1289 1
@


1.41
log
@Fix in handling Vt in SYNOPSIS with trailing punctuation.  Spotted by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.40 2010/01/01 17:14:29 kristaps Exp $ */
d103 1
a103 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Xr */
d1183 3
d1251 14
a1264 1
	
@


1.40
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.39 2010/01/01 13:17:58 kristaps Exp $ */
d34 1
d102 1
a102 1
	{ in_line, MDOC_CALLABLE | MDOC_PARSED }, /* Vt */ 
d402 2
d1328 23
@


1.39
log
@`Fl' has each argument be in a separate scope (thanks Ingo Schwarze).
Situation of `Fl [arg]* "" [arg]*' is fixed: empty arguments are ignored.  Note that OpenBSD crashes when this happens.
Situation of `Fl' is fixed wrt trailing whitespace.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.38 2009/10/26 17:05:44 kristaps Exp $ */
d17 4
@


1.38
log
@Added time.h to various files for FreeBSD compilation (thanks Ulrich Sporlein).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.37 2009/10/24 05:52:13 kristaps Exp $ */
d811 11
@


1.37
log
@Added `%U' to -mdoc (doesn't render in a nice way yet).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.36 2009/09/20 17:24:57 kristaps Exp $ */
d22 1
@


1.36
log
@Some extra html tags and near-complete Bl: -tag is hopeless (synonym for -hang, now) and -column is still pending.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.35 2009/09/16 20:49:06 kristaps Exp $ */
d177 1
@


1.35
log
@Lintifications.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.34 2009/09/16 14:40:56 kristaps Exp $ */
d263 1
@


1.34
log
@Lookup hashes are now static tables, ordered first-level by second character, then randomly along a chain.  Improves performance by a small fraction and considerably cleans up hash sources.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.33 2009/08/20 08:59:12 kristaps Exp $ */
d49 2
a50 2
static	int	  lookup(struct mdoc *, int, const char *);
static	int	  lookup_raw(struct mdoc *, const char *);
d261 1
a261 1
lookup(struct mdoc *mdoc, int from, const char *p)
d266 1
a266 1
	return(lookup_raw(mdoc, p));
d274 1
a274 1
lookup_raw(struct mdoc *mdoc, const char *p)
d672 1
a672 1
		if (MDOC_MAX != (c = lookup(m, tok, p))) {
d756 1
a756 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(m, tok, p);
d935 1
a935 1
		if (MDOC_MAX == (c = lookup(m, tok, p))) {
d998 1
a998 1
		if (MDOC_MAX == (c = lookup(m, tok, p))) {
d1101 1
a1101 1
		if (MDOC_MAX != (c = lookup(m, tok, p))) {
d1212 1
a1212 1
		if (MDOC_MAX != (c = lookup(m, tok, p))) {
d1287 1
a1287 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(m, tok, p);
d1336 1
a1336 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup_raw(m, p);
@


1.33
log
@Delimiter whitespace is correctly flagged (required some special handling).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.32 2009/08/19 14:09:33 kristaps Exp $ */
d278 1
a278 1
	if (MDOC_MAX == (res = mdoc_hash_find(mdoc->htab, p)))
@


1.32
log
@In-line documentation of mdoc_macro file.
Moved _NEXT_ macros into _alloc_ routines (where they belong).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.31 2009/08/19 11:58:32 kristaps Exp $ */
d603 1
a603 1
		c = mdoc_args(mdoc, line, pos, buf, 0, &p);
d1329 1
a1329 1
		w = mdoc_zargs(m, line, &pos, buf, &p);
@


1.31
log
@Moved MDOC_NEXT_SIBLING into mdoc_word (libmdoc).
De-chunking of word terms in libman.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.30 2009/08/13 11:43:24 kristaps Exp $ */
d44 4
a47 5
static	int	  rew_impblock(struct mdoc *, int, int, int);
static	int	  rew_expblock(struct mdoc *, int, int, int);
static	int	  rew_subblock(enum mdoc_type, 
			struct mdoc *, int, int, int);
static	int	  rew_last(struct mdoc *, struct mdoc_node *); /* FIXME: make const */
d235 1
a235 1
mdoc_macroend(struct mdoc *mdoc)
d241 1
a241 2
	n = MDOC_VALID & mdoc->last->flags ?
		mdoc->last->parent : mdoc->last;
d248 1
a248 1
		return(mdoc_nerr(mdoc, n, EOPEN));
d251 3
a253 1
	return(rew_last(mdoc, mdoc->first));
d256 4
d270 3
d287 1
a287 1
rew_last(struct mdoc *mdoc, struct mdoc_node *to)
d309 4
a393 1
		assert(MDOC_HEAD != type);
a451 1

d563 1
a563 1
rew_subblock(enum mdoc_type type, struct mdoc *mdoc, 
d570 9
a578 4
	for (n = mdoc->last; n; n = n->parent) {
		c = rew_dohalt(tok, type, n);
		if (REWIND_HALT == c)
			return(1);
d583 1
a583 1
		if ( ! swarn(mdoc, type, line, ppos, n))
d588 1
a588 50
	return(rew_last(mdoc, n));
}


static int
rew_expblock(struct mdoc *mdoc, int tok, int line, int ppos)
{
	struct mdoc_node *n;
	int		  c;

	/* LINTED */
	for (n = mdoc->last; n; n = n->parent) {
		c = rew_dohalt(tok, MDOC_BLOCK, n);
		if (REWIND_HALT == c)
			return(mdoc_perr(mdoc, line, ppos, ENOCTX));
		if (REWIND_REWIND == c)
			break;
		else if (rew_dobreak(tok, n))
			continue;
		if ( ! swarn(mdoc, MDOC_BLOCK, line, ppos, n))
			return(0);
	}

	assert(n);
	return(rew_last(mdoc, n));
}


/* FIXME: can this be merged with subblock? */
static int
rew_impblock(struct mdoc *mdoc, int tok, int line, int ppos)
{
	struct mdoc_node *n;
	int		  c;

	/* LINTED */
	for (n = mdoc->last; n; n = n->parent) {
		c = rew_dohalt(tok, MDOC_BLOCK, n);
		if (REWIND_HALT == c)
			return(1);
		else if (REWIND_REWIND == c)
			break;
		else if (rew_dobreak(tok, n))
			continue;
		if ( ! swarn(mdoc, MDOC_BLOCK, line, ppos, n))
			return(0);
	}

	assert(n);
	return(rew_last(mdoc, n));
d639 1
a639 1
			if ( ! mdoc_pwarn(mdoc, line, ppos, ENOLINE))
d642 1
a642 1
		if ( ! rew_subblock(MDOC_BODY, mdoc, tok, line, ppos))
d644 1
a644 1
		return(rew_expblock(mdoc, tok, line, ppos));
d647 1
a647 1
	if ( ! rew_subblock(MDOC_BODY, mdoc, tok, line, ppos))
d650 2
a651 3
	if (maxargs > 0) {
		if ( ! mdoc_tail_alloc(mdoc, line, 
					ppos, rew_alt(tok)))
a652 2
		mdoc->next = MDOC_NEXT_CHILD;
	}
d658 1
a658 1
			if ( ! rew_expblock(mdoc, tok, line, ppos))
d663 1
a663 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d672 1
a672 1
		if (MDOC_MAX != (c = lookup(mdoc, tok, p))) {
d674 1
a674 2
				if ( ! rew_expblock(mdoc, tok, 
							line, ppos))
d678 1
a678 1
			if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d683 1
a683 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d687 1
a687 1
	if ( ! flushed && ! rew_expblock(mdoc, tok, line, ppos))
d692 1
a692 1
	return(append_delims(mdoc, line, pos, buf));
a695 3
/*
 * In-line macros where reserved words cause scope close-reopen.
 */
d728 1
a728 1
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d745 1
a745 1
		w = mdoc_args(mdoc, line, pos, buf, tok, &p);
d756 1
a756 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(mdoc, tok, p);
d766 1
a766 1
			if (0 == lastpunct && ! rew_elem(mdoc, tok))
d769 1
a769 2
				if ( ! mdoc_elem_alloc(mdoc, line, ppos, 
							tok, arg))
d771 1
a771 1
				if ( ! rew_last(mdoc, mdoc->last))
d775 1
a775 1
				if ( ! mdoc_pwarn(mdoc, line, ppos, EIGNE))
d778 1
a778 1
			c = mdoc_macro(mdoc, c, line, la, pos, buf);
d783 1
a783 1
			return(append_delims(mdoc, line, pos, buf));
d795 1
a795 1
			if (0 == lastpunct && ! rew_elem(mdoc, tok))
d799 1
a799 2
			c = mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
			if (0 == c)
a800 1
			mdoc->next = MDOC_NEXT_CHILD;
d806 1
a806 1
		if ( ! mdoc_word_alloc(mdoc, line, la, p))
d810 1
a810 1
	if (0 == lastpunct && ! rew_elem(mdoc, tok))
d820 1
a820 2
		c = mdoc_elem_alloc(mdoc, line, ppos, tok, arg);
		if (0 == c)
d822 1
a822 1
		if ( ! rew_last(mdoc, mdoc->last))
d826 1
a826 1
		if ( ! mdoc_pwarn(mdoc, line, ppos, EIGNE))
d832 1
a832 1
	return(append_delims(mdoc, line, pos, buf));
a835 3
/*
 * Block full-explicit and full-implicit.
 */
d860 1
a860 2
		if ( ! rew_subblock(MDOC_BODY, mdoc, 
					tok, line, ppos))
d862 1
a862 1
		if ( ! rew_impblock(mdoc, tok, line, ppos))
d868 1
a868 1
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d884 1
a884 1
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, arg))
a885 1
	mdoc->next = MDOC_NEXT_CHILD;
d888 1
a888 1
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d890 1
a890 2
		if ( ! rew_subblock(MDOC_HEAD, mdoc, 
					tok, line, ppos))
d892 1
a892 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a893 1
		mdoc->next = MDOC_NEXT_CHILD;
d897 1
a897 1
	if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d903 1
a903 1
		if ( ! rew_subblock(MDOC_HEAD, mdoc, tok, line, ppos))
d905 1
a905 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a908 2
	mdoc->next = MDOC_NEXT_CHILD;

d911 1
a911 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d919 1
a919 2
			if (reopen && ! mdoc_head_alloc
					(mdoc, line, ppos, tok))
a920 1
			mdoc->next = MDOC_NEXT_CHILD;
d926 1
a926 1
			if ( ! phrase(mdoc, line, lastarg, buf))
d928 1
a928 2
			if ( ! rew_subblock(MDOC_HEAD, mdoc, 
						tok, line, ppos))
d935 2
a936 2
		if (MDOC_MAX == (c = lookup(mdoc, tok, p))) {
			if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d941 1
a941 1
		if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d946 1
a946 1
	if (1 == ppos && ! append_delims(mdoc, line, pos, buf))
d953 1
a953 1
	if ( ! rew_subblock(MDOC_HEAD, mdoc, tok, line, ppos))
d955 1
a955 1
	if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a956 1
	mdoc->next = MDOC_NEXT_CHILD;
a961 3
/*
 * Block partial-imnplicit scope.
 */
d965 1
a965 1
	int		  lastarg, c;
d969 7
a975 1
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
d977 1
a977 4
	mdoc->next = MDOC_NEXT_CHILD;
	blk = mdoc->last;

	if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d979 1
a979 3
	mdoc->next = MDOC_NEXT_SIBLING;

	if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
d981 2
a982 2
	mdoc->next = MDOC_NEXT_CHILD;
	body = mdoc->last;
d984 1
a984 1
	/* XXX - no known argument macros. */
d987 2
a988 2
		lastarg = *pos;
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d998 2
a999 2
		if (MDOC_MAX == (c = lookup(mdoc, tok, p))) {
			if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d1004 1
a1004 1
		if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d1009 5
a1013 4
	/*
	 * Since we know what our context is, we can rewind directly to
	 * it.  This allows us to accomodate for our scope being
	 * violated by another token.
d1015 1
a1015 2

	for (n = mdoc->last; n; n = n->parent)
d1018 4
d1023 1
a1023 2
	if (NULL == n && ! mdoc_nwarn(mdoc, body, EIMPBRK))
			return(0);
d1025 1
a1025 1
	if (n && ! rew_last(mdoc, body))
d1028 1
a1028 2
	if (1 == ppos && ! append_delims(mdoc, line, pos, buf))
		return(0);
d1030 1
a1030 1
	if (n && ! rew_last(mdoc, blk))
a1036 3
/*
 * Block partial-explicit macros.
 */
d1040 1
a1040 1
	int		  lastarg, flushed, j, c, maxargs;
d1043 1
a1043 5
	flushed = 0;

	/*
	 * Number of arguments (head arguments).  Only `Eo' has these,
	 */
d1054 3
a1056 1
	if ( ! mdoc_block_alloc(mdoc, line, ppos, tok, NULL))
d1058 6
a1063 1
	mdoc->next = MDOC_NEXT_CHILD;
d1066 1
a1066 1
		if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
d1068 1
a1068 2
		if ( ! rew_subblock(MDOC_HEAD, mdoc, 
					tok, line, ppos))
d1070 1
a1070 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
d1073 5
a1077 2
	} else if ( ! mdoc_head_alloc(mdoc, line, ppos, tok))
		return(0);
d1079 1
a1079 1
	mdoc->next = MDOC_NEXT_CHILD;
d1082 1
a1082 1
		lastarg = *pos;
d1084 1
a1084 2
			if ( ! rew_subblock(MDOC_HEAD, mdoc, 
						tok, line, ppos))
d1087 1
a1087 1
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a1088 1
			mdoc->next = MDOC_NEXT_CHILD;
d1091 1
a1091 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d1101 1
a1101 1
		if (MDOC_MAX != (c = lookup(mdoc, tok, p))) {
d1103 1
a1103 2
				if ( ! rew_subblock(MDOC_HEAD, mdoc, 
							tok, line, ppos))
d1106 1
a1106 2
				if ( ! mdoc_body_alloc(mdoc, line, 
							ppos, tok))
a1107 1
				mdoc->next = MDOC_NEXT_CHILD;
d1109 1
a1109 2
			if ( ! mdoc_macro(mdoc, c, line, lastarg, 
						pos, buf))
d1115 1
a1115 2
			if ( ! rew_subblock(MDOC_HEAD, mdoc, 
						tok, line, ppos))
d1118 1
a1118 1
			if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a1119 1
			mdoc->next = MDOC_NEXT_CHILD;
d1122 1
a1122 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d1126 2
d1129 1
a1129 1
		if ( ! rew_subblock(MDOC_HEAD, mdoc, tok, line, ppos))
d1131 1
a1131 1
		if ( ! mdoc_body_alloc(mdoc, line, ppos, tok))
a1132 1
		mdoc->next = MDOC_NEXT_CHILD;
d1135 2
d1139 1
a1139 1
	return(append_delims(mdoc, line, pos, buf));
a1142 4
/*
 * In-line macros where reserved words signal closure of the macro.
 * Macros also have a fixed number of arguments.
 */
d1146 1
a1146 1
	int		  lastarg, flushed, j, c, maxargs;
d1150 1
a1150 5
	
	/* 
	 * Fixed maximum arguments per macro.  Some of these have none
	 * and close as soon as the invocation is parsed.
	 */
d1167 2
d1170 2
a1171 2
		lastarg = *pos;
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d1174 1
a1174 1
			*pos = lastarg;
d1187 3
a1189 1
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
d1191 2
a1192 1
	mdoc->next = MDOC_NEXT_CHILD;
d1195 1
a1195 1
		lastarg = *pos;
d1198 1
a1198 1
			if ( ! rew_elem(mdoc, tok))
d1203 1
a1203 1
		c = mdoc_args(mdoc, line, pos, buf, tok, &p);
d1212 2
a1213 2
		if (MDOC_MAX != (c = lookup(mdoc, tok, p))) {
			if ( ! flushed && ! rew_elem(mdoc, tok))
d1216 1
a1216 1
			if ( ! mdoc_macro(mdoc, c, line, lastarg, pos, buf))
d1223 1
a1223 1
			if ( ! rew_elem(mdoc, tok))
d1228 1
a1228 1
		if ( ! mdoc_word_alloc(mdoc, line, lastarg, p))
d1232 3
a1234 1
	if ( ! flushed && ! rew_elem(mdoc, tok))
d1239 1
a1239 1
	return(append_delims(mdoc, line, pos, buf));
a1242 4
/*
 * In-line macro that spans an entire line.  May be callable, but has no
 * subsequent parsed arguments.
 */
d1252 1
a1252 1
	arg = NULL;
d1254 1
a1254 1
	for (;;) {
d1256 1
a1256 1
		c = mdoc_argv(mdoc, line, tok, &arg, pos, buf);
d1271 3
a1273 1
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
d1276 1
a1276 1
	mdoc->next = MDOC_NEXT_CHILD;
d1280 1
a1280 1
		w = mdoc_args(mdoc, line, pos, buf, tok, &p);
d1287 1
a1287 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup(mdoc, tok, p);
d1290 1
a1290 1
			if ( ! rew_elem(mdoc, tok))
d1292 1
a1292 1
			return(mdoc_macro(mdoc, c, line, la, pos, buf));
d1295 1
a1295 1
		if ( ! mdoc_word_alloc(mdoc, line, la, p))
d1299 3
a1301 1
	return(rew_elem(mdoc, tok));
d1310 1
a1310 1
	return(mdoc_pwarn(mdoc, line, ppos, EOBS));
d1320 1
a1320 1
phrase(struct mdoc *mdoc, int line, int ppos, char *buf)
d1329 1
a1329 1
		w = mdoc_zargs(mdoc, line, &pos, buf, &p);
d1336 1
a1336 1
		c = ARGS_QWORD == w ? MDOC_MAX : lookup_raw(mdoc, p);
d1339 1
a1339 1
			if ( ! mdoc_macro(mdoc, c, line, la, &pos, buf))
d1341 1
a1341 1
			return(append_delims(mdoc, line, &pos, buf));
d1344 1
a1344 1
		if ( ! mdoc_word_alloc(mdoc, line, la, p))
@


1.30
log
@Noted areas that need work in libmdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.29 2009/07/29 08:52:24 kristaps Exp $ */
a647 1
		mdoc->next = MDOC_NEXT_SIBLING;
a723 1
		mdoc->next = MDOC_NEXT_SIBLING;
a852 1
		mdoc->next = MDOC_NEXT_SIBLING;
a995 1
			mdoc->next = MDOC_NEXT_SIBLING;
a1061 1
			mdoc->next = MDOC_NEXT_SIBLING;
a1188 1
		mdoc->next = MDOC_NEXT_SIBLING;
a1294 1
		mdoc->next = MDOC_NEXT_SIBLING;
a1361 1
		mdoc->next = MDOC_NEXT_SIBLING;
a1408 1
		mdoc->next = MDOC_NEXT_SIBLING;
@


1.29
log
@Columns with `Bl -column' correctly check for CALLABLE status.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.28 2009/07/29 08:46:06 kristaps Exp $ */
d48 1
a48 1
static	int	  rew_last(struct mdoc *, struct mdoc_node *);
d602 1
@


1.28
log
@Moved CALLABLE check to lookup_raw().
Made PARSABLE check occur prior to lookup().
Non-PARSEABLE macros no longer warn against having macro-like parameters.
Non-CALLABLE macros no longer produce an error, just display their symbols (as in groff) (pointed out by joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.27 2009/07/25 16:03:03 kristaps Exp $ */
d710 1
a710 3
		if (-1 == (c = lookup(mdoc, tok, p)))
			return(0);
		else if (MDOC_MAX != c) {
d808 1
a808 1
		if (MDOC_MAX != c && -1 != c) {
d828 1
a828 2
		} else if (-1 == c)
			return(0);
d995 1
a995 4
		if (-1 == (c = lookup(mdoc, tok, p)))
			return(0);

		if (MDOC_MAX == c) {
d1062 1
a1062 3
		if (-1 == (c = lookup(mdoc, tok, p)))
			return(0);
		else if (MDOC_MAX == c) {
d1164 1
a1164 3
		if (-1 == (c = lookup(mdoc, tok, p)))
			return(0);
		else if (MDOC_MAX != c) {
d1282 1
a1282 3
		if (-1 == (c = lookup(mdoc, tok, p)))
			return(0);
		else if (MDOC_MAX != c) {
d1360 1
a1360 1
		if (MDOC_MAX != c && -1 != c) {
d1364 1
a1364 2
		} else if (-1 == c)
			return(0);
d1406 1
a1406 2
		c = ARGS_QWORD == w ? MDOC_MAX :
			mdoc_hash_find(mdoc->htab, p);
d1408 1
a1408 1
		if (MDOC_MAX != c && -1 != c) {
d1412 1
a1412 2
		} else if (-1 == c)
			return(0);
@


1.27
log
@Patches and results of LLVM static analysis (thanks uqs@@sporlein.net).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.26 2009/07/24 12:17:25 kristaps Exp $ */
d50 2
a51 1
static	int	  lookup(struct mdoc *, int, int, int, const char *);
d257 11
a267 1
lookup(struct mdoc *mdoc, int line, int pos, int from, const char *p)
d271 3
a273 4
	res = mdoc_hash_find(mdoc->htab, p);
	if (MDOC_PARSED & mdoc_macros[from].flags)
		return(res);
	if (MDOC_MAX == res)
a274 2
	if ( ! mdoc_pwarn(mdoc, line, pos, EMACPARM))
		return(-1);
d710 1
a710 1
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
d801 1
a801 2
		c = ARGS_QWORD == w ? MDOC_MAX :
			lookup(mdoc, line, la, tok, p);
d998 1
a998 1
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
d1068 1
a1068 1
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
d1172 1
a1172 1
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
d1292 1
a1292 1
		if (-1 == (c = lookup(mdoc, line, lastarg, tok, p)))
d1370 1
a1370 2
		c = ARGS_QWORD == w ? MDOC_MAX :
			lookup(mdoc, line, la, tok, p);
@


1.26
log
@Allow `An' to accept NULL arguments (-split/-nosplit).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.25 2009/07/21 15:53:47 kristaps Exp $ */
d684 1
a684 1
	for (lastarg = ppos, flushed = j = 0; ; j++) {
d763 1
a763 1
	for (la = ppos, arg = NULL;; ) {
d1049 1
a1049 1
	for (lastarg = ppos;; ) {
a1109 1
	lastarg = ppos;
d1245 1
a1245 1
	for (lastarg = ppos, arg = NULL;; ) {
@


1.25
log
@Noted that `Pa' can accept 0 arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.24 2009/07/19 21:26:27 kristaps Exp $ */
d745 3
a747 1
	case (MDOC_Nm):
d753 2
a755 2
		/* FALLTHROUGH */
	case (MDOC_Ar):
@


1.24
log
@Fixed and cleaned up "phrase" handling (`Bl -column' columns).
Found strange newline bug in -diag handling (and others?).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.23 2009/07/19 09:17:42 kristaps Exp $ */
d751 2
@


1.23
log
@Made `Cd' parseable (too many SYNOPSIS sections do this).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.22 2009/07/19 08:28:48 kristaps Exp $ */
d1388 5
d1396 2
a1397 1
	int		 i, la, c, quoted;
d1399 2
a1400 7
	/*
	 * Parse over words in a phrase.  We have to handle this
	 * specially because we assume no calling context -- in normal
	 * circumstances, we switch argument parsing based on whether
	 * the parent macro accepts quotes, tabs, etc.  Here, anything
	 * goes.
	 */
d1402 2
a1403 4
	for (i = ppos; buf[i]; ) {
		assert(' ' != buf[i]);
		la = i;
		quoted = 0;
d1405 4
a1408 5
		/* 
		 * Read to next token.  If quoted (check not escaped),
		 * scan ahead to next unescaped quote.  If not quoted or
		 * escape-quoted, then scan ahead to next space.
		 */
d1410 2
a1411 19
		if ((i && '\"' == buf[i] && '\\' != buf[i - 1]) || 
				(0 == i && '\"' == buf[i])) {
			for (la = ++i; buf[i]; i++) 
				if ('\"' != buf[i])
					continue;
				else if ('\\' != buf[i - 1])
					break;
			if (0 == buf[i]) 
				return(mdoc_perr(mdoc, line, la, EQUOTPHR));
			quoted = 1;
		} else
			for ( ; buf[i]; i++)
				if (i && ' ' == buf[i]) {
					if ('\\' != buf[i - 1])
						break;
				} else if (' ' == buf[i])
					break;

		/* If not end-of-line, terminate argument. */
d1413 2
a1414 18
		if (buf[i])
			buf[i++] = 0;

		/* Read to next argument. */

		for ( ; buf[i] && ' ' == buf[i]; i++)
			/* Spin. */ ;

		/* 
		 * If we're a non-quoted string, try to look up the
		 * value as a macro and execute it, if found.
		 */

		c = quoted ? MDOC_MAX :
			mdoc_hash_find(mdoc->htab, &buf[la]);

		if (MDOC_MAX != c) {
			if ( ! mdoc_macro(mdoc, c, line, la, &i, buf))
d1416 3
a1418 2
			return(append_delims(mdoc, line, &i, buf));
		}
d1420 1
a1420 3
		/* A regular word or quoted string. */

		if ( ! mdoc_word_alloc(mdoc, line, la, &buf[la]))
d1427 2
@


1.22
log
@Explicit-close macros now only warn when encountering trailing terms, not
error out (try `.Ed foo').
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.21 2009/07/17 12:08:08 kristaps Exp $ */
d74 1
a74 1
	{ in_line_eoln, MDOC_CALLABLE }, /* Cd */
@


1.21
log
@Documented `br' macro in mdoc.7.
Made `Pp' and `Lp' be inline_eoln() (not sure why they weren't before).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.20 2009/07/17 10:56:57 kristaps Exp $ */
d665 2
a666 3
		if (0 == buf[*pos]) {
			if ( ! rew_subblock(MDOC_BODY, mdoc, 
						tok, line, ppos))
d668 4
a671 3
			return(rew_expblock(mdoc, tok, line, ppos));
		}
		return(mdoc_perr(mdoc, line, ppos, ENOLINE));
@


1.20
log
@Added `br' and `sp' macros (requested by joerg@@netbsd.org, jmc@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.19 2009/07/12 16:34:16 kristaps Exp $ */
d63 1
a63 1
	{ in_line, 0 }, /* Pp */ 
d164 1
a164 1
	{ in_line, 0 }, /* Lp */ 
a744 4
	case (MDOC_Lp):
		/* FALLTHROUGH */
	case (MDOC_Pp):
		/* FALLTHROUGH */
@


1.19
log
@`Nd' is now a BFI (was an ELEM).  Noted by joerg@@netbsd.org, behaviour ok jmc@@openbsd.org, etc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.18 2009/07/07 11:47:17 kristaps Exp $ */
d175 2
@


1.18
log
@Made `In' handling work in new-groff style (see mdoc.samples).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.17 2009/07/07 09:29:15 kristaps Exp $ */
d88 1
a88 1
	{ in_line_eoln, 0 }, /* Nd */ 
d389 2
d496 2
d501 2
d884 1
a884 1
	int		  c, lastarg, reopen;
d888 16
d948 10
d969 1
d1006 5
a1012 1

@


1.17
log
@Tabularised error-code lookup in mdoc.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.16 2009/07/06 13:04:52 kristaps Exp $ */
d86 1
a86 1
	{ in_line_eoln, 0 }, /* In */  /* FIXME: historic usage! */
@


1.16
log
@Consolidated all err/warnings into mdoc.c via libmdoc.h.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.15 2009/07/06 09:21:24 kristaps Exp $ */
d663 1
a663 1
		return(mdoc_perr(mdoc, line, ppos, ENOPARMS));
d1385 1
a1385 1
				return(mdoc_perr(mdoc, line, la, EQUOT));
@


1.15
log
@Initial removal of enum mdoc_warn from mdoc warnings (unnecessary complication).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.14 2009/06/17 19:02:26 kristaps Exp $ */
a24 14
enum	mwarn {
	WIGNE,
	WIMPBRK,
	WMACPARM,
	WOBS
};

enum	merr {
	EOPEN,
	EQUOT,
	ENOCTX,
	ENOPARMS
};

a50 2
static	int	  pwarn(struct mdoc *, int, int, enum mwarn);
static	int	  perr(struct mdoc *, int, int, enum merr);
a53 2
#define	nerr(m, n, t) perr((m), (n)->line, (n)->pos, (t))

a180 50
perr(struct mdoc *mdoc, int line, int pos, enum merr type)
{
	char		*p;

	p = NULL;
	switch (type) {
	case (EOPEN):
		p = "explicit scope still open on exit";
		break;
	case (EQUOT):
		p = "unterminated quotation";
		break;
	case (ENOCTX):
		p = "closure has no prior context";
		break;
	case (ENOPARMS):
		p = "unexpect line arguments";
		break;
	}
	assert(p);
	return(mdoc_perr(mdoc, line, pos, p));
}


static int
pwarn(struct mdoc *mdoc, int line, int pos, enum mwarn type)
{
	char		*p;

	p = NULL;
	switch (type) {
	case (WIGNE):
		p = "ignoring empty element";
		break;
	case (WIMPBRK):
		p = "crufty end-of-line scope violation";
		break;
	case (WMACPARM):
		p = "macro-like parameter";
		break;
	case (WOBS):
		p = "macro marked obsolete";
		break;
	}
	assert(p);
	return(mdoc_pwarn(mdoc, line, pos, p));
}


static int
d218 1
a218 1
		return(mdoc_perr(mdoc, line, pos, 
d221 1
a221 1
	return(mdoc_pwarn(mdoc, line, pos, 
d247 1
a247 1
		return(nerr(mdoc, n, EOPEN));
d263 1
a263 1
	if ( ! pwarn(mdoc, line, pos, WMACPARM))
d572 1
a572 1
			return(perr(mdoc, line, ppos, ENOCTX));
d663 1
a663 1
		return(perr(mdoc, line, ppos, ENOPARMS));
d806 1
a806 1
				if ( ! pwarn(mdoc, line, ppos, WIGNE))
d862 1
a862 1
		if ( ! pwarn(mdoc, line, ppos, WIGNE))
d1046 1
a1046 1
	if (NULL == n && ! pwarn(mdoc, body->line, body->pos, WIMPBRK))
d1349 1
a1349 1
	return(pwarn(mdoc, line, ppos, WOBS));
d1385 1
a1385 1
				return(perr(mdoc, line, la, EQUOT));
@


1.14
log
@Removed superfluous FIXMEs (fixed already).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.13 2009/06/16 19:45:51 kristaps Exp $ */
d244 1
a244 1
	return(mdoc_pwarn(mdoc, line, pos, WARN_SYNTAX, p));
d289 1
a289 1
	return(mdoc_pwarn(mdoc, line, pos, WARN_SYNTAX,
@


1.13
log
@Removed MDOC___: moved MDOC_Ap to its index (comments not passed into mdoc parser).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.12 2009/06/12 09:18:00 kristaps Exp $ */
a24 2
/* FIXME: .Fl, .Ar, .Cd handling of `|'. */

@


1.12
log
@`Lk' is correctly handled as CALLABLE (note groff munges nested output).
`Mt' is now CALLABLE.
Fixed missing validate/action of zero-element, non-called inline elements.
Fixed missing validate/action of nested inline element re-calls.
Fixed bogus column argv index in validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.11 2009/06/11 20:02:37 kristaps Exp $ */
d77 1
a77 1
	{ NULL, 0 }, /* \" */
a183 1
	{ in_line_argn, MDOC_CALLABLE | MDOC_PARSED }, /* Ap */
@


1.11
log
@`Ft' and `Ms' are now callable and compat-noted in mdoc.7 (joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.10 2009/06/11 19:56:14 kristaps Exp $ */
d186 2
a187 2
	{ in_line, MDOC_PARSED }, /* Lk */ 
	{ in_line, MDOC_PARSED }, /* Mt */ 
d816 2
d873 2
a874 1
				mdoc->next = MDOC_NEXT_SIBLING;
d929 2
a930 1
		mdoc->next = MDOC_NEXT_SIBLING;
@


1.10
log
@`An' now callable, historic use noted in mdoc.7 (joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.9 2009/06/10 20:18:43 kristaps Exp $ */
d104 1
a104 1
	{ in_line, MDOC_PARSED }, /* Ft */ 
d106 1
a106 1
	{ in_line_eoln, 0 }, /* In */ 
d148 1
a148 1
	{ in_line, MDOC_PARSED }, /* Ms */
@


1.9
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.8 2009/04/12 19:45:26 kristaps Exp $ */
d92 1
a92 1
	{ in_line, MDOC_PARSED }, /* An */
@


1.8
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: mdoc_macro.c,v 1.7 2009/04/12 19:19:57 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.7
log
@Manual .Dt fields CAPITALISED.
Indent set to 5 chars (nroff compat).
Half-indent set to 3 chars (nroff compat).
Default behaviour is loose-y (ignore macro/char/escape).
Added -fstrict.
Added unknown-character ignoring.
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.6 2009/04/02 06:51:44 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.6
log
@mdoc_tokhash -> hash
Initial man hashtab (BROKEN).
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.5 2009/03/31 13:50:19 kristaps Exp $ */
d874 2
a875 1
			} else if ( ! nc && 0 == cnt)
d878 1
d929 2
a930 1
	} else if ( ! nc && 0 == cnt) 
d933 1
@


1.5
log
@General clean-ups.
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.4 2009/03/27 14:56:15 kristaps Exp $ */
d331 1
a331 1
	res = mdoc_tokhash_find(mdoc->htab, p);
d1476 1
a1476 1
			mdoc_tokhash_find(mdoc->htab, &buf[la]);
@


1.4
log
@Added some new manuals (mdoc.3 mandoc_char.7).
Support for .br in libman.
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.3 2009/03/27 13:44:24 kristaps Exp $ */
a26 6
/*
 * This has scanning/parsing routines, each of which extract a macro and
 * its arguments and parameters, then know how to progress to the next
 * macro. 
 */

@


1.3
log
@Fixes in going over all OpenBSD manuals.
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.2 2009/03/23 15:41:09 kristaps Exp $ */
d36 1
d241 3
d807 1
a807 1
	int		  la, lastpunct, c, w, cnt, d, call;
d811 21
d849 1
a849 1
	for (call = cnt = 0, lastpunct = 1;; ) {
d865 6
a870 1
		/* MDOC_MAX (not a macro) or -1 (error). */
d875 1
a875 1
			if (0 == cnt) {
d879 3
a881 1
				if ( ! rew_elem(mdoc, tok))
a882 2
				mdoc->next = MDOC_NEXT_SIBLING;
			}
d892 5
a896 1
		/* Non-quote-enclosed punctuation. */
d921 8
a928 1
	if (0 == cnt) {
d932 3
a934 1
		if ( ! rew_elem(mdoc, tok))
d936 1
a936 1
	}
@


1.2
log
@-man linked to mandoc in documentation.
@
text
@d1 1
a1 1
/* $Id: mdoc_macro.c,v 1.1 2009/03/23 14:22:11 kristaps Exp $ */
d803 1
a803 1
	int		  la, lastpunct, c, w;
a814 1

d824 1
a824 5
	if ( ! mdoc_elem_alloc(mdoc, line, ppos, tok, arg))
		return(0);
	mdoc->next = MDOC_NEXT_CHILD;

	for (lastpunct = 0;; ) {
d845 8
d864 3
a866 1
		if (ARGS_QWORD != w && mdoc_isdelim(p)) {
a871 1

a873 1

d878 2
d887 7
@


1.1
log
@First addition of -man macro support.
Abstraction of mdoc.
@
text
@d1 1
a1 1
/* $Id: macro.c,v 1.77 2009/03/22 19:01:11 kristaps Exp $ */
d308 1
a308 1
macro_end(struct mdoc *mdoc)
a311 3
	assert(mdoc->first);
	assert(mdoc->last);

@
