head	1.255;
access;
symbols
	VERSION_1_13_3:1.245
	VERSION_1_13_2:1.237
	VERSION_1_12_4:1.228
	VERSION_1_13_1:1.226
	VERSION_1_12_3:1.214
	VERSION_1_12_2:1.210
	VERSION_1_12:1.228.0.2
	VERSION_1_12_1:1.201
	VERSION_1_12_0:1.201
	VERSION_1_11_7:1.197
	VERSION_1_11_6:1.197
	VERSION_1_11_5:1.197
	VERSION_1_11_4:1.197
	VERSION_1_11_3:1.197
	VERSION_1_11_2:1.186
	VERSION_1_11_1:1.183
	VERSION_1_10_10:1.180
	VERSION_1_10_9:1.176
	VERSION_1_10_8:1.175
	VERSION_1_10_7:1.175
	VERSION_1_10_6:1.172
	VERSION_1_10_5:1.166
	VERSION_1_10_5_PREPDF:1.163
	VERSION_1_10_4:1.160
	VERSION_1_10_3:1.154
	VERSION_1_10_2:1.148
	VERSION_1_10_1:1.144
	VERSION_1_9_24:1.132
	VERSION_1_9_25:1.133
	VERSION_1_9_23:1.130
	VERSION_1_9_22:1.129
	VERSION_1_9_21:1.129
	VERSION_1_9_20:1.129
	VERSION_1_9_19:1.129
	VERSION_1_9_18:1.129
	VERSION_1_9_17:1.129
	VERSION_1_9_16:1.128
	VERSION_1_9_15:1.128
	VERSION_1_9_15-pre2:1.128
	VERSION_1_9_15-pre1:1.127
	VERSION_1_9_14:1.127
	VERSION_1_9_13:1.120
	VERSION_1_9_12:1.120
	VERSION_1_9_11:1.112
	VERSION_1_9_10:1.112
	VERSION_1_9_9:1.108
	VERSION_1_9_8:1.104
	VERSION_1_9_7:1.103
	VERSION_1_9_6:1.103
	VERSION_1_9_5:1.102
	VERSION_1_9_2:1.97
	VERSION_1_9_1:1.97
	VERSION_1_9_0:1.97
	VERSION_1_8_5:1.97
	VERSION_1_8_4:1.93
	VERSION_1_8_3:1.92
	VERSION_1_8_2:1.90
	VERSION_1_8_1:1.89
	VERSION_1_8_0:1.85
	VERSION_1_7_24:1.83
	VERSION_1_7_23:1.83
	VERSION_1_7_22:1.83
	VERSION_1_7_21:1.83
	VERSION_1_7_20:1.83
	VERSION_1_7_19:1.79
	VERSION_1_7_17:1.78
	VERSION_1_7_16:1.78
	VERSION_1_7_15:1.78
	VERSION_1_7_14:1.78
	VERSION_1_7_13:1.74
	VERSION_1_7_12:1.73
	OPENBSD_CHECKIN:1.73
	VERSION_1_7_10:1.73
	VERSION_1_6_5:1.64
	VERSION_1_6_2:1.62
	VERSION_1_5_3:1.61
	VERSION_1_5_1:1.59
	VERSION_1_4_6:1.50
	VERSION_1_4_5:1.50
	VERSION_1_4_4:1.49
	VERSION_1_4_2:1.47
	VERSION_1_3_15:1.33
	VERSION_1_3_13:1.31
	VERSION_1_3_11:1.27
	VERSION_1_3_10:1.27
	VERSION_1_3_9:1.27
	VERSION_1_3_8:1.27
	VERSION_1_3_6:1.27
	VERSION_1_3_5:1.19;
locks; strict;
comment	@ * @;


1.255
date	2015.10.23.14.50.58;	author schwarze;	state Exp;
branches;
next	1.254;

1.254
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.253;

1.253
date	2015.10.12.00.08.16;	author schwarze;	state Exp;
branches;
next	1.252;

1.252
date	2015.10.06.18.32.20;	author schwarze;	state Exp;
branches;
next	1.251;

1.251
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.250;

1.250
date	2015.09.21.13.25.00;	author schwarze;	state Exp;
branches;
next	1.249;

1.249
date	2015.08.30.21.10.56;	author schwarze;	state Exp;
branches;
next	1.248;

1.248
date	2015.04.29.18.35.00;	author schwarze;	state Exp;
branches;
next	1.247;

1.247
date	2015.04.04.17.47.18;	author schwarze;	state Exp;
branches;
next	1.246;

1.246
date	2015.04.02.23.48.20;	author schwarze;	state Exp;
branches;
next	1.245;

1.245
date	2015.03.06.13.02.43;	author schwarze;	state Exp;
branches;
next	1.244;

1.244
date	2015.01.31.00.12.41;	author schwarze;	state Exp;
branches;
next	1.243;

1.243
date	2015.01.21.20.33.25;	author schwarze;	state Exp;
branches;
next	1.242;

1.242
date	2014.12.24.23.32.42;	author schwarze;	state Exp;
branches;
next	1.241;

1.241
date	2014.12.24.09.58.35;	author schwarze;	state Exp;
branches;
next	1.240;

1.240
date	2014.12.23.13.48.57;	author schwarze;	state Exp;
branches;
next	1.239;

1.239
date	2014.12.23.06.16.46;	author schwarze;	state Exp;
branches;
next	1.238;

1.238
date	2014.12.19.17.12.04;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2014.12.02.10.08.06;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2014.11.21.01.52.53;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2014.11.16.21.29.35;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2014.11.01.04.03.49;	author schwarze;	state Exp;
branches;
next	1.233;

1.233
date	2014.10.29.00.17.43;	author schwarze;	state Exp;
branches;
next	1.232;

1.232
date	2014.10.28.18.49.33;	author schwarze;	state Exp;
branches;
next	1.231;

1.231
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.230;

1.230
date	2014.10.27.13.31.04;	author schwarze;	state Exp;
branches;
next	1.229;

1.229
date	2014.10.26.17.12.03;	author schwarze;	state Exp;
branches;
next	1.228;

1.228
date	2014.08.18.21.07.53;	author kristaps;	state Exp;
branches;
next	1.227;

1.227
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.226;

1.226
date	2014.08.01.19.38.29;	author schwarze;	state Exp;
branches;
next	1.225;

1.225
date	2014.08.01.19.25.52;	author schwarze;	state Exp;
branches;
next	1.224;

1.224
date	2014.07.06.18.51.13;	author schwarze;	state Exp;
branches;
next	1.223;

1.223
date	2014.04.23.21.06.41;	author schwarze;	state Exp;
branches;
next	1.222;

1.222
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.221;

1.221
date	2014.04.08.07.13.12;	author schwarze;	state Exp;
branches;
next	1.220;

1.220
date	2014.04.05.21.18.19;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2014.03.30.21.28.01;	author schwarze;	state Exp;
branches;
next	1.218;

1.218
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2014.03.13.19.23.50;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2014.01.22.20.58.39;	author schwarze;	state Exp;
branches;
next	1.215;

1.215
date	2013.12.31.18.07.42;	author schwarze;	state Exp;
branches;
next	1.214;

1.214
date	2013.12.25.00.39.31;	author schwarze;	state Exp;
branches;
next	1.213;

1.213
date	2013.12.24.23.04.36;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2013.12.23.02.20.09;	author schwarze;	state Exp;
branches;
next	1.211;

1.211
date	2013.12.22.23.34.13;	author schwarze;	state Exp;
branches;
next	1.210;

1.210
date	2013.08.21.21.20.40;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2013.08.08.20.07.47;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2013.08.05.23.36.42;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2013.05.29.15.17.52;	author schwarze;	state Exp;
branches;
next	1.206;

1.206
date	2012.11.16.17.16.55;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2012.07.16.21.30.42;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2012.07.10.15.35.41;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2012.05.31.22.29.13;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2012.05.27.18.02.49;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2011.09.21.09.57.13;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2011.09.19.22.36.16;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2011.09.18.21.18.19;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2011.09.18.14.14.15;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2011.05.24.21.31.23;	author kristaps;	state Exp;
branches;
next	1.196;

1.196
date	2011.05.20.15.44.55;	author kristaps;	state Exp;
branches;
next	1.195;

1.195
date	2011.05.18.23.59.08;	author kristaps;	state Exp;
branches;
next	1.194;

1.194
date	2011.05.17.22.32.45;	author kristaps;	state Exp;
branches;
next	1.193;

1.193
date	2011.05.17.14.38.34;	author kristaps;	state Exp;
branches;
next	1.192;

1.192
date	2011.05.17.11.55.08;	author kristaps;	state Exp;
branches;
next	1.191;

1.191
date	2011.05.15.22.29.50;	author kristaps;	state Exp;
branches;
next	1.190;

1.190
date	2011.05.15.15.47.46;	author kristaps;	state Exp;
branches;
next	1.189;

1.189
date	2011.05.15.14.50.01;	author kristaps;	state Exp;
branches;
next	1.188;

1.188
date	2011.05.14.18.15.20;	author kristaps;	state Exp;
branches;
next	1.187;

1.187
date	2011.05.14.17.54.42;	author kristaps;	state Exp;
branches;
next	1.186;

1.186
date	2011.04.30.22.24.31;	author kristaps;	state Exp;
branches;
next	1.185;

1.185
date	2011.04.29.22.18.12;	author kristaps;	state Exp;
branches;
next	1.184;

1.184
date	2011.04.09.15.29.40;	author kristaps;	state Exp;
branches;
next	1.183;

1.183
date	2011.04.04.21.14.12;	author kristaps;	state Exp;
branches;
next	1.182;

1.182
date	2011.03.22.14.05.45;	author kristaps;	state Exp;
branches;
next	1.181;

1.181
date	2011.03.22.10.13.01;	author kristaps;	state Exp;
branches;
next	1.180;

1.180
date	2011.03.17.09.16.38;	author kristaps;	state Exp;
branches;
next	1.179;

1.179
date	2011.03.17.08.49.34;	author kristaps;	state Exp;
branches;
next	1.178;

1.178
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.177;

1.177
date	2011.01.30.16.05.37;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2011.01.04.13.14.26;	author kristaps;	state Exp;
branches;
next	1.175;

1.175
date	2010.12.06.13.25.25;	author kristaps;	state Exp;
branches;
next	1.174;

1.174
date	2010.10.02.15.15.55;	author schwarze;	state Exp;
branches;
next	1.173;

1.173
date	2010.10.01.21.51.13;	author schwarze;	state Exp;
branches;
next	1.172;

1.172
date	2010.09.23.20.26.00;	author schwarze;	state Exp;
branches;
next	1.171;

1.171
date	2010.09.15.14.36.16;	author kristaps;	state Exp;
branches;
next	1.170;

1.170
date	2010.09.04.20.18.53;	author kristaps;	state Exp;
branches;
next	1.169;

1.169
date	2010.08.20.23.34.02;	author schwarze;	state Exp;
branches;
next	1.168;

1.168
date	2010.08.20.23.22.09;	author schwarze;	state Exp;
branches;
next	1.167;

1.167
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.166;

1.166
date	2010.07.26.22.26.05;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2010.07.26.21.58.41;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2010.07.25.22.56.47;	author kristaps;	state Exp;
branches;
next	1.163;

1.163
date	2010.07.21.20.35.03;	author kristaps;	state Exp;
branches;
next	1.162;

1.162
date	2010.07.17.12.01.43;	author kristaps;	state Exp;
branches;
next	1.161;

1.161
date	2010.07.16.22.33.30;	author kristaps;	state Exp;
branches;
next	1.160;

1.160
date	2010.07.07.15.04.54;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2010.07.04.22.04.04;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2010.07.03.16.02.12;	author schwarze;	state Exp;
branches;
next	1.157;

1.157
date	2010.07.02.10.50.50;	author kristaps;	state Exp;
branches;
next	1.156;

1.156
date	2010.06.30.12.30.36;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2010.06.30.12.27.55;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2010.06.28.23.26.09;	author kristaps;	state Exp;
branches;
next	1.153;

1.153
date	2010.06.28.22.46.21;	author kristaps;	state Exp;
branches;
next	1.152;

1.152
date	2010.06.28.09.48.44;	author kristaps;	state Exp;
branches;
next	1.151;

1.151
date	2010.06.27.01.26.20;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2010.06.26.15.36.37;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2010.06.25.18.53.14;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2010.06.19.20.46.28;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2010.06.11.07.23.04;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2010.06.08.15.00.17;	author kristaps;	state Exp;
branches;
next	1.145;

1.145
date	2010.06.08.13.22.37;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2010.06.08.09.20.08;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2010.06.07.21.03.02;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2010.06.07.20.57.09;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2010.06.07.10.52.44;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2010.05.25.12.37.20;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2010.05.24.21.51.20;	author schwarze;	state Exp;
branches;
next	1.138;

1.138
date	2010.05.24.21.34.16;	author schwarze;	state Exp;
branches;
next	1.137;

1.137
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.136;

1.136
date	2010.05.17.02.03.49;	author schwarze;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.16.01.35.37;	author schwarze;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.15.16.18.23;	author joerg;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.12.16.01.01;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2010.05.07.04.50.44;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2010.04.08.07.05.38;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2010.04.03.12.46.35;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2010.03.23.12.42.22;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2010.01.01.17.14.30;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2009.11.12.08.21.06;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2009.11.12.05.58.30;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2009.11.12.05.50.12;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2009.11.07.14.14.16;	author kristaps;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.06.10.31.32;	author kristaps;	state Exp;
branches;
next	1.122;

1.122
date	2009.11.05.08.40.16;	author kristaps;	state Exp;
branches;
next	1.121;

1.121
date	2009.11.05.07.21.02;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2009.10.31.06.10.58;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2009.10.30.18.53.09;	author kristaps;	state Exp;
branches;
next	1.118;

1.118
date	2009.10.30.18.50.11;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2009.10.30.18.43.24;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2009.10.28.06.54.12;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2009.10.27.08.26.12;	author kristaps;	state Exp;
branches;
next	1.114;

1.114
date	2009.10.27.08.05.39;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.26.17.05.44;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2009.10.26.09.06.03;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2009.10.26.07.18.23;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2009.10.24.06.19.34;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2009.10.22.18.19.36;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2009.10.19.15.18.30;	author kristaps;	state Exp;
branches;
next	1.107;

1.107
date	2009.10.18.19.03.37;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2009.10.18.13.34.17;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2009.10.13.10.57.25;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.10.11.05.23;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2009.09.23.11.02.21;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2009.09.20.13.43.31;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2009.09.17.07.41.28;	author kristaps;	state Exp;
branches;
next	1.100;

1.100
date	2009.09.16.15.08.31;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2009.09.16.09.41.24;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2009.09.15.08.16.20;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2009.07.28.10.15.12;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2009.07.27.13.10.08;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2009.07.27.12.35.54;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2009.07.27.12.02.49;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2009.07.24.11.54.25;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2009.07.23.08.35.22;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2009.07.21.13.34.13;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2009.07.19.21.26.27;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2009.07.16.13.17.51;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.16.12.34.06;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2009.07.15.15.53.57;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2009.07.15.15.37.48;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2009.07.14.15.49.44;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2009.07.14.15.16.41;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2009.06.22.13.13.10;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.22.12.38.07;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2009.06.22.12.04.05;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.22.10.40.04;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2009.06.17.18.42.42;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2009.06.11.10.34.32;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2009.06.11.07.46.41;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2009.06.11.07.26.35;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2009.06.10.20.18.44;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.12.19.45.26;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2009.04.03.12.27.18;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2009.04.03.11.08.39;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2009.03.31.13.50.19;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2009.03.26.14.38.11;	author kristaps;	state dead;
branches;
next	1.69;

1.69
date	2009.03.23.09.42.43;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.22.21.19.34;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.21.13.47.02;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.21.13.26.30;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.21.13.09.29;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2009.03.21.09.42.07;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2009.03.20.16.43.28;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2009.03.20.15.14.01;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.16.23.37.28;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.16.22.19.19;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.14.12.35.02;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.13.07.46.10;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.12.16.30.50;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.12.15.55.11;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.12.06.32.17;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.12.02.57.36;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.11.00.39.58;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.10.11.16.43;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.09.14.19.59;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.09.13.17.49;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.08.20.57.35;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.03.08.20.50.12;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.08.19.38.08;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.03.08.14.01.46;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.08.13.57.07;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.08.13.52.29;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.06.14.13.47;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.03.05.13.12.12;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.03.04.14.41.40;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.04.14.13.05;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.04.13.57.35;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.03.03.22.28.21;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.03.22.17.19;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.03.02.17.29.16;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.03.02.17.14.46;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.03.02.12.09.32;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.03.01.23.27.14;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.01.23.14.15;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.01.13.06.49;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.28.21.31.13;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.02.28.20.13.06;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.28.19.15.28;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.02.27.09.39.40;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.02.27.08.20.15;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.02.26.16.08.11;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.02.26.14.56.27;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.02.25.23.18.50;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.02.25.17.02.47;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.25.15.12.26;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.25.13.30.53;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.25.12.27.37;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.02.25.12.09.20;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.25.11.37.05;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.24.16.16.45;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.24.15.01.15;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.24.14.52.55;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.24.13.46.54;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.02.23.15.19.47;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.23.09.46.59;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.02.23.09.33.34;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.02.22.19.23.48;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.02.22.15.50.45;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.02.22.14.31.08;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.02.21.21.00.06;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.02.21.19.05.28;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.02.21.15.34.46;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.02.21.14.56.58;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.02.20.23.35.36;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.02.20.11.04.23;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.255
log
@apply bold and italic to all non-ASCII Unicode codepoints,
fixing input like \fB\('e; issue reported by bentley@@
@
text
@/*	$Id: term.c,v 1.254 2015/10/13 22:59:54 schwarze Exp $ */
/*
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "out.h"
#include "term.h"
#include "main.h"

static	size_t		 cond_width(const struct termp *, int, int *);
static	void		 adjbuf(struct termp *p, size_t);
static	void		 bufferc(struct termp *, char);
static	void		 encode(struct termp *, const char *, size_t);
static	void		 encode1(struct termp *, int);


void
term_free(struct termp *p)
{

	free(p->buf);
	free(p->fontq);
	free(p);
}

void
term_begin(struct termp *p, term_margin head,
		term_margin foot, const struct roff_meta *arg)
{

	p->headf = head;
	p->footf = foot;
	p->argf = arg;
	(*p->begin)(p);
}

void
term_end(struct termp *p)
{

	(*p->end)(p);
}

/*
 * Flush a chunk of text.  By default, break the output line each time
 * the right margin is reached, and continue output on the next line
 * at the same offset as the chunk itself.  By default, also break the
 * output line at the end of the chunk.
 * The following flags may be specified:
 *
 *  - TERMP_NOBREAK: Do not break the output line at the right margin,
 *    but only at the max right margin.  Also, do not break the output
 *    line at the end of the chunk, such that the next call can pad to
 *    the next column.  However, if less than p->trailspace blanks,
 *    which can be 0, 1, or 2, remain to the right margin, the line
 *    will be broken.
 *  - TERMP_BRTRSP: Consider trailing whitespace significant
 *    when deciding whether the chunk fits or not.
 *  - TERMP_BRIND: If the chunk does not fit and the output line has
 *    to be broken, start the next line at the right margin instead
 *    of at the offset.  Used together with TERMP_NOBREAK for the tags
 *    in various kinds of tagged lists.
 *  - TERMP_DANGLE: Do not break the output line at the right margin,
 *    append the next chunk after it even if this one is too long.
 *    To be used together with TERMP_NOBREAK.
 *  - TERMP_HANG: Like TERMP_DANGLE, and also suppress padding before
 *    the next chunk if this column is not full.
 */
void
term_flushln(struct termp *p)
{
	size_t		 i;     /* current input position in p->buf */
	int		 ntab;	/* number of tabs to prepend */
	size_t		 vis;   /* current visual position on output */
	size_t		 vbl;   /* number of blanks to prepend to output */
	size_t		 vend;	/* end of word visual position on output */
	size_t		 bp;    /* visual right border position */
	size_t		 dv;    /* temporary for visual pos calculations */
	size_t		 j;     /* temporary loop index for p->buf */
	size_t		 jhy;	/* last hyph before overflow w/r/t j */
	size_t		 maxvis; /* output position of visible boundary */

	/*
	 * First, establish the maximum columns of "visible" content.
	 * This is usually the difference between the right-margin and
	 * an indentation, but can be, for tagged lists or columns, a
	 * small set of values.
	 *
	 * The following unsigned-signed subtractions look strange,
	 * but they are actually correct.  If the int p->overstep
	 * is negative, it gets sign extended.  Subtracting that
	 * very large size_t effectively adds a small number to dv.
	 */
	dv = p->rmargin > p->offset ? p->rmargin - p->offset : 0;
	maxvis = (int)dv > p->overstep ? dv - (size_t)p->overstep : 0;

	if (p->flags & TERMP_NOBREAK) {
		dv = p->maxrmargin > p->offset ?
		     p->maxrmargin - p->offset : 0;
		bp = (int)dv > p->overstep ?
		     dv - (size_t)p->overstep : 0;
	} else
		bp = maxvis;

	/*
	 * Calculate the required amount of padding.
	 */
	vbl = p->offset + p->overstep > p->viscol ?
	      p->offset + p->overstep - p->viscol : 0;

	vis = vend = 0;
	i = 0;

	while (i < p->col) {
		/*
		 * Handle literal tab characters: collapse all
		 * subsequent tabs into a single huge set of spaces.
		 */
		ntab = 0;
		while (i < p->col && '\t' == p->buf[i]) {
			vend = (vis / p->tabwidth + 1) * p->tabwidth;
			vbl += vend - vis;
			vis = vend;
			ntab++;
			i++;
		}

		/*
		 * Count up visible word characters.  Control sequences
		 * (starting with the CSI) aren't counted.  A space
		 * generates a non-printing word, which is valid (the
		 * space is printed according to regular spacing rules).
		 */

		for (j = i, jhy = 0; j < p->col; j++) {
			if (' ' == p->buf[j] || '\t' == p->buf[j])
				break;

			/* Back over the the last printed character. */
			if (8 == p->buf[j]) {
				assert(j);
				vend -= (*p->width)(p, p->buf[j - 1]);
				continue;
			}

			/* Regular word. */
			/* Break at the hyphen point if we overrun. */
			if (vend > vis && vend < bp &&
			    (ASCII_HYPH == p->buf[j] ||
			     ASCII_BREAK == p->buf[j]))
				jhy = j;

			/*
			 * Hyphenation now decided, put back a real
			 * hyphen such that we get the correct width.
			 */
			if (ASCII_HYPH == p->buf[j])
				p->buf[j] = '-';

			vend += (*p->width)(p, p->buf[j]);
		}

		/*
		 * Find out whether we would exceed the right margin.
		 * If so, break to the next line.
		 */
		if (vend > bp && 0 == jhy && vis > 0) {
			vend -= vis;
			(*p->endline)(p);
			p->viscol = 0;
			if (TERMP_BRIND & p->flags) {
				vbl = p->rmargin;
				vend += p->rmargin;
				vend -= p->offset;
			} else
				vbl = p->offset;

			/* use pending tabs on the new line */

			if (0 < ntab)
				vbl += ntab * p->tabwidth;

			/*
			 * Remove the p->overstep width.
			 * Again, if p->overstep is negative,
			 * sign extension does the right thing.
			 */

			bp += (size_t)p->overstep;
			p->overstep = 0;
		}

		/* Write out the [remaining] word. */
		for ( ; i < p->col; i++) {
			if (vend > bp && jhy > 0 && i > jhy)
				break;
			if ('\t' == p->buf[i])
				break;
			if (' ' == p->buf[i]) {
				j = i;
				while (i < p->col && ' ' == p->buf[i])
					i++;
				dv = (i - j) * (*p->width)(p, ' ');
				vbl += dv;
				vend += dv;
				break;
			}
			if (ASCII_NBRSP == p->buf[i]) {
				vbl += (*p->width)(p, ' ');
				continue;
			}
			if (ASCII_BREAK == p->buf[i])
				continue;

			/*
			 * Now we definitely know there will be
			 * printable characters to output,
			 * so write preceding white space now.
			 */
			if (vbl) {
				(*p->advance)(p, vbl);
				p->viscol += vbl;
				vbl = 0;
			}

			(*p->letter)(p, p->buf[i]);
			if (8 == p->buf[i])
				p->viscol -= (*p->width)(p, p->buf[i-1]);
			else
				p->viscol += (*p->width)(p, p->buf[i]);
		}
		vis = vend;
	}

	/*
	 * If there was trailing white space, it was not printed;
	 * so reset the cursor position accordingly.
	 */
	if (vis > vbl)
		vis -= vbl;
	else
		vis = 0;

	p->col = 0;
	p->overstep = 0;
	p->flags &= ~(TERMP_BACKAFTER | TERMP_BACKBEFORE);

	if ( ! (TERMP_NOBREAK & p->flags)) {
		p->viscol = 0;
		(*p->endline)(p);
		return;
	}

	if (TERMP_HANG & p->flags) {
		p->overstep += (int)(p->offset + vis - p->rmargin +
		    p->trailspace * (*p->width)(p, ' '));

		/*
		 * If we have overstepped the margin, temporarily move
		 * it to the right and flag the rest of the line to be
		 * shorter.
		 * If there is a request to keep the columns together,
		 * allow negative overstep when the column is not full.
		 */
		if (p->trailspace && p->overstep < 0)
			p->overstep = 0;
		return;

	} else if (TERMP_DANGLE & p->flags)
		return;

	/* Trailing whitespace is significant in some columns. */
	if (vis && vbl && (TERMP_BRTRSP & p->flags))
		vis += vbl;

	/* If the column was overrun, break the line. */
	if (maxvis < vis + p->trailspace * (*p->width)(p, ' ')) {
		(*p->endline)(p);
		p->viscol = 0;
	}
}

/*
 * A newline only breaks an existing line; it won't assert vertical
 * space.  All data in the output buffer is flushed prior to the newline
 * assertion.
 */
void
term_newln(struct termp *p)
{

	p->flags |= TERMP_NOSPACE;
	if (p->col || p->viscol)
		term_flushln(p);
}

/*
 * Asserts a vertical space (a full, empty line-break between lines).
 * Note that if used twice, this will cause two blank spaces and so on.
 * All data in the output buffer is flushed prior to the newline
 * assertion.
 */
void
term_vspace(struct termp *p)
{

	term_newln(p);
	p->viscol = 0;
	if (0 < p->skipvsp)
		p->skipvsp--;
	else
		(*p->endline)(p);
}

/* Swap current and previous font; for \fP and .ft P */
void
term_fontlast(struct termp *p)
{
	enum termfont	 f;

	f = p->fontl;
	p->fontl = p->fontq[p->fonti];
	p->fontq[p->fonti] = f;
}

/* Set font, save current, discard previous; for \f, .ft, .B etc. */
void
term_fontrepl(struct termp *p, enum termfont f)
{

	p->fontl = p->fontq[p->fonti];
	p->fontq[p->fonti] = f;
}

/* Set font, save previous. */
void
term_fontpush(struct termp *p, enum termfont f)
{

	p->fontl = p->fontq[p->fonti];
	if (++p->fonti == p->fontsz) {
		p->fontsz += 8;
		p->fontq = mandoc_reallocarray(p->fontq,
		    p->fontsz, sizeof(enum termfont *));
	}
	p->fontq[p->fonti] = f;
}

/* Flush to make the saved pointer current again. */
void
term_fontpopq(struct termp *p, int i)
{

	assert(i >= 0);
	if (p->fonti > i)
		p->fonti = i;
}

/* Pop one font off the stack. */
void
term_fontpop(struct termp *p)
{

	assert(p->fonti);
	p->fonti--;
}

/*
 * Handle pwords, partial words, which may be either a single word or a
 * phrase that cannot be broken down (such as a literal string).  This
 * handles word styling.
 */
void
term_word(struct termp *p, const char *word)
{
	const char	 nbrsp[2] = { ASCII_NBRSP, 0 };
	const char	*seq, *cp;
	int		 sz, uc;
	size_t		 ssz;
	enum mandoc_esc	 esc;

	if ( ! (TERMP_NOSPACE & p->flags)) {
		if ( ! (TERMP_KEEP & p->flags)) {
			bufferc(p, ' ');
			if (TERMP_SENTENCE & p->flags)
				bufferc(p, ' ');
		} else
			bufferc(p, ASCII_NBRSP);
	}
	if (TERMP_PREKEEP & p->flags)
		p->flags |= TERMP_KEEP;

	if ( ! (p->flags & TERMP_NONOSPACE))
		p->flags &= ~TERMP_NOSPACE;
	else
		p->flags |= TERMP_NOSPACE;

	p->flags &= ~(TERMP_SENTENCE | TERMP_NONEWLINE);
	p->skipvsp = 0;

	while ('\0' != *word) {
		if ('\\' != *word) {
			if (TERMP_NBRWORD & p->flags) {
				if (' ' == *word) {
					encode(p, nbrsp, 1);
					word++;
					continue;
				}
				ssz = strcspn(word, "\\ ");
			} else
				ssz = strcspn(word, "\\");
			encode(p, word, ssz);
			word += (int)ssz;
			continue;
		}

		word++;
		esc = mandoc_escape(&word, &seq, &sz);
		if (ESCAPE_ERROR == esc)
			continue;

		switch (esc) {
		case ESCAPE_UNICODE:
			uc = mchars_num2uc(seq + 1, sz - 1);
			break;
		case ESCAPE_NUMBERED:
			uc = mchars_num2char(seq, sz);
			if (uc < 0)
				continue;
			break;
		case ESCAPE_SPECIAL:
			if (p->enc == TERMENC_ASCII) {
				cp = mchars_spec2str(seq, sz, &ssz);
				if (cp != NULL)
					encode(p, cp, ssz);
			} else {
				uc = mchars_spec2cp(seq, sz);
				if (uc > 0)
					encode1(p, uc);
			}
			continue;
		case ESCAPE_FONTBOLD:
			term_fontrepl(p, TERMFONT_BOLD);
			continue;
		case ESCAPE_FONTITALIC:
			term_fontrepl(p, TERMFONT_UNDER);
			continue;
		case ESCAPE_FONTBI:
			term_fontrepl(p, TERMFONT_BI);
			continue;
		case ESCAPE_FONT:
		case ESCAPE_FONTROMAN:
			term_fontrepl(p, TERMFONT_NONE);
			continue;
		case ESCAPE_FONTPREV:
			term_fontlast(p);
			continue;
		case ESCAPE_NOSPACE:
			if (p->flags & TERMP_BACKAFTER)
				p->flags &= ~TERMP_BACKAFTER;
			else if (*word == '\0')
				p->flags |= (TERMP_NOSPACE | TERMP_NONEWLINE);
			continue;
		case ESCAPE_SKIPCHAR:
			p->flags |= TERMP_BACKAFTER;
			continue;
		case ESCAPE_OVERSTRIKE:
			cp = seq + sz;
			while (seq < cp) {
				if (*seq == '\\') {
					mandoc_escape(&seq, NULL, NULL);
					continue;
				}
				encode1(p, *seq++);
				if (seq < cp) {
					if (p->flags & TERMP_BACKBEFORE)
						p->flags |= TERMP_BACKAFTER;
					else
						p->flags |= TERMP_BACKBEFORE;
				}
			}
			/* Trim trailing backspace/blank pair. */
			if (p->col > 2 && p->buf[p->col - 1] == ' ')
				p->col -= 2;
			continue;
		default:
			continue;
		}

		/*
		 * Common handling for Unicode and numbered
		 * character escape sequences.
		 */

		if (p->enc == TERMENC_ASCII) {
			cp = ascii_uc2str(uc);
			encode(p, cp, strlen(cp));
		} else {
			if ((uc < 0x20 && uc != 0x09) ||
			    (uc > 0x7E && uc < 0xA0))
				uc = 0xFFFD;
			encode1(p, uc);
		}
	}
	p->flags &= ~TERMP_NBRWORD;
}

static void
adjbuf(struct termp *p, size_t sz)
{

	if (0 == p->maxcols)
		p->maxcols = 1024;
	while (sz >= p->maxcols)
		p->maxcols <<= 2;

	p->buf = mandoc_reallocarray(p->buf, p->maxcols, sizeof(int));
}

static void
bufferc(struct termp *p, char c)
{

	if (p->col + 1 >= p->maxcols)
		adjbuf(p, p->col + 1);

	p->buf[p->col++] = c;
}

/*
 * See encode().
 * Do this for a single (probably unicode) value.
 * Does not check for non-decorated glyphs.
 */
static void
encode1(struct termp *p, int c)
{
	enum termfont	  f;

	if (p->col + 7 >= p->maxcols)
		adjbuf(p, p->col + 7);

	f = (c == ASCII_HYPH || c > 127 || isgraph(c)) ?
	    p->fontq[p->fonti] : TERMFONT_NONE;

	if (p->flags & TERMP_BACKBEFORE) {
		if (p->buf[p->col - 1] == ' ')
			p->col--;
		else
			p->buf[p->col++] = 8;
		p->flags &= ~TERMP_BACKBEFORE;
	}
	if (TERMFONT_UNDER == f || TERMFONT_BI == f) {
		p->buf[p->col++] = '_';
		p->buf[p->col++] = 8;
	}
	if (TERMFONT_BOLD == f || TERMFONT_BI == f) {
		if (ASCII_HYPH == c)
			p->buf[p->col++] = '-';
		else
			p->buf[p->col++] = c;
		p->buf[p->col++] = 8;
	}
	p->buf[p->col++] = c;
	if (p->flags & TERMP_BACKAFTER) {
		p->flags |= TERMP_BACKBEFORE;
		p->flags &= ~TERMP_BACKAFTER;
	}
}

static void
encode(struct termp *p, const char *word, size_t sz)
{
	size_t		  i;

	if (p->col + 2 + (sz * 5) >= p->maxcols)
		adjbuf(p, p->col + 2 + (sz * 5));

	for (i = 0; i < sz; i++) {
		if (ASCII_HYPH == word[i] ||
		    isgraph((unsigned char)word[i]))
			encode1(p, word[i]);
		else
			p->buf[p->col++] = word[i];
	}
}

void
term_setwidth(struct termp *p, const char *wstr)
{
	struct roffsu	 su;
	int		 iop, width;

	iop = 0;
	width = 0;
	if (NULL != wstr) {
		switch (*wstr) {
		case '+':
			iop = 1;
			wstr++;
			break;
		case '-':
			iop = -1;
			wstr++;
			break;
		default:
			break;
		}
		if (a2roffsu(wstr, &su, SCALE_MAX))
			width = term_hspan(p, &su);
		else
			iop = 0;
	}
	(*p->setwidth)(p, iop, width);
}

size_t
term_len(const struct termp *p, size_t sz)
{

	return (*p->width)(p, ' ') * sz;
}

static size_t
cond_width(const struct termp *p, int c, int *skip)
{

	if (*skip) {
		(*skip) = 0;
		return 0;
	} else
		return (*p->width)(p, c);
}

size_t
term_strlen(const struct termp *p, const char *cp)
{
	size_t		 sz, rsz, i;
	int		 ssz, skip, uc;
	const char	*seq, *rhs;
	enum mandoc_esc	 esc;
	static const char rej[] = { '\\', ASCII_NBRSP, ASCII_HYPH,
			ASCII_BREAK, '\0' };

	/*
	 * Account for escaped sequences within string length
	 * calculations.  This follows the logic in term_word() as we
	 * must calculate the width of produced strings.
	 */

	sz = 0;
	skip = 0;
	while ('\0' != *cp) {
		rsz = strcspn(cp, rej);
		for (i = 0; i < rsz; i++)
			sz += cond_width(p, *cp++, &skip);

		switch (*cp) {
		case '\\':
			cp++;
			esc = mandoc_escape(&cp, &seq, &ssz);
			if (ESCAPE_ERROR == esc)
				continue;

			rhs = NULL;

			switch (esc) {
			case ESCAPE_UNICODE:
				uc = mchars_num2uc(seq + 1, ssz - 1);
				break;
			case ESCAPE_NUMBERED:
				uc = mchars_num2char(seq, ssz);
				if (uc < 0)
					continue;
				break;
			case ESCAPE_SPECIAL:
				if (p->enc == TERMENC_ASCII) {
					rhs = mchars_spec2str(seq, ssz, &rsz);
					if (rhs != NULL)
						break;
				} else {
					uc = mchars_spec2cp(seq, ssz);
					if (uc > 0)
						sz += cond_width(p, uc, &skip);
				}
				continue;
			case ESCAPE_SKIPCHAR:
				skip = 1;
				continue;
			case ESCAPE_OVERSTRIKE:
				rsz = 0;
				rhs = seq + ssz;
				while (seq < rhs) {
					if (*seq == '\\') {
						mandoc_escape(&seq, NULL, NULL);
						continue;
					}
					i = (*p->width)(p, *seq++);
					if (rsz < i)
						rsz = i;
				}
				sz += rsz;
				continue;
			default:
				continue;
			}

			/*
			 * Common handling for Unicode and numbered
			 * character escape sequences.
			 */

			if (rhs == NULL) {
				if (p->enc == TERMENC_ASCII) {
					rhs = ascii_uc2str(uc);
					rsz = strlen(rhs);
				} else {
					if ((uc < 0x20 && uc != 0x09) ||
					    (uc > 0x7E && uc < 0xA0))
						uc = 0xFFFD;
					sz += cond_width(p, uc, &skip);
					continue;
				}
			}

			if (skip) {
				skip = 0;
				break;
			}

			/*
			 * Common handling for all escape sequences
			 * printing more than one character.
			 */

			for (i = 0; i < rsz; i++)
				sz += (*p->width)(p, *rhs++);
			break;
		case ASCII_NBRSP:
			sz += cond_width(p, ' ', &skip);
			cp++;
			break;
		case ASCII_HYPH:
			sz += cond_width(p, '-', &skip);
			cp++;
			break;
		default:
			break;
		}
	}

	return sz;
}

int
term_vspan(const struct termp *p, const struct roffsu *su)
{
	double		 r;
	int		 ri;

	switch (su->unit) {
	case SCALE_BU:
		r = su->scale / 40.0;
		break;
	case SCALE_CM:
		r = su->scale * 6.0 / 2.54;
		break;
	case SCALE_FS:
		r = su->scale * 65536.0 / 40.0;
		break;
	case SCALE_IN:
		r = su->scale * 6.0;
		break;
	case SCALE_MM:
		r = su->scale * 0.006;
		break;
	case SCALE_PC:
		r = su->scale;
		break;
	case SCALE_PT:
		r = su->scale / 12.0;
		break;
	case SCALE_EN:
	case SCALE_EM:
		r = su->scale * 0.6;
		break;
	case SCALE_VS:
		r = su->scale;
		break;
	default:
		abort();
	}
	ri = r > 0.0 ? r + 0.4995 : r - 0.4995;
	return ri < 66 ? ri : 1;
}

/*
 * Convert a scaling width to basic units, rounding down.
 */
int
term_hspan(const struct termp *p, const struct roffsu *su)
{

	return (*p->hspan)(p, su);
}
@


1.254
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.253 2015/10/12 00:08:16 schwarze Exp $ */
d567 1
a567 1
	f = (c == ASCII_HYPH || isgraph(c)) ?
@


1.253
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.252 2015/10/06 18:32:20 schwarze Exp $ */
d457 1
a457 2
				cp = mchars_spec2str(p->symtab,
				    seq, sz, &ssz);
d461 1
a461 1
				uc = mchars_spec2cp(p->symtab, seq, sz);
d702 1
a702 2
					rhs = mchars_spec2str(p->symtab,
					    seq, ssz, &rsz);
d706 1
a706 2
					uc = mchars_spec2cp(p->symtab,
					    seq, ssz);
@


1.252
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.251 2015/09/26 00:54:04 schwarze Exp $ */
a476 1
			/* FALLTHROUGH */
a772 2
			/* FALLTHROUGH */
		case ASCII_BREAK:
a810 1
		/* FALLTHROUGH */
@


1.251
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.250 2015/09/21 13:25:00 schwarze Exp $ */
d647 1
a647 1
	return((*p->width)(p, ' ') * sz);
d656 1
a656 1
		return(0);
d658 1
a658 1
		return((*p->width)(p, c));
d782 1
a782 1
	return(sz);
d825 1
a825 1
	return(ri < 66 ? ri : 1);
d835 1
a835 1
	return((*p->hspan)(p, su));
@


1.250
log
@Trailing whitespace is significant when determining the width of a tag
in mdoc(7) .Bl -tag and man(7) .TP, but not in man(7) .IP.
Quirk reported by Jan Stary <hans at stare dot cz> on ports@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.249 2015/08/30 21:10:56 schwarze Exp $ */
a822 1
		/* NOTREACHED */
@


1.249
log
@Drop leading, internal, and trailing blank characters in \o (overstrike)
escape sequences; that's cleaner for all output modes, and it's required
to prevent the PostScript/PDF formatter from dying on assertions.
Bug found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.248 2015/04/29 18:35:00 schwarze Exp $ */
d81 2
d296 4
@


1.248
log
@Replace the kludge for the \z escape sequence by an actual
implementation.  As a side effect, minus ten lines of code.

As another side effect, this also fixes the assertion failure that
used to be triggered by "\z\o'ab'c" at the beginning of an output
line, found by jsg@@ with afl (test case 022/Apr27).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.247 2015/04/04 17:47:18 schwarze Exp $ */
d502 3
d567 4
a570 1
		p->buf[p->col++] = 8;
@


1.247
log
@Rounding rules for horizontal scaling widths are more complicated.
There is a first rounding to basic units on the input side.
After that, rounding rules differ between requests and macros.
Requests round to the nearest possible character position.
Macros round to the next character position to the left.

Implement that by changing the return value of term_hspan()
to basic units and leaving the second scaling and rounding stage
to the formatters instead of doing it in the terminal handler.

Improves for example argtable2(3).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.246 2015/04/02 23:48:20 schwarze Exp $ */
d268 1
a420 5
			if (TERMP_SKIPCHAR & p->flags) {
				p->flags &= ~TERMP_SKIPCHAR;
				word++;
				continue;
			}
d479 3
a481 3
			if (TERMP_SKIPCHAR & p->flags)
				p->flags &= ~TERMP_SKIPCHAR;
			else if ('\0' == *word)
d485 1
a485 1
			p->flags |= TERMP_SKIPCHAR;
d495 6
a500 2
				if (seq < cp)
					encode(p, "\b", 1);
d502 1
d557 2
a558 4
	if (TERMP_SKIPCHAR & p->flags) {
		p->flags &= ~TERMP_SKIPCHAR;
		return;
	}
d560 2
a561 4
	if (p->col + 6 >= p->maxcols)
		adjbuf(p, p->col + 6);

	f = p->fontq[p->fonti];
d563 4
d579 4
d590 2
a591 23
	if (TERMP_SKIPCHAR & p->flags) {
		p->flags &= ~TERMP_SKIPCHAR;
		return;
	}

	/*
	 * Encode and buffer a string of characters.  If the current
	 * font mode is unset, buffer directly, else encode then buffer
	 * character by character.
	 */

	if (p->fontq[p->fonti] == TERMFONT_NONE) {
		if (p->col + sz >= p->maxcols)
			adjbuf(p, p->col + sz);
		for (i = 0; i < sz; i++)
			p->buf[p->col++] = word[i];
		return;
	}

	/* Pre-buffer, assuming worst-case. */

	if (p->col + 1 + (sz * 5) >= p->maxcols)
		adjbuf(p, p->col + 1 + (sz * 5));
@


1.246
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.245 2015/03/06 13:02:43 schwarze Exp $ */
d622 1
a622 2
	size_t		 width;
	int		 iop;
d833 3
a838 1
	double		 v;
d840 1
a840 2
	v = (*p->hspan)(p, su);
	return(v > 0.0 ? v + 0.0005 : v - 0.0005);
@


1.245
log
@prevent the skipvsp flag from creeping past actual text
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.244 2015/01/31 00:12:41 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d52 1
a52 1
		term_margin foot, const void *arg)
@


1.244
log
@Use relative offsets instead of absolute pointers for the terminal
font stack.  The latter fail after the stack is grown with realloc().
Fixing an assertion failure found by jsg@@ with afl some time ago
(test case number 51).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.243 2015/01/21 20:33:25 schwarze Exp $ */
d416 1
@


1.243
log
@Rudimentary implementation of the roff(7) \o escape sequence (overstrike).
This is of some relevance because the pod2man(1) preamble abuses it
for the icelandic letter Thorn, instead of simply using \(TP and \(Tp.
Missing feature found by sthen@@ in DateTime::Locale::is_IS(3p).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.242 2014/12/24 23:32:42 schwarze Exp $ */
a365 8
/* Retrieve pointer to current font. */
const enum termfont *
term_fontq(struct termp *p)
{

	return(&p->fontq[p->fonti]);
}

d368 1
a368 1
term_fontpopq(struct termp *p, const enum termfont *key)
d371 3
a373 3
	while (p->fonti >= 0 && key < p->fontq + p->fonti)
		p->fonti--;
	assert(p->fonti >= 0);
d563 1
a563 1
	f = *term_fontq(p);
d595 1
a595 1
	if (*term_fontq(p) == TERMFONT_NONE) {
@


1.242
log
@Support negative indentations for mdoc(7) displays and lists.
Not exactly recommended for use, rather for groff compatibility.
While here, introduce similar SHRT_MAX limits as in man(7),
fixing a few cases of infinite output found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.241 2014/12/24 09:58:35 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d498 11
d730 14
@


1.241
log
@When a man(7) document contains unreasonably large numbers for
indentations or paragraph distances, large output may be generated,
which is practically the same as an endless loop; found by jsg@@
with afl.
Reject such unreasonably large numbers beyond arbitrary limits
similar to those used by groff (max. 65 blank lines between paragraphs
and max. SHRT_MAX characters per output line) and fall back to
defaults when exceeded.  Having the limits behave in exactly the
same way is not relevant.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.240 2014/12/23 13:48:57 schwarze Exp $ */
d276 1
a276 1
		p->overstep = (int)(vis - maxvis +
@


1.240
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.239 2014/12/23 06:16:46 schwarze Exp $ */
d776 1
d812 2
a813 1
	return(r > 0.0 ? r + 0.4995 : r - 0.4995);
@


1.239
log
@Fix vertical scaling.  Obviously, nobody ever had a serious look at this.
Basic units, centimeters, points, ens, ems, and the rounding algorithm
were all wrong, only inches, pica, and the default vertical span worked.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.238 2014/12/19 17:12:04 schwarze Exp $ */
a103 1
	size_t		 rmargin; /* the rightmost of the two margins */
d116 1
a116 2
	rmargin = p->rmargin > p->offset ? p->rmargin : p->offset;
	dv = p->rmargin - p->offset;
d194 3
a196 2
				vbl = rmargin;
				vend += rmargin - p->offset;
d772 1
a772 1
size_t
d811 1
a811 4

	if (r < 0.0)
		r = 0.0;
	return((size_t)(r + 0.4995));
d814 1
a814 1
size_t
d820 1
a820 3
	if (v < 0.0)
		v = 0.0;
	return((size_t)(v + 0.0005));
@


1.238
log
@Enforcing an arbitrary, implementation dependent, undocumented limit
by calling assert() when valid user input exceeds it is a bad idea.
Allocate the terminal font stack dynamically instead of crashing
above 10 entries.  Issue found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.237 2014/12/02 10:08:06 schwarze Exp $ */
d779 3
d783 4
a786 1
		r = su->scale * 2.0;
d791 3
d798 1
a798 1
		r = su->scale / 8.0;
d800 4
a803 2
	case SCALE_MM:
		r = su->scale / 1000.0;
d809 2
a810 2
		r = su->scale - 1.0;
		break;
d815 1
a815 1
	return((size_t)(r + 0.0005));
@


1.237
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.236 2014/11/21 01:52:53 schwarze Exp $ */
d46 1
d333 1
d344 1
d353 1
a357 1
	assert(p->fonti + 1 < 10);
d359 6
a364 1
	p->fontq[++p->fonti] = f;
d367 2
a368 1
const void *
d375 1
a375 7
enum termfont
term_fonttop(struct termp *p)
{

	return(p->fontq[p->fonti]);
}

d377 1
a377 1
term_fontpopq(struct termp *p, const void *key)
d380 1
a380 1
	while (p->fonti >= 0 && key < (void *)(p->fontq + p->fonti))
d385 1
d561 1
a561 1
	f = term_fonttop(p);
d593 1
a593 1
	if (TERMFONT_NONE == term_fonttop(p)) {
@


1.236
log
@We repeatedly observed assertion crashes in the low-level terminal
output handler because the high level terminal formatters could be
tricked into setting the left margin further to the right than the
right margin.  Today, jsg@@ found more of these with afl.

Change the internal interface between both levels, aiming for
simplicity and robustness of the code.  Treat both margins as
*independent* settings:  Now, termp.offset is the requested left
margin, and termp.rmargin is the available space.  Let the lower
level cope with that case of insufficient space.

Obviously, high level code that does centering or flush right
still has to do careful checks, so i did a full audit of margin
settings in the terminal formatters.

Fixes crashes caused by excessively long title or date strings in
the man(7) footer, operating system or date strings in the mdoc(7)
footer, volume strings in the man(7) or mdoc(7) header, and a few
cases related to some non-prologue macros.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.235 2014/11/16 21:29:35 schwarze Exp $ */
d420 1
a420 1
	p->flags &= ~TERMP_SENTENCE;
d490 1
a490 1
				p->flags |= TERMP_NOSPACE;
@


1.235
log
@When a line (in the sense of term_flushln()) contains white space only,
the `vbl' variable includes the left margin, but `vis' does not.
Prevent a `vis' underflow that caused a bogus blank line.
Bug reported by Carsten Kunze, found in less(1): .Bl -tag ... .It " "
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.234 2014/11/01 04:03:49 schwarze Exp $ */
d103 1
a103 1
	size_t		 mmax; /* used in calculating bp */
d116 2
a117 2
	assert  (p->rmargin >= p->offset);
	dv     = p->rmargin - p->offset;
a118 2
	dv     = p->maxrmargin - p->offset;
	mmax   = (int)dv > p->overstep ? dv - (size_t)p->overstep : 0;
d120 7
a126 1
	bp = TERMP_NOBREAK & p->flags ? mmax : maxvis;
d195 2
a196 2
				vbl = p->rmargin;
				vend += p->rmargin - p->offset;
@


1.234
log
@fix a typo causing crashes in Unicode string length measurement
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.233 2014/10/29 00:17:43 schwarze Exp $ */
d257 1
a257 1
	if (vis)
d259 2
@


1.233
log
@In terminal output, unify handling of Unicode and numbered character
escape sequences just like it was earlier implemented for -Thtml.
Do not let control characters other than ASCII 9 (horizontal tab)
propagate to the output, even though groff allows them; but that
really doesn't look like a great idea.

Let mchars_num2char() return int such that we can distinguish invalid \N
syntax from \N'0'.  This also reduces the danger of signed char issues
popping up.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.232 2014/10/28 18:49:33 schwarze Exp $ */
d687 1
a687 1
				uc = mchars_num2uc(seq + 1, sz - 1);
@


1.232
log
@In -Tascii mode, print "<?>" only for Unicode escapes of unknown
representation, not for character escapes with unknown names.
According to groff, the latter produce no output, and we now warn
about them.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.231 2014/10/28 17:36:19 schwarze Exp $ */
a393 1
	char		 c;
a444 5
			if (p->enc == TERMENC_ASCII) {
				cp = ascii_uc2str(uc);
				encode(p, cp, strlen(cp));
			} else
				encode1(p, uc);
d447 3
a449 3
			c = mchars_num2char(seq, sz);
			if ('\0' != c)
				encode(p, &c, 1);
d462 1
a462 1
			break;
d465 1
a465 1
			break;
d468 1
a468 1
			break;
d471 1
a471 1
			break;
d476 1
a476 1
			break;
d479 1
a479 1
			break;
d485 1
a485 1
			break;
d488 1
a488 1
			break;
d490 16
a505 1
			break;
d657 1
a657 1
	int		 ssz, skip, c;
d687 1
a687 6
				c = mchars_num2uc(seq + 1, sz - 1);
				if (p->enc == TERMENC_ASCII) {
					rhs = ascii_uc2str(c);
					rsz = strlen(rhs);
				} else
					sz += cond_width(p, c, &skip);
d690 3
a692 3
				c = mchars_num2char(seq, ssz);
				if ('\0' != c)
					sz += cond_width(p, c, &skip);
d695 1
a695 1
				if (p->enc == TERMENC_ASCII)
d698 4
a701 2
				else {
					c = mchars_spec2cp(p->symtab,
d703 2
a704 2
					if (c > 0)
						sz += cond_width(p, c, &skip);
d706 1
a706 1
				break;
d709 1
a709 1
				break;
d711 1
a711 1
				break;
d714 17
a730 2
			if (NULL == rhs)
				break;
d737 5
@


1.231
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.230 2014/10/27 13:31:04 schwarze Exp $ */
d461 1
a461 3
				if (cp == NULL)
					encode(p, "<?>", 3);
				else
d691 1
a691 1
				if (p->enc == TERMENC_ASCII) {
d694 1
a694 5
					if (rhs == NULL) {
						rhs = "<?>";
						rsz = 3;
					}
				} else {
@


1.230
log
@Fix a regression in term.c rev. 1.229 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.229 2014/10/26 17:12:03 schwarze Exp $ */
d45 1
a45 5
	if (p->buf)
		free(p->buf);
	if (p->symtab)
		mchars_free(p->symtab);

@


1.229
log
@Improve -Tascii output for Unicode escape sequences: For the first 512
code points, provide ASCII approximations.  This is already much better
than what groff does, which prints nothing for most code points.

A few minor fixes while here:
* Handle Unicode escape sequences in the ASCII range.
* In case of errors, use the REPLACEMENT CHARACTER U+FFFD for -Tutf8
and the string "<?>" for -Tascii output.
* Handle all one-character escape sequences in mchars_spec2{cp,str}()
and remove the workarounds on the higher level.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.228 2014/08/18 21:07:53 kristaps Exp $ */
d471 2
a472 3
				if (uc <= 0)
					uc = 0xFFFD;
				encode1(p, uc);
d707 2
a708 3
					if (c <= 0)
						c = 0xFFFD;
					sz += cond_width(p, c, &skip);
@


1.228
log
@Control reading off the edge of our buffer in term_flushln().
This happens in specific conditions (trailing whitespace in certain
terminal modes), but in practise, it happens quite often (as reported by
valgrind).
In short, "Nothing about term_flushln() is simple.  Srsly!" (schwarze@@)
Discussed on tech@@, ok schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.227 2014/08/10 23:54:41 schwarze Exp $ */
a446 18
		if (TERMENC_ASCII != p->enc)
			switch (esc) {
			case ESCAPE_UNICODE:
				uc = mchars_num2uc(seq + 1, sz - 1);
				if ('\0' == uc)
					break;
				encode1(p, uc);
				continue;
			case ESCAPE_SPECIAL:
				uc = mchars_spec2cp(p->symtab, seq, sz);
				if (uc <= 0)
					break;
				encode1(p, uc);
				continue;
			default:
				break;
			}

d449 6
a454 1
			encode1(p, '?');
d462 13
a474 5
			cp = mchars_spec2str(p->symtab, seq, sz, &ssz);
			if (NULL != cp)
				encode(p, cp, ssz);
			else if (1 == ssz)
				encode(p, seq, sz);
a680 20
			if (TERMENC_ASCII != p->enc)
				switch (esc) {
				case ESCAPE_UNICODE:
					c = mchars_num2uc(seq + 1,
					    ssz - 1);
					if ('\0' == c)
						break;
					sz += cond_width(p, c, &skip);
					continue;
				case ESCAPE_SPECIAL:
					c = mchars_spec2cp(p->symtab,
					    seq, ssz);
					if (c <= 0)
						break;
					sz += cond_width(p, c, &skip);
					continue;
				default:
					break;
				}

d685 6
a690 1
				sz += cond_width(p, '?', &skip);
d698 14
a711 8
				rhs = mchars_spec2str(p->symtab,
				    seq, ssz, &rsz);

				if (ssz != 1 || rhs)
					break;

				rhs = seq;
				rsz = ssz;
@


1.227
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.226 2014/08/01 19:38:29 schwarze Exp $ */
d223 1
a223 1
				while (' ' == p->buf[i])
@


1.226
log
@Fix floating point handling: When converting double to size_t,
properly round to the nearest M (=0.001m), which is the smallest
available unit.

This avoids weirdness like (size_t)(0.6 * 10.0) == 5
by instead calculating (size_t)(0.6 * 10.0 + 0.0005) == 6,
and so it fixes the indentation of the readline(3) manual.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.225 2014/08/01 19:25:52 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
@


1.225
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.224 2014/07/06 18:51:13 schwarze Exp $ */
d796 1
a796 1
	return((size_t)r);
d807 1
a807 1
	return((size_t)v);
@


1.224
log
@After skipping an escape sequence with incomplete arguments,
do not throw away the rest of the string to be rendered.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.223 2014/04/23 21:06:41 schwarze Exp $ */
d772 1
a772 1
		r = su->scale * 2;
d775 1
a775 1
		r = su->scale * 6;
d781 1
a781 1
		r = su->scale / 8;
d784 1
a784 1
		r = su->scale / 1000;
d790 1
a790 1
		r = su->scale - 1;
d804 1
a804 1
	v = ((*p->hspan)(p, su));
@


1.223
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.222 2014/04/20 16:46:05 schwarze Exp $ */
d447 1
a447 1
			break;
d686 1
a686 1
				return(sz);
@


1.222
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.221 2014/04/08 07:13:12 schwarze Exp $ */
d525 1
a525 1
	p->buf = mandoc_realloc(p->buf, sizeof(int) * p->maxcols);
@


1.221
log
@Add a new term_flushln() flag TERMP_BRIND (if break, then indent)
to control indentation of continuation lines in TERMP_NOBREAK mode.
In the past, this was always on; continue using it
for .Bl, .Nm, .Fn, .Fo, and .HP, but no longer for .IP and .TP.

I looked at this because sthen@@ reported the issue in a manual
of a Perl module from ports, but it affects base, too: This patch
reduces groff-mandoc differences in base by more than 15%.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.220 2014/04/05 21:18:19 schwarze Exp $ */
d42 1
a54 1

d56 1
a56 1
term_begin(struct termp *p, term_margin head, 
a65 1

d173 1
a173 1
			if (vend > vis && vend < bp && 
d253 1
a253 1
			else 
d277 1
a277 1
				p->trailspace * (*p->width)(p, ' '));
d300 1
a300 2

/* 
a313 1

a341 1

a349 1

a358 1

a365 1

a372 1

a381 1

d451 1
a451 1
			case (ESCAPE_UNICODE):
d457 1
a457 1
			case (ESCAPE_SPECIAL):
d468 1
a468 1
		case (ESCAPE_UNICODE):
d471 1
a471 1
		case (ESCAPE_NUMBERED):
d476 1
a476 1
		case (ESCAPE_SPECIAL):
d478 1
a478 1
			if (NULL != cp) 
d483 1
a483 1
		case (ESCAPE_FONTBOLD):
d486 1
a486 1
		case (ESCAPE_FONTITALIC):
d489 1
a489 1
		case (ESCAPE_FONTBI):
d492 1
a492 1
		case (ESCAPE_FONT):
d494 1
a494 1
		case (ESCAPE_FONTROMAN):
d497 1
a497 1
		case (ESCAPE_FONTPREV):
d500 1
a500 1
		case (ESCAPE_NOSPACE):
d506 1
a506 1
		case (ESCAPE_SKIPCHAR):
d589 1
a589 1
		if (p->col + sz >= p->maxcols) 
d621 1
a621 1
		case ('+'):
d625 1
a625 1
		case ('-'):
d682 1
a682 1
		case ('\\'):
d690 3
a692 3
				case (ESCAPE_UNICODE):
					c = mchars_num2uc
						(seq + 1, ssz - 1);
d697 3
a699 3
				case (ESCAPE_SPECIAL):
					c = mchars_spec2cp
						(p->symtab, seq, ssz);
d711 1
a711 1
			case (ESCAPE_UNICODE):
d714 1
a714 1
			case (ESCAPE_NUMBERED):
d719 3
a721 3
			case (ESCAPE_SPECIAL):
				rhs = mchars_spec2str
					(p->symtab, seq, ssz, &rsz);
d729 1
a729 1
			case (ESCAPE_SKIPCHAR):
d747 1
a747 1
		case (ASCII_NBRSP):
d751 1
a751 1
		case (ASCII_HYPH):
d755 1
a755 1
		case (ASCII_BREAK):
a764 1
/* ARGSUSED */
d771 1
a771 1
	case (SCALE_CM):
d774 1
a774 1
	case (SCALE_IN):
d777 1
a777 1
	case (SCALE_PC):
d780 1
a780 1
	case (SCALE_PT):
d783 1
a783 1
	case (SCALE_MM):
d786 1
a786 1
	case (SCALE_VS):
d796 1
a796 2
	return(/* LINTED */(size_t)
			r);
d807 1
a807 2
	return((size_t) /* LINTED */
			v);
@


1.220
log
@bugfix: make sure all variables are properly initialized
when rendering .ll (line length) requests.  oops.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.219 2014/03/30 21:28:01 schwarze Exp $ */
d75 4
a78 6
 * Flush a line of text.  A "line" is loosely defined as being something
 * that should be followed by a newline, regardless of whether it's
 * broken apart by newlines getting there.  A line can also be a
 * fragment of a columnar list (`Bl -tag' or `Bl -column'), which does
 * not have a trailing newline.
 *
d81 15
a95 20
 *  - TERMP_NOBREAK: this is the most important and is used when making
 *    columns.  In short: don't print a newline and instead expect the
 *    next call to do the padding up to the start of the next column.
 *    p->trailspace may be set to 0, 1, or 2, depending on how many
 *    space characters are required at the end of the column.
 *
 *  - TERMP_DANGLE: don't newline when TERMP_NOBREAK is specified and
 *    the line is overrun, and don't pad-right if it's underrun.
 *
 *  - TERMP_HANG: like TERMP_DANGLE, but doesn't newline when
 *    overrunning, instead save the position and continue at that point
 *    when the next invocation.
 *
 *  In-line line breaking:
 *
 *  If TERMP_NOBREAK is specified and the line overruns the right
 *  margin, it will break and pad-right to the right margin after
 *  writing.  If maxrmargin is violated, it will break and continue
 *  writing from the right-margin, which will lead to the above scenario
 *  upon exit.  Otherwise, the line will break at the right margin.
d197 1
a197 1
			if (TERMP_NOBREAK & p->flags) {
@


1.219
log
@Support relative arguments to .ll (increase or decrease line length).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.218 2014/03/23 11:25:26 schwarze Exp $ */
d633 2
a645 1
			iop = 0;
d648 3
a650 2
		if ( ! a2roffsu(wstr, &su, SCALE_MAX)) {
			wstr = NULL;
a651 1
		}
a652 1
	width = (NULL != wstr) ? term_hspan(p, &su) : 0;
@


1.218
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.217 2014/03/13 19:23:50 schwarze Exp $ */
d626 30
@


1.217
log
@In -Tutf8 mode, make sure that hyphens get counted against the output line
length even when they are breakable.  Before this, a line containing N
breakable hyphens could get up to N characters wider than the right margin
in -Tutf8 output mode.
Issue reported by tedu@@ on <bugs at OpenBSD>.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.216 2014/01/22 20:58:39 schwarze Exp $ */
a25 1
#include <stdint.h>
d31 1
@


1.216
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.215 2013/12/31 18:07:42 schwarze Exp $ */
d186 7
a257 6
			if (ASCII_HYPH == p->buf[i]) {
				(*p->letter)(p, '-');
				p->viscol += (*p->width)(p, '-');
				continue;
			}

@


1.215
log
@remove assignments that will be overwritten right afterwards,
and remove pointless local variables;
found in a clang output from Ulrich Spoerlein <uqs at FreeBSD>
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.214 2013/12/25 00:39:31 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d182 2
a183 1
					ASCII_HYPH == p->buf[j])
d237 2
d650 2
a651 1
	static const char rej[] = { '\\', ASCII_HYPH, ASCII_NBRSP, '\0' };
d739 2
@


1.214
log
@Do not break output lines in .Fn function arguments in SYNOPSIS mode.
Following an idea from Franco Fichtner, but implemented more cleanly.
This reduces groff-mandoc-differences in OpenBSD base by a fantastic 7.5%.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.213 2013/12/24 23:04:36 schwarze Exp $ */
a661 1
		c = 0;
@


1.213
log
@Delete the unused flag TERMP_IGNDELIM
and the empty callback termp_igndelim_pre().
Sort the remaining termp flags.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.212 2013/12/23 02:20:09 schwarze Exp $ */
d410 1
d442 9
a450 1
			ssz = strcspn(word, "\\");
d525 1
@


1.212
log
@Implement a long-standing desideratum,
hanging indentation for .Fn in SYNOPSIS mode,
exploiting the new trailspace feature
by deliberately *NOT* using it.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.211 2013/12/22 23:34:13 schwarze Exp $ */
d432 1
a432 1
	p->flags &= ~(TERMP_SENTENCE | TERMP_IGNDELIM);
@


1.211
log
@Polishing the worms in my favourite can, term_flushln().

The TERMP_TWOSPACE flag i introduced in August 2009 was idiosyncratic
and served only a very narrow purpose.  Replace it by a more intuitive
and more general termp attribute "trailspace", to be used together
with TERMP_NOBREAK, to request a minimum amount of whitespace at
the end of the current column.  Adapt all code to the new interface.

No functional change intended;
code reviews to confirm that are welcome *eg*.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.210 2013/08/21 21:20:40 schwarze Exp $ */
d123 6
a128 1
	 * small set of values. 
d207 5
a211 1
			/* Remove the p->overstep width. */
d287 2
d290 1
a290 1
		if (p->overstep < 0)
@


1.210
log
@Move the last column-counting members of struct termp (col and maxcols)
from int to size_t, to match some existing ones (offset, *rmargin, viscol).
Move some related local variables from int to size_t as well.

Needed as a preparation to make a generalized adjbuf() function available
beyond the file term.c, i.e. in mandoc.c.
Also saves a couple of ugly casts.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.209 2013/08/08 20:07:47 schwarze Exp $ */
d86 2
a87 3
 *
 *  - TERMP_TWOSPACE: make sure there is room for at least two space
 *    characters of padding.  Otherwise, rather break the line.
d271 2
a272 2
		/* We need one blank after the tag. */
		p->overstep = (int)(vis - maxvis + (*p->width)(p, ' '));
d287 1
a287 2
	if (maxvis <= vis +
	    ((TERMP_TWOSPACE & p->flags) ? (*p->width)(p, ' ') : 0)) {
@


1.209
log
@Implement the roff(7) font-escape sequence \f(BI "bold+italic".
This improves the formatting of about 40 base manuals
and reduces groff-mandoc formatting differences in base by about 5%.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.208 2013/08/05 23:36:42 schwarze Exp $ */
d37 1
a37 1
static	void		 adjbuf(struct termp *p, int);
d108 1
a108 1
	int		 i;     /* current input position in p->buf */
d115 2
a116 2
	int		 j;     /* temporary loop index for p->buf */
	int		 jhy;	/* last hyph before overflow w/r/t j */
d219 1
a219 1
				dv = (size_t)(i - j) * (*p->width)(p, ' ');
d510 1
a510 1
adjbuf(struct termp *p, int sz)
d518 1
a518 2
	p->buf = mandoc_realloc
		(p->buf, sizeof(int) * (size_t)p->maxcols);
d568 1
a568 1
	int		  i, len;
a574 3
	/* LINTED */
	len = sz;

d582 3
a584 3
		if (p->col + len >= p->maxcols) 
			adjbuf(p, p->col + len);
		for (i = 0; i < len; i++)
d591 2
a592 2
	if (p->col + 1 + (len * 5) >= p->maxcols)
		adjbuf(p, p->col + 1 + (len * 5));
d594 1
a594 1
	for (i = 0; i < len; i++) {
@


1.208
log
@After a leading blank on an output line, the first word was counted twice
against vend, causing a premature line break.  Fix that bug by reverting
revision 1.93 which Kristaps committed four years ago.  Kristaps patch is no
longer needed because the code below  /* Write out the [remaining] word. */
now handles leading blanks correctly, probably already for a long time.

This avoids premature line breaks in about a dozen base system manuals,
for example as(1) and gdb(1), and alignment issues in another twenty,
for example mount(2), ip6(4), pfctl(8), and crypto(9).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.207 2013/05/29 15:17:52 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d483 3
d547 2
a548 2
	if (p->col + 4 >= p->maxcols)
		adjbuf(p, p->col + 4);
d552 1
a552 4
	if (TERMFONT_NONE == f) {
		p->buf[p->col++] = c;
		return;
	} else if (TERMFONT_UNDER == f) {
d554 9
a562 4
	} else
		p->buf[p->col++] = c;

	p->buf[p->col++] = 8;
a568 1
	enum termfont	  f;
d585 1
a585 1
	if (TERMFONT_NONE == (f = term_fonttop(p))) {
d595 2
a596 2
	if (p->col + 1 + (len * 3) >= p->maxcols)
		adjbuf(p, p->col + 1 + (len * 3));
d599 3
a601 10
		if (ASCII_HYPH != word[i] &&
		    ! isgraph((unsigned char)word[i])) {
			p->buf[p->col++] = word[i];
			continue;
		}

		if (TERMFONT_UNDER == f)
			p->buf[p->col++] = '_';
		else if (ASCII_HYPH == word[i])
			p->buf[p->col++] = '-';
a603 3

		p->buf[p->col++] = 8;
		p->buf[p->col++] = word[i];
@


1.207
log
@In keep mode, if any text is printed (even in NOSPACE mode),
any text that follows must be kept on the same line.

I already found the issue and wrote the patch in April 2011,
but didn't come round to do proper testing and forgot about it.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.206 2012/11/16 17:16:55 schwarze Exp $ */
d165 1
a165 1
			if ((j && ' ' == p->buf[j]) || '\t' == p->buf[j])
@


1.206
log
@Improve formatting of badly nested font blocks.
The basic idea is to already pop the font at the end marker
instead of allowing it to linger until the final end of the block.

This requires a few preliminaries:
* For each block, save a pointer to the previous font
  to be used in case the block breaks another and gets extended.
* That requires making node information writable during rendering.
* Now fonts may get popped in the wrong order; hence, after the stack
  has already been rewound further by some block that began earlier,
  ignore popping a font that was put on the stack later.
* To be able to exploit all this for font blocks, tie processing
  to their body, not their block, which is more logical anyway.

Triggered by florian@@ reporting vaguely similar issues with list blocks.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.205 2012/07/16 21:30:42 schwarze Exp $ */
a408 2
			if (TERMP_PREKEEP & p->flags)
				p->flags |= TERMP_KEEP;
d415 2
@


1.205
log
@In flush-left mode of both man(7) and mdoc(7), when an output line is broken
at the position of a literal tab, the tab indents the following line.
Fixes the perl(1) SYNOPSIS; reminded by deraadt@@; OpenBSD rev. 1.66.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.204 2012/07/10 15:35:41 schwarze Exp $ */
d379 1
a379 1
	while (p->fonti >= 0 && key != &p->fontq[p->fonti])
@


1.204
log
@Remove a hack that was intended for groff-1.15 bug compatibility:
When the width of a tag in .Bl -hang was exactly one character
shorter than the maximum length that would fit, the following text
would have a negative hang of one character (i.e., hang to the left).
That bug is no longer present in groff-1.21, so relax mandoc, too.
OpenBSD rev. 1.65
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.203 2012/05/31 22:29:13 schwarze Exp $ */
d109 1
d148 1
d153 1
d198 5
@


1.203
log
@Implement the roff \z escape sequence, intended to output the next
character without advancing the cursor position; implement it to
simply skip the next character, as it will usually be overwritten.

With this change, the pod2man(1) preamble user-defined string \*:,
intended to render as a diaeresis or umlaut diacritic above the
preceding character, is rendered in a slightly less ugly way,
though still not correctly.  It was rendered as "z.." and is now
rendered as ".".

Given that the definition of \*: uses elaborate manual \h positioning,
there is little chance for mandoc(1) to ever render it correctly,
but at least we can refrain from printing out a spurious "z", and
we can make the \z do something semi-reasonable for easier cases.

"just commit" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.202 2012/05/27 18:02:49 schwarze Exp $ */
a267 1
		 * Behave exactly the same way as groff:
a270 4
		 * If we landed right at the margin, be happy.
		 * If we are one step before the margin, temporarily
		 * move it one step LEFT and flag the rest of the line
		 * to be longer.
d272 1
a272 1
		if (p->overstep < -1)
@


1.202
log
@Fix the vertical spacing around tbl(7) instances in man(7).

Groff forces the document author to manually request sufficient spacing
after .TE - that is, at least .sp 1v after a table with the "box" option
and at least .sp 2v after a table with the "doublebox" option - or else
it clobbers the box.  I consider that insane, so i'm not imitating groff
in that respect.  Instead, i add at least as much vertical space as groff,
or more where required to avoid clobbering the box.

Consequently, output will be identical for input that looks sane with
groff, and mandoc will make output look better for input that looks bad
with groff.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.201 2011/09/21 09:57:13 schwarze Exp $ */
d36 1
d423 7
a429 1
		if ((ssz = strcspn(word, "\\")) > 0)
d431 1
a431 3

		word += (int)ssz;
		if ('\\' != *word)
d433 1
d489 3
a491 1
			if ('\0' == *word)
d494 3
d536 5
d564 5
d617 10
d632 1
a632 1
	int		 ssz, c;
d644 1
d648 1
a648 1
			sz += (*p->width)(p, *cp++);
d665 1
a665 1
					sz += (*p->width)(p, c);
d672 1
a672 1
					sz += (*p->width)(p, c);
d682 1
a682 1
				sz += (*p->width)(p, '?');
d687 1
a687 1
					sz += (*p->width)(p, c);
d699 3
d709 5
d718 1
a718 1
			sz += (*p->width)(p, ' ');
d722 1
a722 1
			sz += (*p->width)(p, '-');
@


1.201
log
@As noticed by kristaps@@, when breaking an overflowing line,
forget about pending whitespace (vbl), or the next line would
be misaligned and potentially too long; but i'm fixing this
in a simpler way than he proposed.
Also remove the kludges in .HP that compensated for this bug.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.200 2011/09/19 22:36:16 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d319 4
a322 1
	(*p->endline)(p);
@


1.200
log
@Remove the terminal frontend flag TERMP_NOLPAD.

In columnated contexts (.Bl -column, .Bl -tag, .IP, .TP, .HP etc.), do not
pad after writing a column.  Instead, always pad before writing content.

In itself, this change avoids:
 - writing trailing whitespace in some situations
 - with .fi/.nf in .HP, breaking lines that were already padded

It allows several bugfixes included in this patch:
 - Do not count backspace as a character with positive width.
 - Set up proper indentation when encountering .fi/.nf in .HP.
 - Adjust the .HP indentation width to what groff does.
 - Never unlimit the right margin unless in the final column.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.199 2011/09/18 21:18:19 schwarze Exp $ */
d187 1
d189 1
a189 2
				p->viscol = p->rmargin;
				(*p->advance)(p, p->rmargin);
d191 1
a191 2
			} else {
				p->viscol = 0;
a192 1
			}
@


1.199
log
@fix a regression introduced in 1.11.7:
even a breakable hyphen may be bold or underlined
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.198 2011/09/18 14:14:15 schwarze Exp $ */
a81 4
 *  - TERMP_NOLPAD: when beginning to write the line, don't left-pad the
 *    offset value.  This is useful when doing columnar lists where the
 *    prior column has right-padded.
 *
d83 2
a84 2
 *    columns.  In short: don't print a newline and instead pad to the
 *    right margin.  Used in conjunction with TERMP_NOLPAD.
d86 2
a87 2
 *  - TERMP_TWOSPACE: when padding, make sure there are at least two
 *    space characters of padding.  Otherwise, rather break the line.
d93 1
a93 1
 *    overruning, instead save the position and continue at that point
d133 1
a133 1
	 * Indent the first line of a paragraph.
d135 2
a136 1
	vbl = p->flags & TERMP_NOLPAD ? (size_t)0 : p->offset;
d236 7
a242 2
			} else {
				(*p->letter)(p, p->buf[i]);
a243 1
			}
d252 2
a253 1
	vis -= vbl;
d278 1
a278 4
		if (p->overstep >= -1) {
			assert((int)maxvis + p->overstep >= 0);
			maxvis += (size_t)p->overstep;
		} else
d280 1
d285 2
a286 2
	/* Right-pad. */
	if (maxvis > vis +
a287 4
		p->viscol += maxvis - vis;
		(*p->advance)(p, maxvis - vis);
		vis += (maxvis - vis);
	} else {	/* ...or newline break. */
d289 1
a289 2
		p->viscol = p->rmargin;
		(*p->advance)(p, p->rmargin);
d304 2
a305 6
	if (0 == p->col && 0 == p->viscol) {
		p->flags &= ~TERMP_NOLPAD;
		return;
	}
	term_flushln(p);
	p->flags &= ~TERMP_NOLPAD;
@


1.198
log
@forgotten Copyright bumps; no code change
found while syncing to OpenBSD
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.197 2011/05/24 21:31:23 kristaps Exp $ */
d579 2
a580 1
		if ( ! isgraph((unsigned char)word[i])) {
d587 2
@


1.197
log
@Remove all references to ESCAPE_PREDEF, which is now not exposed passed
the libroff point.  This clears up a nice chunk of code.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.196 2011/05/20 15:44:55 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.196
log
@Allow non-ASCII terminal encodings to accept unicode values for the
special characters, if possible.  This is broken into a separate switch
statement for clarity.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.195 2011/05/18 23:59:08 kristaps Exp $ */
a449 6
			case (ESCAPE_PREDEF):
				uc = mchars_res2cp(p->symtab, seq, sz);
				if (uc <= 0)
					break;
				encode1(p, uc);
				continue;
a468 5
		case (ESCAPE_PREDEF):
			cp = mchars_res2str(p->symtab, seq, sz, &ssz);
			if (NULL != cp)
				encode(p, cp, ssz);
			break;
a639 7
				case (ESCAPE_PREDEF):
					c = mchars_res2cp
						(p->symtab, seq, ssz);
					if (c <= 0)
						break;
					sz += (*p->width)(p, c);
					continue;
a661 4
			case (ESCAPE_PREDEF):
				rhs = mchars_res2str
					(p->symtab, seq, ssz, &rsz);
				break;
@


1.195
log
@Make any un-recognised font be considered a call for the Roman font.
This makes sequences of \f[unknown] \fP not completely puke.  From a
TODO by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.194 2011/05/17 22:32:45 kristaps Exp $ */
d442 24
d468 1
a468 7
			if (TERMENC_ASCII == p->enc) {
				encode1(p, '?');
				break;
			}
			uc = mchars_num2uc(seq + 1, sz - 1);
			if ('\0' != uc)
				encode1(p, uc);
d471 2
a472 1
			if ('\0' != (c = mchars_num2char(seq, sz)))
d619 1
d638 2
a639 3
			rhs = NULL;
			switch (mandoc_escape(&cp, &seq, &ssz)) {
			case (ESCAPE_ERROR):
d641 25
a665 3
			case (ESCAPE_UNICODE):
				if (TERMENC_ASCII != p->enc) {
					sz += (*p->width)(p, '?');
d668 6
a673 3
				c = mchars_num2uc(seq + 1, ssz - 1);
				if ('\0' != c)
					sz += (*p->width)(p, c);
@


1.194
log
@Locale support.  I'm checking this in to clean up fall-out in-tree, but
it looks pretty good.  Basically, the -Tlocale option propogates into
term_ascii.c, where we set locale-specific console call-backs IFF (1)
setlocale() works; (2) locale support is compiled in (see Makefile for
-DUSE_WCHAR); (3) the internal structure of wchar_t maps directly to
Unicode codepoints as defined by __STDC_ISO_10646__; and (4) the console
supports multi-byte characters.

To date, this configuration only supports GNU/Linux.  OpenBSD doesn't
export __STDC_ISO_10646__ although I'm told by stsp@@openbsd.org that it
should (it has the correct map).  Apparently FreeBSD is the same way.
NetBSD?  Don't know.  Apple also supports this, but doesn't define the
macro.  Special-casing!

Benchmark: -Tlocale incurs less than 0.2 factor overhead when run
through several thousand manuals when UTF8 output is enabled.  Native
mode (whether directly -Tascii or through no locale or whatever) is
UNCHANGED: the function callbacks are the same as before.

Note.  If the underlying system does NOT support STDC_ISO_10646, there
is a "slow" version possible with iconv or other means of flipping from
a Unicode codepoint to a wchar_t.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.193 2011/05/17 14:38:34 kristaps Exp $ */
d474 2
@


1.193
log
@Add mode for -Tlocale.  This mode, with this commit, behaves exactly
like -Tascii.  While adding this, inline term_alloc() (was a one-liner),
remove some switches around the terminal encoding for the symbol table
(unnecessary), and split out ascii_alloc() into ascii_init(), which is
also called from locale_init().
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.192 2011/05/17 11:55:08 kristaps Exp $ */
d39 1
d407 1
a407 1
	int		 sz;
d444 7
a450 1
			encode(p, "?", 1);
d513 27
d621 8
a628 2
				c = '?';
				/* FALLTHROUGH */
d630 1
a630 2
				if ('\0' != c)
					c = mchars_num2char(seq, ssz);
@


1.192
log
@Flip on printing `?' at Unicode codepoints in -Tascii, -Tpdf, and -Tps.
The reasoning behind printing SOMETHING at a Unicode codepoint is
because the input is not "wrong" (we suppress printing of "wrong"
things).  It's just that ASCII can't handle it.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.191 2011/05/15 22:29:50 kristaps Exp $ */
a71 12

struct termp *
term_alloc(enum termenc enc)
{
	struct termp	*p;

	p = mandoc_calloc(1, sizeof(struct termp));
	p->enc = enc;
	return(p);
}


@


1.191
log
@Remove function calls to res() and so forth in term_word().  These were
only used once and simply bloated the binary.  Also fix mchars_num2char
to correctly render the character instead of using atoi().  This makes
the conversation more strict, but it's more correct.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.190 2011/05/15 15:47:46 kristaps Exp $ */
d454 3
d590 1
d598 3
d602 2
a603 1
				c = mchars_num2char(seq, ssz);
@


1.190
log
@Fix missing support for \N'n' when calculating string widths in -Tascii
(oops).  Do the same for -Thtml (oops^2).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.189 2011/05/15 14:50:01 kristaps Exp $ */
d36 3
a38 6
static	void		  spec(struct termp *, const char *, size_t);
static	void		  res(struct termp *, const char *, size_t);
static	void		  bufferc(struct termp *, char);
static	void		  adjbuf(struct termp *p, int);
static	void		  encode(struct termp *, const char *, size_t);

a343 37

static void
numbered(struct termp *p, const char *word, size_t len)
{
	char		 c;

	if ('\0' != (c = mchars_num2char(word, len)))
		encode(p, &c, 1);
}


static void
spec(struct termp *p, const char *word, size_t len)
{
	const char	*rhs;
	size_t		 sz;

	rhs = mchars_spec2str(p->symtab, word, len, &sz);
	if (rhs) 
		encode(p, rhs, sz);
	else if (1 == len)
		encode(p, word, len);
}


static void
res(struct termp *p, const char *word, size_t len)
{
	const char	*rhs;
	size_t		 sz;

	rhs = mchars_res2str(p->symtab, word, len, &sz);
	if (rhs)
		encode(p, rhs, sz);
}


a407 1

d416 2
a417 1
	const char	*seq;
d455 2
a456 1
			numbered(p, seq, sz);
d459 3
a461 1
			res(p, seq, sz);
d464 5
a468 1
			spec(p, seq, sz);
a491 1

a504 1

a514 1

a558 1

@


1.189
log
@Use strcspn() in term_strlen().  Clarifies the code.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.188 2011/05/14 18:15:20 kristaps Exp $ */
d608 1
a608 1
	int		 ssz;
d627 1
d631 5
a650 1
				rhs = NULL;
@


1.188
log
@Make some values "int" that were "size_t".  These are primarily used for
indexing into arrays, so this removes lots of casts from size_t to int.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.187 2011/05/14 17:54:42 kristaps Exp $ */
a608 1
	enum mandoc_esc	 esc;
d610 1
d619 5
a623 1
	while ('\0' != *cp)
d626 3
a628 3
			++cp;
			esc = mandoc_escape(&cp, &seq, &ssz);
			if (ESCAPE_ERROR == esc)
a629 2

			switch (esc) {
a663 1
			sz += (*p->width)(p, *cp++);
d666 1
a670 1

a706 1

@


1.187
log
@Make character engine (-Tascii, -Tpdf, -Tps) ready for Unicode: make buffer
consist of type "int".  This will take more work (especially in encode and
friends), but this is a strong start.  This commit also consists of some
harmless lint fixes.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.186 2011/04/30 22:24:31 kristaps Exp $ */
d39 1
a39 1
static	void		  adjbuf(struct termp *p, size_t);
d158 1
a158 1
	while (i < (int)p->col) {
d163 1
a163 1
		while (i < (int)p->col && '\t' == p->buf[i]) {
d177 1
a177 1
		for (j = i, jhy = 0; j < (int)p->col; j++) {
d220 1
a220 1
		for ( ; i < (int)p->col; i++) {
d527 1
a527 1
adjbuf(struct termp *p, size_t sz)
d535 2
a536 1
	p->buf = mandoc_realloc(p->buf, sizeof(int) * p->maxcols);
d547 1
a547 1
	p->buf[(int)p->col++] = c;
d555 4
a558 1
	int		  i;
d567 4
a570 4
		if (p->col + sz >= p->maxcols) 
			adjbuf(p, p->col + sz);
		for (i = 0; i < (int)sz; i++)
			p->buf[(int)p->col++] = word[i];
d576 2
a577 2
	if (p->col + 1 + (sz * 3) >= p->maxcols)
		adjbuf(p, p->col + 1 + (sz * 3));
d579 3
a581 3
	for (i = 0; i < (int)sz; i++) {
		if ( ! isgraph((u_char)word[i])) {
			p->buf[(int)p->col++] = word[i];
d586 1
a586 1
			p->buf[(int)p->col++] = '_';
d588 1
a588 1
			p->buf[(int)p->col++] = word[i];
d590 2
a591 2
		p->buf[(int)p->col++] = 8;
		p->buf[(int)p->col++] = word[i];
@


1.186
log
@Make mchars_num2char() return a char like it says.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.185 2011/04/29 22:18:12 kristaps Exp $ */
d535 1
a535 1
	p->buf = mandoc_realloc(p->buf, p->maxcols);
d565 2
a566 2
		memcpy(&p->buf[(int)p->col], word, sz);
		p->col += sz;
@


1.185
log
@Move "chars" interface out of out.h and into mandoc.h.  This doesn't
change any code but for renaming functions and types to be consistent
with other mandoc.h stuff.  The reason for moving into libmandoc is that
the rendering of special characters is part of mandoc itself---not an
external part.  From mandoc(1)'s perspective, this changes nothing, but
for other utilities, it's important to have these part of libmandoc.
Note this isn't documented [yet] in mandoc.3 because there are some
parts I'd like to change around beforehand.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.184 2011/04/09 15:29:40 kristaps Exp $ */
d351 1
a351 1
	const char	*rhs;
d353 2
a354 3
	rhs = mchars_num2char(word, len);
	if (rhs) 
		encode(p, rhs, 1);
@


1.184
log
@Remove a2roffdeco() and mandoc_special() functions and replace them with
a public (mandoc.h) function mandoc_escape(), which merges the
functionality of both prior functions.

Reason: code duplication.  The a2roffdeco() and mandoc_special()
functions were pretty much the same thing and both quite complex.  This
allows one function to receive improvements in (e.g.) subexpression
handling and performance, instead of having to replicate functionality.

As such, the mandoc_escape() function already handles a superset of the
escapes handled in previous versions and has improvements in performance
(using strcspn(), for example) and reliable handling of subexpressions.

This code Works For Me, but may need work to catch any regressions.
Since the benefits are great (leaner code, simpler API), I'd rather have
it in-tree than floating as a patch.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.183 2011/04/04 21:14:12 kristaps Exp $ */
d50 1
a50 1
		chars_free(p->symtab);
d353 1
a353 1
	rhs = chars_num2char(word, len);
d365 1
a365 1
	rhs = chars_spec2str(p->symtab, word, len, &sz);
d379 1
a379 1
	rhs = chars_res2str(p->symtab, word, len, &sz);
d626 1
a626 1
				rhs = chars_res2str
d630 1
a630 1
				rhs = chars_spec2str
@


1.183
log
@Remove an unused variable (caught in lint-check)
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.182 2011/03/22 14:05:45 kristaps Exp $ */
d36 1
a36 2
static	void		  spec(struct termp *, enum roffdeco,
				const char *, size_t);
d360 1
a360 1
spec(struct termp *p, enum roffdeco d, const char *word, size_t len)
d368 1
a368 1
	else if (DECO_SSPECIAL == d)
d459 1
d461 1
a461 1
	enum roffdeco	 deco;
d481 1
a481 1
	while (*word) {
d489 4
a492 2
		seq = ++word;
		word += a2roffdeco(&deco, &seq, &ssz);
d494 9
a502 11
		switch (deco) {
		case (DECO_NUMBERED):
			numbered(p, seq, ssz);
			break;
		case (DECO_RESERVED):
			res(p, seq, ssz);
			break;
		case (DECO_SPECIAL):
			/* FALLTHROUGH */
		case (DECO_SSPECIAL):
			spec(p, deco, seq, ssz);
d504 1
a504 1
		case (DECO_BOLD):
d507 1
a507 1
		case (DECO_ITALIC):
d510 1
a510 1
		case (DECO_ROMAN):
d513 1
a513 1
		case (DECO_PREVIOUS):
d516 4
a522 3

		if (DECO_NOSPACE == deco && '\0' == *word)
			p->flags |= TERMP_NOSPACE;
d604 3
a606 2
	size_t		 sz, ssz, rsz, i;
	enum roffdeco	 d;
d609 14
a622 9
	for (sz = 0; '\0' != *cp; )
		/*
		 * Account for escaped sequences within string length
		 * calculations.  This follows the logic in term_word()
		 * as we must calculate the width of produced strings.
		 */
		if ('\\' == *cp) {
			seq = ++cp;
			cp += a2roffdeco(&d, &seq, &ssz);
d624 2
a625 2
			switch (d) {
			case (DECO_RESERVED):
d629 1
a629 3
			case (DECO_SPECIAL):
				/* FALLTHROUGH */
			case (DECO_SSPECIAL):
d633 1
a633 2
				/* Allow for one-char escapes. */
				if (DECO_SSPECIAL != d || rhs)
d644 7
a650 4
			if (rhs)
				for (i = 0; i < rsz; i++)
					sz += (*p->width)(p, *rhs++);
		} else if (ASCII_NBRSP == *cp) {
d653 2
a654 1
		} else if (ASCII_HYPH == *cp) {
d657 2
a658 1
		} else
d660 2
@


1.182
log
@Move mandoc_isdelim() back into libmdoc.h.  This fixes an unreported
error where (1) -man pages were punctuating delimiters (e.g., `.B a ;')
and where (2) standalone punctuation in -mdoc or -man (e.g., ";" on its
own line) would also be punctuated.  This introduces a small amount of
complexity of mdoc_{html,term}.c must manage their own spacing with
running print_word() or print_text().  The check for delimiting now
happens in mdoc_macro.c's dword().
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.181 2011/03/22 10:13:01 kristaps Exp $ */
d459 1
a459 1
	const char	*sv, *seq;
a462 2
	sv = word;

@


1.181
log
@Step 4: merge chars.h into out.h.  The functions in this file are
necessary to all [real] front-ends, so stop pretending it's special.
While here, add some documentation to the variable types.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.180 2011/03/17 09:16:38 kristaps Exp $ */
a464 4
	if (DELIM_CLOSE == mandoc_isdelim(word))
		if ( ! (TERMP_IGNDELIM & p->flags))
			p->flags |= TERMP_NOSPACE;

a524 3

	if (DELIM_OPEN == mandoc_isdelim(sv))
		p->flags |= TERMP_NOSPACE;
@


1.180
log
@Move mdoc_isdelim() into mandoc.h as mandoc_isdelim().  This allows the
removal of manual delimiter checks in html.c and term.c.  Finally, add
the escaped period as a closing delimiter, removing a TODO to this
effect.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.179 2011/03/17 08:49:34 kristaps Exp $ */
a31 1
#include "chars.h"
@


1.179
log
@Move mandoc_{realloc,malloc,calloc} out of libmandoc.h and into mandoc.h
so that everybody can use them.  This follows the convention of
libXXXX.h being internal to a library and XXXX.h being the external
interface.  Not only does this allow the removal of lots of redundant
NULL-checking code, it also sets the tone for adding new mandoc-global
routines.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.178 2011/03/15 16:23:51 kristaps Exp $ */
d466 3
a468 23
	if (word[0] && '\0' == word[1])
		switch (word[0]) {
		case('.'):
			/* FALLTHROUGH */
		case(','):
			/* FALLTHROUGH */
		case(';'):
			/* FALLTHROUGH */
		case(':'):
			/* FALLTHROUGH */
		case('?'):
			/* FALLTHROUGH */
		case('!'):
			/* FALLTHROUGH */
		case(')'):
			/* FALLTHROUGH */
		case(']'):
			if ( ! (TERMP_IGNDELIM & p->flags))
				p->flags |= TERMP_NOSPACE;
			break;
		default:
			break;
		}
d531 2
a532 14
	/* 
	 * Note that we don't process the pipe: the parser sees it as
	 * punctuation, but we don't in terms of typography.
	 */
	if (sv[0] && '\0' == sv[1])
		switch (sv[0]) {
		case('('):
			/* FALLTHROUGH */
		case('['):
			p->flags |= TERMP_NOSPACE;
			break;
		default:
			break;
		}
@


1.178
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.177 2011/01/30 16:05:37 schwarze Exp $ */
d83 1
a83 6
	p = calloc(1, sizeof(struct termp));
	if (NULL == p) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}

d577 1
a577 5
	p->buf = realloc(p->buf, p->maxcols);
	if (NULL == p->buf) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.177
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ jmc@@ and tested by Matthieu Herrb (matthieu at openbsd dot org)
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.176 2011/01/04 13:14:26 kristaps Exp $ */
d517 1
a517 1
		word += ssz;
@


1.176
log
@Fix spacing for tables to use term_len().  Also make term.c properly
recode ASCII_HYPHEN and ASCII_NBRSP before passing back for widths.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.175 2010/12/06 13:25:25 kristaps Exp $ */
d4 1
a4 1
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d356 11
d525 3
@


1.175
log
@Track down a bug of empty `de XX' macros causing uncertain behaviour by
returning empty strings in roff_getstrn() instead of NULL.  This caused
maddeningly irregular segfaults in the pod2man preamble for `de IX'.
But only on DEC alpha.

Also integrate the kinda-probably-safe assertion relaxation in term.c,
field-tested by schwarze@@.  This allows ALL [unpreprocessed] base and
xenocara manuals for all BSD systems to run without segfault.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.174 2010/10/02 15:15:55 schwarze Exp $ */
d680 6
@


1.174
log
@style cleanup, no functional change:
* make the initial maxvis/mmax calculation easier to understand
* where real, non-indexing casts happen, make them explicit
* avoid a few lint warnings that can easily be fixed
* remove one needless LINTED comment
"I like this" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.173 2010/10/01 21:51:13 schwarze Exp $ */
d149 1
a149 1
	assert  (p->rmargin > p->offset);
@


1.173
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.172 2010/09/23 20:26:00 schwarze Exp $ */
d149 5
a153 9

	assert(p->offset < p->rmargin);

	maxvis = (int)(p->rmargin - p->offset) - p->overstep < 0 ?
		/* LINTED */ 
		0 : p->rmargin - p->offset - p->overstep;
	mmax = (int)(p->maxrmargin - p->offset) - p->overstep < 0 ?
		/* LINTED */
		0 : p->maxrmargin - p->offset - p->overstep;
d160 1
a160 1
	vbl = p->flags & TERMP_NOLPAD ? 0 : p->offset;
d162 2
a163 1
	vis = vend = i = 0;
a183 1
		/* LINTED */
d222 1
a222 2
			bp += (int)/* LINTED */
				p->overstep;
d236 1
a236 1
				dv = (i - j) * (*p->width)(p, ' ');
d285 1
a285 2
		p->overstep = /* LINTED */
			vis - maxvis + (*p->width)(p, ' ');
d299 1
a299 2
			/* LINTED */
			maxvis += p->overstep;
d307 2
a308 3
	if (maxvis > vis + /* LINTED */
			((TERMP_TWOSPACE & p->flags) ? 
			 (*p->width)(p, ' ') : 0)) {
@


1.172
log
@Count trailing escaped blanks correctly;
those ruined the alignment of columns.
Tested by jmc@@, and kristaps@@ agrees with the direction.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.49 2010/08/20 23:34:00 schwarze Exp $ */
d508 1
a508 1
	p->flags &= ~TERMP_SENTENCE;
@


1.171
log
@Allow string lengths to account for escapes.  Now all calls to calculate
column width in -Tascii, -Tpdf, and -Tps will account for "more real"
string lengths.

Example:

.Bl -tag -width \s[+123424]foo
.It bar
baz
.El

The size escape will be correctly tossed.

.Bl -tag -width \(aqbar
.It \(aqbar
baz
.El

The \(aq will be correctly handled.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.170 2010/09/04 20:18:53 kristaps Exp $ */
d137 1
d241 3
a243 1
				vbl += (i - j) * (*p->width)(p, ' ');
a269 1
		vend += vbl;
@


1.170
log
@Churny commit to quiet lint.  No functional changes.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.169 2010/08/20 23:34:02 schwarze Exp $ */
a460 1
	int		 sz;
d517 1
a517 1
		sz = a2roffdeco(&deco, &seq, &ssz);
a543 1
		word += sz;
d646 36
a681 1
	size_t		 sz;
d683 5
a687 2
	for (sz = 0; *cp; cp++)
		sz += (*p->width)(p, *cp);
@


1.169
log
@Centralize handling of literal tabs in term_flushln() in one place,
making the code simpler and easier to understand.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.168 2010/08/20 23:22:09 schwarze Exp $ */
d86 1
a86 1
		exit(MANDOCLEVEL_SYSERR);
d579 1
a579 1
		exit(MANDOCLEVEL_SYSERR);
@


1.168
log
@When a column contains trailing spaces, calculate the padding
to the start of the next column correctly.
Fixing a problem found by jmc@@ in sysctl(3), reminded by kettenis@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.167 2010/08/20 01:02:07 schwarze Exp $ */
d172 1
a172 3
		for (j = i; j < (int)p->col; j++) {
			if ('\t' != p->buf[j])
				break;
d176 1
d187 1
a187 1
		for (jhy = 0; j < (int)p->col; j++) {
a229 6
		/*
		 * Skip leading tabs, they were handled above.
		 */
		while (i < (int)p->col && '\t' == p->buf[i])
			i++;

@


1.167
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.166 2010/07/26 22:26:05 kristaps Exp $ */
d278 6
@


1.166
log
@Make `Sm' start no-spacing after the first output word.  Fix in both
-T[x]html and -T{pdf,ps,ascii}.  Reported by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.165 2010/07/26 21:58:41 kristaps Exp $ */
d86 1
a86 1
		exit(EXIT_FAILURE);
d580 1
a580 1
		exit(EXIT_FAILURE);
@


1.165
log
@Clean up some tight spots in mandoc's default mode: pessimistically
pre-allocate the output buffer for words and in-line the buffera()
function, which was only called in one place anyway.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.164 2010/07/25 22:56:47 kristaps Exp $ */
d505 2
@


1.164
log
@Avoid running the "width" termp callback for each whitespace.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.163 2010/07/21 20:35:03 kristaps Exp $ */
a39 1
static	void		  buffera(struct termp *, const char *, size_t);
a583 12
buffera(struct termp *p, const char *word, size_t sz)
{

	if (p->col + sz >= p->maxcols) 
		adjbuf(p, p->col + sz);

	memcpy(&p->buf[(int)p->col], word, sz);
	p->col += sz;
}


static void
d607 4
a610 1
		buffera(p, word, sz);
d614 5
d621 1
a621 1
			bufferc(p, word[i]);
d626 1
a626 1
			bufferc(p, '_');
d628 1
a628 1
			bufferc(p, word[i]);
d630 2
a631 2
		bufferc(p, 8);
		bufferc(p, word[i]);
@


1.163
log
@Accomodate for groff's crappy behaviour wherein an unrecognised
single-character escape (and ONLY this type of escape) will map back
into itself:

       "If a backslash is followed by a character that does not
	constitute a defined escape sequence the backslash is silently
        ignored and the  character maps to itself."

(From groff.7.)

Found by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.162 2010/07/17 12:01:43 kristaps Exp $ */
d245 2
a246 2
				while (' ' == p->buf[i]) {
					vbl += (*p->width)(p, p->buf[i]);
d248 1
a248 1
				}
@


1.162
log
@Avoid letter-by-letter encoding by using strcspn() in term_word().
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.161 2010/07/16 22:33:30 kristaps Exp $ */
d37 2
a38 1
static	void		  spec(struct termp *, const char *, size_t);
d364 1
a364 1
spec(struct termp *p, const char *word, size_t len)
d372 2
d525 3
a527 1
			spec(p, seq, ssz);
@


1.161
log
@Change chars.in HTML encoding to be a Unicode codepoint (int), which is
later formatted in html.c.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.160 2010/07/07 15:04:54 kristaps Exp $ */
d506 3
a508 1
	/* FIXME: use strcspn. */
d510 2
a511 4
	while (*word) {
		if ('\\' != *word) {
			encode(p, word, 1);
			word++;
a512 1
		}
d549 1
a549 1
	if (sv[0] && 0 == sv[1])
@


1.160
log
@Re-constitution of `ds' symbol processing.  First, push the
roff_getstr() family of functions into roff.c with the "first_string"
directly in struct roff.  Second, pre-process each line for reserved
words in libroff, splicing and re-running a line if it has one (this
allows defined symbols to be macros).  Remove term.c's invocation of the
roff_getstrn() function.  Removed function documentation in roff.3 and
added roff.7 `ds' documentation.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.159 2010/07/04 22:04:04 schwarze Exp $ */
d368 1
a368 1
	rhs = chars_a2ascii(p->symtab, word, len, &sz);
d380 1
a380 1
	rhs = chars_a2res(p->symtab, word, len, &sz);
@


1.159
log
@Assert my copyright, making it explicit that i'm granting the same license
on those parts of the code and text that i have written as Kristaps is.
"fine with me" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.158 2010/07/03 16:02:12 schwarze Exp $ */
a33 1
#include "regs.h"
a380 5
	if (NULL == rhs) {
		rhs = roff_getstrn(word, len);
		if (rhs)
			sz = strlen(rhs);
	}
@


1.158
log
@Rudimentary implementation of user-defined strings;
no time for more refinement right now.
In particular, fixes terminfo(3) and mdoc.samples(7).
ok kristaps@@, who will add the HTML frontend bits
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.157 2010/07/02 10:50:50 kristaps Exp $ */
d3 2
a4 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.157
log
@Lint tweak.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.156 2010/06/30 12:30:36 kristaps Exp $ */
d33 1
d381 5
@


1.156
log
@Pushed normalisation of scaling units into term_hspan().
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.155 2010/06/30 12:27:55 kristaps Exp $ */
d656 1
@


1.155
log
@Move term_hspan() calculation into the output devices, where it belongs.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.154 2010/06/28 23:26:09 kristaps Exp $ */
d695 1
d697 5
a701 1
	return((*p->hspan)(p, su));
@


1.154
log
@Clean-up of variable-width glyph support.  Adds no new code; only
restructured to make a bit more readable.  Also removed an unused entry
in the PS engine structure.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.153 2010/06/28 22:46:21 kristaps Exp $ */
a694 3
	double		 r;

	/* XXX: CM, IN, and PT are approximations. */
d696 1
a696 29
	switch (su->unit) {
	case (SCALE_CM):
		r = 4 * su->scale;
		break;
	case (SCALE_IN):
		/* XXX: this is an approximation. */
		r = 10 * su->scale;
		break;
	case (SCALE_PC):
		r = (10 * su->scale) / 6;
		break;
	case (SCALE_PT):
		r = (10 * su->scale) / 72;
		break;
	case (SCALE_MM):
		r = su->scale / 1000; /* FIXME: double-check. */
		break;
	case (SCALE_VS):
		r = su->scale * 2 - 1; /* FIXME: double-check. */
		break;
	default:
		r = su->scale;
		break;
	}

	if (r < 0.0)
		r = 0.0;
	return((size_t)/* LINTED */
			r);
a697 2


@


1.153
log
@This enables variable glyph-width output.  The checkin will be followed
by a [functionless] clean-up in term_ps.c, but this makes the
appropriate changes to "enable" initial proportional-width functionality
in term.c and fixes some areas of term_ps.c that were causing errors.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.152 2010/06/28 09:48:44 kristaps Exp $ */
d164 1
a164 4
	/* 
	 * FIXME: if bp is zero, we still output the first word before
	 * breaking the line.
	 */
a165 1
	vis = vend = i = 0;
a166 1

d168 2
a169 1
		 * Handle literal tab characters.
d174 1
a174 1
			vend = (vis/p->tabwidth+1)*p->tabwidth;
d190 3
a192 6
			if (8 != p->buf[j]) {
				if (vend > vis && vend < bp &&
				    ASCII_HYPH == p->buf[j])
					jhy = j;
				vend += (*p->width)(p, p->buf[j]);
			} else {
d195 1
d197 8
d313 2
a314 1
			((TERMP_TWOSPACE & p->flags) ? (*p->width)(p, ' ') : 0)) {
@


1.152
log
@Tiny commit clarifying flushln() documentation as to what refers to
visual screen output and what's an array index (getting closer to
variable-width fonting).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.151 2010/06/27 01:26:20 schwarze Exp $ */
d198 5
a202 3
				vend++;
			} else
				vend--;
d242 1
a242 1
					vbl++;
d248 1
a248 1
				vbl++;
d263 1
a263 1
			if (ASCII_HYPH == p->buf[i])
d265 2
a266 1
			else
d268 2
a269 2

			p->viscol += 1;
d287 1
a287 1
			vis - maxvis + 1;
d311 1
a311 1
			((TERMP_TWOSPACE & p->flags) ? 1 : 0)) {
@


1.151
log
@Basic implementation of .Bk/.Ek; from OpenBSD.
OK and one stylistic tweak by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.150 2010/06/26 15:36:37 kristaps Exp $ */
d136 4
a139 3
	int		 j;     /* temporary loop index */
	int		 jhy;	/* last hyphen before line overflow */
	size_t		 maxvis, mmax;
@


1.150
log
@Churn-ish check-in getting mdoc_parseln() and man_parseln() to accept a
const struct regset pointer.  No functionality.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.149 2010/06/25 18:53:14 kristaps Exp $ */
d483 3
a485 2
		bufferc(p, ' ');
		if (TERMP_SENTENCE & p->flags)
d487 4
@


1.149
log
@Initial chunks for variable-width fonts.  Pushes all width calculations
in mdoc_term.c and man_term.c down into term.c.  This is still not
implemented in term.c, although stubs for width calculations are in
place.  From now on, offset, rmargin, and other layout variables are
abstract screen widths.  They will resolve to the the familiar values
for -Tascii but -Tps will eventually use points instead of chars.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.148 2010/06/19 20:46:28 kristaps Exp $ */
a33 2
#include "man.h"
#include "mdoc.h"
@


1.148
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.147 2010/06/11 07:23:04 kristaps Exp $ */
a89 1
	p->tabwidth = 5;
a90 1
	p->defrmargin = 78;
d627 21
a647 1
term_vspan(const struct roffsu *su)
d683 1
a683 1
term_hspan(const struct roffsu *su)
@


1.147
log
@Teach -Tps to ignore backspace-encoding by using a one-char buffer and a
simple state machine.  This paves the way for decorated text.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.146 2010/06/08 15:00:17 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.146
log
@Broke ascii_*() functions into term_ascii.c

Made low-level engine functions into function pointers.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.145 2010/06/08 13:22:37 kristaps Exp $ */
d606 1
a606 4
	if (TERMTYPE_PS == p->type) {
		buffera(p, word, sz);
		return;
	} else if (TERMFONT_NONE == (f = term_fonttop(p))) {
@


1.145
log
@No functionality changes: just restructuring.  Deprecated
terminal_free() in favour of ps_free() and ascii_free().  Moved ps_*()
functions into term_ps.c so that they don't clutter up term.c.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.144 2010/06/08 09:20:08 kristaps Exp $ */
a24 1
#include <getopt.h>
a28 1
#include <time.h>
a37 8
#define	PS_CHAR_WIDTH	  6
#define	PS_CHAR_HEIGHT	  12
#define	PS_CHAR_TOPMARG	 (792 - 24)
#define	PS_CHAR_TOP	 (PS_CHAR_TOPMARG - 36)
#define	PS_CHAR_LEFT	  36
#define	PS_CHAR_BOTMARG	  24
#define	PS_CHAR_BOT	 (PS_CHAR_BOTMARG + 36)

a43 44
static	void		  advance(struct termp *, size_t);
static	void		  endline(struct termp *);
static	void		  letter(struct termp *, char);
static	void		  pageopen(struct termp *);


void *
ascii_alloc(char *outopts)
{
	struct termp	*p;
	const char	*toks[2];
	char		*v;

	if (NULL == (p = term_alloc(TERMENC_ASCII)))
		return(NULL);

	p->type = TERMTYPE_CHAR;

	toks[0] = "width";
	toks[1] = NULL;

	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case (0):
			p->defrmargin = (size_t)atoi(v);
			break;
		default:
			break;
		}

	/* Enforce a lower boundary. */
	if (p->defrmargin < 58)
		p->defrmargin = 58;

	return(p);
}


void
ascii_free(void *arg)
{

	term_free((struct termp *)arg);
}
a58 55
/*
 * Push a single letter into our output engine.
 */
static void
letter(struct termp *p, char c)
{
	
	if (TERMTYPE_CHAR == p->type) {
		/*
		 * If using the terminal device, just push the letter
		 * out into the screen.
		 */
		putchar(c);
		return;
	}

	if ( ! (PS_INLINE & p->psstate)) {
		/*
		 * If we're not in a PostScript "word" context, then
		 * open one now at the current cursor.
		 */
		printf("%zu %zu moveto\n", p->pscol, p->psrow);
		putchar('(');
		p->psstate |= PS_INLINE;
	}

	/*
	 * We need to escape these characters as per the PostScript
	 * specification.  We would also escape non-graphable characters
	 * (like tabs), but none of them would get to this point and
	 * it's superfluous to abort() on them.
	 */

	switch (c) {
	case ('('):
		/* FALLTHROUGH */
	case (')'):
		/* FALLTHROUGH */
	case ('\\'):
		putchar('\\');
		break;
	default:
		break;
	}

	/* Write the character and adjust where we are on the page. */
	putchar(c);
	p->pscol += PS_CHAR_WIDTH;
}


/*
 * Begin a "terminal" context.  Since terminal encompasses PostScript,
 * the actual terminal, etc., there are a few things we can do here.
 */
d67 1
a67 58

	if (TERMTYPE_CHAR == p->type) {
		/* Emit the header and be done. */
		(*p->headf)(p, p->argf);
		return;
	}
	
	/*
	 * Emit the standard PostScript prologue, set our initial page
	 * position, then run pageopen() on the initial page.
	 */

	printf("%s\n", "%!PS");
	printf("%s\n", "/Courier");
	printf("%s\n", "10 selectfont");

	p->pspage = 1;
	p->psstate = 0;
	pageopen(p);
}


/*
 * Open a page.  This is only used for -Tps at the moment.  It opens a
 * page context, printing the header and the footer.  THE OUTPUT BUFFER
 * MUST BE EMPTY.  If it is not, output will ghost on the next line and
 * we'll be all gross and out of state.
 */
static void
pageopen(struct termp *p)
{
	
	assert(TERMTYPE_PS == p->type);
	assert(0 == p->psstate);

	p->pscol = PS_CHAR_LEFT;
	p->psrow = PS_CHAR_TOPMARG;
	p->psstate |= PS_MARGINS;

	(*p->headf)(p, p->argf);
	endline(p);

	p->psstate &= ~PS_MARGINS;
	assert(0 == p->psstate);

	p->pscol = PS_CHAR_LEFT;
	p->psrow = PS_CHAR_BOTMARG;
	p->psstate |= PS_MARGINS;

	(*p->footf)(p, p->argf);
	endline(p);

	p->psstate &= ~PS_MARGINS;
	assert(0 == p->psstate);

	p->pscol = PS_CHAR_LEFT;
	p->psrow = PS_CHAR_TOP;

d75 1
a75 64
	if (TERMTYPE_CHAR == p->type) {
		(*p->footf)(p, p->argf);
		return;
	}

	printf("%s\n", "%%END");
}


static void
endline(struct termp *p)
{

	if (TERMTYPE_CHAR == p->type) {
		putchar('\n');
		return;
	}

	if (PS_INLINE & p->psstate) {
		printf(") show\n");
		p->psstate &= ~PS_INLINE;
	} 

	if (PS_MARGINS & p->psstate)
		return;

	p->pscol = PS_CHAR_LEFT;
	if (p->psrow >= PS_CHAR_HEIGHT + PS_CHAR_BOT) {
		p->psrow -= PS_CHAR_HEIGHT;
		return;
	}

	/* 
	 * XXX: can't run pageopen() until we're certain a flushln() has
	 * occured, else the buf will reopen in an awkward state on the
	 * next line.
	 */
	printf("showpage\n");
	p->psrow = PS_CHAR_TOP;
}


/*
 * Advance the output engine by a certain amount of whitespace.
 */
static void
advance(struct termp *p, size_t len)
{
	size_t	 	i;

	if (TERMTYPE_CHAR == p->type) {
		/* Just print whitespace on the terminal. */
		for (i = 0; i < len; i++)
			putchar(' ');
		return;
	}

	if (PS_INLINE & p->psstate) {
		/* Dump out any existing line scope. */
		printf(") show\n");
		p->psstate &= ~PS_INLINE;
	}

	p->pscol += len ? len * PS_CHAR_WIDTH : 0;
d212 1
a212 1
			endline(p);
d215 1
a215 1
				advance(p, p->rmargin);
d259 1
a259 1
				advance(p, vbl);
d265 1
a265 1
				letter(p, '-');
d267 1
a267 1
				letter(p, p->buf[i]);
d280 1
a280 1
		endline(p);
d313 1
a313 1
		advance(p, maxvis - vis);
d316 1
a316 1
		endline(p);
d318 1
a318 1
		advance(p, p->rmargin);
d354 1
a354 1
	endline(p);
@


1.144
log
@Missing prototype for getsubopt() on NetBSD fixed.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.143 2010/06/07 21:03:02 kristaps Exp $ */
a47 2
static	struct termp	 *alloc(char *, enum termenc, enum termtype);
static	void		  term_free(struct termp *);
d63 8
d72 2
a73 2
	return(alloc(outopts, TERMENC_ASCII, TERMTYPE_CHAR));
}
d75 8
d84 3
a86 3
void *
ps_alloc(void)
{
d88 1
a88 1
	return(alloc(NULL, TERMENC_ASCII, TERMTYPE_PS));
d93 1
a93 1
terminal_free(void *arg)
d100 1
a100 1
static void
d108 1
d308 2
a309 2
static struct termp *
alloc(char *outopts, enum termenc enc, enum termtype type)
a311 6
	const char	*toks[2];
	char		*v;
	size_t		 width;

	toks[0] = "width";
	toks[1] = NULL;
a318 1
	p->type = type;
d321 1
a321 16

	width = 80;

	while (outopts && *outopts)
		switch (getsubopt(&outopts, UNCONST(toks), &v)) {
		case (0):
			width = (size_t)atoi(v);
			break;
		default:
			break;
		}

	/* Enforce some lower boundary. */
	if (width < 60)
		width = 60;
	p->defrmargin = width - 2;
@


1.143
log
@Lint fix.

Added J.C. Roberts' TODO note.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.142 2010/06/07 20:57:09 kristaps Exp $ */
d25 1
@


1.142
log
@First check-in of PostScript output.  This does not change any logic
within term.c, but does add a small shim over putchar() that switches on
the output engine.  Prints, for this initial version, only monospace and
without font decorations.  It's a start.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.141 2010/06/07 10:52:44 kristaps Exp $ */
d318 1
a318 1
			width = atoi(v);
@


1.141
log
@Add -Owidth=width option to mandoc -Tascii.  Asked for by joerg@@ about a
thousand years ago.  Note that this is normalised to >=60.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.140 2010/05/25 12:37:20 kristaps Exp $ */
d39 9
a47 1
static	struct termp	 *term_alloc(char *, enum termenc);
d55 4
d65 9
a73 1
	return(term_alloc(outopts, TERMENC_ASCII));
d93 108
d202 87
a288 1
	free(p);
d293 1
a293 1
term_alloc(char *outopts, enum termenc enc)
d309 1
d312 1
d447 1
a447 1
			putchar('\n');
d450 1
a450 2
				for (j = 0; j < (int)p->rmargin; j++)
					putchar(' ');
d494 1
a494 2
				for (j = 0; j < (int)vbl; j++)
					putchar(' ');
d500 1
a500 1
				putchar('-');
d502 1
a502 1
				putchar(p->buf[i]);
d515 1
a515 1
		putchar('\n');
d548 2
a549 2
		for ( ; vis < maxvis; vis++)
			putchar(' ');
d551 1
a551 1
		putchar('\n');
d553 1
a553 2
		for (i = 0; i < (int)p->rmargin; i++)
			putchar(' ');
d589 1
a589 1
	putchar('\n');
d841 4
a844 1
	if (TERMFONT_NONE == (f = term_fonttop(p))) {
@


1.140
log
@Modified version of Ingo Schwarze's patch for hyphen-breaking.
Breakable hyphens are cued in the back-ends (with ASCII_HYPH) and acted
upon in term.c or ignored in html.c.

Also cleaned up XML decl printing (no need for extra vars).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.139 2010/05/24 21:51:20 schwarze Exp $ */
d25 1
d39 1
a39 1
static	struct termp	 *term_alloc(enum termenc, size_t);
d50 1
a50 1
ascii_alloc(size_t width)
d53 1
a53 1
	return(term_alloc(TERMENC_ASCII, width));
d79 1
a79 1
term_alloc(enum termenc enc, size_t width)
d81 7
a87 1
	struct termp *p;
d94 1
d97 11
@


1.139
log
@sync to OpenBSD:
save the visual cursor position in term_flushln()
and use that to avoid multiple blank lines in nested lists while
still putting subsequent empty list tags each on their own line;
"go ahead" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.138 2010/05/24 21:34:16 schwarze Exp $ */
d141 1
d194 1
a194 1
		for ( ; j < (int)p->col; j++) {
d197 6
a202 1
			if (8 == p->buf[j])
a203 2
			else
				vend++;
d210 1
a210 1
		if (vend > bp && vis > 0) {
d238 2
d265 6
a270 1
			putchar(p->buf[i]);
@


1.138
log
@Handle literal tab characters both in literal context (.Bd -literal)
and outside.  In literal context, tab stops are at each eigth column;
outside, they are at each fifth column.

from OpenBSD mdoc_term.c rev. 1.75;
"commit" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.137 2010/05/17 22:11:42 kristaps Exp $ */
d210 1
d215 1
d256 1
d260 1
d270 1
d302 2
a303 1
			((TERMP_TWOSPACE & p->flags) ? 1 : 0))  
d306 1
a306 1
	else {	/* ...or newline break. */
d308 1
d325 1
a325 1
	if (0 == p->col) {
d345 1
@


1.137
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.136 2010/05/17 02:03:49 schwarze Exp $ */
d87 1
d175 11
d193 2
a194 2
		for (j = i; j < (int)p->col; j++) {
			if (j && ' ' == p->buf[j]) 
d224 6
d232 2
@


1.136
log
@The function term_flushln() had effectively forked in OpenBSD.
This is the bsd.lv part of the main step to bring it back in sync.
At the same time, this prevents trailing whitespace in the output:
We delay writing blanks until we are sure printable characters follow.

This is achieved by
* remembering the end of the word instead of its length
* and not using vbl any longer for the control of line breaking
* such that vbl can sum up all kinds of white space
* before writing a word, printing all the blanks collected in vbl
* within the word, adding NBSP chars to vbl, then continuing with the word
* after the word, adding blanks to vbl, then starting the next word

"looks good" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.135 2010/05/16 01:35:37 schwarze Exp $ */
d30 1
@


1.135
log
@sync to OpenBSD:
introduce a #define to get rid of the magic number
describing the ASCII character used to represent non-breaking space;
ok kristaps
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.134 2010/05/15 16:18:23 joerg Exp $ */
d136 1
a136 1
	size_t		 vsz;   /* visual characters to write to output */
d159 5
d169 2
a170 7
	vis = 0;

	/*
	 * If in the standard case (left-justified), then begin with our
	 * indentation, otherwise (columns, etc.) just start spitting
	 * out text.
	 */
a171 6
	if ( ! (p->flags & TERMP_NOLPAD))
		/* LINTED */
		for (j = 0; j < (int)p->offset; j++)
			putchar(' ');

	for (i = 0; i < (int)p->col; i++) {
d180 1
a180 1
		for (j = i, vsz = 0; j < (int)p->col; j++) {
d184 1
a184 1
				vsz--;
d186 1
a186 1
				vsz++;
a189 8
		 * Choose the number of blanks to prepend: no blank at the
		 * beginning of a line, one between words -- but do not
		 * actually write them yet.
		 */

		vbl = (size_t)(0 == vis ? 0 : 1);

		/*
d191 1
a191 2
		 * If so, break to the next line.  Otherwise, write the chosen
		 * number of blanks.
d193 2
a194 2

		if (vis && vis + vbl + vsz > bp) {
d199 1
a199 1
				vis = p->rmargin - p->offset;
d201 1
a201 3
				for (j = 0; j < (int)p->offset; j++)
					putchar(' ');
				vis = 0;
a208 4
		} else {
			for (j = 0; j < (int)vbl; j++)
				putchar(' ');
			vis += vbl;
d212 6
a217 2
		for ( ; i < (int)p->col; i++)
			if (' ' == p->buf[i])
d219 5
a223 4
			else if (ASCII_NBRSP == p->buf[i])
				putchar(' ');
			else
				putchar(p->buf[i]);
d225 14
a238 1
		vis += vsz;
@


1.134
log
@Make the output width an option for ascii_alloc and use that to compute
the default margin. Hard-code 80 chars/line for now.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.133 2010/05/12 16:01:01 kristaps Exp $ */
d236 1
a236 1
			else if (31 == p->buf[i])
@


1.133
log
@Tiny EOS patch.  Back-end cues front-end through flag.  Front-end cues output engine with flag.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.132 2010/05/07 04:50:44 kristaps Exp $ */
d37 1
a37 1
static	struct termp	 *term_alloc(enum termenc);
d48 1
a48 1
ascii_alloc(void)
d51 1
a51 1
	return(term_alloc(TERMENC_ASCII));
d77 1
a77 1
term_alloc(enum termenc enc)
d87 4
@


1.132
log
@Backed out break-at-hyphen changes.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.131 2010/04/08 07:05:38 kristaps Exp $ */
d448 1
a448 1
	if ( ! (TERMP_NOSPACE & p->flags))
d450 3
d457 2
@


1.131
log
@Removed pipe from front-end ("typographic") recognition as punctuation (noted by Ingo Schwarze).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.130 2010/04/03 12:46:35 kristaps Exp $ */
a133 1
	size_t		 hyph;	/* visible position of hyphen */
a178 4
		 * Collect the number of printable characters until the
		 * first hyphen, if found.  Hyphens aren't included if
		 * they're the first character (so `Fl' doesn't break)
		 * or second consecutive character (`Fl -').
d182 1
a182 1
		for (j = i, vsz = 0, hyph = 0; j < (int)p->col; j++) {
a188 3
			if (j > i && '-' == p->buf[j] && 0 == hyph)
			       if ('-' != p->buf[j - 1])
					hyph = vsz;
d201 2
a202 3
		 * If so, break to the next line, possibly after
		 * emittign character up to a hyphen.  Otherwise, write
		 * the chosen number of blanks.
a205 26
			/*
			 * Has a hyphen been found before the breakpoint
			 * that we can use?
			 */
			if (hyph && vis + vbl + hyph <= bp) {
				/* First prepend blanks. */
				for (j = 0; j < (int)vbl; j++)
					putchar(' ');
				
				/* Emit up to the character. */
				do {
					if (31 == p->buf[i])
						putchar(' ');
					else
						putchar(p->buf[i]);
					if (8 != p->buf[i])
						vsz--;
				} while ('-' != p->buf[i++]);

				/* Emit trailing decoration. */
				if (8 == p->buf[i]) {
					putchar(p->buf[i]);
					putchar(p->buf[i + 1]);
				}
			} 

@


1.130
log
@Removed erroneous `{' and `}' as punctuation (see mdoc.samples "General Syntax" for why this mistake was made).  Noted by Ingo Schwarze.
Lines of text now break at a hyphen, unless the hyphen is the first or second subsequent in a word.  Inspired by a Ingo Schwarze's patch.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.129 2010/03/23 12:42:22 kristaps Exp $ */
d529 4
a534 2
		case('|'):
			/* FALLTHROUGH */
@


1.129
log
@Fixed two very subtle bugs in retaining overstep and maxrmargin widths between parse sequences.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.128 2010/01/01 17:14:30 kristaps Exp $ */
d95 2
a96 1
 * fragment of a columnar list.
d98 1
a98 4
 * Specifically, a line is whatever's in p->buf of length p->col, which
 * is zeroed after this function returns.
 *
 * The usage of termp:flags is as follows:
d134 1
d180 4
d187 1
a187 1
		for (j = i, vsz = 0; j < (int)p->col; j++) {
d190 1
a190 1
			else if (8 == p->buf[j])
d194 3
d204 1
d209 3
a211 2
		 * If so, break to the next line.  (TODO: hyphenate)
		 * Otherwise, write the chosen number of blanks now.
d213 1
d215 26
d251 1
d253 1
d263 2
a264 4
		/*
		 * Finally, write out the word.
		 */
		for ( ; i < (int)p->col; i++) {
d267 1
a267 3

			/* The unit sep. is a non-breaking space. */
			if (31 == p->buf[i])
d271 1
a271 1
		}
a475 2
			/* FALLTHROUGH */
		case('}'):
d531 2
a535 2
			/* FALLTHROUGH */
		case('{'):
@


1.128
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.127 2009/11/12 08:21:06 kristaps Exp $ */
a85 1
	p->maxrmargin = 78;
a137 1
	static int	 overstep = 0;
d148 1
a148 1
	maxvis = (int)(p->rmargin - p->offset) - overstep < 0 ?
d150 2
a151 2
		0 : p->rmargin - p->offset - overstep;
	mmax = (int)(p->maxrmargin - p->offset) - overstep < 0 ?
d153 1
a153 1
		0 : p->maxrmargin - p->offset - overstep;
d216 1
a216 1
			/* Remove the overstep width. */
d218 2
a219 2
				overstep;
			overstep = 0;
d243 1
a243 1
	overstep = 0;
d252 1
a252 1
		overstep = /* LINTED */
d265 2
a266 2
		if (overstep >= -1) {
			assert((int)maxvis + overstep >= 0);
d268 1
a268 1
			maxvis += overstep;
d270 1
a270 1
			overstep = 0;
@


1.127
log
@Fixed \c support for all input and output modes (documented in mandoc_char.7).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.126 2009/11/12 05:58:30 kristaps Exp $ */
d17 4
@


1.126
log
@FreeBSD sys/types inclusion fixed.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.125 2009/11/12 05:50:12 kristaps Exp $ */
d490 1
d492 2
@


1.125
log
@Basically re-wrote -Tascii font handling: instead of incrementers for
bold and underline, we use a stack (no cascading, no double-font-mode).
Font modes with \f only affect the current stack point, as documented in
mdoc.7 and man.7.  While -mdoc stacks fonts with embedded macros, -man
replaces them (the stack is always size 1).  This works for all
invocations in supported systems' manual corpora to date.  It doesn't
support groff's insanity with line-scoped \f as documented in mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.124 2009/11/07 14:14:16 kristaps Exp $ */
d17 2
d532 1
a532 1
	memcpy(&p->buf[p->col], word, sz);
d544 1
a544 1
	p->buf[p->col++] = c;
@


1.124
log
@Hooked up -Tascii to a2roffdeco backend.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.123 2009/11/06 10:31:32 kristaps Exp $ */
a30 3
/* FIXME: accomodate non-breaking, non-collapsing white-space. */
/* FIXME: accomodate non-breaking, collapsing white-space. */

d33 6
a38 7

static	void		  do_special(struct termp *,
				const char *, size_t);
static	void		  do_reserved(struct termp *,
				const char *, size_t);
static	void		  buffer(struct termp *, char);
static	void		  encode(struct termp *, char);
d319 1
a319 1
do_special(struct termp *p, const char *word, size_t len)
a322 1
	int		 i;
d325 2
a326 12

	if (NULL == rhs) {
#if 0
		fputs("Unknown special character: ", stderr);
		for (i = 0; i < (int)len; i++)
			fputc(word[i], stderr);
		fputc('\n', stderr);
#endif
		return;
	}
	for (i = 0; i < (int)sz; i++) 
		encode(p, rhs[i]);
d331 1
a331 1
do_reserved(struct termp *p, const char *word, size_t len)
a334 1
	int		 i;
d337 59
d397 7
a403 11
	if (NULL == rhs) {
#if 0
		fputs("Unknown reserved word: ", stderr);
		for (i = 0; i < (int)len; i++)
			fputc(word[i], stderr);
		fputc('\n', stderr);
#endif
		return;
	}
	for (i = 0; i < (int)sz; i++) 
		encode(p, rhs[i]);
d416 1
a416 1
	int		 sz, meta;
d449 1
a449 1
		buffer(p, ' ');
d454 1
a454 5
	/*
	 * FIXME: it's faster to put the metafont conditional here,
	 * because most of the time we're not a metafont and can use
	 * strcspn and fwrite.
	 */
d458 1
a458 1
			encode(p, *word);
d468 1
a468 1
			do_reserved(p, seq, ssz);
d471 1
a471 1
			do_special(p, seq, ssz);
d474 1
a474 2
			p->metamask = p->metafont;
			p->metafont |= METAF_BOLD;
d477 1
a477 2
			p->metamask = p->metafont;
			p->metafont |= METAF_UNDER;
d480 1
a480 3
			p->metamask = p->metafont;
			p->metafont &= ~METAF_UNDER;
			p->metafont &= ~METAF_BOLD;
d483 1
a483 3
			meta = p->metamask;
			p->metamask = p->metafont;
			p->metafont = meta;
a505 5
/*
 * Insert a single character into the line-buffer.  If the buffer's
 * space is exceeded, then allocate more space by doubling the buffer
 * size.
 */
d507 1
a507 1
buffer(struct termp *p, char c)
a508 1
	size_t		 s;
d510 9
a518 10
	if (p->col + 1 >= p->maxcols) {
		if (0 == p->maxcols)
			p->maxcols = 256;
		s = p->maxcols * 2;
		p->buf = realloc(p->buf, s);
		if (NULL == p->buf) {
			perror(NULL);
			exit(EXIT_FAILURE);
		}
		p->maxcols = s;
a519 1
	p->buf[(int)(p->col)++] = c;
d524 1
a524 1
encode(struct termp *p, char c)
d526 41
a566 9
	
	if (isgraph((u_char)c)) {
		if (p->under || METAF_UNDER & p->metafont) {
			buffer(p, '_');
			buffer(p, 8);
		}
		if (p->bold || METAF_BOLD & p->metafont) {
			buffer(p, c);
			buffer(p, 8);
d568 8
a576 1
	buffer(p, c);
@


1.123
log
@-Tascii now correctly ignores \s clauses.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.122 2009/11/05 08:40:16 kristaps Exp $ */
a36 1
static	void		  do_escaped(struct termp *, const char **);
a368 195
 * Handle an escape sequence: determine its length and pass it to the
 * escape-symbol look table.  Note that we assume mdoc(3) has validated
 * the escape sequence (we assert upon badly-formed escape sequences).
 */
static void
do_escaped(struct termp *p, const char **word)
{
	int		 j, type, sv, t, lim;
	const char	*wp;

	wp = *word;
	type = 1;

	if ('\0' == *(++wp)) {
		*word = wp;
		return;
	}

	if ('(' == *wp) {
		wp++;
		if ('\0' == *wp || '\0' == *(wp + 1)) {
			*word = '\0' == *wp ? wp : wp + 1;
			return;
		}

		do_special(p, wp, 2);
		*word = ++wp;
		return;

	} else if ('*' == *wp) {
		if ('\0' == *(++wp)) {
			*word = wp;
			return;
		}

		switch (*wp) {
		case ('('):
			wp++;
			if ('\0' == *wp || '\0' == *(wp + 1)) {
				*word = '\0' == *wp ? wp : wp + 1;
				return;
			}

			do_reserved(p, wp, 2);
			*word = ++wp;
			return;
		case ('['):
			type = 0;
			break;
		default:
			do_reserved(p, wp, 1);
			*word = wp;
			return;
		}

	} else if ('s' == *wp) {
		/* This closely follows mandoc_special(). */
		if ('\0' == *(++wp)) {
			*word = wp;
			return;
		}

		t = 0;
		lim = 1;

		if (*wp == '\'') {
			lim = 0;
			t = 1;
			++wp;
		} else if (*wp == '[') {
			lim = 0;
			t = 2;
			++wp;
		} else if (*wp == '(') {
			lim = 2;
			t = 3;
			++wp;
		}

		if (*wp == '+' || *wp == '-')
			++wp;

		if (*wp == '\'') {
			if (t) {
				*word = wp;
				return;
			}
			lim = 0;
			t = 1;
			++wp;
		} else if (*wp == '[') {
			if (t) {
				*word = wp;
				return;
			}
			lim = 0;
			t = 2;
			++wp;
		} else if (*wp == '(') {
			if (t) {
				*word = wp;
				return;
			}
			lim = 2;
			t = 3;
			++wp;
		}

		if ( ! isdigit((u_char)*wp)) {
			*word = --wp;
			return;
		}

		for (j = 0; isdigit((u_char)*wp); j++) {
			if (lim && j >= lim)
				break;
			++wp;
		}

		if (t && t < 3) {
			if (1 == t && *wp != '\'') {
				*word = --wp;
				return;
			}
			if (2 == t && *wp != ']') {
				*word = --wp;
				return;
			}
			++wp;
		}
		*word = --wp;
		return;

	} else if ('f' == *wp) {
		if ('\0' == *(++wp)) {
			*word = wp;
			return;
		}

		switch (*wp) {
		case ('3'):
			/* FALLTHROUGH */
		case ('B'):
			p->metamask = p->metafont;
			p->metafont |= METAF_BOLD;
			break;
		case ('2'):
			/* FALLTHROUGH */
		case ('I'):
			p->metamask = p->metafont;
			p->metafont |= METAF_UNDER;
			break;
		case ('P'):
			sv = p->metamask;
			p->metamask = p->metafont;
			p->metafont = sv;
			break;
		case ('1'):
			/* FALLTHROUGH */
		case ('R'):
			p->metamask = p->metafont;
			p->metafont &= ~METAF_UNDER;
			p->metafont &= ~METAF_BOLD;
			break;
		default:
			break;
		}

		*word = wp;
		return;

	} else if ('[' != *wp) {
		do_special(p, wp, 1);
		*word = wp;
		return;
	}

	wp++;
	for (j = 0; *wp && ']' != *wp; wp++, j++)
		/* Loop... */ ;

	if ('\0' == *wp) {
		*word = wp;
		return;
	}

	if (type)
		do_special(p, wp - j, (size_t)j);
	else
		do_reserved(p, wp - j, (size_t)j);
	*word = wp;
}


/*
d376 4
a379 1
	const char	 *sv;
d415 8
a422 2
	for ( ; *word; word++)
		if ('\\' != *word)
d424 37
a460 2
		else
			do_escaped(p, &word);
@


1.122
log
@Correct support for `\fX' font modes in -Tascii.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.121 2009/11/05 07:21:02 kristaps Exp $ */
d377 1
a377 1
	int		 j, type, sv;
d383 1
a383 1
	if (0 == *(++wp)) {
d390 2
a391 2
		if (0 == *wp || 0 == *(wp + 1)) {
			*word = 0 == *wp ? wp : wp + 1;
d400 1
a400 1
		if (0 == *(++wp)) {
d408 2
a409 2
			if (0 == *wp || 0 == *(wp + 1)) {
				*word = 0 == *wp ? wp : wp + 1;
d424 79
a502 1
	
d504 1
a504 1
		if (0 == *(++wp)) {
d551 1
a551 1
	if (0 == *wp) {
d576 1
a576 1
	if (word[0] && 0 == word[1])
@


1.121
log
@Added functionality of -Tascii non-breaking `\~' space.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.120 2009/10/31 06:10:58 kristaps Exp $ */
d18 1
d377 1
a377 1
	int		 j, type;
d432 2
d435 2
a436 1
			p->bold++;
d438 2
d441 2
a442 1
			p->under++;
d445 5
d452 3
a454 1
			p->bold = p->under = 0;
d580 2
a581 2
	if (' ' != c) {
		if (p->under) {
d585 1
a585 1
		if (p->bold) {
@


1.120
log
@Using perror() instead of fprintf for failure from library functions.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.119 2009/10/30 18:53:09 kristaps Exp $ */
d232 6
a237 1
			putchar(p->buf[i]);
@


1.119
log
@More lint fixes.
Removed err.h from inclusions (less main.c--still in progress).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.118 2009/10/30 18:50:11 kristaps Exp $ */
d81 1
a81 1
		fprintf(stderr, "memory exhausted\n");
d548 1
a548 1
			fprintf(stderr, "memory exhausted\n");
@


1.118
log
@Lint fixes.
Made realloc puke with fprintf.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.117 2009/10/30 18:43:24 kristaps Exp $ */
a17 1
#include <err.h>
d149 2
a150 1
			0 : p->rmargin - p->offset - overstep;
d152 2
a153 1
			0 : p->maxrmargin - p->offset - overstep;
@


1.117
log
@Continued safe handling of allocations.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.116 2009/10/28 06:54:12 kristaps Exp $ */
d546 4
a549 2
		if (NULL == p->buf)
			err(1, "realloc"); /* FIXME: shouldn't be here! */
@


1.116
log
@Removed superfluous memset (thanks Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.115 2009/10/27 08:26:12 kristaps Exp $ */
d80 5
a84 2
	if (NULL == (p = calloc(1, sizeof(struct termp))))
		return(NULL);
@


1.115
log
@bzero() -> memset() (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.114 2009/10/27 08:05:39 kristaps Exp $ */
d80 1
a80 1
	if (NULL == (p = malloc(sizeof(struct termp))))
a81 1
	memset(p, 0, sizeof(struct termp));
@


1.114
log
@Merged Ingo's comments on term_flushln() variable names.
Fixed assertion (this needs more consideration) when an overstep line is exactly as long as the rmargin.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.113 2009/10/26 17:05:44 kristaps Exp $ */
d82 1
a82 1
	bzero(p, sizeof(struct termp));
d142 1
a142 1
	 * small set of values.
d153 6
@


1.113
log
@Added time.h to various files for FreeBSD compilation (thanks Ulrich Sporlein).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.112 2009/10/26 09:06:03 kristaps Exp $ */
d123 2
a124 6
 *  writing from the right-margin, which will lead to the above
 *  scenario upon exit.
 *
 *  Otherwise, the line will break at the right margin.  Extremely long
 *  lines will cause the system to emit a warning (TODO: hyphenate, if
 *  possible).
d129 7
a135 2
	int		 i, j;
	size_t		 vbl, vsz, vis, maxvis, mmax, bp;
a145 1
	assert((int)(p->rmargin - p->offset) - overstep > 0);
d147 4
a150 4
	maxvis = /* LINTED */
		p->rmargin - p->offset - overstep;
	mmax = /* LINTED */
		p->maxrmargin - p->offset - overstep;
@


1.112
log
@Lint fix.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.111 2009/10/26 07:18:23 kristaps Exp $ */
d22 1
@


1.111
log
@Fixed overstep patch.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.110 2009/10/24 06:19:34 kristaps Exp $ */
d207 2
a208 1
			bp += overstep;
@


1.110
log
@Removed need for superfluous `os' value in overstep calculation (thanks Ingo Schwarze).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.109 2009/10/22 18:19:36 kristaps Exp $ */
d225 1
d227 1
a233 1
	overstep = 0;
@


1.109
log
@Fixed order of printing backspace-encoding for terms that are both bold and underlined (noted by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.108 2009/10/19 15:18:30 kristaps Exp $ */
d133 1
a133 1
	size_t		 vbl, vsz, vis, maxvis, mmax, bp, os;
a145 3
	/* Save the overstep. */
	os = (size_t)overstep;

a152 1
	overstep = 0;
d207 2
a208 2
			bp += os;
			os = 0;
d232 1
@


1.108
log
@More fixes to scaling-width multipliers (which, just to make my life difficult, differ not only between -mdoc and -man, but between various invocation, e.g., -offset and -width).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.107 2009/10/18 19:03:37 kristaps Exp $ */
d551 4
a558 4
		if (p->under) {
			buffer(p, '_');
			buffer(p, 8);
		}
@


1.107
log
@Made sure devices and formats recognise that -man and -mdoc have different syntax for scaling widths: -mdoc assumes no unit means that the value is a string literal while -man instead uses the default vertical/horizontal scale.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.106 2009/10/18 13:34:17 kristaps Exp $ */
d605 2
d609 1
a609 1
		r = (4 * su->scale) + 2; /* FIXME: double-check. */
d612 2
a613 1
		r = (10 * su->scale) + 2; /* FIXME: double-check. */
d616 1
a616 1
		r = (10 * su->scale) / 6; /* FIXME: double-check. */
d619 1
a619 1
		r = (10 * su->scale) / 72; /* FIXME: double-check. */
@


1.106
log
@Arbitrary horizontal and vertical scaling widths now handled by -mdoc -Tascii.
Terminal scaling backend pushed into term.c.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.105 2009/10/13 10:57:25 kristaps Exp $ */
d24 1
a28 1
#include "out.h"
d564 2
a565 2
int
a2height(const char *p)
a566 1
	struct roffsu	 su;
d569 1
a569 4
	if ( ! a2roffsu(p, &su)) 
		return(-1);

	switch (su.unit) {
d571 1
a571 1
		r = su.scale * 2;
d574 1
a574 1
		r = su.scale * 6;
d577 1
a577 1
		r = su.scale;
d580 1
a580 1
		r = su.scale / 8;
d583 1
a583 1
		r = su.scale / 1000;
d586 1
a586 1
		r = su.scale;
d589 1
a589 1
		r = su.scale - 1;
d595 1
a595 1
	return(/* LINTED */(int)
d600 2
a601 2
int
a2width(const char *p)
a602 1
	struct roffsu	 su;
d605 1
a605 4
	if ( ! a2roffsu(p, &su)) 
		return(-1);

	switch (su.unit) {
d607 1
a607 1
		r = (4 * su.scale) + 2; /* FIXME: double-check. */
d610 1
a610 1
		r = (10 * su.scale) + 2; /* FIXME: double-check. */
d613 1
a613 1
		r = (10 * su.scale) / 6; /* FIXME: double-check. */
d616 1
a616 1
		r = (10 * su.scale) / 72; /* FIXME: double-check. */
d619 1
a619 1
		r = su.scale / 1000; /* FIXME: double-check. */
d622 1
a622 1
		r = su.scale * 2 - 1; /* FIXME: double-check. */
d625 1
a625 1
		r = su.scale + 2;
d631 1
a631 1
	return((int)/* LINTED */
@


1.105
log
@Moved output definitions into main.h.
Pushed terminal_{mdoc,man} into {mdoc,man}_term.c.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.104 2009/10/10 11:05:23 kristaps Exp $ */
d28 1
d562 82
@


1.104
log
@Fix hang lists in -Tascii -Tmdoc, which seem to have been broken since ~1.8.x.
Noted similarity of HP/TP and -hang/-tag in mandoc.1.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.103 2009/09/23 11:02:21 kristaps Exp $ */
d27 1
a31 5
extern	void		  man_run(struct termp *, 
				const struct man *);
extern	void		  mdoc_run(struct termp *, 
				const struct mdoc *);

a52 26
terminal_man(void *arg, const struct man *man)
{
	struct termp	*p;

	p = (struct termp *)arg;
	if (NULL == p->symtab)
		p->symtab = chars_init(CHARS_ASCII);

	man_run(p, man);
}


void
terminal_mdoc(void *arg, const struct mdoc *mdoc)
{
	struct termp	*p;

	p = (struct termp *)arg;
	if (NULL == p->symtab)
		p->symtab = chars_init(CHARS_ASCII);

	mdoc_run(p, mdoc);
}


void
@


1.103
log
@All special characters sync'd with groff, both -Thtml and -Tascii.
Re-added text links to index.sgml (just for show).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.102 2009/09/20 13:43:31 kristaps Exp $ */
d162 1
a162 1
	size_t		 vbl, vsz, vis, maxvis, mmax, bp;
d175 3
d239 3
@


1.102
log
@Fixed memory leak on close.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.101 2009/09/17 07:41:28 kristaps Exp $ */
d28 3
@


1.101
log
@ascii_xxx -> chars_xxx (intended to hold more than just ascii encoding).
More html work.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.100 2009/09/16 15:08:31 kristaps Exp $ */
d93 1
a93 1
	if (TERMENC_ASCII == p->enc && p->symtab)
@


1.100
log
@Put closedelim and opendelim right in term_word() (unnecessary extra function).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.99 2009/09/16 09:41:24 kristaps Exp $ */
d23 1
d60 1
a60 1
		p->symtab = term_ascii2htab();
d73 1
a73 1
		p->symtab = term_ascii2htab();
d94 1
a94 1
		term_asciifree(p->symtab);
d335 1
a335 1
	rhs = term_a2ascii(p->symtab, word, len, &sz);
d358 1
a358 1
	rhs = term_a2res(p->symtab, word, len, &sz);
@


1.99
log
@Made tree/term/out() functions return void.
Put err() functions back into front-ends (no use making it needlessly complex).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.98 2009/09/15 08:16:20 kristaps Exp $ */
a41 2
static	int		  isopendelim(const char *);
static	int		  isclosedelim(const char *);
a112 56
static int
isclosedelim(const char *p)
{

	if ( ! (*p && 0 == *(p + 1)))
		return(0);

	switch (*p) {
	case('.'):
		/* FALLTHROUGH */
	case(','):
		/* FALLTHROUGH */
	case(';'):
		/* FALLTHROUGH */
	case(':'):
		/* FALLTHROUGH */
	case('?'):
		/* FALLTHROUGH */
	case('!'):
		/* FALLTHROUGH */
	case(')'):
		/* FALLTHROUGH */
	case(']'):
		/* FALLTHROUGH */
	case('}'):
		return(1);
	default:
		break;
	}

	return(0);
}


static int
isopendelim(const char *p)
{

	if ( ! (*p && 0 == *(p + 1)))
		return(0);

	switch (*p) {
	case('('):
		/* FALLTHROUGH */
	case('['):
		/* FALLTHROUGH */
	case('{'):
		return(1);
	default:
		break;
	}

	return(0);
}


d487 27
a513 3
	if (isclosedelim(word))
		if ( ! (TERMP_IGNDELIM & p->flags))
			p->flags |= TERMP_NOSPACE;
d521 1
a521 1
	for (sv = word; *word; word++)
d527 12
a538 2
	if (isopendelim(sv))
		p->flags |= TERMP_NOSPACE;
@


1.98
log
@Removed TERMP_BOLD, TERMP_UNDER, TERMP_STYLE in favour of recursive-friendly increments.
Cleaned up confusing behaviour of p->flags.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.97 2009/07/28 10:15:12 kristaps Exp $ */
d27 1
a27 1
extern	int		  man_run(struct termp *, 
d29 1
a29 1
extern	int		  mdoc_run(struct termp *, 
d54 1
a54 1
int
d63 1
a63 1
	return(man_run(p, man));
d67 1
a67 1
int
d76 1
a76 1
	return(mdoc_run(p, mdoc));
@


1.97
log
@Fix in newline.
Correct printing of N-char predefined/special strings.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.96 2009/07/27 13:10:08 kristaps Exp $ */
d107 1
a107 1
		err(1, "malloc");
d495 1
a495 1
			p->flags |= TERMP_BOLD;
d498 1
a498 1
			p->flags |= TERMP_UNDER;
d503 1
a503 1
			p->flags &= ~TERMP_STYLE;
d582 1
a582 1
			err(1, "realloc");
d593 2
a594 2
	if (' ' != c && TERMP_STYLE & p->flags) {
		if (TERMP_BOLD & p->flags) {
d598 1
a598 1
		if (TERMP_UNDER & p->flags) {
@


1.96
log
@Re-ordered ascii.in looking for dupes.
Added `vim -q' tip to manuals.7 (thanks uqs@@sporlein.net).
ifdef'd production of missing specials/predefines.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.95 2009/07/27 12:35:54 kristaps Exp $ */
d395 1
a395 1
#if 1
d439 1
a439 1
	int		 j;
d443 1
d479 1
d527 4
a530 1
	do_special(p, wp - j, (size_t)j);
@


1.95
log
@Clarified special chars/predefined chars in mandoc_char.7.
Cleaned up escape section in man.7, mdoc.7.
Cleaned up function names in term.c.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.94 2009/07/27 12:02:49 kristaps Exp $ */
d394 7
a400 1
	if (NULL == rhs)
d402 1
d417 7
a423 1
	if (NULL == rhs)
d425 1
@


1.94
log
@Correct handling of \*(xx, \*[xxx], \*x versus \x, \(xx, \([xxx]: predefined strings and escape characters, respectively.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.93 2009/07/24 11:54:25 kristaps Exp $ */
d34 3
a36 2
static	void		  term_pescape(struct termp *, const char **);
static	void		  term_nescape(struct termp *,
d38 1
a38 1
static	void		  term_sescape(struct termp *,
d40 4
a43 4
static	void		  term_chara(struct termp *, char);
static	void		  term_encodea(struct termp *, char);
static	int		  term_isopendelim(const char *);
static	int		  term_isclosedelim(const char *);
d116 1
a116 1
term_isclosedelim(const char *p)
d150 1
a150 1
term_isopendelim(const char *p)
a210 6
 *
 *  FIXME: newline breaks occur (in groff) also occur when a single
 *  space follows a NOBREAK (try `Bl -tag')
 *
 *  FIXME: there's a newline error where a `Bl -diag' will have a
 *  trailing newline if the line is exactly 73 chars long.
a384 5
/*
 * Determine the symbol indicated by an escape sequences, that is, one
 * starting with a backslash.  Once done, we pass this value into the
 * output buffer by way of the symbol table.
 */
d386 1
a386 1
term_nescape(struct termp *p, const char *word, size_t len)
d397 1
a397 1
		term_encodea(p, rhs[i]);
d402 1
a402 1
term_sescape(struct termp *p, const char *word, size_t len)
d413 1
a413 1
		term_encodea(p, rhs[i]);
d423 1
a423 1
term_pescape(struct termp *p, const char **word)
d442 1
a442 1
		term_nescape(p, wp, 2);
d460 1
a460 1
			term_sescape(p, wp, 2);
d466 1
a466 1
			term_sescape(p, wp, 1);
d497 1
a497 1
		term_nescape(p, wp, 1);
d511 1
a511 1
	term_nescape(p, wp - j, (size_t)j);
d526 1
a526 1
	if (term_isclosedelim(word))
d531 1
a531 1
		term_chara(p, ' ');
a535 5
	/* 
	 * If ANSI (word-length styling), then apply our style now,
	 * before the word.
	 */

d538 1
a538 1
			term_encodea(p, *word);
d540 1
a540 1
			term_pescape(p, &word);
d542 1
a542 1
	if (term_isopendelim(sv))
d553 1
a553 1
term_chara(struct termp *p, char c)
d571 1
a571 1
term_encodea(struct termp *p, char c)
d576 2
a577 2
			term_chara(p, c);
			term_chara(p, 8);
d580 2
a581 2
			term_chara(p, '_');
			term_chara(p, 8);
d584 1
a584 1
	term_chara(p, c);
@


1.93
log
@Text tokens with leading whitespace (like indented blocks in `Bd -literal') are printed correctly.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.92 2009/07/23 08:35:22 kristaps Exp $ */
d37 2
d404 20
a423 3
	if (rhs)
		for (i = 0; i < (int)sz; i++) 
			term_encodea(p, rhs[i]);
d470 1
a470 1
			term_nescape(p, wp, 2);
d476 1
a476 1
			term_nescape(p, wp, 1);
@


1.92
log
@Lintified term_flushln() (type mismatches).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.91 2009/07/21 13:34:13 kristaps Exp $ */
d262 1
a262 1
			if (' ' == p->buf[j]) 
@


1.91
log
@Bringing spacing more in line with groff, patches from schwarze@@openbsd.org.  Pre-testing.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.90 2009/07/19 21:26:27 kristaps Exp $ */
d230 7
a236 2
	maxvis = p->rmargin - p->offset - overstep;
	mmax = p->maxrmargin - p->offset - overstep;
a316 1

d318 2
a319 1
		overstep = vis - maxvis + 1;
d323 3
a325 2
		 * If we have overstepped the margin, temporarily move it
		 * to the right and flag the rest of the line to be shorter.
d327 3
a329 2
		 * If we are one step before the margin, temporarily move it
		 * one step LEFT and flag the rest of the line to be longer.
d331 3
a333 1
		if (overstep >= -1)
d335 1
a335 1
		else
d341 3
a343 1
	if (maxvis > vis + ((TERMP_TWOSPACE & p->flags) ? 1 : 0))  /* pad */
d346 1
a346 1
	else {	/* break */
@


1.90
log
@Fixed and cleaned up "phrase" handling (`Bl -column' columns).
Found strange newline bug in -diag handling (and others?).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.89 2009/07/16 13:17:51 kristaps Exp $ */
d187 3
d220 1
a220 1
	static int	 sv = -1;
d230 2
a231 2
	maxvis = p->rmargin - p->offset;
	mmax = p->maxrmargin - p->offset;
d234 1
a234 5

	if (sv >= 0) {
		vis = (size_t)sv;
		sv = -1;
	}
d304 1
d306 2
a307 15
	/*
	 * If we've overstepped our maximum visible no-break space, then
	 * cause a newline and offset at the right margin.
	 */

	if ((TERMP_NOBREAK & p->flags) && vis >= maxvis) {
		if ( ! (TERMP_DANGLE & p->flags) &&
				! (TERMP_HANG & p->flags)) {
			putchar('\n');
			for (i = 0; i < (int)p->rmargin; i++)
				putchar(' ');
		}
		if (TERMP_HANG & p->flags)
			sv = (int)(vis - maxvis);
		p->col = 0;
d311 20
a330 4
	/*
	 * If we're not to right-marginalise it (newline), then instead
	 * pad to the right margin and stay off.
	 */
d332 4
a335 5
	if (p->flags & TERMP_NOBREAK) {
		if ( ! (TERMP_DANGLE & p->flags))
			for ( ; vis < maxvis; vis++)
				putchar(' ');
	} else
d337 3
a339 2

	p->col = 0;
@


1.89
log
@Subtle fixes correcting vis count with erroneously-decorated whitespace.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.88 2009/07/16 12:34:06 kristaps Exp $ */
d207 4
a210 1
 *  space follows a NOBREAK!
@


1.88
log
@Fix in nospace following close-delimiter.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.87 2009/07/15 15:53:57 kristaps Exp $ */
d255 1
a255 1
			if (' ' == p->buf[j])
d258 1
a258 1
				j += 1;
d552 2
a553 2

	if (TERMP_STYLE & p->flags) {
@


1.87
log
@Removed assertion (disregarded blank literal lines).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.86 2009/07/15 15:37:48 kristaps Exp $ */
d498 1
d515 1
a515 1
	for ( ; *word; word++)
d521 1
a521 1
	if (term_isopendelim(word))
@


1.86
log
@Removed term.c break-up of tokens (happens in libmdoc).
Removed costly, redundant calculations of string length (in-line printing).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.85 2009/07/14 15:49:44 kristaps Exp $ */
a498 1
	assert(*word);
@


1.85
log
@Cleaned up arg_width and arg_column functions.
Added XXn and XXm support to -offset (not documented in mdoc.samples, but used in mdoc.samples!).
Lint warnings fixed.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.84 2009/07/14 15:16:41 kristaps Exp $ */
d34 1
a34 3
static	void		  term_pword(struct termp *, const char *, int);
static	void		  term_pescape(struct termp *, 
				const char *, int *, int);
d39 2
a40 2
static	int		  term_isopendelim(const char *, int);
static	int		  term_isclosedelim(const char *, int);
d113 1
a113 1
term_isclosedelim(const char *p, int len)
d116 1
a116 1
	if (1 != len)
d147 1
a147 1
term_isopendelim(const char *p, int len)
d150 1
a150 1
	if (1 != len)
a371 44
 * Break apart a word into "pwords" (partial-words, usually from
 * breaking up a phrase into individual words) and, eventually, put them
 * into the output buffer.  If we're a literal word, then don't break up
 * the word and put it verbatim into the output buffer.
 */
void
term_word(struct termp *p, const char *word)
{
	int 		 i, j, len;

	len = (int)strlen(word);

	if (p->flags & TERMP_LITERAL) {
		term_pword(p, word, len);
		return;
	}

	/* LINTED */
	for (j = i = 0; i < len; i++) {
		if (' ' != word[i]) {
			j++;
			continue;
		} 
		
		/* Escaped spaces don't delimit... */
		if (i && ' ' == word[i] && '\\' == word[i - 1]) {
			j++;
			continue;
		}

		if (0 == j)
			continue;
		assert(i >= j);
		term_pword(p, &word[i - j], j);
		j = 0;
	}
	if (j > 0) {
		assert(i >= j);
		term_pword(p, &word[i - j], j);
	}
}


/*
d384 1
d397 1
a397 1
term_pescape(struct termp *p, const char *word, int *i, int len)
d400 3
d404 2
a405 1
	if (++(*i) >= len)
d407 1
d409 4
a412 3
	if ('(' == word[*i]) {
		(*i)++;
		if (*i + 1 >= len)
d414 1
d416 2
a417 2
		term_nescape(p, &word[*i], 2);
		(*i)++;
d420 3
a422 3
	} else if ('*' == word[*i]) { 
		(*i)++;
		if (*i >= len)
d424 1
d426 1
a426 1
		switch (word[*i]) {
d428 3
a430 2
			(*i)++;
			if (*i + 1 >= len)
d432 1
d434 2
a435 2
			term_nescape(p, &word[*i], 2);
			(*i)++;
d440 2
a441 1
			term_nescape(p, &word[*i], 1);
d445 3
a447 3
	} else if ('f' == word[*i]) {
		(*i)++;
		if (*i >= len)
d449 3
a451 1
		switch (word[*i]) {
d466 2
d470 3
a472 2
	} else if ('[' != word[*i]) {
		term_nescape(p, &word[*i], 1);
d476 2
a477 2
	(*i)++;
	for (j = 0; word[*i] && ']' != word[*i]; (*i)++, j++)
d480 2
a481 1
	if (0 == word[*i])
d483 1
d485 2
a486 1
	term_nescape(p, &word[*i - j], (size_t)j);
d495 2
a496 2
static void
term_pword(struct termp *p, const char *word, int len)
a497 1
	int		 i;
d499 2
a500 1
	if (term_isclosedelim(word, len))
d515 3
a517 3
	for (i = 0; i < len; i++) 
		if ('\\' == word[i]) 
			term_pescape(p, word, &i, len);
d519 1
a519 1
			term_encodea(p, word[i]);
d521 1
a521 1
	if (term_isopendelim(word, len))
@


1.84
log
@Support for TERMP_HANG in flushln(): -hang lists.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.83 2009/06/22 13:13:10 kristaps Exp $ */
d318 1
a318 1
			sv = vis - maxvis;
@


1.83
log
@Lint fixes.
Version up.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.82 2009/06/22 12:38:07 kristaps Exp $ */
d179 1
a179 2
 * The variables TERMP_NOLPAD, TERMP_LITERAL and TERMP_NOBREAK are of
 * critical importance here.  Their behaviour follows:
d189 6
a194 1
 *  - TERMP_NONOBREAK: don't newline when TERMP_NOBREAK is specified.
d216 1
d231 5
d311 2
a312 1
		if ( ! (TERMP_NONOBREAK & p->flags)) {
d317 2
d329 1
a329 1
		if ( ! (TERMP_NONOBREAK & p->flags))
@


1.82
log
@Noted .Cd tabs-ok issue (will fix later).
Added single space to -diag lists.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.81 2009/06/22 12:04:05 kristaps Exp $ */
d416 2
a417 1
	if ((rhs = term_a2ascii(p->symtab, word, len, &sz))) 
@


1.81
log
@Added "Spacing" part of "Punctuation and Spacing" in mandoc.1 manual.
Fixed `Ds' meta-macro default width.
Fixed -width and -offset "indent", "indent-two", and "left" widths.
Fixed -width and -offset literal-word and numeric widths.
Fixed off-by-one errors in whitespace output (schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.80 2009/06/22 10:40:04 kristaps Exp $ */
d203 3
@


1.80
log
@Reverted max column width 80 -> 78 (schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.79 2009/06/17 18:42:42 kristaps Exp $ */
d208 1
a208 1
	size_t		 vsz, vis, maxvis, mmax, bp;
d253 3
a255 5
		 * Do line-breaking.  If we're greater than our
		 * break-point and already in-line, break to the next
		 * line and start writing.  If we're at the line start,
		 * then write out the word (TODO: hyphenate) and break
		 * in a subsequent loop invocation.
d257 1
d259 12
a270 3
		if ( ! (TERMP_NOBREAK & p->flags)) {
			if (vis && vis + vsz > bp) {
				putchar('\n');
d274 3
a276 4
			} 
		} else if (vis && vis + vsz > bp) {
			putchar('\n');
			for (j = 0; j < (int)p->rmargin; j++)
d278 1
a278 1
			vis = p->rmargin - p->offset;
d282 1
a282 2
		 * Prepend a space if we're not already at the beginning
		 * of the line, then the word.
a283 4

		if (0 < vis++)
			putchar(' ');

d297 1
a297 1
	if ((TERMP_NOBREAK & p->flags) && vis > maxvis) {
d314 1
a314 1
			for ( ; vis <= maxvis; vis++)
@


1.79
log
@Special characters, e.g. \(ae, are now correctly rendered in the current font decoration.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.78 2009/06/11 10:34:32 kristaps Exp $ */
d108 1
a108 1
	p->maxrmargin = 80;
@


1.78
log
@Clean up validation of field widths.
Pushed field-width warn/error into warn/error routine.
Removed superfluous space at output eoln.
Fixed overzealous line break in lists.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.77 2009/06/11 07:46:41 kristaps Exp $ */
d40 1
a40 2
static	void		  term_stringa(struct termp *, 
				const char *, size_t);
d409 1
d411 3
a413 3
	if (NULL == (rhs = term_a2ascii(p->symtab, word, len, &sz))) 
		return;
	term_stringa(p, rhs, sz);
d522 2
a523 2
	for (i = 0; i < len; i++) {
		if ('\\' == word[i]) {
d525 2
a526 16
			continue;
		}

		if (TERMP_STYLE & p->flags) {
			if (TERMP_BOLD & p->flags) {
				term_chara(p, word[i]);
				term_chara(p, 8);
			}
			if (TERMP_UNDER & p->flags) {
				term_chara(p, '_');
				term_chara(p, 8);
			}
		}

		term_chara(p, word[i]);
	}
a533 29
 * Like term_chara() but for arbitrary-length buffers.  Resize the
 * buffer by a factor of two (if the buffer is less than that) or the
 * buffer's size.
 */
static void
term_stringa(struct termp *p, const char *c, size_t sz)
{
	size_t		 s;

	if (0 == sz)
		return;

	assert(c);
	if (p->col + sz >= p->maxcols) {
		if (0 == p->maxcols)
			p->maxcols = 256;
		s = sz > p->maxcols * 2 ? sz : p->maxcols * 2;
		p->buf = realloc(p->buf, s);
		if (NULL == p->buf)
			err(1, "realloc");
		p->maxcols = s;
	}

	(void)memcpy(&p->buf[(int)p->col], c, sz);
	p->col += sz;
}


/*
d555 17
@


1.77
log
@Fix space-before-newline (inspired by schwarze@@openbsd.org).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.76 2009/06/11 07:26:35 kristaps Exp $ */
d275 3
a277 4
		/* 
		 * Write out the word and a trailing space.  Omit the
		 * space if we're the last word in the line or beyond
		 * our breakpoint.
d296 1
a296 1
	if ((TERMP_NOBREAK & p->flags) && vis >= maxvis) {
@


1.76
log
@Fixed email address in manual AUTHOR reference.
Set max right margin to 80 columns (schwarze@@openbsd.org).
Fixed centre-field heading position (schwarze@@openbsd.org).
Also fixed -Tman centre-field.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.75 2009/06/10 20:18:44 kristaps Exp $ */
d281 3
a289 4
		if (i < (int)p->col && vis <= bp) {
			putchar(' ');
			vis++;
		}
d314 1
a314 1
			for ( ; vis < maxvis; vis++)
@


1.75
log
@Fixed license email address.
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.74 2009/04/12 19:45:26 kristaps Exp $ */
d109 1
a109 1
	p->maxrmargin = 78;
@


1.74
log
@Using proper license template (const).
@
text
@d1 1
a1 1
/*	$Id: term.c,v 1.73 2009/04/03 12:27:18 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
@


1.73
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.72 2009/04/03 11:08:39 kristaps Exp $ */
d6 2
a7 3
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
d9 7
a15 8
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
@


1.72
log
@Proper resetting of memory.
Array boundary fixed (-W).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.71 2009/03/31 13:50:19 kristaps Exp $ */
a61 1

a74 1

@


1.71
log
@General clean-ups.
@
text
@d1 1
a1 1
/* $Id: terminal.c,v 1.12 2009/03/26 16:47:13 kristaps Exp $ */
d57 1
a57 2
terminal_run(void *arg, const struct man *man,
		const struct mdoc *mdoc)
d66 13
a78 4
	if (man)
		return(man_run(p, man));
	if (mdoc)
		return(mdoc_run(p, mdoc));
d80 1
a80 1
	return(1);
@


1.70
log
@Initial front-end formatting for -man pages.
@
text
@d1 595
@


1.69
log
@More manual documentation fixed/improved.
@
text
@a0 1926
/* $Id: term.c,v 1.68 2009/03/22 21:19:34 kristaps Exp $ */
/*
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "term.h"

/*
 * Performs actions on nodes of the abstract syntax tree.  Both pre- and
 * post-fix operations are defined here.
 */

/* FIXME: macro arguments can be escaped. */

#define	TTYPE_PROG	  0
#define	TTYPE_CMD_FLAG	  1
#define	TTYPE_CMD_ARG	  2
#define	TTYPE_SECTION	  3
#define	TTYPE_FUNC_DECL	  4
#define	TTYPE_VAR_DECL	  5
#define	TTYPE_FUNC_TYPE	  6
#define	TTYPE_FUNC_NAME	  7
#define	TTYPE_FUNC_ARG	  8
#define	TTYPE_LINK	  9
#define	TTYPE_SSECTION	  10
#define	TTYPE_FILE	  11
#define	TTYPE_EMPH	  12
#define	TTYPE_CONFIG	  13
#define	TTYPE_CMD	  14
#define	TTYPE_INCLUDE	  15
#define	TTYPE_SYMB	  16
#define	TTYPE_SYMBOL	  17
#define	TTYPE_DIAG	  18
#define	TTYPE_LINK_ANCHOR 19
#define	TTYPE_LINK_TEXT	  20
#define	TTYPE_REF_JOURNAL 21
#define	TTYPE_LIST	  22
#define	TTYPE_NMAX	  23

/* 
 * These define "styles" for element types, like command arguments or
 * executable names.  This is useful when multiple macros must decorate
 * the same thing (like .Ex -std cmd and .Nm cmd). 
 */

/* TODO: abstract this into mdocterm.c. */

const	int ttypes[TTYPE_NMAX] = {
	TERMP_BOLD, 		/* TTYPE_PROG */
	TERMP_BOLD,		/* TTYPE_CMD_FLAG */
	TERMP_UNDER, 		/* TTYPE_CMD_ARG */
	TERMP_BOLD, 		/* TTYPE_SECTION */
	TERMP_BOLD,		/* TTYPE_FUNC_DECL */
	TERMP_UNDER,		/* TTYPE_VAR_DECL */
	TERMP_UNDER,		/* TTYPE_FUNC_TYPE */
	TERMP_BOLD, 		/* TTYPE_FUNC_NAME */
	TERMP_UNDER, 		/* TTYPE_FUNC_ARG */
	TERMP_UNDER, 		/* TTYPE_LINK */
	TERMP_BOLD,	 	/* TTYPE_SSECTION */
	TERMP_UNDER, 		/* TTYPE_FILE */
	TERMP_UNDER, 		/* TTYPE_EMPH */
	TERMP_BOLD,	 	/* TTYPE_CONFIG */
	TERMP_BOLD,	 	/* TTYPE_CMD */
	TERMP_BOLD,	 	/* TTYPE_INCLUDE */
	TERMP_BOLD,	 	/* TTYPE_SYMB */
	TERMP_BOLD,	 	/* TTYPE_SYMBOL */
	TERMP_BOLD,	 	/* TTYPE_DIAG */
	TERMP_UNDER, 		/* TTYPE_LINK_ANCHOR */
	TERMP_BOLD,	 	/* TTYPE_LINK_TEXT */
	TERMP_UNDER,	 	/* TTYPE_REF_JOURNAL */
	TERMP_BOLD		/* TTYPE_LIST */
};

static	int		  arg_hasattr(int, const struct mdoc_node *);
static	int		  arg_getattrs(const int *, int *, size_t,
				const struct mdoc_node *);
static	int		  arg_getattr(int, const struct mdoc_node *);
static	size_t		  arg_offset(const struct mdoc_argv *);
static	size_t		  arg_width(const struct mdoc_argv *, int);
static	int		  arg_listtype(const struct mdoc_node *);
static	int		  fmt_block_vspace(struct termp *,
				const struct mdoc_node *,
				const struct mdoc_node *);

/*
 * What follows describes prefix and postfix operations for the abstract
 * syntax tree descent.
 */

#define	DECL_ARGS \
	struct termp *p, \
	struct termpair *pair, \
	const struct mdoc_meta *meta, \
	const struct mdoc_node *node

#define	DECL_PRE(name) \
static	int	 	  name##_pre(DECL_ARGS)
#define	DECL_POST(name) \
static	void	 	  name##_post(DECL_ARGS)
#define	DECL_PREPOST(name) \
DECL_PRE(name); \
DECL_POST(name);

DECL_PREPOST(termp__t);
DECL_PREPOST(termp_aq);
DECL_PREPOST(termp_bd);
DECL_PREPOST(termp_bq);
DECL_PREPOST(termp_brq);
DECL_PREPOST(termp_d1);
DECL_PREPOST(termp_dq);
DECL_PREPOST(termp_fd);
DECL_PREPOST(termp_fn);
DECL_PREPOST(termp_fo);
DECL_PREPOST(termp_ft);
DECL_PREPOST(termp_in);
DECL_PREPOST(termp_it);
DECL_PREPOST(termp_lb);
DECL_PREPOST(termp_op);
DECL_PREPOST(termp_pf);
DECL_PREPOST(termp_pq);
DECL_PREPOST(termp_qq);
DECL_PREPOST(termp_sh);
DECL_PREPOST(termp_ss);
DECL_PREPOST(termp_sq);
DECL_PREPOST(termp_vt);

DECL_PRE(termp__j);
DECL_PRE(termp_ap);
DECL_PRE(termp_ar);
DECL_PRE(termp_at);
DECL_PRE(termp_bf);
DECL_PRE(termp_bsx);
DECL_PRE(termp_bt);
DECL_PRE(termp_cd);
DECL_PRE(termp_cm);
DECL_PRE(termp_dx);
DECL_PRE(termp_em);
DECL_PRE(termp_ex);
DECL_PRE(termp_fa);
DECL_PRE(termp_fl);
DECL_PRE(termp_fx);
DECL_PRE(termp_ic);
DECL_PRE(termp_lk);
DECL_PRE(termp_ms);
DECL_PRE(termp_mt);
DECL_PRE(termp_nd);
DECL_PRE(termp_nm);
DECL_PRE(termp_ns);
DECL_PRE(termp_nx);
DECL_PRE(termp_ox);
DECL_PRE(termp_pa);
DECL_PRE(termp_pp);
DECL_PRE(termp_rs);
DECL_PRE(termp_rv);
DECL_PRE(termp_sm);
DECL_PRE(termp_st);
DECL_PRE(termp_sx);
DECL_PRE(termp_sy);
DECL_PRE(termp_ud);
DECL_PRE(termp_ux);
DECL_PRE(termp_va);
DECL_PRE(termp_xr);

DECL_POST(termp___);
DECL_POST(termp_bl);
DECL_POST(termp_bx);

const	struct termact __termacts[MDOC_MAX] = {
	{ NULL, NULL }, /* \" */
	{ NULL, NULL }, /* Dd */
	{ NULL, NULL }, /* Dt */
	{ NULL, NULL }, /* Os */
	{ termp_sh_pre, termp_sh_post }, /* Sh */
	{ termp_ss_pre, termp_ss_post }, /* Ss */ 
	{ termp_pp_pre, NULL }, /* Pp */ 
	{ termp_d1_pre, termp_d1_post }, /* D1 */
	{ termp_d1_pre, termp_d1_post }, /* Dl */
	{ termp_bd_pre, termp_bd_post }, /* Bd */
	{ NULL, NULL }, /* Ed */
	{ NULL, termp_bl_post }, /* Bl */
	{ NULL, NULL }, /* El */
	{ termp_it_pre, termp_it_post }, /* It */
	{ NULL, NULL }, /* Ad */ 
	{ NULL, NULL }, /* An */
	{ termp_ar_pre, NULL }, /* Ar */
	{ termp_cd_pre, NULL }, /* Cd */
	{ termp_cm_pre, NULL }, /* Cm */
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
	{ termp_ex_pre, NULL }, /* Ex */
	{ termp_fa_pre, NULL }, /* Fa */ 
	{ termp_fd_pre, termp_fd_post }, /* Fd */ 
	{ termp_fl_pre, NULL }, /* Fl */
	{ termp_fn_pre, termp_fn_post }, /* Fn */ 
	{ termp_ft_pre, termp_ft_post }, /* Ft */ 
	{ termp_ic_pre, NULL }, /* Ic */ 
	{ termp_in_pre, termp_in_post }, /* In */ 
	{ NULL, NULL }, /* Li */
	{ termp_nd_pre, NULL }, /* Nd */ 
	{ termp_nm_pre, NULL }, /* Nm */ 
	{ termp_op_pre, termp_op_post }, /* Op */
	{ NULL, NULL }, /* Ot */
	{ termp_pa_pre, NULL }, /* Pa */
	{ termp_rv_pre, NULL }, /* Rv */
	{ termp_st_pre, NULL }, /* St */ 
	{ termp_va_pre, NULL }, /* Va */
	{ termp_vt_pre, termp_vt_post }, /* Vt */ 
	{ termp_xr_pre, NULL }, /* Xr */
	{ NULL, termp____post }, /* %A */
	{ NULL, termp____post }, /* %B */
	{ NULL, termp____post }, /* %D */
	{ NULL, termp____post }, /* %I */
	{ termp__j_pre, termp____post }, /* %J */
	{ NULL, termp____post }, /* %N */
	{ NULL, termp____post }, /* %O */
	{ NULL, termp____post }, /* %P */
	{ NULL, termp____post }, /* %R */
	{ termp__t_pre, termp__t_post }, /* %T */
	{ NULL, termp____post }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ termp_aq_pre, termp_aq_post }, /* Ao */
	{ termp_aq_pre, termp_aq_post }, /* Aq */
	{ termp_at_pre, NULL }, /* At */
	{ NULL, NULL }, /* Bc */
	{ termp_bf_pre, NULL }, /* Bf */ 
	{ termp_bq_pre, termp_bq_post }, /* Bo */
	{ termp_bq_pre, termp_bq_post }, /* Bq */
	{ termp_bsx_pre, NULL }, /* Bsx */
	{ NULL, termp_bx_post }, /* Bx */
	{ NULL, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ termp_dq_pre, termp_dq_post }, /* Do */
	{ termp_dq_pre, termp_dq_post }, /* Dq */
	{ NULL, NULL }, /* Ec */
	{ NULL, NULL }, /* Ef */
	{ termp_em_pre, NULL }, /* Em */ 
	{ NULL, NULL }, /* Eo */
	{ termp_fx_pre, NULL }, /* Fx */
	{ termp_ms_pre, NULL }, /* Ms */
	{ NULL, NULL }, /* No */
	{ termp_ns_pre, NULL }, /* Ns */
	{ termp_nx_pre, NULL }, /* Nx */
	{ termp_ox_pre, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ termp_pf_pre, termp_pf_post }, /* Pf */
	{ termp_pq_pre, termp_pq_post }, /* Po */
	{ termp_pq_pre, termp_pq_post }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ termp_sq_pre, termp_sq_post }, /* Ql */
	{ termp_qq_pre, termp_qq_post }, /* Qo */
	{ termp_qq_pre, termp_qq_post }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ termp_rs_pre, NULL }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ termp_sq_pre, termp_sq_post }, /* So */
	{ termp_sq_pre, termp_sq_post }, /* Sq */
	{ termp_sm_pre, NULL }, /* Sm */
	{ termp_sx_pre, NULL }, /* Sx */
	{ termp_sy_pre, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
	{ termp_ux_pre, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ termp_fo_pre, termp_fo_post }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
	{ termp_op_pre, termp_op_post }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ NULL, NULL }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ termp_bt_pre, NULL }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ NULL, NULL }, /* Fr */
	{ termp_ud_pre, NULL }, /* Ud */
	{ termp_lb_pre, termp_lb_post }, /* Lb */
	{ termp_ap_pre, NULL }, /* Lb */
	{ termp_pp_pre, NULL }, /* Pp */ 
	{ termp_lk_pre, NULL }, /* Lk */ 
	{ termp_mt_pre, NULL }, /* Mt */ 
	{ termp_brq_pre, termp_brq_post }, /* Brq */ 
	{ termp_brq_pre, termp_brq_post }, /* Bro */ 
	{ NULL, NULL }, /* Brc */ 
	{ NULL, NULL }, /* %C */ 
	{ NULL, NULL }, /* Es */ 
	{ NULL, NULL }, /* En */ 
	{ termp_dx_pre, NULL }, /* Dx */ 
	{ NULL, NULL }, /* %Q */ 
};

const struct termact *termacts = __termacts;


static size_t
arg_width(const struct mdoc_argv *arg, int pos)
{
	size_t		 v;
	int		 i, len;

	assert(pos < (int)arg->sz && pos >= 0);
	assert(arg->value[pos]);
	if (0 == strcmp(arg->value[pos], "indent"))
		return(INDENT);
	if (0 == strcmp(arg->value[pos], "indent-two"))
		return(INDENT * 2);

	if (0 == (len = (int)strlen(arg->value[pos])))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)arg->value[pos][i]))
			break;

	if (i == len - 1) {
		if ('n' == arg->value[pos][len - 1]) {
			v = (size_t)atoi(arg->value[pos]);
			return(v);
		}

	}
	return(strlen(arg->value[pos]) + 1);
}


static int
arg_listtype(const struct mdoc_node *n)
{
	int		 i, len;

	assert(MDOC_BLOCK == n->type);

	len = (int)(n->args ? n->args->argc : 0);

	for (i = 0; i < len; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	errx(1, "list type not supported");
	/* NOTREACHED */
}


static size_t
arg_offset(const struct mdoc_argv *arg)
{

	/* TODO */
	assert(*arg->value);
	if (0 == strcmp(*arg->value, "indent"))
		return(INDENT);
	if (0 == strcmp(*arg->value, "indent-two"))
		return(INDENT * 2);
	return(strlen(*arg->value));
}


static int
arg_hasattr(int arg, const struct mdoc_node *n)
{

	return(-1 != arg_getattr(arg, n));
}


static int
arg_getattr(int v, const struct mdoc_node *n)
{
	int		 val;

	return(arg_getattrs(&v, &val, 1, n) ? val : -1);
}


static int
arg_getattrs(const int *keys, int *vals, 
		size_t sz, const struct mdoc_node *n)
{
	int		 i, j, k;

	if (NULL == n->args)
		return(0);

	for (k = i = 0; i < (int)n->args->argc; i++) 
		for (j = 0; j < (int)sz; j++)
			if (n->args->argv[i].arg == keys[j]) {
				vals[j] = i;
				k++;
			}
	return(k);
}


/* ARGSUSED */
static int
fmt_block_vspace(struct termp *p, 
		const struct mdoc_node *bl, 
		const struct mdoc_node *node)
{
	const struct mdoc_node *n;

	term_newln(p);

	if (arg_hasattr(MDOC_Compact, bl))
		return(1);

	for (n = node; n; n = n->parent) {
		if (MDOC_BLOCK != n->type)
			continue;
		if (MDOC_Ss == n->tok)
			break;
		if (MDOC_Sh == n->tok)
			break;
		if (NULL == n->prev)
			continue;
		term_vspace(p);
		break;
	}

	return(1);
}


/* ARGSUSED */
static int
termp_dq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);

	term_word(p, "\\(lq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_dq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rq");
}


/* ARGSUSED */
static int
termp_it_pre(DECL_ARGS)
{
	const struct mdoc_node *bl, *n;
	char		        buf[7];
	int		        i, type, keys[3], vals[3];
	size_t		        width, offset;

	if (MDOC_BLOCK == node->type)
		return(fmt_block_vspace(p, node->parent->parent, node));

	bl = node->parent->parent->parent;

	/* Save parent attributes. */

	pair->offset = p->offset;
	pair->rmargin = p->rmargin;
	pair->flag = p->flags;

	/* Get list width and offset. */

	keys[0] = MDOC_Width;
	keys[1] = MDOC_Offset;
	keys[2] = MDOC_Column;

	vals[0] = vals[1] = vals[2] = -1;

	width = offset = 0;

	(void)arg_getattrs(keys, vals, 3, bl);

	type = arg_listtype(bl);

	/* Calculate real width and offset. */

	switch (type) {
	case (MDOC_Column):
		if (MDOC_BODY == node->type)
			break;
		for (i = 0, n = node->prev; n; n = n->prev, i++)
			offset += arg_width 
				(&bl->args->argv[vals[2]], i);
		assert(i < (int)bl->args->argv[vals[2]].sz);
		width = arg_width(&bl->args->argv[vals[2]], i);
		if (vals[1] >= 0) 
			offset += arg_offset(&bl->args->argv[vals[1]]);
		break;
	default:
		if (vals[0] >= 0) 
			width = arg_width(&bl->args->argv[vals[0]], 0);
		if (vals[1] >= 0) 
			offset = arg_offset(&bl->args->argv[vals[1]]);
		break;
	}

	/* 
	 * List-type can override the width in the case of fixed-head
	 * values (bullet, dash/hyphen, enum).  Tags need a non-zero
	 * offset.
	 */

	switch (type) {
	case (MDOC_Bullet):
		/* FALLTHROUGH */
	case (MDOC_Dash):
		/* FALLTHROUGH */
	case (MDOC_Enum):
		/* FALLTHROUGH */
	case (MDOC_Hyphen):
		if (width < 4)
			width = 4;
		break;
	case (MDOC_Tag):
		if (0 == width)
			width = 10;
		break;
	default:
		break;
	}

	/* 
	 * Whitespace control.  Inset bodies need an initial space.
	 */

	switch (type) {
	case (MDOC_Diag):
		/* FALLTHROUGH */
	case (MDOC_Inset):
		if (MDOC_BODY == node->type) 
			p->flags &= ~TERMP_NOSPACE;
		else
			p->flags |= TERMP_NOSPACE;
		break;
	default:
		p->flags |= TERMP_NOSPACE;
		break;
	}

	/*
	 * Style flags.  Diagnostic heads need TTYPE_DIAG.
	 */

	switch (type) {
	case (MDOC_Diag):
		if (MDOC_HEAD == node->type)
			p->flags |= ttypes[TTYPE_DIAG];
		break;
	default:
		break;
	}

	/*
	 * Pad and break control.  This is the tricker part.  Lists with
	 * set right-margins for the head get TERMP_NOBREAK because, if
	 * they overrun the margin, they wrap to the new margin.
	 * Correspondingly, the body for these types don't left-pad, as
	 * the head will pad out to to the right.
	 */

	switch (type) {
	case (MDOC_Bullet):
		/* FALLTHROUGH */
	case (MDOC_Dash):
		/* FALLTHROUGH */
	case (MDOC_Enum):
		/* FALLTHROUGH */
	case (MDOC_Hyphen):
		/* FALLTHROUGH */
	case (MDOC_Tag):
		if (MDOC_HEAD == node->type)
			p->flags |= TERMP_NOBREAK;
		else
			p->flags |= TERMP_NOLPAD;
		if (MDOC_HEAD == node->type && MDOC_Tag == type)
			if (NULL == node->next ||
					NULL == node->next->child)
				p->flags |= TERMP_NONOBREAK;
		break;
	case (MDOC_Column):
		if (MDOC_HEAD == node->type) {
			assert(node->next);
			if (MDOC_BODY == node->next->type)
				p->flags &= ~TERMP_NOBREAK;
			else
				p->flags |= TERMP_NOBREAK;
			if (node->prev) 
				p->flags |= TERMP_NOLPAD;
		}
		break;
	case (MDOC_Diag):
		if (MDOC_HEAD == node->type)
			p->flags |= TERMP_NOBREAK;
		break;
	default:
		break;
	}

	/* 
	 * Margin control.  Set-head-width lists have their right
	 * margins shortened.  The body for these lists has the offset
	 * necessarily lengthened.  Everybody gets the offset.
	 */

	p->offset += offset;

	switch (type) {
	case (MDOC_Bullet):
		/* FALLTHROUGH */
	case (MDOC_Dash):
		/* FALLTHROUGH */
	case (MDOC_Enum):
		/* FALLTHROUGH */
	case (MDOC_Hyphen):
		/* FALLTHROUGH */
	case (MDOC_Tag):
		if (MDOC_HEAD == node->type)
			p->rmargin = p->offset + width;
		else 
			p->offset += width;
		break;
	case (MDOC_Column):
		p->rmargin = p->offset + width;
		break;
	default:
		break;
	}

	/* 
	 * The dash, hyphen, bullet and enum lists all have a special
	 * HEAD character.  Print it now.
	 */

	if (MDOC_HEAD == node->type)
		switch (type) {
		case (MDOC_Bullet):
			term_word(p, "\\[bu]");
			break;
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			term_word(p, "\\-");
			break;
		case (MDOC_Enum):
			(pair->ppair->ppair->count)++;
			(void)snprintf(buf, sizeof(buf), "%d.", 
					pair->ppair->ppair->count);
			term_word(p, buf);
			break;
		default:
			break;
		}

	/* 
	 * If we're not going to process our children, indicate so here.
	 */

	switch (type) {
	case (MDOC_Bullet):
		/* FALLTHROUGH */
	case (MDOC_Item):
		/* FALLTHROUGH */
	case (MDOC_Dash):
		/* FALLTHROUGH */
	case (MDOC_Hyphen):
		/* FALLTHROUGH */
	case (MDOC_Enum):
		if (MDOC_HEAD == node->type)
			return(0);
		break;
	case (MDOC_Column):
		if (MDOC_BODY == node->type)
			return(0);
		break;
	default:
		break;
	}

	return(1);
}


/* ARGSUSED */
static void
termp_it_post(DECL_ARGS)
{
	int		   type;

	if (MDOC_BODY != node->type && MDOC_HEAD != node->type)
		return;

	type = arg_listtype(node->parent->parent->parent);

	switch (type) {
	case (MDOC_Diag):
		/* FALLTHROUGH */
	case (MDOC_Item):
		/* FALLTHROUGH */
	case (MDOC_Inset):
		if (MDOC_BODY == node->type)
			term_flushln(p);
		break;
	case (MDOC_Column):
		if (MDOC_HEAD == node->type)
			term_flushln(p);
		break;
	default:
		term_flushln(p);
		break;
	}

	p->offset = pair->offset;
	p->rmargin = pair->rmargin;
	p->flags = pair->flag;
}


/* ARGSUSED */
static int
termp_nm_pre(DECL_ARGS)
{

	if (SEC_SYNOPSIS == node->sec)
		term_newln(p);

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_PROG]);
	if (NULL == node->child)
		term_word(p, meta->name);

	return(1);
}


/* ARGSUSED */
static int
termp_fl_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_FLAG]);
	term_word(p, "\\-");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static int
termp_ar_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_ARG]);
	return(1);
}


/* ARGSUSED */
static int
termp_ns_pre(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static int
termp_pp_pre(DECL_ARGS)
{

	term_vspace(p);
	return(1);
}


/* ARGSUSED */
static int
termp_st_pre(DECL_ARGS)
{
	const char	*cp;

	if (node->child && (cp = mdoc_a2st(node->child->string)))
		term_word(p, cp);
	return(0);
}


/* ARGSUSED */
static int
termp_rs_pre(DECL_ARGS)
{

	if (MDOC_BLOCK == node->type && node->prev)
		term_vspace(p);
	return(1);
}


/* ARGSUSED */
static int
termp_rv_pre(DECL_ARGS)
{
	int		 i;

	if (-1 == (i = arg_getattr(MDOC_Std, node)))
		errx(1, "expected -std argument");
	if (1 != node->args->argv[i].sz)
		errx(1, "expected -std argument");

	term_newln(p);
	term_word(p, "The");

	p->flags |= ttypes[TTYPE_FUNC_NAME];
	term_word(p, *node->args->argv[i].value);
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];
	p->flags |= TERMP_NOSPACE;

       	term_word(p, "() function returns the value 0 if successful;");
       	term_word(p, "otherwise the value -1 is returned and the");
       	term_word(p, "global variable");

	p->flags |= ttypes[TTYPE_VAR_DECL];
	term_word(p, "errno");
	p->flags &= ~ttypes[TTYPE_VAR_DECL];

       	term_word(p, "is set to indicate the error.");

	return(1);
}


/* ARGSUSED */
static int
termp_ex_pre(DECL_ARGS)
{
	int		 i;

	if (-1 == (i = arg_getattr(MDOC_Std, node)))
		errx(1, "expected -std argument");
	if (1 != node->args->argv[i].sz)
		errx(1, "expected -std argument");

	term_word(p, "The");
	p->flags |= ttypes[TTYPE_PROG];
	term_word(p, *node->args->argv[i].value);
	p->flags &= ~ttypes[TTYPE_PROG];
       	term_word(p, "utility exits 0 on success, and >0 if an error occurs.");

	return(1);
}


/* ARGSUSED */
static int
termp_nd_pre(DECL_ARGS)
{

	term_word(p, "\\-");
	return(1);
}


/* ARGSUSED */
static void
termp_bl_post(DECL_ARGS)
{

	if (MDOC_BLOCK == node->type)
		term_newln(p);
}


/* ARGSUSED */
static void
termp_op_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type) 
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rB");
}


/* ARGSUSED */
static int
termp_xr_pre(DECL_ARGS)
{
	const struct mdoc_node *n;

	if (NULL == (n = node->child))
		errx(1, "expected text line argument");
	term_word(p, n->string);
	if (NULL == (n = n->next)) 
		return(0);
	p->flags |= TERMP_NOSPACE;
	term_word(p, "(");
	p->flags |= TERMP_NOSPACE;
	term_word(p, n->string);
	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");
	return(0);
}


/* ARGSUSED */
static int
termp_vt_pre(DECL_ARGS)
{

	/* FIXME: this can be "type name". */
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_VAR_DECL]);
	return(1);
}


/* ARGSUSED */
static void
termp_vt_post(DECL_ARGS)
{

	if (node->sec == SEC_SYNOPSIS)
		term_vspace(p);
}


/* ARGSUSED */
static int
termp_fd_pre(DECL_ARGS)
{

	/* 
	 * FIXME: this naming is bad.  This value is used, in general,
	 * for the #include header or other preprocessor statement.
	 */
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_DECL]);
	return(1);
}


/* ARGSUSED */
static void
termp_fd_post(DECL_ARGS)
{

	if (node->sec != SEC_SYNOPSIS)
		return;
	term_newln(p);
	if (node->next && MDOC_Fd != node->next->tok)
		term_vspace(p);
}


/* ARGSUSED */
static int
termp_sh_pre(DECL_ARGS)
{

	switch (node->type) {
	case (MDOC_HEAD):
		term_vspace(p);
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SECTION]);
		break;
	case (MDOC_BODY):
		p->offset = INDENT;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static void
termp_sh_post(DECL_ARGS)
{

	switch (node->type) {
	case (MDOC_HEAD):
		term_newln(p);
		break;
	case (MDOC_BODY):
		term_newln(p);
		p->offset = 0;
		break;
	default:
		break;
	}
}


/* ARGSUSED */
static int
termp_op_pre(DECL_ARGS)
{

	switch (node->type) {
	case (MDOC_BODY):
		term_word(p, "\\(lB");
		p->flags |= TERMP_NOSPACE;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
termp_bt_pre(DECL_ARGS)
{

	term_word(p, "is currently in beta test.");
	return(1);
}


/* ARGSUSED */
static int
termp_lb_pre(DECL_ARGS)
{
	const char	*lb;

	if (NULL == node->child)
		errx(1, "expected text line argument");
	if ((lb = mdoc_a2lib(node->child->string))) {
		term_word(p, lb);
		return(0);
	}
	term_word(p, "library");
	return(1);
}


/* ARGSUSED */
static void
termp_lb_post(DECL_ARGS)
{

	term_newln(p);
}


/* ARGSUSED */
static int
termp_ud_pre(DECL_ARGS)
{

	term_word(p, "currently under development.");
	return(1);
}


/* ARGSUSED */
static int
termp_d1_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_newln(p);
	p->offset += (pair->offset = INDENT);
	return(1);
}


/* ARGSUSED */
static void
termp_d1_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type) 
		return;
	term_newln(p);
	p->offset -= pair->offset;
}


/* ARGSUSED */
static int
termp_aq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_word(p, "\\(la");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_aq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(ra");
}


/* ARGSUSED */
static int
termp_ft_pre(DECL_ARGS)
{

	if (SEC_SYNOPSIS == node->sec)
		if (node->prev && MDOC_Fo == node->prev->tok)
			term_vspace(p);
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_TYPE]);
	return(1);
}


/* ARGSUSED */
static void
termp_ft_post(DECL_ARGS)
{

	if (SEC_SYNOPSIS == node->sec)
		term_newln(p);
}


/* ARGSUSED */
static int
termp_fn_pre(DECL_ARGS)
{
	const struct mdoc_node *n;

	if (NULL == node->child)
		errx(1, "expected text line arguments");

	/* FIXME: can be "type funcname" "type varname"... */

	p->flags |= ttypes[TTYPE_FUNC_NAME];
	term_word(p, node->child->string);
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];

	p->flags |= TERMP_NOSPACE;
	term_word(p, "(");

	for (n = node->child->next; n; n = n->next) {
		p->flags |= ttypes[TTYPE_FUNC_ARG];
		term_word(p, n->string);
		p->flags &= ~ttypes[TTYPE_FUNC_ARG];
		if (n->next)
			term_word(p, ",");
	}

	term_word(p, ")");

	if (SEC_SYNOPSIS == node->sec)
		term_word(p, ";");

	return(0);
}


/* ARGSUSED */
static void
termp_fn_post(DECL_ARGS)
{

	if (node->sec == SEC_SYNOPSIS && node->next)
		term_vspace(p);

}


/* ARGSUSED */
static int
termp_sx_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK]);
	return(1);
}


/* ARGSUSED */
static int
termp_fa_pre(DECL_ARGS)
{
	struct mdoc_node *n;

	if (node->parent->tok != MDOC_Fo) {
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FUNC_ARG]);
		return(1);
	}

	for (n = node->child; n; n = n->next) {
		p->flags |= ttypes[TTYPE_FUNC_ARG];
		term_word(p, n->string);
		p->flags &= ~ttypes[TTYPE_FUNC_ARG];
		if (n->next)
			term_word(p, ",");
	}

	if (node->child && node->next && node->next->tok == MDOC_Fa)
		term_word(p, ",");

	return(0);
}


/* ARGSUSED */
static int
termp_va_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_VAR_DECL]);
	return(1);
}


/* ARGSUSED */
static int
termp_bd_pre(DECL_ARGS)
{
	int	         i, type, ln;

	/*
	 * This is fairly tricky due primarily to crappy documentation.
	 * If -ragged or -filled are specified, the block does nothing
	 * but change the indentation.
	 *
	 * If, on the other hand, -unfilled or -literal are specified,
	 * then the game changes.  Text is printed exactly as entered in
	 * the display: if a macro line, a newline is appended to the
	 * line.  Blank lines are allowed.
	 */

	if (MDOC_BLOCK == node->type)
		return(fmt_block_vspace(p, node, node));
	else if (MDOC_BODY != node->type)
		return(1);

	if (NULL == node->parent->args)
		errx(1, "missing display type");

	pair->offset = p->offset;

	for (type = -1, i = 0; 
			i < (int)node->parent->args->argc; i++) {
		switch (node->parent->args->argv[i].arg) {
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			type = node->parent->args->argv[i].arg;
			i = (int)node->parent->args->argc;
			break;
		default:
			break;
		}
	}

	if (NULL == node->parent->args)
		errx(1, "missing display type");

	i = arg_getattr(MDOC_Offset, node->parent);
	if (-1 != i) {
		if (1 != node->parent->args->argv[i].sz)
			errx(1, "expected single value");
		p->offset += arg_offset(&node->parent->args->argv[i]);
	}

	switch (type) {
	case (MDOC_Literal):
		/* FALLTHROUGH */
	case (MDOC_Unfilled):
		break;
	default:
		return(1);
	}

	/*
	 * Tricky.  Iterate through all children.  If we're on a
	 * different parse line, append a newline and then the contents.
	 * Ew.
	 */

	p->flags |= TERMP_LITERAL;
	ln = node->child ? node->child->line : 0;

	for (node = node->child; node; node = node->next) {
		if (ln < node->line) {
			term_flushln(p);
			p->flags |= TERMP_NOSPACE;
		}
		ln = node->line;
		term_node(p, pair, meta, node);
	}

	return(0);
}


/* ARGSUSED */
static void
termp_bd_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type) 
		return;

	term_flushln(p);
	p->flags &= ~TERMP_LITERAL;
	p->offset = pair->offset;
	p->flags |= TERMP_NOSPACE;
}


/* ARGSUSED */
static int
termp_qq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_word(p, "\"");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_qq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\"");
}


/* ARGSUSED */
static int
termp_bsx_pre(DECL_ARGS)
{

	term_word(p, "BSDI BSD/OS");
	return(1);
}


/* ARGSUSED */
static void
termp_bx_post(DECL_ARGS)
{

	if (node->child)
		p->flags |= TERMP_NOSPACE;
	term_word(p, "BSD");
}


/* ARGSUSED */
static int
termp_ox_pre(DECL_ARGS)
{

	term_word(p, "OpenBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_dx_pre(DECL_ARGS)
{

	term_word(p, "DragonFly");
	return(1);
}


/* ARGSUSED */
static int
termp_ux_pre(DECL_ARGS)
{

	term_word(p, "UNIX");
	return(1);
}


/* ARGSUSED */
static int
termp_fx_pre(DECL_ARGS)
{

	term_word(p, "FreeBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_nx_pre(DECL_ARGS)
{

	term_word(p, "NetBSD");
	return(1);
}


/* ARGSUSED */
static int
termp_sq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_word(p, "\\(oq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_sq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(aq");
}


/* ARGSUSED */
static int
termp_pf_pre(DECL_ARGS)
{

	p->flags |= TERMP_IGNDELIM;
	return(1);
}


/* ARGSUSED */
static void
termp_pf_post(DECL_ARGS)
{

	p->flags &= ~TERMP_IGNDELIM;
	p->flags |= TERMP_NOSPACE;
}


/* ARGSUSED */
static int
termp_ss_pre(DECL_ARGS)
{

	switch (node->type) {
	case (MDOC_BLOCK):
		term_newln(p);
		if (node->prev)
			term_vspace(p);
		break;
	case (MDOC_HEAD):
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SSECTION]);
		p->offset = INDENT / 2;
		break;
	default:
		break;
	}

	return(1);
}


/* ARGSUSED */
static void
termp_ss_post(DECL_ARGS)
{

	switch (node->type) {
	case (MDOC_HEAD):
		term_newln(p);
		p->offset = INDENT;
		break;
	default:
		break;
	}
}


/* ARGSUSED */
static int
termp_pa_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_FILE]);
	return(1);
}


/* ARGSUSED */
static int
termp_em_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
	return(1);
}


/* ARGSUSED */
static int
termp_cd_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CONFIG]);
	term_newln(p);
	return(1);
}


/* ARGSUSED */
static int
termp_cm_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD_FLAG]);
	return(1);
}


/* ARGSUSED */
static int
termp_ic_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_CMD]);
	return(1);
}


/* ARGSUSED */
static int
termp_in_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_INCLUDE]);
	term_word(p, "#include");
	term_word(p, "<");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_in_post(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, ">");

	term_newln(p);
	if (SEC_SYNOPSIS != node->sec)
		return;
	if (node->next && MDOC_In != node->next->tok)
		term_vspace(p);
}


/* ARGSUSED */
static int
termp_at_pre(DECL_ARGS)
{
	const char	*att;

	att = NULL;

	if (node->child)
		att = mdoc_a2att(node->child->string);
	if (NULL == att)
		att = "AT&T UNIX";

	term_word(p, att);
	return(0);
}


/* ARGSUSED */
static int
termp_brq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_word(p, "\\(lC");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_brq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rC");
}


/* ARGSUSED */
static int
termp_bq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_word(p, "\\(lB");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_bq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(rB");
}


/* ARGSUSED */
static int
termp_pq_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	term_word(p, "\\&(");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_pq_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	term_word(p, ")");
}


/* ARGSUSED */
static int
termp_fo_pre(DECL_ARGS)
{
	const struct mdoc_node *n;

	if (MDOC_BODY == node->type) {
		term_word(p, "(");
		p->flags |= TERMP_NOSPACE;
		return(1);
	} else if (MDOC_HEAD != node->type) 
		return(1);

	/* XXX - groff shows only first parameter */

	p->flags |= ttypes[TTYPE_FUNC_NAME];
	for (n = node->child; n; n = n->next) {
		if (MDOC_TEXT != n->type)
			errx(1, "expected text line argument");
		term_word(p, n->string);
	}
	p->flags &= ~ttypes[TTYPE_FUNC_NAME];

	return(0);
}


/* ARGSUSED */
static void
termp_fo_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	term_word(p, ")");
	p->flags |= TERMP_NOSPACE;
	term_word(p, ";");
	term_newln(p);
}


/* ARGSUSED */
static int
termp_bf_pre(DECL_ARGS)
{
	const struct mdoc_node	*n;

	if (MDOC_HEAD == node->type) {
		return(0);
	} else if (MDOC_BLOCK != node->type)
		return(1);

	if (NULL == (n = node->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, node))
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
		else if (arg_hasattr(MDOC_Symbolic, node))
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMB]);

		return(1);
	} 

	if (MDOC_TEXT != n->type)
		errx(1, "expected text line arguments");

	if (0 == strcmp("Em", n->string))
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);
	else if (0 == strcmp("Sy", n->string))
		TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_EMPH]);

	return(1);
}


/* ARGSUSED */
static int
termp_sy_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMB]);
	return(1);
}


/* ARGSUSED */
static int
termp_ms_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_SYMBOL]);
	return(1);
}



/* ARGSUSED */
static int
termp_sm_pre(DECL_ARGS)
{

	if (NULL == node->child || MDOC_TEXT != node->child->type)
		errx(1, "expected boolean line argument");

	if (0 == strcmp("on", node->child->string)) {
		p->flags &= ~TERMP_NONOSPACE;
		p->flags &= ~TERMP_NOSPACE;
	} else
		p->flags |= TERMP_NONOSPACE;

	return(0);
}


/* ARGSUSED */
static int
termp_ap_pre(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\\(aq");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static int
termp__j_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_REF_JOURNAL]);
	return(1);
}


/* ARGSUSED */
static int
termp__t_pre(DECL_ARGS)
{

	term_word(p, "\"");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp__t_post(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, "\"");
	termp____post(p, pair, meta, node);
}


/* ARGSUSED */
static void
termp____post(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	term_word(p, node->next ? "," : ".");
}


/* ARGSUSED */
static int
termp_lk_pre(DECL_ARGS)
{
	const struct mdoc_node *n;

	if (NULL == (n = node->child))
		errx(1, "expected line argument");

	p->flags |= ttypes[TTYPE_LINK_ANCHOR];
	term_word(p, n->string);
	p->flags &= ~ttypes[TTYPE_LINK_ANCHOR];
	p->flags |= TERMP_NOSPACE;
	term_word(p, ":");

	p->flags |= ttypes[TTYPE_LINK_TEXT];
	for ( ; n; n = n->next) {
		term_word(p, n->string);
	}
	p->flags &= ~ttypes[TTYPE_LINK_TEXT];

	return(0);
}


/* ARGSUSED */
static int
termp_mt_pre(DECL_ARGS)
{

	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_LINK_ANCHOR]);
	return(1);
}

@


1.68
log
@Fixed Bd -compact.
Fixed vspace before Bd and Bl.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.67 2009/03/21 13:47:02 kristaps Exp $ */
d59 2
a60 1
#define	TTYPE_NMAX	  22
d92 2
a93 1
	TERMP_UNDER	 	/* TTYPE_REF_JOURNAL */
@


1.67
log
@Freed more macros from zero-length restrictions.
Fixed `Fn' spacing.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.66 2009/03/21 13:26:30 kristaps Exp $ */
d101 3
d436 30
a492 13
termp_it_pre_block(DECL_ARGS)
{

	term_newln(p);
	if ( ! arg_hasattr(MDOC_Compact, node->parent->parent))
		term_vspace(p);

	return(1);
}


/* ARGSUSED */
static int
d501 1
a501 1
		return(termp_it_pre_block(p, pair, meta, node));
d1288 3
a1290 6
	if (MDOC_BLOCK == node->type) {
		/* FIXME: parent prev? */
		if (node->prev)
			term_vspace(p);
		return(1);
	} else if (MDOC_BODY != node->type)
@


1.66
log
@Handling -width="" in lists.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.65 2009/03/21 13:09:29 kristaps Exp $ */
d1174 1
a1176 1
	p->flags |= TERMP_NOSPACE;
d1234 1
a1234 1
	if (node->next && node->next->tok == MDOC_Fa)
@


1.65
log
@`Em' accepts empty tokens.
Punctuation fully fixed (per-reserved-word).
Sm enabled.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.64 2009/03/21 09:42:07 kristaps Exp $ */
d323 2
a324 2
	len = (int)strlen(arg->value[pos]);
	assert(len > 0);
@


1.64
log
@Added %Q macro.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.63 2009/03/20 16:43:28 kristaps Exp $ */
d58 1
a58 1
#define	TTYPE_REF_TITLE	  21
d91 1
a91 1
	TERMP_UNDER	 	/* TTYPE_REF_TITLE */
d121 1
d144 1
a144 1
DECL_PRE(termp__t);
d231 1
a231 1
	{ NULL, termp____post }, /* %J */
d236 1
a236 1
	{ termp__t_pre, termp____post }, /* %T */
d1807 4
a1810 3
#if notyet
	assert(node->child);
	if (0 == strcmp("off", node->child->data.text.string)) {
d1813 1
a1813 1
	} else {
a1814 3
		p->flags |= TERMP_NOSPACE;
	}
#endif
d1834 10
d1847 2
a1848 1
	TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_REF_TITLE]);
d1855 11
@


1.63
log
@Fixed literal-formatting error with `Dl'.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.62 2009/03/20 15:14:01 kristaps Exp $ */
d303 1
@


1.62
log
@Support for `Bd' of all types (see mdoc.7 for newline/tab rules).
Renamed term.c and terminal.c functions to be term_.
Some bugfixes to lists.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.61 2009/03/16 23:37:28 kristaps Exp $ */
d1346 1
@


1.61
log
@Changed e-mail address to @@openbsd.
Cleaned up manual-page documentation.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.60 2009/03/16 22:19:19 kristaps Exp $ */
d437 1
a437 1
	word(p, "\\(lq");
d452 1
a452 1
	word(p, "\\(rq");
d461 1
a461 1
	newln(p);
d463 1
a463 3
		/* FIXME: parent->parent->parent? */
		if (node->prev || node->parent->parent->prev)
			vspace(p);
d665 1
a665 1
			word(p, "\\[bu]");
d670 1
a670 1
			word(p, "\\-");
d676 1
a676 1
			word(p, buf);
d729 1
a729 1
			flushln(p);
d733 1
a733 1
			flushln(p);
d736 1
a736 1
		flushln(p);
d752 1
a752 1
		newln(p);
d756 1
a756 1
		word(p, meta->name);
d768 1
a768 1
	word(p, "\\-");
d799 1
a799 1
	vspace(p);
d811 1
a811 1
		word(p, cp);
d822 1
a822 1
		vspace(p);
d838 2
a839 2
	newln(p);
	word(p, "The");
d842 1
a842 1
	word(p, *node->args->argv[i].value);
d846 3
a848 3
       	word(p, "() function returns the value 0 if successful;");
       	word(p, "otherwise the value -1 is returned and the");
       	word(p, "global variable");
d851 1
a851 1
	word(p, "errno");
d854 1
a854 1
       	word(p, "is set to indicate the error.");
d871 1
a871 1
	word(p, "The");
d873 1
a873 1
	word(p, *node->args->argv[i].value);
d875 1
a875 1
       	word(p, "utility exits 0 on success, and >0 if an error occurs.");
d886 1
a886 1
	word(p, "\\-");
d897 1
a897 1
		newln(p);
d909 1
a909 1
	word(p, "\\(rB");
d921 1
a921 1
	word(p, n->string);
d925 1
a925 1
	word(p, "(");
d927 1
a927 1
	word(p, n->string);
d929 1
a929 1
	word(p, ")");
d951 1
a951 1
		vspace(p);
d976 1
a976 1
	newln(p);
d978 1
a978 1
		vspace(p);
d989 1
a989 1
		vspace(p);
d1009 1
a1009 1
		newln(p);
d1012 1
a1012 1
		newln(p);
d1028 1
a1028 1
		word(p, "\\(lB");
d1043 1
a1043 1
	word(p, "is currently in beta test.");
d1057 1
a1057 1
		word(p, lb);
d1060 1
a1060 1
	word(p, "library");
d1070 1
a1070 1
	newln(p);
d1079 1
a1079 1
	word(p, "currently under development.");
d1091 1
a1091 1
	newln(p);
d1104 1
a1104 1
	newln(p);
d1116 1
a1116 1
	word(p, "\\(la");
d1130 1
a1130 1
	word(p, "\\(ra");
d1141 1
a1141 1
			vspace(p);
d1153 1
a1153 1
		newln(p);
d1169 1
a1169 1
	word(p, node->child->string);
d1172 1
a1172 1
	word(p, "(");
d1177 1
a1177 1
		word(p, n->string);
d1180 1
a1180 1
			word(p, ",");
d1183 1
a1183 1
	word(p, ")");
d1186 1
a1186 1
		word(p, ";");
d1198 1
a1198 1
		vspace(p);
d1226 1
a1226 1
		word(p, n->string);
d1229 1
a1229 1
			word(p, ",");
d1233 1
a1233 1
		word(p, ",");
d1253 12
a1264 2
	const struct mdoc_node  *n;
	int		         i, type;
d1269 1
a1269 1
			vspace(p);
d1316 6
d1323 1
d1325 4
a1328 4
	for (n = node->child; n; n = n->next) {
		if (MDOC_TEXT != n->type) {
			warnx("non-text children not yet allowed");
			continue;
d1330 2
a1331 2
		word(p, n->string);
		flushln(p);
a1345 3
	if ( ! (p->flags & TERMP_LITERAL))
		flushln(p);

d1348 1
d1359 1
a1359 1
	word(p, "\"");
d1373 1
a1373 1
	word(p, "\"");
d1382 1
a1382 1
	word(p, "BSDI BSD/OS");
d1394 1
a1394 1
	word(p, "BSD");
d1403 1
a1403 1
	word(p, "OpenBSD");
d1413 1
a1413 1
	word(p, "DragonFly");
d1423 1
a1423 1
	word(p, "UNIX");
d1433 1
a1433 1
	word(p, "FreeBSD");
d1443 1
a1443 1
	word(p, "NetBSD");
d1455 1
a1455 1
	word(p, "\\(oq");
d1469 1
a1469 1
	word(p, "\\(aq");
d1500 1
a1500 1
		newln(p);
d1502 1
a1502 1
			vspace(p);
d1523 1
a1523 1
		newln(p);
d1558 1
a1558 1
	newln(p);
d1589 2
a1590 2
	word(p, "#include");
	word(p, "<");
d1602 1
a1602 1
	word(p, ">");
d1604 1
a1604 1
	newln(p);
d1608 1
a1608 1
		vspace(p);
d1625 1
a1625 1
	word(p, att);
d1637 1
a1637 1
	word(p, "\\(lC");
d1651 1
a1651 1
	word(p, "\\(rC");
d1662 1
a1662 1
	word(p, "\\(lB");
d1676 1
a1676 1
	word(p, "\\(rB");
d1687 1
a1687 1
	word(p, "\\&(");
d1700 1
a1700 1
	word(p, ")");
d1711 1
a1711 1
		word(p, "(");
d1723 1
a1723 1
		word(p, n->string);
d1739 1
a1739 1
	word(p, ")");
d1741 2
a1742 2
	word(p, ";");
	newln(p);
d1825 1
a1825 1
	word(p, "\\(aq");
d1847 1
a1847 1
	word(p, node->next ? "," : ".");
d1861 1
a1861 1
	word(p, n->string);
d1864 1
a1864 1
	word(p, ":");
d1868 1
a1868 1
		word(p, n->string);
@


1.60
log
@Fixed mdoc_phrase escape handling.
Added MDOC_IGNDELIM (Pf, soon Li, etc.).
macro_constant_delimited ignargs -> argv.c parsing.
Renamed macro functions to correspond to ontologies.
`Fo' and `St' made callable (compat documented).
strings.sh deprecated (directly using CPP).
Abstracted ASCII translation into ascii.{c,in}.
ASCII table uses a self-reordering chained hashtable.
Removed old regressions.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.59 2009/03/14 12:35:02 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
d152 1
d302 1
d1397 10
@


1.59
log
@Added colour styles (not being used) to struct termp.
Added nroff style-escape encoding.
Removed ANSI schema string tables (there's only ANSI and nroff/backspace).
Pushed styling directly into pword (simpler).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.58 2009/03/13 07:46:10 kristaps Exp $ */
d299 2
@


1.58
log
@Added canonical mdoc.7.
Added \q macro.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.57 2009/03/12 16:30:50 kristaps Exp $ */
d70 1
a70 1
	TERMP_BOLD,		/* TTYPE_PROG */
d72 1
a72 1
	TERMP_UNDERLINE, 	/* TTYPE_CMD_ARG */
d75 2
a76 2
	TERMP_UNDERLINE,	/* TTYPE_VAR_DECL */
	TERMP_UNDERLINE,	/* TTYPE_FUNC_TYPE */
d78 2
a79 2
	TERMP_UNDERLINE, 	/* TTYPE_FUNC_ARG */
	TERMP_UNDERLINE, 	/* TTYPE_LINK */
d81 2
a82 2
	TERMP_UNDERLINE, 	/* TTYPE_FILE */
	TERMP_UNDERLINE, 	/* TTYPE_EMPH */
d89 1
a89 1
	TERMP_UNDERLINE, 	/* TTYPE_LINK_ANCHOR */
d91 1
a91 1
	TERMP_UNDERLINE	 	/* TTYPE_REF_TITLE */
@


1.57
log
@Added -nested (doesn't do anything).
Added .%C.
.Cd is now callable.
Added .Rv -std.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.56 2009/03/12 15:55:11 kristaps Exp $ */
d1472 5
a1477 1
		vspace(p);
@


1.56
log
@NetBSD '.[[:whitespace:]]*' properly handled.
mdoc.3 indicates compatibilities and bugs.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.55 2009/03/12 06:32:17 kristaps Exp $ */
d298 1
d842 1
@


1.55
log
@Removed segfault with empty word.
Initial "full" -column support.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.54 2009/03/12 02:57:36 kristaps Exp $ */
d511 2
@


1.54
log
@Brq/Bro/Brc fixed up and pretty.
Cleaned up Aq/Sq use of escapes in term.c.
Added initial -column support.
Fixed argv returning ARGV_WORD and tokenising anyway.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.53 2009/03/11 00:39:58 kristaps Exp $ */
d534 1
a534 1
		if (width > 4)
@


1.53
log
@Expanded perfect htab to use 27 * 26 * 3 space.
Added Brq, Bro and Brc macros.
Added lbrace and rbrace to special characters.
Fixed spacing in braces.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.52 2009/03/10 11:16:43 kristaps Exp $ */
d58 2
a59 1
#define	TTYPE_NMAX	  21
d90 2
a91 1
	TERMP_BOLD	 	/* TTYPE_LINK_TEXT */
d95 2
d99 1
a99 1
static	size_t		  arg_width(const struct mdoc_argv *);
a120 1
DECL_PREPOST(termp__t);
d143 1
d234 1
a234 1
	{ termp__t_pre, termp__t_post }, /* %T */
d304 1
a304 1
arg_width(const struct mdoc_argv *arg)
d309 3
a311 2
	assert(*arg->value);
	if (0 == strcmp(*arg->value, "indent"))
d313 1
a313 1
	if (0 == strcmp(*arg->value, "indent-two"))
d316 1
a316 1
	len = (int)strlen(*arg->value);
d320 1
a320 1
		if ( ! isdigit((u_char)(*arg->value)[i]))
d324 2
a325 2
		if ('n' == (*arg->value)[len - 1]) {
			v = (size_t)atoi(*arg->value);
d330 1
a330 1
	return(strlen(*arg->value) + 1);
d361 2
d397 11
a407 1
arg_getattr(int arg, const struct mdoc_node *n)
d409 1
a409 1
	int		 i;
d412 9
a420 5
		return(-1);
	for (i = 0; i < (int)n->args->argc; i++) 
		if (n->args->argv[i].arg == arg)
			return(i);
	return(-1);
d432 1
a432 1
	word(p, "``");
d447 1
a447 1
	word(p, "''");
d458 1
d470 4
a473 4
	const struct mdoc_node *bl;
	char		 buf[7];
	int		 i, type;
	size_t		 width, offset;
a477 2
	/* Get ptr to list block, type, etc. */

a478 1
	type = arg_listtype(bl);
d488 13
a500 2
	i = arg_getattr(MDOC_Width, bl);
	width = i >= 0 ? arg_width(&bl->args->argv[i]) : 0;
d502 17
a518 2
	i = arg_getattr(MDOC_Offset, bl);
	offset = i >= 0 ? arg_offset(&bl->args->argv[i]) : 0;
d534 2
a535 1
		width = width > 4 ? width : 4;
d538 3
a540 4
		if (width)
			break;
		errx(1, "need non-zero %s for list type", 
				mdoc_argnames[MDOC_Width]);
d603 11
d644 4
a647 1
		/* FALLTHROUGH */
a667 1
			/* TODO: have a wordfmt or something. */
d678 1
a678 2
	 * If we're not going to process our header children, indicate
	 * so here.
d681 15
a695 11
	if (MDOC_HEAD == node->type) 
		switch (type) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Enum):
d697 3
a699 2
		default:
			break;
d723 6
a728 3
		if (MDOC_BODY != node->type)
			break;
		flushln(p);
d1251 1
d1424 1
a1424 1
	word(p, "`");
d1438 1
a1438 1
	word(p, "\'");
d1801 1
a1801 3
	/* FIXME: titles are underlined. */
	word(p, "\"");
	p->flags |= TERMP_NOSPACE;
a1807 12
termp__t_post(DECL_ARGS)
{

	p->flags |= TERMP_NOSPACE;
	/* FIXME: titles are underlined. */
	word(p, "\"");
	word(p, node->next ? "," : ".");
}


/* ARGSUSED */
static void
@


1.52
log
@Added regular-form sanity check in mdocterm.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.51 2009/03/09 14:19:59 kristaps Exp $ */
d121 1
d291 3
d1531 25
d1561 1
a1561 1
	word(p, "[");
d1574 2
a1575 1
	word(p, "]");
d1637 1
d1639 1
@


1.51
log
@Added `Mt' and `Lk' macros (NetBSD).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.50 2009/03/09 13:17:49 kristaps Exp $ */
d736 2
a737 6
	if (node->child) {
		if (MDOC_TEXT != node->child->type)
			errx(1, "expected text line arguments");
		if ((cp = mdoc_a2st(node->child->string)))
			word(p, cp);
	}
a845 3
	if (MDOC_TEXT != n->type)
		errx(1, "expected text line argument");

a846 1

a848 3
	if (MDOC_TEXT != n->type)
		errx(1, "expected text line argument");

a854 1

a980 3
	if (MDOC_TEXT != node->child->type)
		errx(1, "expected text line argument");

a984 1

a1089 2
	if (MDOC_TEXT != node->child->type)
		errx(1, "expected text line arguments");
a1100 2
		if (MDOC_TEXT != n->type)
			errx(1, "expected text line arguments");
a1149 3
		if (MDOC_TEXT != n->type)
			errx(1, "expected text line arguments");

a1152 1

d1515 1
a1515 3
	if (node->child) {
		if (MDOC_TEXT != node->child->type)
			errx(1, "expected text line argument");
a1516 2
	}

d1739 1
a1739 3
		errx(1, "expected text line argument");
	if (MDOC_TEXT != n->type)
		errx(1, "expected text line argument");
a1748 2
		if (MDOC_TEXT != n->type)
			errx(1, "expected text line argument");
@


1.50
log
@Easier integration into FreeBSD (sys/types.h, time.h, etc.).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.49 2009/03/08 20:57:35 kristaps Exp $ */
d56 3
a58 1
#define	TTYPE_NMAX	  19
d87 3
a89 1
	TERMP_BOLD	 	/* TTYPE_DIAG */
d153 1
d155 1
d288 2
d1758 40
@


1.49
log
@Added `Lp' macro.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.48 2009/03/08 20:50:12 kristaps Exp $ */
d19 2
@


1.48
log
@Added .Ap.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.47 2009/03/08 19:38:08 kristaps Exp $ */
d279 1
@


1.47
log
@Front-end handling of `Lb'.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.46 2009/03/08 14:01:46 kristaps Exp $ */
d133 1
d278 1
d1705 12
@


1.46
log
@Bumped minor-number.
All sources converted to new schema.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.45 2009/03/08 13:57:07 kristaps Exp $ */
d123 1
a167 1
DECL_POST(termp_lb);
d276 1
a276 1
	{ NULL, termp_lb_post }, /* lb */
d973 21
@


1.45
log
@Segmentation-fault fix in mdocterm.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.44 2009/03/08 13:52:29 kristaps Exp $ */
d319 1
a319 1
	len = n->args ? n->args->argc : 0;
@


1.44
log
@mdocterm now using new API.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.43 2009/03/06 14:13:47 kristaps Exp $ */
d1206 1
a1206 1
		if (1 != node->args->argv[i].sz)
d1208 1
a1208 1
		p->offset += arg_offset(&node->args->argv[i]);
@


1.43
log
@Strings abstracted into dynamically-created C files.
Added -V option.
Deprecated README files.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.42 2009/03/05 13:12:12 kristaps Exp $ */
d86 4
a89 6
static	int		  arg_hasattr(int, size_t, 
				const struct mdoc_arg *);
static	int		  arg_getattr(int, size_t, 
				const struct mdoc_arg *);
static	size_t		  arg_offset(const struct mdoc_arg *);
static	size_t		  arg_width(const struct mdoc_arg *);
d283 1
a283 1
arg_width(const struct mdoc_arg *arg)
a314 1
	const struct mdoc_block *bl;
d317 3
a319 2
	bl = &n->data.block;
	len = (int)bl->argc;
d322 1
a322 1
		switch (bl->argv[i].arg) {
d340 1
a340 1
			return(bl->argv[i].arg);
d351 1
a351 1
arg_offset(const struct mdoc_arg *arg)
d365 1
a365 1
arg_hasattr(int arg, size_t argc, const struct mdoc_arg *argv)
d368 1
a368 1
	return(-1 != arg_getattr(arg, argc, argv));
d373 1
a373 1
arg_getattr(int arg, size_t argc, const struct mdoc_arg *argv)
d377 4
a380 2
	for (i = 0; i < (int)argc; i++) 
		if (argv[i].arg == arg)
a416 5
	const struct mdoc_node  *n;
	const struct mdoc_block *bl;

	n = node->parent->parent;
	bl = &n->data.block;
d419 2
a420 2
	if ( ! arg_hasattr(MDOC_Compact, bl->argc, bl->argv))
		if (node->prev || n->prev)
d431 1
a431 1
	const struct mdoc_block *bl;
d441 2
a442 2
	bl = &node->parent->parent->parent->data.block;
	type = arg_listtype(node->parent->parent->parent);
d452 2
a453 2
	i = arg_getattr(MDOC_Width, bl->argc, bl->argv);
	width = i >= 0 ? arg_width(&bl->argv[i]) : 0;
d455 2
a456 2
	i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
	offset = i >= 0 ? arg_offset(&bl->argv[i]) : 0;
d723 4
a726 3
	/* XXX - if child isn't text? */
	if (node->child) 
		if ((cp = mdoc_a2st(node->child->data.text.string)))
d728 1
d750 4
a753 3
	i = arg_getattr(MDOC_Std, node->data.elem.argc, 
			node->data.elem.argv);
	assert(i >= 0);
d759 1
a759 1
	word(p, *node->data.elem.argv[i].value);
d782 4
a785 3
	i = arg_getattr(MDOC_Std, node->data.elem.argc, 
			node->data.elem.argv);
	assert(i >= 0);
d789 1
a789 1
	word(p, *node->data.elem.argv[i].value);
d835 4
a838 2
	n = node->child;
	assert(n);
d840 1
a840 2
	assert(MDOC_TEXT == n->type);
	word(p, n->data.text.string);
d844 2
a846 1
	assert(MDOC_TEXT == n->type);
d850 1
a850 1
	word(p, n->data.text.string);
d1070 4
a1073 2
	assert(node->child);
	assert(MDOC_TEXT == node->child->type);
d1078 1
a1078 1
	word(p, node->child->data.text.string);
d1085 2
a1086 1
		assert(MDOC_TEXT == n->type);
d1088 1
a1088 1
		word(p, n->data.text.string);
d1136 2
a1137 1
		assert(MDOC_TEXT == n->type);
d1140 1
a1140 1
		word(p, n->data.text.string);
a1167 1
	const struct mdoc_block *bl;
d1169 1
a1169 1
	int		 i, type;
d1178 3
a1181 1
	bl = &node->parent->data.block;
d1183 3
a1185 2
	for (type = -1, i = 0; i < (int)bl->argc; i++) {
		switch (bl->argv[i].arg) {
d1193 2
a1194 2
			type = bl->argv[i].arg;
			i = (int)bl->argc;
d1197 1
a1197 1
			errx(1, "display type not supported");
d1201 2
a1202 1
	assert(-1 != type);
d1204 1
a1204 1
	i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
d1206 3
a1208 2
		assert(1 == bl->argv[i].sz);
		p->offset += arg_offset(&bl->argv[i]);
a1210 1

d1227 1
a1227 1
		word(p, n->data.text.string);
d1506 3
a1508 2
		assert(MDOC_TEXT == node->child->type);
		att = mdoc_a2att(node->child->data.text.string);
d1584 3
a1586 2
		assert(MDOC_TEXT == n->type);
		word(p, n->data.text.string);
a1611 1
	const struct mdoc_block	*b;
d1613 1
a1613 3
	/* XXX - we skip over possible trailing HEAD tokens. */

	if (MDOC_HEAD == node->type)
d1615 1
a1615 1
	else if (MDOC_BLOCK != node->type)
d1618 2
a1619 4
	b = &node->data.block;

	if (NULL == (n = b->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, b->argc, b->argv))
d1621 1
a1621 1
		else if (arg_hasattr(MDOC_Symbolic, b->argc, b->argv))
d1627 2
a1628 1
	assert(MDOC_TEXT == n->type);
d1630 1
a1630 1
	if (0 == strcmp("Em", n->data.text.string))
d1632 1
a1632 1
	else if (0 == strcmp("Sy", n->data.text.string))
@


1.42
log
@Cleaned up ctype functions (netbsd).
Fixed .Ex/.Rv -std usage.
Made Ar provide default value.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.41 2009/03/04 14:41:40 kristaps Exp $ */
d169 1
d278 1
d726 1
a726 1
	const char 	*tp;
d728 5
a732 6
	assert(1 == node->data.elem.argc);

	tp = mdoc_st2a(node->data.elem.argv[0].arg);
	word(p, tp);

	return(1);
d972 9
d1493 3
a1495 1
	enum mdoc_att	 c;
a1496 1
	c = ATT_DEFAULT;
d1499 1
a1499 1
		c = mdoc_atoatt(node->child->data.text.string);
d1502 4
a1505 1
	word(p, mdoc_att2a(c));
@


1.41
log
@-tag, if followed by empty body, doesn't newline.
Versioning up.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.40 2009/03/04 14:13:05 kristaps Exp $ */
d298 1
a298 1
		if ( ! isdigit((int)(*arg->value)[i]))
a695 4
	if (NULL == node->child) {
		word(p, "file");
		word(p, "...");
	}
@


1.40
log
@Fixed some character-escapes.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.39 2009/03/04 13:57:35 kristaps Exp $ */
d539 4
d1669 1
d1682 1
@


1.39
log
@Considerably cleaned up list handling.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.38 2009/03/03 22:28:21 kristaps Exp $ */
d1012 1
a1012 1
	word(p, "<");
d1026 1
a1026 1
	word(p, ">");
@


1.38
log
@-diag fixed (allows quoted parameters)
Versioned up.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.37 2009/03/03 22:17:19 kristaps Exp $ */
d92 1
d312 38
d413 19
a433 1
	const struct mdoc_node *n, *it;
d435 1
a435 1
	char		 buf[7], *tp;
d439 2
a440 12
	switch (node->type) {
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_HEAD):
		it = node->parent;
		break;
	case (MDOC_BLOCK):
		it = node;
		break;
	default:
		return(1);
	}
d442 1
a442 2
	n = it->parent->parent;
	bl = &n->data.block;
d444 2
a445 34
	if (MDOC_BLOCK == node->type) {
		newln(p);
		if ( ! arg_hasattr(MDOC_Compact, bl->argc, bl->argv))
			if (node->prev || n->prev)
				vspace(p);
		return(1);
	}

	/* Get our list type. */

	for (type = -1, i = 0; i < (int)bl->argc; i++) 
		switch (bl->argv[i].arg) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			type = bl->argv[i].arg;
			i = (int)bl->argc;
			break;
		default:
			errx(1, "list type not supported");
			/* NOTREACHED */
		}
d447 1
a447 3
	assert(-1 != type);

	/* Save our existing (inherited) margin and offset. */
d451 1
d461 5
a465 1
	/* Override the width. */
d478 4
a481 3
		if (0 == width)
			errx(1, "need non-zero -width");
		break;
d486 3
a488 1
	/* Word-wrap control. */
a491 3
		/* XXX - ignore child macros!? */
		if (MDOC_HEAD == node->type)
			TERMPAIR_SETFLAG(p, pair, ttypes[TTYPE_DIAG]);
d494 16
d511 3
a513 1
			p->flags |= TERMP_NOSPACE;
d515 11
a534 1
		p->flags |= TERMP_NOSPACE;
d537 1
a537 1
		else if (MDOC_BODY == node->type)
d540 4
d549 3
a551 2
	 * Get a token to use as the HEAD lead-in.  If NULL, we use the
	 * HEAD child. 
a553 19
	tp = NULL;

	if (MDOC_HEAD == node->type) {
		if (arg_hasattr(MDOC_Bullet, bl->argc, bl->argv))
			tp = "\\[bu]";
		if (arg_hasattr(MDOC_Dash, bl->argc, bl->argv))
			tp = "\\-";
		if (arg_hasattr(MDOC_Enum, bl->argc, bl->argv)) {
			(pair->ppair->ppair->count)++;
			(void)snprintf(buf, sizeof(buf), "%d.", 
					pair->ppair->ppair->count);
			tp = buf;
		}
		if (arg_hasattr(MDOC_Hyphen, bl->argc, bl->argv))
			tp = "\\-";
	}

	/* Margin control. */

d568 1
a568 1
		else if (MDOC_BODY == node->type) 
d570 1
a570 1
		break;
d575 46
a620 2
	if (NULL == tp)
		return(1);
d622 1
a622 2
	word(p, tp);
	return(0);
d630 1
a630 2
	int		   type, i;
	struct mdoc_block *bl;
d635 1
a635 29
	assert(MDOC_BLOCK == node->parent->parent->parent->type);
	assert(MDOC_Bl == node->parent->parent->parent->tok);
	bl = &node->parent->parent->parent->data.block;

	for (type = -1, i = 0; i < (int)bl->argc; i++) 
		switch (bl->argv[i].arg) {
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			type = bl->argv[i].arg;
			i = (int)bl->argc;
			break;
		default:
			errx(1, "list type not supported");
			/* NOTREACHED */
		}

d640 2
d643 3
d654 1
a654 11

	switch (type) {
	case (MDOC_Inset):
		break;
	default:
		if (MDOC_HEAD == node->type)
			p->flags &= ~TERMP_NOBREAK;
		else if (MDOC_BODY == node->type)
			p->flags &= ~TERMP_NOLPAD;
		break;
	}
@


1.37
log
@-inset and -diag lists now supported.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.36 2009/03/02 17:29:16 kristaps Exp $ */
d458 1
a458 1
		width = width > 6 ? width : 6;
d472 1
@


1.36
log
@Noted lacking areas in mdocterm.1.
Put styles into symtab (for real this time).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.35 2009/03/02 17:14:46 kristaps Exp $ */
d53 2
a54 1
#define	TTYPE_NMAX	  18
d82 2
a83 1
	TERMP_BOLD	 	/* TTYPE_SYMBOL */
d420 4
a460 1
		/* FIXME: auto-size. */
a469 2
	p->flags |= TERMP_NOSPACE;

d471 8
d488 1
d555 2
d561 39
a599 1
	flushln(p);
d604 10
a613 4
	if (MDOC_HEAD == node->type)
		p->flags &= ~TERMP_NOBREAK;
	else if (MDOC_BODY == node->type)
		p->flags &= ~TERMP_NOLPAD;
@


1.35
log
@Added new old escape sequence \*[nn].
Initial correct .Bd support (still only text in literal displays).
Symbols put into tables (character-encoding).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.34 2009/03/02 12:09:32 kristaps Exp $ */
a32 1
/* FIXME: indent/tab. */
d61 2
@


1.34
log
@Support for maxrmargin-breaking with TERMP_NOBREAK.
Tabs auto-converted to spaces.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.33 2009/03/01 23:27:14 kristaps Exp $ */
d1054 2
a1055 2
	const struct mdoc_node *n;
	int		 i;
a1063 1
	assert(MDOC_BLOCK == node->parent->type);
d1065 1
d1067 18
a1084 1
	bl = &node->parent->data.block;
d1092 10
d1105 6
a1110 8
		if (MDOC_TEXT != n->type) 
			errx(1, "non-text displays unsupported");
		if ((*n->data.text.string)) {
			word(p, n->data.text.string);
			flushln(p);
		} else
			vspace(p);

a1112 1
	p->flags &= ~TERMP_LITERAL;
d1124 5
a1128 1
	newln(p);
@


1.33
log
@Cd breaks line properly.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.32 2009/03/01 23:14:15 kristaps Exp $ */
a27 2
#define	INDENT		  6

d935 3
d948 1
a948 1
	if (node->sec == SEC_SYNOPSIS)
d1145 2
a1146 1
	p->flags |= TERMP_NOSPACE;
@


1.32
log
@Backed-out warning about Ds.
Backed-out assertion about Bd subtypes.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.31 2009/03/01 13:06:49 kristaps Exp $ */
d1295 1
@


1.31
log
@Fixed TERMP_NOBREAK and line overruns.
Fixed TERMP_SETFLAGS and current-flag omission.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.30 2009/02/28 21:31:13 kristaps Exp $ */
a1067 1

a1073 3
	if ( ! arg_hasattr(MDOC_Literal, bl->argc, bl->argv))
		return(1);

d1077 2
a1078 1
		assert(MDOC_TEXT == n->type); /* FIXME */
@


1.30
log
@Many more changes and fixes (`In', `Fd', etc.).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.29 2009/02/28 20:13:06 kristaps Exp $ */
a136 1
DECL_PRE(termp_bx);
d166 1
d230 1
a230 1
	{ termp_bx_pre, NULL }, /* Bx */
d306 1
a306 1
	return(strlen(*arg->value) + 2);
d553 1
a553 1
	if (MDOC_HEAD == node->type) {
d555 1
a555 2
		p->flags &= ~TERMP_NORPAD;
	} else if (MDOC_BODY == node->type)
d568 1
a568 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_PROG]);
d571 1
d581 1
a581 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_CMD_FLAG]);
d593 4
a596 3
	if (node->child) {
		TERMPAIR_SETFLAG(pair, ttypes[TTYPE_CMD_ARG]);
		return(1);
a597 4
	p->flags |= ttypes[TTYPE_CMD_ARG];
	word(p, "file");
	word(p, "...");
	p->flags &= ~ttypes[TTYPE_CMD_ARG];
d764 1
a764 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_VAR_DECL]);
d788 1
a788 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_FUNC_DECL]);
d814 1
a814 1
		TERMPAIR_SETFLAG(pair, ttypes[TTYPE_SECTION]);
d937 1
a937 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_FUNC_TYPE]);
d1004 1
a1004 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_LINK]);
d1016 1
a1016 1
		TERMPAIR_SETFLAG(pair, ttypes[TTYPE_FUNC_ARG]);
d1043 1
a1043 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_VAR_DECL]);
d1143 2
a1144 2
static int
termp_bx_pre(DECL_ARGS)
d1147 1
a1148 1
	return(1);
d1245 1
a1245 1
		TERMPAIR_SETFLAG(pair, ttypes[TTYPE_SSECTION]);
d1277 1
a1277 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_FILE]);
d1287 1
a1287 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_EMPH]);
d1297 1
a1297 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_CONFIG]);
d1307 1
a1307 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_CMD_FLAG]);
d1317 1
a1317 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_CMD]);
d1327 1
a1327 1
	p->flags |= ttypes[TTYPE_INCLUDE];
a1329 1
	p->flags &= ~ttypes[TTYPE_INCLUDE];
a1330 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_INCLUDE]);
d1399 1
a1399 1
	word(p, "(");
d1473 1
a1473 1
			TERMPAIR_SETFLAG(pair, ttypes[TTYPE_EMPH]);
d1475 1
a1475 1
			TERMPAIR_SETFLAG(pair, ttypes[TTYPE_SYMB]);
d1483 1
a1483 1
		TERMPAIR_SETFLAG(pair, ttypes[TTYPE_EMPH]);
d1485 1
a1485 1
		TERMPAIR_SETFLAG(pair, ttypes[TTYPE_EMPH]);
d1496 1
a1496 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_SYMB]);
d1506 1
a1506 1
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_SYMBOL]);
@


1.29
log
@More fixes (hard-escapes, etc.).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.28 2009/02/28 19:15:28 kristaps Exp $ */
d121 1
a145 1
DECL_PRE(termp_in);
d198 1
a198 1
	{ termp_in_pre, NULL }, /* In */ 
d645 1
a645 1
	if (MDOC_BLOCK == node->type)
d801 4
a804 1
	if (node->sec == SEC_SYNOPSIS)
d996 1
a996 1
	if (node->sec == SEC_SYNOPSIS)
d1060 2
a1061 1
		vspace(p);
d1330 5
d1341 16
d1380 1
a1380 1
	word(p, "\\[");
d1404 1
a1404 1
	word(p, "\\&(");
@


1.28
log
@Initial Rs/Re support.
Fixed default Ds width.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.27 2009/02/27 09:39:40 kristaps Exp $ */
d28 1
a28 1
#define	INDENT		  8
d177 1
a177 1
	{ NULL, NULL }, /* Dl */
d211 1
a211 1
	{ NULL, NULL }, /* %B */
d213 1
a213 1
	{ NULL, NULL }, /* %I */
d215 4
a218 4
	{ NULL, NULL }, /* %N */
	{ NULL, NULL }, /* %O */
	{ NULL, NULL }, /* %P */
	{ NULL, NULL }, /* %R */
d220 1
a220 1
	{ NULL, NULL }, /* %V */
d306 1
a306 1
	return(strlen(*arg->value) + 1);
d398 4
a401 4
		if (arg_hasattr(MDOC_Compact, bl->argc, bl->argv))
			newln(p);
		else
			vspace(p);
d566 3
d593 8
a600 3
	TERMPAIR_SETFLAG(pair, ttypes[TTYPE_CMD_ARG]);
	if (NULL == node->child)
		word(p, "...");
@


1.27
log
@Lintified sources.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.26 2009/02/27 08:20:15 kristaps Exp $ */
d28 1
a28 1
#define	INDENT		  6
d111 1
d154 1
d165 1
d210 1
a210 1
	{ NULL, NULL }, /* %A */
d212 1
a212 1
	{ NULL, NULL }, /* %D */
d214 1
a214 1
	{ NULL, NULL }, /* %J */
d219 1
a219 1
	{ NULL, NULL }, /* %T */
d254 1
a254 1
	{ NULL, NULL }, /* Rs */
d306 1
a306 1
	return(strlen(*arg->value));
d634 11
d1190 1
a1190 1
	word(p, "\'");
d1502 32
@


1.26
log
@More character-encoding.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.25 2009/02/26 16:08:11 kristaps Exp $ */
d280 2
a281 1
	size_t		 len, i, v;
d289 1
a289 1
	len = strlen(*arg->value);
@


1.25
log
@Support for macro widths (/usr/share/tmac/mdoc/doc-common).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.24 2009/02/26 14:56:27 kristaps Exp $ */
d28 1
a28 1
#define	INDENT		  4
a281 1
	/* TODO */
d1332 1
a1332 1
	word(p, "[");
d1356 1
a1356 1
	word(p, "(");
@


1.24
log
@Lists (scoped elements) now put delims in-scope.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.23 2009/02/25 23:18:50 kristaps Exp $ */
d20 1
d280 1
d284 19
a316 1

@


1.23
log
@More list work.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.22 2009/02/25 17:02:47 kristaps Exp $ */
d384 1
a384 1
	for (i = 0; i < (int)bl->argc; i++) 
a393 2
		case (MDOC_Item):
			/* FALLTHROUGH */
d400 1
a400 7
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Column):
a402 2
		default:
			break;
d405 2
a413 1
	/* FIXME: auto-size. */
d433 1
d460 1
a460 1
	case (MDOC_Ohang):
d470 1
a483 2
		if (arg_hasattr(MDOC_Item, bl->argc, bl->argv))
			tp = "";
a498 2
	case (MDOC_Item):
		/* FALLTHROUGH */
d505 1
a505 1
	case (MDOC_Ohang):
a511 2
	/* XXX - ignoring children. */

@


1.22
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.21 2009/02/25 15:12:26 kristaps Exp $ */
d20 1
d354 2
a355 2
	char		 buf[7];
	int		 i;
d382 35
d420 2
d424 1
a424 1
	width = i >= 0 ? arg_width(&bl->argv[i]) : 10;
d429 1
a429 2
	assert(MDOC_HEAD == node->type || 
			MDOC_BODY == node->type);
d431 17
a447 9
	if (arg_hasattr(MDOC_Tag, bl->argc, bl->argv)) {
		p->flags |= TERMP_NOSPACE;
		if (MDOC_BODY == node->type) {
			p->flags |= TERMP_NOLPAD;
			p->offset += width;
		} else  {
			p->flags |= TERMP_NOBREAK;
			p->rmargin = p->offset + offset + width;
		}
d449 1
a449 2
	} else if (arg_hasattr(MDOC_Ohang, bl->argc, bl->argv)) {
		p->flags |= TERMP_NOSPACE;
d451 1
a451 2
	} else if (arg_hasattr(MDOC_Diag, bl->argc, bl->argv)) {
		/* TODO. */
d453 18
a470 2
	} else if (arg_hasattr(MDOC_Hang, bl->argc, bl->argv)) {
		/* TODO. */
d472 4
a475 10
	} else if (arg_hasattr(MDOC_Bullet, bl->argc, bl->argv)) {
		p->flags |= TERMP_NOSPACE;
		if (MDOC_BODY == node->type) {
			p->flags |= TERMP_NOLPAD;
			p->offset += 6;
		} else {
			word(p, "\\[bu]");
			p->flags |= TERMP_NOBREAK;
			p->rmargin = p->offset + offset + 6;
		}
d477 7
a483 6
	} else if (arg_hasattr(MDOC_Enum, bl->argc, bl->argv)) {
		p->flags |= TERMP_NOSPACE;
		if (MDOC_BODY == node->type) {
			p->flags |= TERMP_NOLPAD;
			p->offset += 6;
		} else {
d487 1
a487 3
			word(p, buf);
			p->flags |= TERMP_NOBREAK;
			p->rmargin = p->offset + offset + 6;
d489 5
d495 1
a495 13
	} else if (arg_hasattr(MDOC_Dash, bl->argc, bl->argv) ||
			arg_hasattr(MDOC_Hyphen, bl->argc, bl->argv)) {
		p->flags |= TERMP_NOSPACE;
		if (MDOC_BODY == node->type) {
			p->flags |= TERMP_NOLPAD;
			p->offset += 6;
			return(1);
		} else {
			word(p, "\\-");
			p->flags |= TERMP_NOBREAK;
			p->rmargin = p->offset + offset + 6;
		}
	} 
d498 29
a526 1
	return(1);
a533 2
	const struct mdoc_node *n, *it;
	const struct mdoc_block *bl;
d538 1
a538 15
	it = node->parent;
	n = it->parent->parent;
	bl = &n->data.block;

	if (arg_hasattr(MDOC_Tag, bl->argc, bl->argv) ||
			arg_hasattr(MDOC_Bullet, bl->argc, bl->argv) ||
			arg_hasattr(MDOC_Dash, bl->argc, bl->argv) ||
			arg_hasattr(MDOC_Enum, bl->argc, bl->argv) ||
			arg_hasattr(MDOC_Hyphen, bl->argc, bl->argv)) {
		flushln(p);
		if (MDOC_HEAD == node->type) {
			p->rmargin = pair->rmargin;
			p->flags &= ~TERMP_NOBREAK;
		} else
			p->flags &= ~TERMP_NOLPAD;
d540 2
a541 6
	} else if (arg_hasattr(MDOC_Ohang, bl->argc, bl->argv)) {
		flushln(p);

	} else if (arg_hasattr(MDOC_Inset, bl->argc, bl->argv)) {
		if (MDOC_BODY == node->type)
			flushln(p);
d543 5
a547 6
	} else if (arg_hasattr(MDOC_Item, bl->argc, bl->argv)) {
		if (MDOC_BODY == node->type)
			flushln(p);
	}

	p->offset = pair->offset;
@


1.21
log
@Added [almost] all list types.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.20 2009/02/25 13:30:53 kristaps Exp $ */
d20 1
d152 1
d253 1
a253 1
	{ NULL, NULL }, /* Sm */
d1409 20
@


1.20
log
@Support for nested lists added.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.19 2009/02/25 12:27:37 kristaps Exp $ */
d33 1
a33 1
/* FIXME: handle nested lists. */
d351 1
d368 1
a368 7
	assert(MDOC_BLOCK == it->type);
	assert(MDOC_It == it->tok);

	n = it->parent;
	assert(MDOC_BODY == n->type);
	assert(MDOC_Bl == n->tok);
	n = n->parent;
a370 2
	/* If `-compact', don't assert vertical space. */

d394 7
d402 16
a417 1
		if (MDOC_HEAD == node->type) {
d419 8
a426 2
			p->offset += offset;
			p->rmargin = p->offset + width;
d428 6
a433 2
			p->flags |= TERMP_NOLPAD;
			p->offset += width;
d436 2
a437 1
	} else if (arg_hasattr(MDOC_Ohang, bl->argc, bl->argv)) {
d439 10
a448 2
		p->offset += offset;
	}
d450 1
d462 1
a462 6
	switch (node->type) {
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_HEAD):
		break;
	default:
a463 1
	}
d466 1
a466 7
	assert(MDOC_BLOCK == it->type);
	assert(MDOC_It == it->tok);

	n = it->parent;
	assert(MDOC_BODY == n->type);
	assert(MDOC_Bl == n->tok);
	n = n->parent;
d469 5
a473 3
	/* If `-tag', adjust our margins accordingly. */

	if (arg_hasattr(MDOC_Tag, bl->argc, bl->argv)) {
a474 1

a476 1
			p->offset = pair->offset;
d478 1
a478 2
		} else {
			p->offset = pair->offset;
a479 1
		}
d483 8
a490 1
		p->offset = pair->offset;
d492 2
@


1.19
log
@Some offsets built into termpair.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.18 2009/02/25 12:09:20 kristaps Exp $ */
d346 2
a347 2
static void
termp_it_post(DECL_ARGS)
a353 7
	/*
	 * This (and termp_it_pre()) are the most complicated functions
	 * here.  They must account for a considerable number of
	 * switches that completely change the output behaviour, like
	 * -tag versus -column.  Yech.
	 */

d358 4
d364 1
a364 1
		return;
a366 1
	it = node->parent;
d376 22
a397 1
	/* If `-tag', adjust our margins accordingly. */
d400 1
a400 9
		flushln(p);

		/* FIXME: this should auto-size. */
		i = arg_getattr(MDOC_Width, bl->argc, bl->argv);
		width = i >= 0 ? arg_width(&bl->argv[i]) : 10;

		/* FIXME: nesting!  Should happen at block. */
		i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
		offset = i >= 0 ? arg_width(&bl->argv[i]) : 0;
d403 3
a405 3
			p->rmargin = p->maxrmargin;
			p->offset -= offset;
			p->flags &= ~TERMP_NOBREAK;
d407 2
a408 2
			p->offset -= width;
			p->flags &= ~TERMP_NOLPAD;
d410 4
d416 1
a416 8
	if (arg_hasattr(MDOC_Ohang, bl->argc, bl->argv)) {
		i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
		offset = i >= 0 ? arg_offset(&bl->argv[i]) : 0;

		flushln(p);
		p->offset -= offset;
		return;
	}
d421 2
a422 2
static int
termp_it_pre(DECL_ARGS)
a425 6
	int		 i;
	size_t		 width, offset;

	/*
	 * Also see termp_it_post() for general comments.
	 */
a430 4
		it = node->parent;
		break;
	case (MDOC_BLOCK):
		it = node;
d433 1
a433 1
		return(1);
d436 1
a445 15
	/* If `-compact', don't assert vertical space. */

	if (MDOC_BLOCK == node->type) {
		if (arg_hasattr(MDOC_Compact, bl->argc, bl->argv))
			newln(p);
		else
			vspace(p);
		return(1);
	}

	assert(MDOC_HEAD == node->type 
			|| MDOC_BODY == node->type);

	/* FIXME: see termp_it_post(). */

d449 1
a449 7
		p->flags |= TERMP_NOSPACE;

		i = arg_getattr(MDOC_Width, bl->argc, bl->argv);
		width = i >= 0 ? arg_width(&bl->argv[i]) : 10;

		i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
		offset = i >= 0 ? arg_offset(&bl->argv[i]) : 0;
d452 3
a454 3
			p->flags |= TERMP_NOBREAK;
			p->offset += offset;
			p->rmargin = p->offset + width;
d456 2
a457 3
			p->flags |= TERMP_NOSPACE;
			p->flags |= TERMP_NOLPAD;
			p->offset += width;
a458 2
		return(1);
	}
d460 3
a462 9
	/* If `-ohang', adjust left-margin. */

	if (arg_hasattr(MDOC_Ohang, bl->argc, bl->argv)) {
		i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
		offset = i >= 0 ? arg_offset(&bl->argv[i]) : 0;

		p->flags |= TERMP_NOSPACE;
		p->offset += offset;
		return(1);
a463 2

	return(1);
d950 1
d954 1
d958 1
a958 2
		pair->offset = arg_offset(&bl->argv[i]);
		p->offset += pair->offset;
d986 4
a989 2
	if (MDOC_BODY == node->type)
		p->offset -= pair->offset;
@


1.18
log
@Added "termpair" for symmetric flag-setting.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.17 2009/02/25 11:37:05 kristaps Exp $ */
a656 19
static void
termp_sh_post(DECL_ARGS)
{

	switch (node->type) {
	case (MDOC_HEAD):
		newln(p);
		break;
	case (MDOC_BODY):
		newln(p);
		p->offset = 0;
		break;
	default:
		break;
	}
}


/* ARGSUSED */
d749 19
d812 1
a812 1
	p->offset += INDENT;
d825 1
a825 1
	p->offset -= INDENT;
d991 2
a992 1
		p->offset += arg_offset(&bl->argv[i]);
a1018 8
	int		 i;
	const struct mdoc_block *bl;

	if (MDOC_BODY != node->type)
		return;

	assert(MDOC_BLOCK == node->parent->type);
	bl = &node->parent->data.block;
d1020 2
a1021 5
	i = arg_getattr(MDOC_Offset, bl->argc, bl->argv);
	if (-1 != i) {
		assert(1 == bl->argv[i].sz);
		p->offset -= arg_offset(&bl->argv[i]);
	}
@


1.17
log
@All "low-hanging" macros implemented in term.c.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.16 2009/02/24 16:16:45 kristaps Exp $ */
d96 1
a108 2
DECL_PREPOST(termp_ar);
DECL_PREPOST(termp_bf);
a110 2
DECL_PREPOST(termp_cd);
DECL_PREPOST(termp_cm);
a112 2
DECL_PREPOST(termp_em);
DECL_PREPOST(termp_fa);
a113 1
DECL_PREPOST(termp_fl);
a116 2
DECL_PREPOST(termp_ic);
DECL_PREPOST(termp_in);
a117 2
DECL_PREPOST(termp_ms);
DECL_PREPOST(termp_nm);
a118 1
DECL_PREPOST(termp_pa);
a124 3
DECL_PREPOST(termp_sx);
DECL_PREPOST(termp_sy);
DECL_PREPOST(termp_va);
d127 1
d129 1
d133 3
d137 2
d140 3
d144 1
d148 1
d152 2
d156 1
d178 3
a180 3
	{ termp_ar_pre, termp_ar_post }, /* Ar */
	{ termp_cd_pre, termp_cd_post }, /* Cd */
	{ termp_cm_pre, termp_cm_post }, /* Cm */
d185 1
a185 1
	{ termp_fa_pre, termp_fa_post }, /* Fa */ 
d187 1
a187 1
	{ termp_fl_pre, termp_fl_post }, /* Fl */
d190 2
a191 2
	{ termp_ic_pre, termp_ic_post }, /* Ic */ 
	{ termp_in_pre, termp_in_post }, /* In */ 
d194 1
a194 1
	{ termp_nm_pre, termp_nm_post }, /* Nm */ 
d197 1
a197 1
	{ termp_pa_pre, termp_pa_post }, /* Pa */
d200 1
a200 1
	{ termp_va_pre, termp_va_post }, /* Va */
d219 1
a219 1
	{ termp_bf_pre, termp_bf_post }, /* Bf */ 
d230 1
a230 1
	{ termp_em_pre, termp_em_post }, /* Em */ 
d233 1
a233 1
	{ termp_ms_pre, termp_ms_post }, /* Ms */
d252 2
a253 2
	{ termp_sx_pre, termp_sx_post }, /* Sx */
	{ termp_sy_pre, termp_sy_post }, /* Sy */
d503 2
a504 2
static void
termp_nm_post(DECL_ARGS)
d507 4
a510 1
	p->flags &= ~ttypes[TTYPE_PROG];
d515 2
a516 2
static void
termp_fl_post(DECL_ARGS)
d519 4
a522 1
	p->flags &= ~ttypes[TTYPE_CMD_FLAG];
d531 1
a531 1
	p->flags |= ttypes[TTYPE_CMD_ARG];
a539 12
termp_nm_pre(DECL_ARGS)
{

	p->flags |= ttypes[TTYPE_PROG];
	if (NULL == node->child)
		word(p, meta->name);
	return(1);
}


/* ARGSUSED */
static int
a558 9
static void
termp_ar_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_CMD_ARG];
}


/* ARGSUSED */
a662 1
		p->flags &= ~ttypes[TTYPE_SECTION];
d708 1
a708 1
	p->flags |= ttypes[TTYPE_VAR_DECL];
a717 1
	p->flags &= ~ttypes[TTYPE_VAR_DECL];
d732 1
a732 1
	p->flags |= ttypes[TTYPE_FUNC_DECL];
a741 1
	p->flags &= ~ttypes[TTYPE_FUNC_DECL];
a743 1

d755 1
a755 1
		p->flags |= ttypes[TTYPE_SECTION];
a805 12
termp_fl_pre(DECL_ARGS)
{

	p->flags |= ttypes[TTYPE_CMD_FLAG];
	word(p, "\\-");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static int
d859 1
a859 1
	p->flags |= ttypes[TTYPE_FUNC_TYPE];
a868 1
	p->flags &= ~ttypes[TTYPE_FUNC_TYPE];
a870 1

d926 1
a926 1
	p->flags |= ttypes[TTYPE_LINK];
a931 9
static void
termp_sx_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_LINK];
}


/* ARGSUSED */
d938 1
a938 1
		p->flags |= ttypes[TTYPE_FUNC_ARG];
a960 9
static void
termp_fa_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_FUNC_ARG];
}


/* ARGSUSED */
d965 1
a965 1
	p->flags |= ttypes[TTYPE_VAR_DECL];
a970 9
static void
termp_va_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_VAR_DECL];
}


/* ARGSUSED */
d1173 1
a1173 1
		p->flags |= ttypes[TTYPE_SSECTION];
a1190 1
		p->flags &= ~ttypes[TTYPE_SSECTION];
d1205 1
a1205 1
	p->flags |= ttypes[TTYPE_FILE];
a1210 9
static void
termp_pa_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_FILE];
}


/* ARGSUSED */
d1215 1
a1215 1
	p->flags |= ttypes[TTYPE_EMPH];
a1220 9
static void
termp_em_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_EMPH];
}


/* ARGSUSED */
d1225 1
a1225 1
	p->flags |= ttypes[TTYPE_CONFIG];
a1230 9
static void
termp_cd_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_CONFIG];
}


/* ARGSUSED */
d1235 1
a1235 1
	p->flags |= ttypes[TTYPE_CMD_FLAG];
a1240 9
static void
termp_cm_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_CMD_FLAG];
}


/* ARGSUSED */
d1245 1
a1245 1
	p->flags |= ttypes[TTYPE_CMD];
a1250 9
static void
termp_ic_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_CMD];
}


/* ARGSUSED */
d1255 1
a1255 1
	p->flags |= ttypes[TTYPE_INCLUDE];
a1260 9
static void
termp_in_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_INCLUDE];
}


/* ARGSUSED */
d1382 1
a1382 1
			p->flags |= ttypes[TTYPE_EMPH];
d1384 1
a1384 1
			p->flags |= ttypes[TTYPE_SYMB];
d1392 1
a1392 1
		p->flags |= ttypes[TTYPE_EMPH];
d1394 1
a1394 1
		p->flags |= ttypes[TTYPE_SYMB];
a1400 32
static void
termp_bf_post(DECL_ARGS)
{
	const struct mdoc_node	*n;
	const struct mdoc_block	*b;

	if (MDOC_BLOCK != node->type)
		return;

	b = &node->data.block;

	if (NULL == (n = b->head->child)) {
		if (arg_hasattr(MDOC_Emphasis, b->argc, b->argv))
			p->flags &= ~ttypes[TTYPE_EMPH];
		else if (arg_hasattr(MDOC_Symbolic, b->argc, b->argv))
			p->flags &= ~ttypes[TTYPE_SYMB];

		return;
	} 

	assert(MDOC_TEXT == n->type);

	if (0 == strcmp("Emphasis", n->data.text.string))
		p->flags &= ~ttypes[TTYPE_EMPH];
	else if (0 == strcmp("Symbolic", n->data.text.string))
		p->flags &= ~ttypes[TTYPE_SYMB];

	return;
}


/* ARGSUSED */
d1405 1
a1405 1
	p->flags |= ttypes[TTYPE_SYMB];
a1410 9
static void
termp_sy_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_SYMB];
}


/* ARGSUSED */
d1415 1
a1415 1
	p->flags |= ttypes[TTYPE_SYMBOL];
a1418 8

/* ARGSUSED */
static void
termp_ms_post(DECL_ARGS)
{

	p->flags &= ~ttypes[TTYPE_SYMBOL];
}
@


1.16
log
@Raft of mdocterm callbacks in place.
Fixed Fo/Fc handling in validate/mdocterm.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.15 2009/02/24 15:01:15 kristaps Exp $ */
d51 3
a53 1
#define	TTYPE_NMAX	  16
d77 3
a79 1
	TERMP_BOLD	 	/* TTYPE_INCLUDE */
d109 1
d126 1
d137 1
d143 1
d218 1
a218 1
	{ NULL, NULL }, /* Bf */ 
d232 1
a232 1
	{ NULL, NULL }, /* Ms */
d252 1
a252 1
	{ NULL, NULL }, /* Sy */
d263 1
a263 1
	{ NULL, NULL }, /* Bt */
d804 10
d1452 2
d1478 104
@


1.15
log
@More macros filled in.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.14 2009/02/24 14:52:55 kristaps Exp $ */
d116 1
d138 1
d147 1
d223 1
a223 1
	{ NULL, NULL }, /* Fx */
d234 1
a234 1
	{ NULL, NULL }, /* Ql */
d246 1
a246 1
	{ NULL, NULL }, /* Ux */
d249 1
a249 1
	{ NULL, NULL }, /* Fo */ 
d251 1
a251 1
	{ NULL, NULL }, /* Oo */
a902 1
	p->flags |= TERMP_NOSPACE;
d911 1
a911 1
		if ((n->next))
a914 1
	p->flags |= TERMP_NOSPACE;
d958 20
d979 1
a979 2
	p->flags |= ttypes[TTYPE_FUNC_ARG];
	return(1);
d1133 20
a1392 1
	p->flags |= TERMP_NOSPACE;
a1416 1
	p->flags |= TERMP_NOSPACE;
d1421 37
@


1.14
log
@Added several more mdocterm outputs.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.13 2009/02/24 13:46:54 kristaps Exp $ */
d106 1
d124 1
a124 1
DECL_PREPOST(termp_qo);
d134 1
d208 3
a210 3
	{ NULL, NULL }, /* Bo */
	{ NULL, NULL }, /* Bq */
	{ NULL, NULL }, /* Bsx */
d214 1
a214 1
	{ NULL, NULL }, /* Do */
d228 2
a229 2
	{ NULL, NULL }, /* Po */
	{ NULL, NULL }, /* Pq */
d232 1
a232 1
	{ termp_qo_pre, termp_qo_post }, /* Qo */
d237 1
a237 1
	{ NULL, NULL }, /* So */
d1083 10
a1222 25
termp_qo_pre(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return(1);
	word(p, "\"");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
termp_qo_post(DECL_ARGS)
{

	if (MDOC_BODY != node->type)
		return;
	p->flags |= TERMP_NOSPACE;
	word(p, "\"");
}


/* ARGSUSED */
static int
d1331 52
@


1.13
log
@Character-encoding checked for all text (arguments/values).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.12 2009/02/23 15:19:47 kristaps Exp $ */
d48 4
a51 1
#define	TTYPE_NMAX	  13
d72 4
a75 1
	TERMP_UNDERLINE	 	/* TTYPE_EMPH */
d106 2
d116 2
d132 1
d140 2
d165 2
a166 2
	{ NULL, NULL }, /* Cd */
	{ NULL, NULL }, /* Cm */
d176 2
a177 2
	{ NULL, NULL }, /* Ic */ 
	{ NULL, NULL }, /* In */ 
d184 2
a185 2
	{ NULL, NULL }, /* Rv */
	{ NULL, NULL }, /* St */ 
d201 1
a201 1
	{ NULL, NULL }, /* Ao */
d203 1
a203 1
	{ NULL, NULL }, /* At */
d561 46
d1251 93
@


1.12
log
@Adding revamped webpage.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.11 2009/02/23 09:46:59 kristaps Exp $ */
d1057 1
a1057 1
	word(p, "`");
@


1.11
log
@More documentation in place.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.10 2009/02/23 09:33:34 kristaps Exp $ */
d33 1
d76 2
a77 1
static	size_t		  arg_offset(const char *);
d99 1
a121 1
DECL_PRE(termp_bd);
d144 1
a144 1
	{ termp_bd_pre, NULL }, /* Bd */
d247 1
a247 1
arg_offset(const char *v)
d249 14
a262 1
	if (0 == strcmp(v, "indent"))
d264 1
a264 1
	if (0 == strcmp(v, "indent-two"))
d267 1
a267 2
	/* TODO */
	return(0);
d325 1
a325 1
	size_t		 width;
d356 3
d360 5
a364 3
		assert(i >= 0);
		assert(1 == bl->argv[i].sz);
		width = strlen(*bl->argv[i].value); /* XXX */
a366 2
			flushln(p);
			/* FIXME: nested lists. */
d368 1
d371 1
a371 2
			flushln(p);
			p->offset -= width + 1;
a373 1
		return;
d378 1
a378 5
		width = 0;
		if (i >= 0) {
			assert(1 == bl->argv[i].sz);
			width = arg_offset(*bl->argv[i].value);
		}
d381 1
a381 1
		p->offset -= width;
d394 1
a394 1
	size_t		 width;
d435 2
d440 2
d443 1
a443 3
		assert(i >= 0); /* XXX */
		assert(1 == bl->argv[i].sz);
		width = strlen(*bl->argv[i].value); /* XXX */
d445 2
a446 1
		/* FIXME: nested lists. */
d450 1
a450 1
			p->flags |= TERMP_NOSPACE;
d455 1
a455 1
			p->offset += width + 1;
a462 1
		width = 0;
d464 1
a464 4
		if (i >= 0) {
			assert(1 == bl->argv[i].sz);
			width = arg_offset(*bl->argv[i].value);
		} 
d467 1
a467 1
		p->offset += width;
d936 1
d947 7
d975 21
@


1.10
log
@Considerable mdoc.3 documentation.
Added a few more escapes and macros.
@
text
@d1 1
a1 1
/* $Id: termact.c,v 1.6 2009/02/22 19:23:48 kristaps Exp $ */
d46 2
a47 1
#define	TTYPE_NMAX	  12
d67 2
a68 1
	TERMP_UNDERLINE	 	/* TTYPE_FILE */
d99 1
d110 1
d201 1
a201 1
	{ NULL, NULL }, /* Em */ 
d215 1
a215 1
	{ NULL, NULL }, /* Qo */
d1108 44
@


1.9
log
@Fixed `.Pf' handling.
System now supports all mdocml manual pages.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.8 2009/02/22 15:50:45 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
a19 2
#include <ctype.h>
#include <err.h>
a20 1
#include <stdio.h>
a21 1
#include <unistd.h>
d23 45
a67 3
#ifdef __linux__
#include <time.h>
#endif
d69 10
a78 1
#include "term.h"
d80 155
a234 4
enum	termstyle {
	STYLE_CLEAR,
	STYLE_BOLD,
	STYLE_UNDERLINE
d237 15
a251 18
static	void		  termprint_r(struct termp *,
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	void		  termprint_header(struct termp *,
				const struct mdoc_meta *);
static	void		  termprint_footer(struct termp *,
				const struct mdoc_meta *);

static	void		  pword(struct termp *, const char *, size_t);
static	void		  pescape(struct termp *, 
				const char *, size_t *, size_t);
static	void		  chara(struct termp *, char);
static	void		  style(struct termp *, enum termstyle);

#ifdef __linux__
extern	size_t		  strlcat(char *, const char *, size_t);
extern	size_t		  strlcpy(char *, const char *, size_t);
#endif
d253 2
a254 2
void
flushln(struct termp *p)
a255 1
	size_t		 i, j, vsz, vis, maxvis;
d257 37
a293 6
	/*
	 * First, establish the maximum columns of "visible" content.
	 * This is usually the difference between the right-margin and
	 * an indentation, but can be, for tagged lists or columns, a
	 * small set of values.
	 */
d295 3
a297 3
	assert(p->offset < p->rmargin);
	maxvis = p->rmargin - p->offset;
	vis = 0;
a298 5
	/*
	 * If in the standard case (left-justified), then begin with our
	 * indentation, otherwise (columns, etc.) just start spitting
	 * out text.
	 */
d300 8
a307 4
	if ( ! (p->flags & TERMP_NOLPAD))
		/* LINTED */
		for (j = 0; j < p->offset; j++)
			putchar(' ');
d310 4
a313 1
	 * If we're literal, print out verbatim.
d315 7
a321 6
	if (p->flags & TERMP_LITERAL) {
		/* FIXME: count non-printing chars. */
		for (i = 0; i < p->col; i++)
			putchar(p->buf[i]);
		putchar('\n');
		p->col = 0;
d325 27
a351 16
	for (i = 0; i < p->col; i++) {
		/*
		 * Count up visible word characters.  Control sequences
		 * (starting with the CSI) aren't counted. 
		 */
		assert( ! isspace(p->buf[i]));

		/* LINTED */
		for (j = i, vsz = 0; j < p->col; j++) {
			if (isspace(p->buf[j]))
				break;
			else if (27 == p->buf[j]) {
				assert(j + 4 <= p->col);
				j += 3;
			} else
				vsz++;
d353 2
a354 1
		assert(vsz > 0);
d356 6
a361 19
		/*
		 * If a word is too long and we're within a line, put it
		 * on the next line.  Puke if we're being asked to write
		 * something that will exceed the right margin (i.e.,
		 * from a fresh line or when we're not allowed to break
		 * the line with TERMP_NOBREAK).
		 */

		if (vis && vis + vsz >= maxvis) {
			/* FIXME */
			if (p->flags & TERMP_NOBREAK)
				errx(1, "word breaks right margin");
			putchar('\n');
			for (j = 0; j < p->offset; j++)
				putchar(' ');
			vis = 0;
		} else if (vis + vsz >= maxvis) {
			/* FIXME */
			errx(1, "word breaks right margin");
d364 3
a366 15
		/* 
		 * Write out the word and a trailing space.  Omit the
		 * space if we're the last word in the line.
		 */

		for ( ; i < p->col; i++) {
			if (isspace(p->buf[i]))
				break;
			putchar(p->buf[i]);
		}
		vis += vsz;
		if (i < p->col) {
			putchar(' ');
			vis++;
		}
d368 11
d381 1
a381 2
	 * If we're not to right-marginalise it (newline), then instead
	 * pad to the right margin and stay off.
d384 71
a454 5
	if (p->flags & TERMP_NOBREAK) {
		for ( ; vis <= maxvis; vis++)
			putchar(' ');
	} else
		putchar('\n');
d456 1
a456 1
	p->col = 0;
d460 45
a504 2
void
newln(struct termp *p)
a506 4
	/* 
	 * A newline only breaks an existing line; it won't assert
	 * vertical space.
	 */
d508 69
a576 1
	if (0 == p->col) 
d578 49
a626 1
	flushln(p);
d630 3
a632 2
void
vspace(struct termp *p)
d635 3
a637 6
	/*
	 * Asserts a vertical space (a full, empty line-break between
	 * lines).
	 */
	newln(p);
	putchar('\n');
d641 1
d643 12
a654 1
chara(struct termp *p, char c)
d657 6
a662 4
	/* TODO: dynamically expand the buffer. */
	if (p->col + 1 >= p->maxcols)
		errx(1, "line overrun");
	p->buf[(p->col)++] = c;
d666 1
d668 1
a668 1
style(struct termp *p, enum termstyle esc)
d671 11
a681 2
	if (p->col + 4 >= p->maxcols)
		errx(1, "line overrun");
d683 4
a686 5
	p->buf[(p->col)++] = 27;
	p->buf[(p->col)++] = '[';
	switch (esc) {
	case (STYLE_CLEAR):
		p->buf[(p->col)++] = '0';
d688 2
a689 2
	case (STYLE_BOLD):
		p->buf[(p->col)++] = '1';
d691 16
a706 2
	case (STYLE_UNDERLINE):
		p->buf[(p->col)++] = '4';
d709 1
a709 2
		abort();
		/* NOTREACHED */
d711 36
a746 1
	p->buf[(p->col)++] = 'm';
d750 1
d752 13
a764 1
pescape(struct termp *p, const char *word, size_t *i, size_t len)
d767 6
a772 2
	(*i)++;
	assert(*i < len);
a773 4
	if ('(' == word[*i]) {
		/* Two-character escapes. */
		(*i)++;
		assert(*i + 1 < len);
d775 4
a778 4
		if ('r' == word[*i] && 'B' == word[*i + 1])
			chara(p, ']');
		else if ('l' == word[*i] && 'B' == word[*i + 1])
			chara(p, '[');
d780 1
a780 1
		(*i)++;
d782 3
d786 8
a793 19
	} else if ('[' != word[*i]) {
		/* One-character escapes. */
		switch (word[*i]) {
		case ('\\'):
			/* FALLTHROUGH */
		case ('\''):
			/* FALLTHROUGH */
		case ('`'):
			/* FALLTHROUGH */
		case ('-'):
			/* FALLTHROUGH */
		case ('.'):
			chara(p, word[*i]);
		default:
			break;
		}
		return;
	}
	/* n-character escapes. */
d797 1
d799 1
a799 1
pword(struct termp *p, const char *word, size_t len)
a800 1
	size_t		 i;
d802 5
a806 1
	/*assert(len > 0);*/ /* Can be, if literal. */
a807 3
	if ( ! (p->flags & TERMP_NOSPACE) && 
			! (p->flags & TERMP_LITERAL))
		chara(p, ' ');
d809 8
a816 1
	p->flags &= ~TERMP_NOSPACE;
d818 1
a818 4
	if (p->flags & TERMP_BOLD)
		style(p, STYLE_BOLD);
	if (p->flags & TERMP_UNDERLINE)
		style(p, STYLE_UNDERLINE);
d820 15
a834 6
	for (i = 0; i < len; i++) {
		if ('\\' == word[i]) {
			pescape(p, word, &i, len);
			continue;
		}
		chara(p, word[i]);
d837 7
a843 3
	if (p->flags & TERMP_BOLD ||
			p->flags & TERMP_UNDERLINE)
		style(p, STYLE_CLEAR);
d847 3
a849 2
void
word(struct termp *p, const char *word)
a850 1
	size_t 		 i, j, len;
d852 4
a855 4
	if (p->flags & TERMP_LITERAL) {
		pword(p, word, strlen(word));
		return;
	}
a856 2
	len = strlen(word);
	assert(len > 0);
d858 4
a861 5
	if (mdoc_isdelim(word)) {
		if ( ! (p->flags & TERMP_IGNDELIM))
			p->flags |= TERMP_NOSPACE;
		p->flags &= ~TERMP_IGNDELIM;
	}
d863 2
a864 16
	/* LINTED */
	for (j = i = 0; i < len; i++) {
		if ( ! isspace(word[i])) {
			j++;
			continue;
		}
		if (0 == j)
			continue;
		assert(i >= j);
		pword(p, &word[i - j], j);
		j = 0;
	}
	if (j > 0) {
		assert(i >= j);
		pword(p, &word[i - j], j);
	}
d868 1
d870 1
a870 2
termprint_r(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
a871 1
	int		 dochild;
d873 2
a874 1
	/* Pre-processing. */
a875 1
	dochild = 1;
d877 4
a880 6
	if (MDOC_TEXT != node->type) {
		if (termacts[node->tok].pre)
			if ( ! (*termacts[node->tok].pre)(p, meta, node))
				dochild = 0;
	} else /* MDOC_TEXT == node->type */
		word(p, node->data.text.string);
d882 3
a884 1
	/* Children. */
a885 2
	if (dochild && node->child)
		termprint_r(p, meta, node->child);
d887 7
a893 1
	/* Post-processing. */
a894 3
	if (MDOC_TEXT != node->type)
		if (termacts[node->tok].post)
			(*termacts[node->tok].post)(p, meta, node);
d896 4
a899 1
	/* Siblings. */
d901 2
a902 2
	if (node->next)
		termprint_r(p, meta, node->next);
d906 1
d908 1
a908 1
termprint_footer(struct termp *p, const struct mdoc_meta *meta)
a909 3
	struct tm	*tm;
	char		*buf, *os;
	size_t		 sz, osz, ssz, i;
d911 2
a912 4
	if (NULL == (buf = malloc(p->rmargin)))
		err(1, "malloc");
	if (NULL == (os = malloc(p->rmargin)))
		err(1, "malloc");
a913 1
	tm = localtime(&meta->date);
d915 6
a920 6
#ifdef __linux__
	if (0 == strftime(buf, p->rmargin, "%B %d, %Y", tm))
#else
	if (NULL == strftime(buf, p->rmargin, "%B %d, %Y", tm))
#endif
		err(1, "strftime");
d922 21
a942 1
	osz = strlcpy(os, meta->os, p->rmargin);
d944 1
a944 2
	sz = strlen(buf);
	ssz = sz + osz + 1;
d946 3
a948 7
	if (ssz > p->rmargin) {
		ssz -= p->rmargin;
		assert(ssz <= osz);
		os[osz - ssz] = 0;
		ssz = 1;
	} else
		ssz = p->rmargin - ssz + 1;
a949 4
	printf("\n");
	printf("%s", os);
	for (i = 0; i < ssz; i++)
		printf(" ");
d951 4
a954 2
	printf("%s\n", buf);
	fflush(stdout);
d956 5
a960 2
	free(buf);
	free(os);
d964 1
d966 1
a966 1
termprint_header(struct termp *p, const struct mdoc_meta *meta)
a967 3
	char		*buf, *title;
	const char	*pp, *msec;
	size_t		 ssz, tsz, ttsz, i;;
d969 11
a979 4
	if (NULL == (buf = malloc(p->rmargin)))
		err(1, "malloc");
	if (NULL == (title = malloc(p->rmargin)))
		err(1, "malloc");
d981 36
a1016 31
	if (NULL == (pp = mdoc_vol2a(meta->vol)))
		switch (meta->msec) {
		case (MSEC_1):
			/* FALLTHROUGH */
		case (MSEC_6):
			/* FALLTHROUGH */
		case (MSEC_7):
			pp = mdoc_vol2a(VOL_URM);
			break;
		case (MSEC_8):
			pp = mdoc_vol2a(VOL_SMM);
			break;
		case (MSEC_2):
			/* FALLTHROUGH */
		case (MSEC_3):
			/* FALLTHROUGH */
		case (MSEC_4):
			/* FALLTHROUGH */
		case (MSEC_5):
			pp = mdoc_vol2a(VOL_PRM);
			break;
		case (MSEC_9):
			pp = mdoc_vol2a(VOL_KM);
			break;
		default:
			/* FIXME: capitalise. */
			if (NULL == (pp = mdoc_msec2a(meta->msec)))
				pp = mdoc_msec2a(MSEC_local);
			break;
		}
	assert(pp);
a1017 2
	tsz = strlcpy(buf, pp, p->rmargin);
	assert(tsz < p->rmargin);
d1019 10
a1028 8
	if ((pp = mdoc_arch2a(meta->arch))) {
		tsz = strlcat(buf, " (", p->rmargin);
		assert(tsz < p->rmargin);
		tsz = strlcat(buf, pp, p->rmargin);
		assert(tsz < p->rmargin);
		tsz = strlcat(buf, ")", p->rmargin);
		assert(tsz < p->rmargin);
	}
a1029 1
	ttsz = strlcpy(title, meta->title, p->rmargin);
d1031 4
a1034 2
	if (NULL == (msec = mdoc_msec2a(meta->msec)))
		msec = "";
d1036 3
a1038 1
	ssz = (2 * (ttsz + 2 + strlen(msec))) + tsz + 2;
a1039 10
	if (ssz > p->rmargin) {
		if ((ssz -= p->rmargin) % 2)
			ssz++;
		ssz /= 2;
	
		assert(ssz <= ttsz);
		title[ttsz - ssz] = 0;
		ssz = 1;
	} else
		ssz = ((p->rmargin - ssz) / 2) + 1;
d1041 4
a1044 1
	printf("%s(%s)", title, msec);
d1046 3
a1048 2
	for (i = 0; i < ssz; i++)
		printf(" ");
a1049 1
	printf("%s", buf);
d1051 4
a1054 2
	for (i = 0; i < ssz; i++)
		printf(" ");
d1056 9
a1064 2
	printf("%s(%s)\n", title, msec);
	fflush(stdout);
d1066 1
a1066 2
	free(title);
	free(buf);
d1070 3
a1072 3
void
termprint(const struct mdoc_node *node,
		const struct mdoc_meta *meta)
a1073 1
	struct termp	 p;
d1075 10
a1084 5
	p.maxrmargin = 80; /* XXX */
	p.rmargin = p.maxrmargin;
	p.maxcols = 1024;
	p.offset = p.col = 0;
	p.flags = TERMP_NOSPACE;
a1085 2
	if (NULL == (p.buf = malloc(p.maxcols)))
		err(1, "malloc");
d1087 4
a1090 3
	termprint_header(&p, meta);
	termprint_r(&p, meta, node);
	termprint_footer(&p, meta);
d1092 2
a1093 1
	free(p.buf);
d1097 7
@


1.8
log
@Initial block-display support.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.7 2009/02/22 14:31:08 kristaps Exp $ */
d322 5
a326 2
	if (mdoc_isdelim(word))
		p->flags |= TERMP_NOSPACE;
@


1.7
log
@Cleaned up validation source a bit.
Fixed `Nm' and `Nd' detection.
Added a few more terminal outputs.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.6 2009/02/21 21:00:06 kristaps Exp $ */
d85 12
d282 1
a282 1
	assert(len > 0);
d284 2
a285 1
	if ( ! (p->flags & TERMP_NOSPACE))
d314 4
a317 2
	if (mdoc_isdelim(word))
		p->flags |= TERMP_NOSPACE;
d322 3
@


1.6
log
@Split mdocml -> mdocterm, mdoctree (new manuals, etc.).
Escape-recognition term.c.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.5 2009/02/21 19:05:28 kristaps Exp $ */
d27 4
d53 4
d374 4
d379 1
@


1.5
log
@Split down term.c into term.h, termact.c.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.4 2009/02/21 15:34:46 kristaps Exp $ */
a27 1
#include "private.h" /* XXX */
d44 2
d47 1
a47 1
static	void		  escape(struct termp *, enum termstyle);
d189 1
a189 1
escape(struct termp *p, enum termstyle esc)
d216 42
d270 1
a270 1
		escape(p, STYLE_BOLD);
d272 1
a272 1
		escape(p, STYLE_UNDERLINE);
d274 5
a278 3
	/* TODO: escape patterns. */

	for (i = 0; i < len; i++) 
d280 1
d284 1
a284 1
		escape(p, STYLE_CLEAR);
d342 1
a342 1
	if (MDOC_TEXT != node->type) {
d344 1
a344 3
			if ( ! (*termacts[node->tok].post)(p, meta, node))
				return;
	} 
d398 2
a399 1
	char		*msec, *buf, *title, *pp;
d487 1
a487 1
int
a506 2

	return(1);
@


1.4
log
@A few more macros in place.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.3 2009/02/21 14:56:58 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
a20 1
#include <curses.h>
a24 1
#include <term.h>
d27 2
a28 1
#include "private.h"
d30 4
a33 28
enum	termesc {
	ESC_CLEAR,
	ESC_BOLD,
	ESC_UNDERLINE
};

struct	termp {
	size_t		  rmargin;
	size_t		  maxrmargin;
	size_t		  maxcols;
	size_t		  offset;
	size_t		  col;
	int		  flags;
#define	TERMP_BOLD	 (1 << 0)	/* Embolden words. */
#define	TERMP_UNDERLINE	 (1 << 1)	/* Underline words. */
#define	TERMP_NOSPACE	 (1 << 2)	/* No space before words. */
#define	TERMP_NOLPAD	 (1 << 3)	/* No left-padding. */
#define	TERMP_NOBREAK	 (1 << 4)	/* No break after line */
	char		 *buf;
};

struct	termact {
	int		(*pre)(struct termp *,
				const struct mdoc_meta *,
				const struct mdoc_node *);
	int		(*post)(struct termp *,
				const struct mdoc_meta *,
				const struct mdoc_node *);
a43 7
static	int		  arg_hasattr(int, size_t, 
				const struct mdoc_arg *);
static	int		  arg_getattr(int, size_t, 
				const struct mdoc_arg *);

static	void		  newln(struct termp *);
static	void		  vspace(struct termp *);
d45 2
a46 139
static	void		  word(struct termp *, const char *);

#define	decl_prepost(name, suffix) \
static	int		  name##_##suffix(struct termp *, \
				const struct mdoc_meta *, \
				const struct mdoc_node *)

#define	decl_pre(name)	  decl_prepost(name, pre)
#define	decl_post(name)   decl_prepost(name, post)

decl_pre(termp_fl);
decl_pre(termp_it);
decl_pre(termp_nd);
decl_pre(termp_ns);
decl_pre(termp_op);
decl_pre(termp_pp);
decl_pre(termp_sh);
decl_pre(termp_xr);

decl_post(termp_bl);
decl_post(termp_it);
decl_post(termp_op);
decl_post(termp_sh);

decl_pre(termp_bold);
decl_pre(termp_under);

decl_post(termp_bold);
decl_post(termp_under);

const	struct termact termacts[MDOC_MAX] = {
	{ NULL, NULL }, /* \" */
	{ NULL, NULL }, /* Dd */
	{ NULL, NULL }, /* Dt */
	{ NULL, NULL }, /* Os */
	{ termp_sh_pre, termp_sh_post }, /* Sh */
	{ NULL, NULL }, /* Ss */ 
	{ termp_pp_pre, NULL }, /* Pp */ 
	{ NULL, NULL }, /* D1 */
	{ NULL, NULL }, /* Dl */
	{ NULL, NULL }, /* Bd */
	{ NULL, NULL }, /* Ed */
	{ NULL, termp_bl_post }, /* Bl */
	{ NULL, NULL }, /* El */
	{ termp_it_pre, termp_it_post }, /* It */
	{ NULL, NULL }, /* Ad */ 
	{ NULL, NULL }, /* An */
	{ termp_under_pre, termp_under_post }, /* Ar */
	{ NULL, NULL }, /* Cd */
	{ NULL, NULL }, /* Cm */
	{ NULL, NULL }, /* Dv */ 
	{ NULL, NULL }, /* Er */ 
	{ NULL, NULL }, /* Ev */ 
	{ NULL, NULL }, /* Ex */
	{ NULL, NULL }, /* Fa */ 
	{ NULL, NULL }, /* Fd */ 
	{ termp_fl_pre, termp_bold_post }, /* Fl */
	{ NULL, NULL }, /* Fn */ 
	{ NULL, NULL }, /* Ft */ 
	{ NULL, NULL }, /* Ic */ 
	{ NULL, NULL }, /* In */ 
	{ NULL, NULL }, /* Li */
	{ termp_nd_pre, NULL }, /* Nd */ 
	{ termp_bold_pre, termp_bold_post }, /* Nm */ 
	{ termp_op_pre, termp_op_post }, /* Op */
	{ NULL, NULL }, /* Ot */
	{ NULL, NULL }, /* Pa */
	{ NULL, NULL }, /* Rv */
	{ NULL, NULL }, /* St */ 
	{ NULL, NULL }, /* Va */
	{ NULL, NULL }, /* Vt */ 
	{ termp_xr_pre, NULL }, /* Xr */
	{ NULL, NULL }, /* %A */
	{ NULL, NULL }, /* %B */
	{ NULL, NULL }, /* %D */
	{ NULL, NULL }, /* %I */
	{ NULL, NULL }, /* %J */
	{ NULL, NULL }, /* %N */
	{ NULL, NULL }, /* %O */
	{ NULL, NULL }, /* %P */
	{ NULL, NULL }, /* %R */
	{ NULL, NULL }, /* %T */
	{ NULL, NULL }, /* %V */
	{ NULL, NULL }, /* Ac */
	{ NULL, NULL }, /* Ao */
	{ NULL, NULL }, /* Aq */
	{ NULL, NULL }, /* At */
	{ NULL, NULL }, /* Bc */
	{ NULL, NULL }, /* Bf */ 
	{ NULL, NULL }, /* Bo */
	{ NULL, NULL }, /* Bq */
	{ NULL, NULL }, /* Bsx */
	{ NULL, NULL }, /* Bx */
	{ NULL, NULL }, /* Db */
	{ NULL, NULL }, /* Dc */
	{ NULL, NULL }, /* Do */
	{ NULL, NULL }, /* Dq */
	{ NULL, NULL }, /* Ec */
	{ NULL, NULL }, /* Ef */
	{ NULL, NULL }, /* Em */ 
	{ NULL, NULL }, /* Eo */
	{ NULL, NULL }, /* Fx */
	{ NULL, NULL }, /* Ms */
	{ NULL, NULL }, /* No */
	{ termp_ns_pre, NULL }, /* Ns */
	{ NULL, NULL }, /* Nx */
	{ NULL, NULL }, /* Ox */
	{ NULL, NULL }, /* Pc */
	{ NULL, NULL }, /* Pf */
	{ NULL, NULL }, /* Po */
	{ NULL, NULL }, /* Pq */
	{ NULL, NULL }, /* Qc */
	{ NULL, NULL }, /* Ql */
	{ NULL, NULL }, /* Qo */
	{ NULL, NULL }, /* Qq */
	{ NULL, NULL }, /* Re */
	{ NULL, NULL }, /* Rs */
	{ NULL, NULL }, /* Sc */
	{ NULL, NULL }, /* So */
	{ NULL, NULL }, /* Sq */
	{ NULL, NULL }, /* Sm */
	{ NULL, NULL }, /* Sx */
	{ NULL, NULL }, /* Sy */
	{ NULL, NULL }, /* Tn */
	{ NULL, NULL }, /* Ux */
	{ NULL, NULL }, /* Xc */
	{ NULL, NULL }, /* Xo */
	{ NULL, NULL }, /* Fo */ 
	{ NULL, NULL }, /* Fc */ 
	{ NULL, NULL }, /* Oo */
	{ NULL, NULL }, /* Oc */
	{ NULL, NULL }, /* Bk */
	{ NULL, NULL }, /* Ek */
	{ NULL, NULL }, /* Bt */
	{ NULL, NULL }, /* Hf */
	{ NULL, NULL }, /* Fr */
	{ NULL, NULL }, /* Ud */
};

a47 3
static int
arg_hasattr(int arg, size_t argc, const struct mdoc_arg *argv)
{
d49 1
a49 17
	return(-1 != arg_getattr(arg, argc, argv));
}


static int
arg_getattr(int arg, size_t argc, const struct mdoc_arg *argv)
{
	int		 i;

	for (i = 0; i < (int)argc; i++) 
		if (argv[i].arg == arg)
			return(i);
	return(-1);
}


static void
d148 1
a148 1
static void
d163 1
a163 1
static void
d188 1
a188 1
escape(struct termp *p, enum termesc esc)
d197 1
a197 1
	case (ESC_CLEAR):
d200 1
a200 1
	case (ESC_BOLD):
d203 1
a203 1
	case (ESC_UNDERLINE):
d227 1
a227 1
		escape(p, ESC_BOLD);
d229 1
a229 1
		escape(p, ESC_UNDERLINE);
d238 1
a238 1
		escape(p, ESC_CLEAR);
d242 1
a242 1
static void
a271 337
/* ARGSUSED */
static int
termp_it_post(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{
	const struct mdoc_node *n, *it;
	const struct mdoc_block *bl;
	int		 i;
	size_t		 width;

	switch (node->type) {
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_HEAD):
		break;
	default:
		return(1);
	}

	it = node->parent;
	assert(MDOC_BLOCK == it->type);
	assert(MDOC_It == it->tok);

	n = it->parent;
	assert(MDOC_BODY == n->type);
	assert(MDOC_Bl == n->tok);
	n = n->parent;
	bl = &n->data.block;

	/* If `-tag', adjust our margins accordingly. */

	if (arg_hasattr(MDOC_Tag, bl->argc, bl->argv)) {
		i = arg_getattr(MDOC_Width, bl->argc, bl->argv);
		assert(i >= 0);
		assert(1 == bl->argv[i].sz);
		width = strlen(*bl->argv[i].value); /* XXX */

		if (MDOC_HEAD == node->type) {
			flushln(p);
			/* FIXME: nested lists. */
			p->rmargin = p->maxrmargin;
			p->flags &= ~TERMP_NOBREAK;
		} else {
			flushln(p);
			p->offset -= width + 1;
			p->flags &= ~TERMP_NOLPAD;
		}
	}

	return(1);
}


/* ARGSUSED */
static int
termp_it_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{
	const struct mdoc_node *n, *it;
	const struct mdoc_block *bl;
	int		 i;
	size_t		 width;

	switch (node->type) {
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_HEAD):
		it = node->parent;
		break;
	case (MDOC_BLOCK):
		it = node;
		break;
	default:
		return(1);
	}

	assert(MDOC_BLOCK == it->type);
	assert(MDOC_It == it->tok);

	n = it->parent;
	assert(MDOC_BODY == n->type);
	assert(MDOC_Bl == n->tok);
	n = n->parent;
	bl = &n->data.block;

	/* If `-compact', don't assert vertical space. */

	if (MDOC_BLOCK == node->type) {
		if (arg_hasattr(MDOC_Compact, bl->argc, bl->argv))
			newln(p);
		else
			vspace(p);
		return(1);
	}

	assert(MDOC_HEAD == node->type 
			|| MDOC_BODY == node->type);

	/* If `-tag', adjust our margins accordingly. */

	if (arg_hasattr(MDOC_Tag, bl->argc, bl->argv)) {
		i = arg_getattr(MDOC_Width, bl->argc, bl->argv);
		assert(i >= 0); /* XXX */
		assert(1 == bl->argv[i].sz);
		width = strlen(*bl->argv[i].value); /* XXX */

		/* FIXME: nested lists. */

		if (MDOC_HEAD == node->type) {
			p->flags |= TERMP_NOBREAK;
			p->flags |= TERMP_NOSPACE;
			p->rmargin = p->offset + width;
		} else {
			p->flags |= TERMP_NOSPACE;
			p->flags |= TERMP_NOLPAD;
			p->offset += width + 1;
		}
	}

	return(1);
}


/* ARGSUSED */
static int
termp_bold_post(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	p->flags &= ~TERMP_BOLD;
	return(1);
}


/* ARGSUSED */
static int
termp_under_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	p->flags |= TERMP_UNDERLINE;
	return(1);
}


/* ARGSUSED */
static int
termp_bold_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	p->flags |= TERMP_BOLD;
	return(1);
}


/* ARGSUSED */
static int
termp_ns_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	p->flags |= TERMP_NOSPACE;
	return(1);
}


/* ARGSUSED */
static int
termp_pp_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	vspace(p);
	return(1);
}


/* ARGSUSED */
static int
termp_under_post(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	p->flags &= ~TERMP_UNDERLINE;
	return(1);
}


/* ARGSUSED */
static int
termp_nd_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	word(p, "-");
	return(1);
}


/* ARGSUSED */
static int
termp_bl_post(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	switch (node->type) {
	case (MDOC_BLOCK):
		newln(p);
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
termp_op_post(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	switch (node->type) {
	case (MDOC_BODY):
		p->flags |= TERMP_NOSPACE;
		word(p, "\\]");
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
termp_sh_post(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	switch (node->type) {
	case (MDOC_HEAD):
		p->flags &= ~TERMP_BOLD;
		newln(p);
		break;
	case (MDOC_BODY):
		newln(p);
		p->offset -= 4;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
termp_xr_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{
	const struct mdoc_node *n;

	n = node->child;
	assert(n);

	assert(MDOC_TEXT == n->type);
	word(p, n->data.text.string);

	if (NULL == (n = n->next)) 
		return(0);

	assert(MDOC_TEXT == n->type);
	p->flags |= TERMP_NOSPACE;
	word(p, "\\(");
	p->flags |= TERMP_NOSPACE;
	word(p, n->data.text.string);
	p->flags |= TERMP_NOSPACE;
	word(p, "\\)");

	return(0);
}


/* ARGSUSED */
static int
termp_sh_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	switch (node->type) {
	case (MDOC_HEAD):
		vspace(p);
		p->flags |= TERMP_BOLD;
		break;
	case (MDOC_BODY):
		p->offset += 4;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
termp_op_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	switch (node->type) {
	case (MDOC_BODY):
		word(p, "\\[");
		p->flags |= TERMP_NOSPACE;
		break;
	default:
		break;
	}
	return(1);
}


/* ARGSUSED */
static int
termp_fl_pre(struct termp *p, const struct mdoc_meta *meta,
		const struct mdoc_node *node)
{

	p->flags |= TERMP_BOLD;
	word(p, "-");
	p->flags |= TERMP_NOSPACE;
	return(1);
}


d278 1
a278 1
	/* Pre-processing ----------------- */
d289 1
a289 1
	/* Children ---------------------- */
d291 1
a291 19
	if (dochild && NULL == node->child) {
		/* No-child processing. */
		switch (node->type) {
		case (MDOC_ELEM):
			switch (node->tok) {
			case (MDOC_Nm):
				word(p, "progname"); /* TODO */
				break;
			case (MDOC_Ar):
				word(p, "..."); 
				break;
			default:
				break;
			}
			break;
		default:
			break;
		}
	} else if (dochild)
d294 1
a294 1
	/* Post-processing --------------- */
d302 1
a302 1
	/* Siblings ---------------------- */
d448 1
a448 4
	if (ERR == setupterm(NULL, STDOUT_FILENO, NULL))
		return(0);

	p.maxrmargin = columns < 60 ? 60 : (size_t)columns;
@


1.3
log
@Initial list support (not nested, yet).
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.2 2009/02/20 23:35:36 kristaps Exp $ */
d94 1
d148 1
a148 1
	{ NULL, NULL }, /* Xr */
d686 1
a686 1
		word(p, "\\(rB");
d719 28
d774 1
a774 1
		word(p, "\\(lB");
d801 1
d805 2
d810 1
a810 1
				return;
d816 1
a816 1
	if (NULL == node->child) {
d834 1
a834 1
	} else
@


1.2
log
@More flesh in terminal-encoder.
@
text
@d1 1
a1 1
/* $Id: term.c,v 1.1 2009/02/20 11:04:23 kristaps Exp $ */
a30 1

d38 2
a39 1
	size_t		  maxvisible;
d41 1
a41 1
	size_t		  indent;
d44 5
a48 3
#define	TERMP_BOLD	 (1 << 0)
#define	TERMP_UNDERLINE	 (1 << 1)
#define	TERMP_NOSPACE	 (1 << 2)
d69 5
d79 26
a104 42
static	int		  termp_it_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_ns_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_pp_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_fl_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_op_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_op_post(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_bl_post(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_sh_post(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_sh_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_nd_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_bold_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_under_pre(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_bold_post(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
static	int		  termp_under_post(struct termp *, 
				const struct mdoc_meta *,
				const struct mdoc_node *);
d120 1
a120 1
	{ termp_it_pre, NULL }, /* It */
d216 20
d237 1
a237 1
flush(struct termp *p)
d241 9
a249 1
	maxvis = p->maxvisible - (p->indent * 4);
d252 10
a261 2
	for (j = 0; j < (p->indent * 4); j++)
		putchar(' ');
d264 7
d282 8
d291 3
d295 1
a295 1
			for (j = 0; j < (p->indent * 4); j++)
d298 9
a306 1
		} 
d320 11
a330 1
	putchar('\n');
d339 4
d346 1
a346 1
	flush(p);
d354 4
d367 1
a369 1

d418 2
d434 2
a435 1
	/* TODO: delimiters? */
d440 1
d459 54
d517 4
d523 2
d526 4
a529 2
		/* TODO: only print one, if compat. */
		vspace(p);
d532 44
a575 1
		break;
d577 1
d582 1
d593 1
d604 1
d615 1
d626 1
d637 1
d648 1
d659 1
d676 1
d694 1
d707 1
a707 1
		(p->indent)--;
d716 1
d728 1
a728 1
		(p->indent)++;
d737 1
d755 1
d827 1
a827 1
	if (NULL == (buf = malloc(p->maxvisible)))
d829 1
a829 1
	if (NULL == (os = malloc(p->maxvisible)))
d833 1
a833 1
	if (NULL == strftime(buf, p->maxvisible, "%B %d, %Y", tm))
d836 1
a836 1
	osz = strlcpy(os, meta->os, p->maxvisible);
d841 2
a842 2
	if (ssz > p->maxvisible) {
		ssz -= p->maxvisible;
d847 1
a847 1
		ssz = p->maxvisible - ssz + 1;
d868 1
a868 1
	if (NULL == (buf = malloc(p->maxvisible)))
d870 1
a870 1
	if (NULL == (title = malloc(p->maxvisible)))
d905 2
a906 2
	tsz = strlcpy(buf, pp, p->maxvisible);
	assert(tsz < p->maxvisible);
d909 6
a914 6
		tsz = strlcat(buf, " (", p->maxvisible);
		assert(tsz < p->maxvisible);
		tsz = strlcat(buf, pp, p->maxvisible);
		assert(tsz < p->maxvisible);
		tsz = strlcat(buf, ")", p->maxvisible);
		assert(tsz < p->maxvisible);
d917 1
a917 1
	ttsz = strlcpy(title, meta->title, p->maxvisible);
d924 2
a925 2
	if (ssz > p->maxvisible) {
		if ((ssz -= p->maxvisible) % 2)
d933 1
a933 1
		ssz = ((p->maxvisible - ssz) / 2) + 1;
d962 2
a963 1
	p.maxvisible = columns < 60 ? 60 : (size_t)columns;
d965 1
a965 1
	p.indent = p.col = 0;
@


1.1
log
@Re-added tree.c (for now).
Added initial terminal-output filter (term.c).
@
text
@d1 1
a1 1
/* $Id: tree.c,v 1.2 2009/01/17 14:04:25 kristaps Exp $ */
d20 1
d29 1
a29 1
#include "mdoc.h"
d32 21
a52 1
static	int		 termprint_r(size_t, size_t, 
d54 9
a62 1
static	void		 termprint_head(size_t, 
d64 1
a64 1
static	void		 termprint_tail(size_t, 
d67 327
a393 96
static	char 		*arch2a(enum mdoc_arch);
static	char 		*vol2a(enum mdoc_vol);
static	char 		*msec2a(enum mdoc_msec);

static	size_t 		 ttitle2a(char *, enum mdoc_vol, enum mdoc_msec,
				enum mdoc_arch, size_t);


static char *
arch2a(enum mdoc_arch arch)
{

	switch (arch) {
	case (ARCH_alpha):
		return("Alpha");
	case (ARCH_amd64):
		return("AMD64");
	case (ARCH_amiga):
		return("Amiga");
	case (ARCH_arc):
		return("ARC");
	case (ARCH_arm):
		return("ARM");
	case (ARCH_armish):
		return("ARMISH");
	case (ARCH_aviion):
		return("AViion");
	case (ARCH_hp300):
		return("HP300");
	case (ARCH_hppa):
		return("HPPA");
	case (ARCH_hppa64):
		return("HPPA64");
	case (ARCH_i386):
		return("i386");
	case (ARCH_landisk):
		return("LANDISK");
	case (ARCH_luna88k):
		return("Luna88k");
	case (ARCH_mac68k):
		return("Mac68k");
	case (ARCH_macppc):
		return("MacPPC");
	case (ARCH_mvme68k):
		return("MVME68k");
	case (ARCH_mvme88k):
		return("MVME88k");
	case (ARCH_mvmeppc):
		return("MVMEPPC");
	case (ARCH_pmax):
		return("PMAX");
	case (ARCH_sgi):
		return("SGI");
	case (ARCH_socppc):
		return("SOCPPC");
	case (ARCH_sparc):
		return("SPARC");
	case (ARCH_sparc64):
		return("SPARC64");
	case (ARCH_sun3):
		return("Sun3");
	case (ARCH_vax):
		return("VAX");
	case (ARCH_zaurus):
		return("Zaurus");
	default:	 	
		break;
	}

	return(NULL);
}


static char *
vol2a(enum mdoc_vol vol)
{

	switch (vol) {
	case (VOL_AMD):
		return("OpenBSD Ancestral Manual Documents");
	case (VOL_IND):
		return("OpenBSD Manual Master Index");
	case (VOL_KM):
		return("OpenBSD Kernel Manual");
	case (VOL_LOCAL):
		return("OpenBSD Local Manual");
	case (VOL_PRM):
		return("OpenBSD Programmer's Manual");
	case (VOL_PS1):
		return("OpenBSD Programmer's Supplementary Documents");
	case (VOL_SMM):
		return("OpenBSD System Manager's Manual");
	case (VOL_URM):
		return("OpenBSD Reference Manual");
	case (VOL_USD):
		return("OpenBSD User's Supplementary Documents");
d397 2
d400 18
a417 1
	return(NULL);
d421 3
a423 2
static char *
msec2a(enum mdoc_msec msec)
d426 54
a479 37
	switch (msec) {
	case(MSEC_1):
		return("1");
	case(MSEC_2):
		return("2");
	case(MSEC_3):
		return("3");
	case(MSEC_3f):
		return("3f");
	case(MSEC_3p):
		return("3p");
	case(MSEC_4):
		return("4");
	case(MSEC_5):
		return("5");
	case(MSEC_6):
		return("6");
	case(MSEC_7):
		return("7");
	case(MSEC_8):
		return("8");
	case(MSEC_9):
		return("9");
	case(MSEC_X11):
		return("X11");
	case(MSEC_X11R6):
		return("X11R6");
	case(MSEC_local):
		return("local");
	case(MSEC_n):
		return("n");
	case(MSEC_unass):
		/* FALLTHROUGH */
	case(MSEC_draft):
		return("draft");
	case(MSEC_paper):
		return("paper");
d483 1
a483 1
	return(NULL);
d487 20
a506 3
static size_t
ttitle2a(char *dst, enum mdoc_vol vol, enum mdoc_msec msec,
		enum mdoc_arch arch, size_t sz)
a507 2
	char		*p;
	size_t		 ssz;
d509 15
a523 31
	if (NULL == (p = vol2a(vol)))
		switch (msec) {
		case (MSEC_1):
			/* FALLTHROUGH */
		case (MSEC_6):
			/* FALLTHROUGH */
		case (MSEC_7):
			p = vol2a(VOL_URM);
			break;
		case (MSEC_8):
			p = vol2a(VOL_SMM);
			break;
		case (MSEC_2):
			/* FALLTHROUGH */
		case (MSEC_3):
			/* FALLTHROUGH */
		case (MSEC_4):
			/* FALLTHROUGH */
		case (MSEC_5):
			p = vol2a(VOL_PRM);
			break;
		case (MSEC_9):
			p = vol2a(VOL_KM);
			break;
		default:
			/* FIXME: capitalise. */
			if (NULL == (p = msec2a(msec)))
				p = msec2a(MSEC_local);
			break;
		}
	assert(p);
d525 4
a528 2
	if ((ssz = strlcpy(dst, p, sz)) >= sz)
		return(ssz);
d530 10
a539 7
	if ((p = arch2a(arch))) {
		if ((ssz = strlcat(dst, " (", sz)) >= sz)
			return(ssz);
		if ((ssz = strlcat(dst, p, sz)) >= sz)
			return(ssz);
		if ((ssz = strlcat(dst, ")", sz)) >= sz)
			return(ssz);
d541 3
d545 14
a558 1
	return(ssz);
d563 2
a564 1
termprint_r(size_t cols, size_t indent, const struct mdoc_node *node)
d567 3
d575 53
a627 1
termprint_tail(size_t cols, const struct mdoc_meta *meta)
d633 1
a633 1
	if (NULL == (buf = malloc(cols)))
d635 1
a635 1
	if (NULL == (os = malloc(cols)))
d639 1
a639 1
	if (NULL == strftime(buf, cols, "%B %d, %Y", tm))
d642 1
a642 1
	osz = strlcpy(os, meta->os, cols);
d647 2
a648 2
	if (ssz > cols) {
		ssz -= cols;
d653 1
a653 1
		ssz = cols - ssz + 1;
d655 1
d661 1
d669 1
a669 1
termprint_head(size_t cols, const struct mdoc_meta *meta)
d671 2
a672 2
	char		*msec, *buf, *title;
	size_t		 ssz, tsz, ttsz, i;
d674 1
a674 1
	if (NULL == (buf = malloc(cols)))
d676 1
a676 1
	if (NULL == (title = malloc(cols)))
d679 31
a709 1
	/* Format the manual page header. */
d711 2
a712 2
	tsz = ttitle2a(buf, meta->vol, meta->msec, meta->arch, cols);
	ttsz = strlcpy(title, meta->title, cols);
d714 12
a725 1
	if (NULL == (msec = msec2a(meta->msec)))
d730 2
a731 2
	if (ssz > cols) {
		if ((ssz -= cols) % 2)
d739 1
a739 1
		ssz = ((cols - ssz) / 2) + 1;
d751 2
a752 1
	printf("%s(%s)\n\n", title, msec);
d763 1
a763 1
	size_t		 cols;
d768 13
a780 1
	cols = columns < 60 ? 60 : (size_t)columns;
a781 4
	termprint_head(cols, meta);
	if ( ! termprint_r(cols, 0, node))
		return(0);
	termprint_tail(cols, meta);
@
