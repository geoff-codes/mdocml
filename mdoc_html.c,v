head	1.238;
access;
symbols
	VERSION_1_13_3:1.226
	VERSION_1_13_2:1.216
	VERSION_1_12_4:1.198
	VERSION_1_13_1:1.195
	VERSION_1_12_3:1.186
	VERSION_1_12_2:1.184
	VERSION_1_12:1.198.0.2
	VERSION_1_12_1:1.182
	VERSION_1_12_0:1.179
	VERSION_1_11_7:1.178
	VERSION_1_11_6:1.175
	VERSION_1_11_5:1.174
	VERSION_1_11_4:1.172
	VERSION_1_11_3:1.169
	VERSION_1_11_2:1.165
	VERSION_1_11_1:1.162
	VERSION_1_10_10:1.154
	VERSION_1_10_9:1.142
	VERSION_1_10_8:1.138
	VERSION_1_10_7:1.114
	VERSION_1_10_6:1.108
	VERSION_1_10_5:1.100
	VERSION_1_10_5_PREPDF:1.99
	VERSION_1_10_4:1.95
	VERSION_1_10_3:1.87
	VERSION_1_10_2:1.85
	VERSION_1_10_1:1.78
	VERSION_1_9_24:1.61
	VERSION_1_9_25:1.62
	VERSION_1_9_23:1.60
	VERSION_1_9_22:1.55
	VERSION_1_9_21:1.55
	VERSION_1_9_20:1.55
	VERSION_1_9_19:1.54
	VERSION_1_9_18:1.54
	VERSION_1_9_17:1.54
	VERSION_1_9_16:1.54
	VERSION_1_9_15:1.54
	VERSION_1_9_15-pre2:1.52
	VERSION_1_9_15-pre1:1.51
	VERSION_1_9_14:1.48
	VERSION_1_9_13:1.46
	VERSION_1_9_12:1.44
	VERSION_1_9_11:1.39
	VERSION_1_9_10:1.39
	VERSION_1_9_9:1.35
	VERSION_1_9_8:1.28
	VERSION_1_9_7:1.27
	VERSION_1_9_6:1.12
	VERSION_1_9_5:1.1;
locks; strict;
comment	@ * @;


1.238
date	2015.10.12.00.08.15;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2015.09.26.00.32.35;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2015.09.26.00.22.07;	author schwarze;	state Exp;
branches;
next	1.233;

1.233
date	2015.08.30.19.00.14;	author schwarze;	state Exp;
branches;
next	1.232;

1.232
date	2015.04.18.17.53.21;	author schwarze;	state Exp;
branches;
next	1.231;

1.231
date	2015.04.18.16.06.40;	author schwarze;	state Exp;
branches;
next	1.230;

1.230
date	2015.04.16.20.22.27;	author schwarze;	state Exp;
branches;
next	1.229;

1.229
date	2015.04.02.23.48.20;	author schwarze;	state Exp;
branches;
next	1.228;

1.228
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.227;

1.227
date	2015.04.02.21.36.50;	author schwarze;	state Exp;
branches;
next	1.226;

1.226
date	2015.03.03.21.11.34;	author schwarze;	state Exp;
branches;
next	1.225;

1.225
date	2015.02.12.12.24.33;	author schwarze;	state Exp;
branches;
next	1.224;

1.224
date	2015.02.11.14.15.12;	author schwarze;	state Exp;
branches;
next	1.223;

1.223
date	2015.02.05.01.46.56;	author schwarze;	state Exp;
branches;
next	1.222;

1.222
date	2015.02.05.00.14.13;	author schwarze;	state Exp;
branches;
next	1.221;

1.221
date	2015.02.01.23.10.35;	author schwarze;	state Exp;
branches;
next	1.220;

1.220
date	2015.01.30.22.04.44;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2015.01.23.14.21.01;	author schwarze;	state Exp;
branches;
next	1.218;

1.218
date	2014.12.23.13.48.57;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2014.12.23.09.31.46;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2014.12.02.10.08.06;	author schwarze;	state Exp;
branches;
next	1.215;

1.215
date	2014.12.01.08.05.52;	author schwarze;	state Exp;
branches;
next	1.214;

1.214
date	2014.11.30.05.29.00;	author schwarze;	state Exp;
branches;
next	1.213;

1.213
date	2014.11.27.22.27.56;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2014.11.27.16.20.31;	author schwarze;	state Exp;
branches;
next	1.211;

1.211
date	2014.11.19.22.00.37;	author schwarze;	state Exp;
branches;
next	1.210;

1.210
date	2014.11.17.06.44.58;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2014.10.30.20.10.02;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2014.10.10.15.26.29;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2014.09.27.11.17.19;	author kristaps;	state Exp;
branches;
next	1.206;

1.206
date	2014.09.27.10.56.18;	author kristaps;	state Exp;
branches;
next	1.205;

1.205
date	2014.09.27.09.26.01;	author kristaps;	state Exp;
branches;
next	1.204;

1.204
date	2014.09.27.09.20.03;	author kristaps;	state Exp;
branches;
next	1.203;

1.203
date	2014.09.27.09.13.39;	author kristaps;	state Exp;
branches;
next	1.202;

1.202
date	2014.09.27.09.05.57;	author kristaps;	state Exp;
branches;
next	1.201;

1.201
date	2014.09.27.09.02.19;	author kristaps;	state Exp;
branches;
next	1.200;

1.200
date	2014.09.17.19.55.59;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2014.08.21.12.57.17;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2014.08.14.00.31.43;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2014.08.13.15.25.22;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2014.08.06.15.09.05;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2014.08.01.19.25.52;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2014.07.30.00.19.16;	author schwarze;	state Exp;
branches;
next	1.192;

1.192
date	2014.07.02.19.55.10;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2014.07.02.03.48.07;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2014.04.23.16.08.33;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2014.04.20.20.18.12;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2014.03.30.19.47.48;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2013.12.24.20.45.27;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2013.12.24.19.11.46;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2012.11.17.00.26.33;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2012.08.12.10.04.09;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2011.11.03.20.37.00;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2011.10.16.12.20.34;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2011.10.09.22.10.53;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2011.10.05.21.35.17;	author kristaps;	state Exp;
branches;
next	1.178;

1.178
date	2011.08.26.09.03.17;	author kristaps;	state Exp;
branches;
next	1.177;

1.177
date	2011.08.18.09.16.01;	author kristaps;	state Exp;
branches;
next	1.176;

1.176
date	2011.08.18.09.02.22;	author kristaps;	state Exp;
branches;
next	1.175;

1.175
date	2011.08.10.14.07.23;	author kristaps;	state Exp;
branches;
next	1.174;

1.174
date	2011.07.23.22.57.13;	author kristaps;	state Exp;
branches;
next	1.173;

1.173
date	2011.07.21.11.34.53;	author kristaps;	state Exp;
branches;
next	1.172;

1.172
date	2011.07.04.09.42.38;	author kristaps;	state Exp;
branches;
next	1.171;

1.171
date	2011.06.29.15.38.09;	author kristaps;	state Exp;
branches;
next	1.170;

1.170
date	2011.06.16.22.21.28;	author kristaps;	state Exp;
branches;
next	1.169;

1.169
date	2011.05.17.11.38.18;	author kristaps;	state Exp;
branches;
next	1.168;

1.168
date	2011.05.17.11.34.31;	author kristaps;	state Exp;
branches;
next	1.167;

1.167
date	2011.05.17.11.19.45;	author kristaps;	state Exp;
branches;
next	1.166;

1.166
date	2011.05.14.16.28.23;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2011.04.23.09.10.50;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2011.04.23.08.56.29;	author kristaps;	state Exp;
branches;
next	1.163;

1.163
date	2011.04.04.22.38.26;	author kristaps;	state Exp;
branches;
next	1.162;

1.162
date	2011.04.04.16.48.18;	author kristaps;	state Exp;
branches;
next	1.161;

1.161
date	2011.04.04.16.44.56;	author kristaps;	state Exp;
branches;
next	1.160;

1.160
date	2011.04.04.16.15.58;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2011.04.04.16.01.47;	author kristaps;	state Exp;
branches;
next	1.158;

1.158
date	2011.04.04.15.45.12;	author kristaps;	state Exp;
branches;
next	1.157;

1.157
date	2011.04.04.15.41.05;	author kristaps;	state Exp;
branches;
next	1.156;

1.156
date	2011.04.04.15.33.03;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2011.03.22.14.05.45;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2011.03.07.01.35.51;	author schwarze;	state Exp;
branches;
next	1.153;

1.153
date	2011.02.09.09.52.47;	author kristaps;	state Exp;
branches;
next	1.152;

1.152
date	2011.02.06.23.02.31;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2011.02.06.21.44.36;	author kristaps;	state Exp;
branches;
next	1.150;

1.150
date	2011.02.02.21.40.45;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2011.01.29.14.49.44;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2011.01.25.16.20.24;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2011.01.25.15.46.05;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2011.01.25.15.28.56;	author kristaps;	state Exp;
branches;
next	1.145;

1.145
date	2011.01.25.15.17.18;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2011.01.13.14.30.13;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2011.01.12.10.43.22;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2011.01.07.13.20.58;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2011.01.04.10.29.41;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2011.01.01.12.18.37;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2010.12.24.22.47.37;	author kristaps;	state Exp;
branches;
next	1.138;

1.138
date	2010.12.24.14.14.00;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2010.12.24.14.00.40;	author kristaps;	state Exp;
branches;
next	1.136;

1.136
date	2010.12.23.00.45.03;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2010.12.22.11.15.16;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2010.12.20.13.39.24;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2010.12.20.13.07.55;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2010.12.20.10.40.11;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2010.12.19.12.14.36;	author kristaps;	state Exp;
branches;
next	1.130;

1.130
date	2010.12.17.12.57.49;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2010.12.17.11.19.42;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2010.12.17.11.01.24;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2010.12.17.10.43.51;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2010.12.17.10.37.26;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2010.12.17.08.17.40;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2010.12.17.01.02.00;	author kristaps;	state Exp;
branches;
next	1.123;

1.123
date	2010.12.17.00.18.29;	author kristaps;	state Exp;
branches;
next	1.122;

1.122
date	2010.12.16.22.57.20;	author kristaps;	state Exp;
branches;
next	1.121;

1.121
date	2010.12.15.23.44.02;	author kristaps;	state Exp;
branches;
next	1.120;

1.120
date	2010.12.15.17.19.41;	author kristaps;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.15.16.35.21;	author kristaps;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.15.16.08.18;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.15.15.59.23;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.15.15.32.01;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.15.14.52.16;	author kristaps;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.05.15.37.30;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2010.11.29.13.02.47;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2010.10.23.23.31.10;	author schwarze;	state Exp;
branches;
next	1.111;

1.111
date	2010.10.10.09.59.48;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2010.10.01.21.51.13;	author schwarze;	state Exp;
branches;
next	1.109;

1.109
date	2010.10.01.12.09.55;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.27.11.21.39;	author kristaps;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.26.10.32.14;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.25.16.41.33;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.25.15.51.30;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2010.09.04.20.18.53;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.04.19.01.52;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2010.08.07.17.20.17;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.27.08.38.04;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.23.00.08.57;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.19.11.11.54;	author kristaps;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.19.11.06.31;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.13.23.53.20;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.07.15.04.54;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.06.12.37.17;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.04.21.59.30;	author kristaps;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.02.12.54.33;	author kristaps;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.02.10.42.46;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2010.07.01.22.56.17;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.01.14.34.03;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.29.19.20.38;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.27.16.18.13;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.26.15.36.37;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.19.20.46.28;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2010.06.13.21.41.58;	author kristaps;	state Exp;
branches;
next	1.83;

1.83
date	2010.06.12.12.38.01;	author kristaps;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.12.12.10.55;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2010.06.12.11.58.22;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.12.11.21.44;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2010.06.12.10.09.19;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2010.06.07.11.01.15;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2010.06.06.10.50.56;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.04.22.26.13;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.04.22.16.27;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.04.21.49.39;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.04.21.05.39;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.03.13.44.36;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.31.10.28.04;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.30.22.56.02;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.29.18.58.52;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.29.18.47.54;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.24.12.17.09;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2010.05.17.23.57.06;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2010.05.17.22.11.42;	author kristaps;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.17.02.38.13;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2010.05.15.16.24.38;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2010.05.13.06.22.11;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.08.08.17.55;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2010.04.07.07.49.38;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2010.04.06.11.28.17;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2010.04.06.07.27.42;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2010.04.05.08.51.56;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.03.14.25.12;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2010.03.29.19.28.04;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2010.01.30.08.42.20;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2010.01.29.14.39.38;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.01.17.14.29;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.01.13.35.30;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2010.01.01.13.17.58;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.02.10.16.55;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.16.08.46.59;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.14.12.04.59;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.31.08.34.12;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.31.06.50.25;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.31.06.10.58;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.30.18.53.08;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.28.08.00.18;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.28.05.08.17;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.27.04.50.15;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.26.08.18.16;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.26.04.09.45;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2009.10.24.05.52.13;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2009.10.22.18.55.32;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2009.10.20.05.45.21;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.19.11.02.24;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.19.10.18.06;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2009.10.18.19.03.37;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.18.11.14.04;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.15.01.33.12;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.13.10.57.25;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.10.10.05.12;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2009.10.08.23.00.15;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.07.15.06.03;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.07.14.50.28;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.07.14.39.00;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.07.12.35.24;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2009.10.04.15.24.54;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.04.09.00.40;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.03.19.57.53;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.03.19.02.45;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2009.10.03.16.36.06;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2009.10.03.15.26.26;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.03.15.08.09;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2009.09.26.18.31.36;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.26.18.02.51;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.26.17.35.49;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.25.13.00.13;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.25.12.43.05;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.24.23.54.43;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.24.15.05.56;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.24.13.18.37;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.09.24.11.55.28;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.09.24.11.05.45;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.09.24.09.50.31;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.24.09.20.02;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.09.22.16.10.52;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.21.23.12.08;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2009.09.21.14.56.57;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.238
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@/*	$Id: mdoc_html.c,v 1.237 2015/10/06 18:32:19 schwarze Exp $ */
/*
 * Copyright (c) 2008-2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "mandoc_aux.h"
#include "roff.h"
#include "mdoc.h"
#include "out.h"
#include "html.h"
#include "main.h"

#define	INDENT		 5

#define	MDOC_ARGS	  const struct roff_meta *meta, \
			  struct roff_node *n, \
			  struct html *h

#ifndef MIN
#define	MIN(a,b)	((/*CONSTCOND*/(a)<(b))?(a):(b))
#endif

struct	htmlmdoc {
	int		(*pre)(MDOC_ARGS);
	void		(*post)(MDOC_ARGS);
};

static	void		  print_mdoc_head(MDOC_ARGS);
static	void		  print_mdoc_node(MDOC_ARGS);
static	void		  print_mdoc_nodelist(MDOC_ARGS);
static	void		  synopsis_pre(struct html *,
				const struct roff_node *);

static	void		  a2width(const char *, struct roffsu *);

static	void		  mdoc_root_post(MDOC_ARGS);
static	int		  mdoc_root_pre(MDOC_ARGS);

static	void		  mdoc__x_post(MDOC_ARGS);
static	int		  mdoc__x_pre(MDOC_ARGS);
static	int		  mdoc_ad_pre(MDOC_ARGS);
static	int		  mdoc_an_pre(MDOC_ARGS);
static	int		  mdoc_ap_pre(MDOC_ARGS);
static	int		  mdoc_ar_pre(MDOC_ARGS);
static	int		  mdoc_bd_pre(MDOC_ARGS);
static	int		  mdoc_bf_pre(MDOC_ARGS);
static	void		  mdoc_bk_post(MDOC_ARGS);
static	int		  mdoc_bk_pre(MDOC_ARGS);
static	int		  mdoc_bl_pre(MDOC_ARGS);
static	int		  mdoc_bt_pre(MDOC_ARGS);
static	int		  mdoc_bx_pre(MDOC_ARGS);
static	int		  mdoc_cd_pre(MDOC_ARGS);
static	int		  mdoc_d1_pre(MDOC_ARGS);
static	int		  mdoc_dv_pre(MDOC_ARGS);
static	int		  mdoc_fa_pre(MDOC_ARGS);
static	int		  mdoc_fd_pre(MDOC_ARGS);
static	int		  mdoc_fl_pre(MDOC_ARGS);
static	int		  mdoc_fn_pre(MDOC_ARGS);
static	int		  mdoc_ft_pre(MDOC_ARGS);
static	int		  mdoc_em_pre(MDOC_ARGS);
static	void		  mdoc_eo_post(MDOC_ARGS);
static	int		  mdoc_eo_pre(MDOC_ARGS);
static	int		  mdoc_er_pre(MDOC_ARGS);
static	int		  mdoc_ev_pre(MDOC_ARGS);
static	int		  mdoc_ex_pre(MDOC_ARGS);
static	void		  mdoc_fo_post(MDOC_ARGS);
static	int		  mdoc_fo_pre(MDOC_ARGS);
static	int		  mdoc_ic_pre(MDOC_ARGS);
static	int		  mdoc_igndelim_pre(MDOC_ARGS);
static	int		  mdoc_in_pre(MDOC_ARGS);
static	int		  mdoc_it_pre(MDOC_ARGS);
static	int		  mdoc_lb_pre(MDOC_ARGS);
static	int		  mdoc_li_pre(MDOC_ARGS);
static	int		  mdoc_lk_pre(MDOC_ARGS);
static	int		  mdoc_mt_pre(MDOC_ARGS);
static	int		  mdoc_ms_pre(MDOC_ARGS);
static	int		  mdoc_nd_pre(MDOC_ARGS);
static	int		  mdoc_nm_pre(MDOC_ARGS);
static	int		  mdoc_no_pre(MDOC_ARGS);
static	int		  mdoc_ns_pre(MDOC_ARGS);
static	int		  mdoc_pa_pre(MDOC_ARGS);
static	void		  mdoc_pf_post(MDOC_ARGS);
static	int		  mdoc_pp_pre(MDOC_ARGS);
static	void		  mdoc_quote_post(MDOC_ARGS);
static	int		  mdoc_quote_pre(MDOC_ARGS);
static	int		  mdoc_rs_pre(MDOC_ARGS);
static	int		  mdoc_rv_pre(MDOC_ARGS);
static	int		  mdoc_sh_pre(MDOC_ARGS);
static	int		  mdoc_skip_pre(MDOC_ARGS);
static	int		  mdoc_sm_pre(MDOC_ARGS);
static	int		  mdoc_sp_pre(MDOC_ARGS);
static	int		  mdoc_ss_pre(MDOC_ARGS);
static	int		  mdoc_sx_pre(MDOC_ARGS);
static	int		  mdoc_sy_pre(MDOC_ARGS);
static	int		  mdoc_ud_pre(MDOC_ARGS);
static	int		  mdoc_va_pre(MDOC_ARGS);
static	int		  mdoc_vt_pre(MDOC_ARGS);
static	int		  mdoc_xr_pre(MDOC_ARGS);
static	int		  mdoc_xx_pre(MDOC_ARGS);

static	const struct htmlmdoc mdocs[MDOC_MAX] = {
	{mdoc_ap_pre, NULL}, /* Ap */
	{NULL, NULL}, /* Dd */
	{NULL, NULL}, /* Dt */
	{NULL, NULL}, /* Os */
	{mdoc_sh_pre, NULL }, /* Sh */
	{mdoc_ss_pre, NULL }, /* Ss */
	{mdoc_pp_pre, NULL}, /* Pp */
	{mdoc_d1_pre, NULL}, /* D1 */
	{mdoc_d1_pre, NULL}, /* Dl */
	{mdoc_bd_pre, NULL}, /* Bd */
	{NULL, NULL}, /* Ed */
	{mdoc_bl_pre, NULL}, /* Bl */
	{NULL, NULL}, /* El */
	{mdoc_it_pre, NULL}, /* It */
	{mdoc_ad_pre, NULL}, /* Ad */
	{mdoc_an_pre, NULL}, /* An */
	{mdoc_ar_pre, NULL}, /* Ar */
	{mdoc_cd_pre, NULL}, /* Cd */
	{mdoc_fl_pre, NULL}, /* Cm */
	{mdoc_dv_pre, NULL}, /* Dv */
	{mdoc_er_pre, NULL}, /* Er */
	{mdoc_ev_pre, NULL}, /* Ev */
	{mdoc_ex_pre, NULL}, /* Ex */
	{mdoc_fa_pre, NULL}, /* Fa */
	{mdoc_fd_pre, NULL}, /* Fd */
	{mdoc_fl_pre, NULL}, /* Fl */
	{mdoc_fn_pre, NULL}, /* Fn */
	{mdoc_ft_pre, NULL}, /* Ft */
	{mdoc_ic_pre, NULL}, /* Ic */
	{mdoc_in_pre, NULL}, /* In */
	{mdoc_li_pre, NULL}, /* Li */
	{mdoc_nd_pre, NULL}, /* Nd */
	{mdoc_nm_pre, NULL}, /* Nm */
	{mdoc_quote_pre, mdoc_quote_post}, /* Op */
	{mdoc_ft_pre, NULL}, /* Ot */
	{mdoc_pa_pre, NULL}, /* Pa */
	{mdoc_rv_pre, NULL}, /* Rv */
	{NULL, NULL}, /* St */
	{mdoc_va_pre, NULL}, /* Va */
	{mdoc_vt_pre, NULL}, /* Vt */
	{mdoc_xr_pre, NULL}, /* Xr */
	{mdoc__x_pre, mdoc__x_post}, /* %A */
	{mdoc__x_pre, mdoc__x_post}, /* %B */
	{mdoc__x_pre, mdoc__x_post}, /* %D */
	{mdoc__x_pre, mdoc__x_post}, /* %I */
	{mdoc__x_pre, mdoc__x_post}, /* %J */
	{mdoc__x_pre, mdoc__x_post}, /* %N */
	{mdoc__x_pre, mdoc__x_post}, /* %O */
	{mdoc__x_pre, mdoc__x_post}, /* %P */
	{mdoc__x_pre, mdoc__x_post}, /* %R */
	{mdoc__x_pre, mdoc__x_post}, /* %T */
	{mdoc__x_pre, mdoc__x_post}, /* %V */
	{NULL, NULL}, /* Ac */
	{mdoc_quote_pre, mdoc_quote_post}, /* Ao */
	{mdoc_quote_pre, mdoc_quote_post}, /* Aq */
	{NULL, NULL}, /* At */
	{NULL, NULL}, /* Bc */
	{mdoc_bf_pre, NULL}, /* Bf */
	{mdoc_quote_pre, mdoc_quote_post}, /* Bo */
	{mdoc_quote_pre, mdoc_quote_post}, /* Bq */
	{mdoc_xx_pre, NULL}, /* Bsx */
	{mdoc_bx_pre, NULL}, /* Bx */
	{mdoc_skip_pre, NULL}, /* Db */
	{NULL, NULL}, /* Dc */
	{mdoc_quote_pre, mdoc_quote_post}, /* Do */
	{mdoc_quote_pre, mdoc_quote_post}, /* Dq */
	{NULL, NULL}, /* Ec */ /* FIXME: no space */
	{NULL, NULL}, /* Ef */
	{mdoc_em_pre, NULL}, /* Em */
	{mdoc_eo_pre, mdoc_eo_post}, /* Eo */
	{mdoc_xx_pre, NULL}, /* Fx */
	{mdoc_ms_pre, NULL}, /* Ms */
	{mdoc_no_pre, NULL}, /* No */
	{mdoc_ns_pre, NULL}, /* Ns */
	{mdoc_xx_pre, NULL}, /* Nx */
	{mdoc_xx_pre, NULL}, /* Ox */
	{NULL, NULL}, /* Pc */
	{mdoc_igndelim_pre, mdoc_pf_post}, /* Pf */
	{mdoc_quote_pre, mdoc_quote_post}, /* Po */
	{mdoc_quote_pre, mdoc_quote_post}, /* Pq */
	{NULL, NULL}, /* Qc */
	{mdoc_quote_pre, mdoc_quote_post}, /* Ql */
	{mdoc_quote_pre, mdoc_quote_post}, /* Qo */
	{mdoc_quote_pre, mdoc_quote_post}, /* Qq */
	{NULL, NULL}, /* Re */
	{mdoc_rs_pre, NULL}, /* Rs */
	{NULL, NULL}, /* Sc */
	{mdoc_quote_pre, mdoc_quote_post}, /* So */
	{mdoc_quote_pre, mdoc_quote_post}, /* Sq */
	{mdoc_sm_pre, NULL}, /* Sm */
	{mdoc_sx_pre, NULL}, /* Sx */
	{mdoc_sy_pre, NULL}, /* Sy */
	{NULL, NULL}, /* Tn */
	{mdoc_xx_pre, NULL}, /* Ux */
	{NULL, NULL}, /* Xc */
	{NULL, NULL}, /* Xo */
	{mdoc_fo_pre, mdoc_fo_post}, /* Fo */
	{NULL, NULL}, /* Fc */
	{mdoc_quote_pre, mdoc_quote_post}, /* Oo */
	{NULL, NULL}, /* Oc */
	{mdoc_bk_pre, mdoc_bk_post}, /* Bk */
	{NULL, NULL}, /* Ek */
	{mdoc_bt_pre, NULL}, /* Bt */
	{NULL, NULL}, /* Hf */
	{mdoc_em_pre, NULL}, /* Fr */
	{mdoc_ud_pre, NULL}, /* Ud */
	{mdoc_lb_pre, NULL}, /* Lb */
	{mdoc_pp_pre, NULL}, /* Lp */
	{mdoc_lk_pre, NULL}, /* Lk */
	{mdoc_mt_pre, NULL}, /* Mt */
	{mdoc_quote_pre, mdoc_quote_post}, /* Brq */
	{mdoc_quote_pre, mdoc_quote_post}, /* Bro */
	{NULL, NULL}, /* Brc */
	{mdoc__x_pre, mdoc__x_post}, /* %C */
	{mdoc_skip_pre, NULL}, /* Es */
	{mdoc_quote_pre, mdoc_quote_post}, /* En */
	{mdoc_xx_pre, NULL}, /* Dx */
	{mdoc__x_pre, mdoc__x_post}, /* %Q */
	{mdoc_sp_pre, NULL}, /* br */
	{mdoc_sp_pre, NULL}, /* sp */
	{mdoc__x_pre, mdoc__x_post}, /* %U */
	{NULL, NULL}, /* Ta */
	{mdoc_skip_pre, NULL}, /* ll */
};

static	const char * const lists[LIST_MAX] = {
	NULL,
	"list-bul",
	"list-col",
	"list-dash",
	"list-diag",
	"list-enum",
	"list-hang",
	"list-hyph",
	"list-inset",
	"list-item",
	"list-ohang",
	"list-tag"
};


/*
 * Calculate the scaling unit passed in a `-width' argument.  This uses
 * either a native scaling unit (e.g., 1i, 2m) or the string length of
 * the value.
 */
static void
a2width(const char *p, struct roffsu *su)
{

	if (a2roffsu(p, su, SCALE_MAX) < 2) {
		su->unit = SCALE_EN;
		su->scale = html_strlen(p);
	} else if (su->scale < 0.0)
		su->scale = 0.0;
}

/*
 * See the same function in mdoc_term.c for documentation.
 */
static void
synopsis_pre(struct html *h, const struct roff_node *n)
{

	if (NULL == n->prev || ! (MDOC_SYNPRETTY & n->flags))
		return;

	if (n->prev->tok == n->tok &&
	    MDOC_Fo != n->tok &&
	    MDOC_Ft != n->tok &&
	    MDOC_Fn != n->tok) {
		print_otag(h, TAG_BR, 0, NULL);
		return;
	}

	switch (n->prev->tok) {
	case MDOC_Fd:
	case MDOC_Fn:
	case MDOC_Fo:
	case MDOC_In:
	case MDOC_Vt:
		print_paragraph(h);
		break;
	case MDOC_Ft:
		if (MDOC_Fn != n->tok && MDOC_Fo != n->tok) {
			print_paragraph(h);
			break;
		}
		/* FALLTHROUGH */
	default:
		print_otag(h, TAG_BR, 0, NULL);
		break;
	}
}

void
html_mdoc(void *arg, const struct roff_man *mdoc)
{
	struct htmlpair	 tag;
	struct html	*h;
	struct tag	*t, *tt;

	PAIR_CLASS_INIT(&tag, "mandoc");
	h = (struct html *)arg;

	if ( ! (HTML_FRAGMENT & h->oflags)) {
		print_gen_decls(h);
		t = print_otag(h, TAG_HTML, 0, NULL);
		tt = print_otag(h, TAG_HEAD, 0, NULL);
		print_mdoc_head(&mdoc->meta, mdoc->first->child, h);
		print_tagq(h, tt);
		print_otag(h, TAG_BODY, 0, NULL);
		print_otag(h, TAG_DIV, 1, &tag);
	} else
		t = print_otag(h, TAG_DIV, 1, &tag);

	mdoc_root_pre(&mdoc->meta, mdoc->first->child, h);
	print_mdoc_nodelist(&mdoc->meta, mdoc->first->child, h);
	mdoc_root_post(&mdoc->meta, mdoc->first->child, h);
	print_tagq(h, t);
	putchar('\n');
}

static void
print_mdoc_head(MDOC_ARGS)
{

	print_gen_head(h);
	bufinit(h);
	bufcat(h, meta->title);
	if (meta->msec)
		bufcat_fmt(h, "(%s)", meta->msec);
	if (meta->arch)
		bufcat_fmt(h, " (%s)", meta->arch);

	print_otag(h, TAG_TITLE, 0, NULL);
	print_text(h, h->buf);
}

static void
print_mdoc_nodelist(MDOC_ARGS)
{

	while (n != NULL) {
		print_mdoc_node(meta, n, h);
		n = n->next;
	}
}

static void
print_mdoc_node(MDOC_ARGS)
{
	int		 child;
	struct tag	*t;

	child = 1;
	t = h->tags.head;
	n->flags &= ~MDOC_ENDED;

	switch (n->type) {
	case ROFFT_TEXT:
		/* No tables in this mode... */
		assert(NULL == h->tblt);

		/*
		 * Make sure that if we're in a literal mode already
		 * (i.e., within a <PRE>) don't print the newline.
		 */
		if (' ' == *n->string && MDOC_LINE & n->flags)
			if ( ! (HTML_LITERAL & h->flags))
				print_otag(h, TAG_BR, 0, NULL);
		if (MDOC_DELIMC & n->flags)
			h->flags |= HTML_NOSPACE;
		print_text(h, n->string);
		if (MDOC_DELIMO & n->flags)
			h->flags |= HTML_NOSPACE;
		return;
	case ROFFT_EQN:
		if (n->flags & MDOC_LINE)
			putchar('\n');
		print_eqn(h, n->eqn);
		break;
	case ROFFT_TBL:
		/*
		 * This will take care of initialising all of the table
		 * state data for the first table, then tearing it down
		 * for the last one.
		 */
		print_tbl(h, n->span);
		return;
	default:
		/*
		 * Close out the current table, if it's open, and unset
		 * the "meta" table state.  This will be reopened on the
		 * next table element.
		 */
		if (h->tblt != NULL) {
			print_tblclose(h);
			t = h->tags.head;
		}
		assert(h->tblt == NULL);
		if (mdocs[n->tok].pre && (n->end == ENDBODY_NOT || n->child))
			child = (*mdocs[n->tok].pre)(meta, n, h);
		break;
	}

	if (h->flags & HTML_KEEP && n->flags & MDOC_LINE) {
		h->flags &= ~HTML_KEEP;
		h->flags |= HTML_PREKEEP;
	}

	if (child && n->child)
		print_mdoc_nodelist(meta, n->child, h);

	print_stagq(h, t);

	switch (n->type) {
	case ROFFT_EQN:
		break;
	default:
		if ( ! mdocs[n->tok].post || n->flags & MDOC_ENDED)
			break;
		(*mdocs[n->tok].post)(meta, n, h);
		if (n->end != ENDBODY_NOT)
			n->body->flags |= MDOC_ENDED;
		if (n->end == ENDBODY_NOSPACE)
			h->flags |= HTML_NOSPACE;
		break;
	}
}

static void
mdoc_root_post(MDOC_ARGS)
{
	struct htmlpair	 tag;
	struct tag	*t, *tt;

	PAIR_CLASS_INIT(&tag, "foot");
	t = print_otag(h, TAG_TABLE, 1, &tag);

	print_otag(h, TAG_TBODY, 0, NULL);

	tt = print_otag(h, TAG_TR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "foot-date");
	print_otag(h, TAG_TD, 1, &tag);
	print_text(h, meta->date);
	print_stagq(h, tt);

	PAIR_CLASS_INIT(&tag, "foot-os");
	print_otag(h, TAG_TD, 1, &tag);
	print_text(h, meta->os);
	print_tagq(h, t);
}

static int
mdoc_root_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;
	struct tag	*t, *tt;
	char		*volume, *title;

	if (NULL == meta->arch)
		volume = mandoc_strdup(meta->vol);
	else
		mandoc_asprintf(&volume, "%s (%s)",
		    meta->vol, meta->arch);

	if (NULL == meta->msec)
		title = mandoc_strdup(meta->title);
	else
		mandoc_asprintf(&title, "%s(%s)",
		    meta->title, meta->msec);

	PAIR_CLASS_INIT(&tag, "head");
	t = print_otag(h, TAG_TABLE, 1, &tag);

	print_otag(h, TAG_TBODY, 0, NULL);

	tt = print_otag(h, TAG_TR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "head-ltitle");
	print_otag(h, TAG_TD, 1, &tag);
	print_text(h, title);
	print_stagq(h, tt);

	PAIR_CLASS_INIT(&tag, "head-vol");
	print_otag(h, TAG_TD, 1, &tag);
	print_text(h, volume);
	print_stagq(h, tt);

	PAIR_CLASS_INIT(&tag, "head-rtitle");
	print_otag(h, TAG_TD, 1, &tag);
	print_text(h, title);
	print_tagq(h, t);

	free(title);
	free(volume);
	return 1;
}

static int
mdoc_sh_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	switch (n->type) {
	case ROFFT_BLOCK:
		PAIR_CLASS_INIT(&tag, "section");
		print_otag(h, TAG_DIV, 1, &tag);
		return 1;
	case ROFFT_BODY:
		if (n->sec == SEC_AUTHORS)
			h->flags &= ~(HTML_SPLIT|HTML_NOSPLIT);
		return 1;
	default:
		break;
	}

	bufinit(h);
	bufcat(h, "x");

	for (n = n->child; n != NULL && n->type == ROFFT_TEXT; ) {
		bufcat_id(h, n->string);
		if (NULL != (n = n->next))
			bufcat_id(h, " ");
	}

	if (NULL == n) {
		PAIR_ID_INIT(&tag, h->buf);
		print_otag(h, TAG_H1, 1, &tag);
	} else
		print_otag(h, TAG_H1, 0, NULL);

	return 1;
}

static int
mdoc_ss_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (n->type == ROFFT_BLOCK) {
		PAIR_CLASS_INIT(&tag, "subsection");
		print_otag(h, TAG_DIV, 1, &tag);
		return 1;
	} else if (n->type == ROFFT_BODY)
		return 1;

	bufinit(h);
	bufcat(h, "x");

	for (n = n->child; n != NULL && n->type == ROFFT_TEXT; ) {
		bufcat_id(h, n->string);
		if (NULL != (n = n->next))
			bufcat_id(h, " ");
	}

	if (NULL == n) {
		PAIR_ID_INIT(&tag, h->buf);
		print_otag(h, TAG_H2, 1, &tag);
	} else
		print_otag(h, TAG_H2, 0, NULL);

	return 1;
}

static int
mdoc_fl_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "flag");
	print_otag(h, TAG_B, 1, &tag);

	/* `Cm' has no leading hyphen. */

	if (MDOC_Cm == n->tok)
		return 1;

	print_text(h, "\\-");

	if ( ! (n->nchild == 0 &&
	    (n->next == NULL ||
	     n->next->type == ROFFT_TEXT ||
	     n->next->flags & MDOC_LINE)))
		h->flags |= HTML_NOSPACE;

	return 1;
}

static int
mdoc_nd_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (n->type != ROFFT_BODY)
		return 1;

	/* XXX: this tag in theory can contain block elements. */

	print_text(h, "\\(em");
	PAIR_CLASS_INIT(&tag, "desc");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_nm_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;
	struct roffsu	 su;
	int		 len;

	switch (n->type) {
	case ROFFT_HEAD:
		print_otag(h, TAG_TD, 0, NULL);
		/* FALLTHROUGH */
	case ROFFT_ELEM:
		PAIR_CLASS_INIT(&tag, "name");
		print_otag(h, TAG_B, 1, &tag);
		if (n->child == NULL && meta->name != NULL)
			print_text(h, meta->name);
		return 1;
	case ROFFT_BODY:
		print_otag(h, TAG_TD, 0, NULL);
		return 1;
	default:
		break;
	}

	synopsis_pre(h, n);
	PAIR_CLASS_INIT(&tag, "synopsis");
	print_otag(h, TAG_TABLE, 1, &tag);

	for (len = 0, n = n->head->child; n; n = n->next)
		if (n->type == ROFFT_TEXT)
			len += html_strlen(n->string);

	if (len == 0 && meta->name != NULL)
		len = html_strlen(meta->name);

	SCALE_HS_INIT(&su, len);
	bufinit(h);
	bufcat_su(h, "width", &su);
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_COL, 1, &tag);
	print_otag(h, TAG_COL, 0, NULL);
	print_otag(h, TAG_TBODY, 0, NULL);
	print_otag(h, TAG_TR, 0, NULL);
	return 1;
}

static int
mdoc_xr_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];

	if (NULL == n->child)
		return 0;

	PAIR_CLASS_INIT(&tag[0], "link-man");

	if (h->base_man) {
		buffmt_man(h, n->child->string,
		    n->child->next ?
		    n->child->next->string : NULL);
		PAIR_HREF_INIT(&tag[1], h->buf);
		print_otag(h, TAG_A, 2, tag);
	} else
		print_otag(h, TAG_A, 1, tag);

	n = n->child;
	print_text(h, n->string);

	if (NULL == (n = n->next))
		return 0;

	h->flags |= HTML_NOSPACE;
	print_text(h, "(");
	h->flags |= HTML_NOSPACE;
	print_text(h, n->string);
	h->flags |= HTML_NOSPACE;
	print_text(h, ")");
	return 0;
}

static int
mdoc_ns_pre(MDOC_ARGS)
{

	if ( ! (MDOC_LINE & n->flags))
		h->flags |= HTML_NOSPACE;
	return 1;
}

static int
mdoc_ar_pre(MDOC_ARGS)
{
	struct htmlpair tag;

	PAIR_CLASS_INIT(&tag, "arg");
	print_otag(h, TAG_I, 1, &tag);
	return 1;
}

static int
mdoc_xx_pre(MDOC_ARGS)
{
	const char	*pp;
	struct htmlpair	 tag;
	int		 flags;

	switch (n->tok) {
	case MDOC_Bsx:
		pp = "BSD/OS";
		break;
	case MDOC_Dx:
		pp = "DragonFly";
		break;
	case MDOC_Fx:
		pp = "FreeBSD";
		break;
	case MDOC_Nx:
		pp = "NetBSD";
		break;
	case MDOC_Ox:
		pp = "OpenBSD";
		break;
	case MDOC_Ux:
		pp = "UNIX";
		break;
	default:
		return 1;
	}

	PAIR_CLASS_INIT(&tag, "unix");
	print_otag(h, TAG_SPAN, 1, &tag);

	print_text(h, pp);
	if (n->child) {
		flags = h->flags;
		h->flags |= HTML_KEEP;
		print_text(h, n->child->string);
		h->flags = flags;
	}
	return 0;
}

static int
mdoc_bx_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	PAIR_CLASS_INIT(&tag, "unix");
	print_otag(h, TAG_SPAN, 1, &tag);

	if (NULL != (n = n->child)) {
		print_text(h, n->string);
		h->flags |= HTML_NOSPACE;
		print_text(h, "BSD");
	} else {
		print_text(h, "BSD");
		return 0;
	}

	if (NULL != (n = n->next)) {
		h->flags |= HTML_NOSPACE;
		print_text(h, "-");
		h->flags |= HTML_NOSPACE;
		print_text(h, n->string);
	}

	return 0;
}

static int
mdoc_it_pre(MDOC_ARGS)
{
	struct roffsu	 su;
	enum mdoc_list	 type;
	struct htmlpair	 tag[2];
	const struct roff_node *bl;

	bl = n->parent;
	while (bl && MDOC_Bl != bl->tok)
		bl = bl->parent;

	assert(bl);

	type = bl->norm->Bl.type;

	assert(lists[type]);
	PAIR_CLASS_INIT(&tag[0], lists[type]);

	bufinit(h);

	if (n->type == ROFFT_HEAD) {
		switch (type) {
		case LIST_bullet:
		case LIST_dash:
		case LIST_item:
		case LIST_hyphen:
		case LIST_enum:
			return 0;
		case LIST_diag:
		case LIST_hang:
		case LIST_inset:
		case LIST_ohang:
		case LIST_tag:
			SCALE_VS_INIT(&su, ! bl->norm->Bl.comp);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DT, 2, tag);
			if (LIST_diag != type)
				break;
			PAIR_CLASS_INIT(&tag[0], "diag");
			print_otag(h, TAG_B, 1, tag);
			break;
		case LIST_column:
			break;
		default:
			break;
		}
	} else if (n->type == ROFFT_BODY) {
		switch (type) {
		case LIST_bullet:
		case LIST_hyphen:
		case LIST_dash:
		case LIST_enum:
		case LIST_item:
			SCALE_VS_INIT(&su, ! bl->norm->Bl.comp);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_LI, 2, tag);
			break;
		case LIST_diag:
		case LIST_hang:
		case LIST_inset:
		case LIST_ohang:
		case LIST_tag:
			if (NULL == bl->norm->Bl.width) {
				print_otag(h, TAG_DD, 1, tag);
				break;
			}
			a2width(bl->norm->Bl.width, &su);
			bufcat_su(h, "margin-left", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DD, 2, tag);
			break;
		case LIST_column:
			SCALE_VS_INIT(&su, ! bl->norm->Bl.comp);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_TD, 2, tag);
			break;
		default:
			break;
		}
	} else {
		switch (type) {
		case LIST_column:
			print_otag(h, TAG_TR, 1, tag);
			break;
		default:
			break;
		}
	}

	return 1;
}

static int
mdoc_bl_pre(MDOC_ARGS)
{
	int		 i;
	struct htmlpair	 tag[3];
	struct roffsu	 su;
	char		 buf[BUFSIZ];

	if (n->type == ROFFT_BODY) {
		if (LIST_column == n->norm->Bl.type)
			print_otag(h, TAG_TBODY, 0, NULL);
		return 1;
	}

	if (n->type == ROFFT_HEAD) {
		if (LIST_column != n->norm->Bl.type)
			return 0;

		/*
		 * For each column, print out the <COL> tag with our
		 * suggested width.  The last column gets min-width, as
		 * in terminal mode it auto-sizes to the width of the
		 * screen and we want to preserve that behaviour.
		 */

		for (i = 0; i < (int)n->norm->Bl.ncols; i++) {
			bufinit(h);
			a2width(n->norm->Bl.cols[i], &su);
			if (i < (int)n->norm->Bl.ncols - 1)
				bufcat_su(h, "width", &su);
			else
				bufcat_su(h, "min-width", &su);
			PAIR_STYLE_INIT(&tag[0], h);
			print_otag(h, TAG_COL, 1, tag);
		}

		return 0;
	}

	SCALE_VS_INIT(&su, 0);
	bufinit(h);
	bufcat_su(h, "margin-top", &su);
	bufcat_su(h, "margin-bottom", &su);
	PAIR_STYLE_INIT(&tag[0], h);

	assert(lists[n->norm->Bl.type]);
	(void)strlcpy(buf, "list ", BUFSIZ);
	(void)strlcat(buf, lists[n->norm->Bl.type], BUFSIZ);
	PAIR_INIT(&tag[1], ATTR_CLASS, buf);

	/* Set the block's left-hand margin. */

	if (n->norm->Bl.offs) {
		a2width(n->norm->Bl.offs, &su);
		bufcat_su(h, "margin-left", &su);
	}

	switch (n->norm->Bl.type) {
	case LIST_bullet:
	case LIST_dash:
	case LIST_hyphen:
	case LIST_item:
		print_otag(h, TAG_UL, 2, tag);
		break;
	case LIST_enum:
		print_otag(h, TAG_OL, 2, tag);
		break;
	case LIST_diag:
	case LIST_hang:
	case LIST_inset:
	case LIST_ohang:
	case LIST_tag:
		print_otag(h, TAG_DL, 2, tag);
		break;
	case LIST_column:
		print_otag(h, TAG_TABLE, 2, tag);
		break;
	default:
		abort();
	}

	return 1;
}

static int
mdoc_ex_pre(MDOC_ARGS)
{
	struct tag	*t;
	struct htmlpair	 tag;
	int		 nchild;

	if (n->prev)
		print_otag(h, TAG_BR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "utility");

	print_text(h, "The");

	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);

		t = print_otag(h, TAG_B, 1, &tag);
		print_text(h, n->string);
		print_tagq(h, t);

		if (nchild > 2 && n->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
		}

		if (n->next && NULL == n->next->next)
			print_text(h, "and");
	}

	if (nchild > 1)
		print_text(h, "utilities exit\\~0");
	else
		print_text(h, "utility exits\\~0");

	print_text(h, "on success, and\\~>0 if an error occurs.");
	return 0;
}

static int
mdoc_em_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "emph");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_d1_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];
	struct roffsu	 su;

	if (n->type != ROFFT_BLOCK)
		return 1;

	SCALE_VS_INIT(&su, 0);
	bufinit(h);
	bufcat_su(h, "margin-top", &su);
	bufcat_su(h, "margin-bottom", &su);
	PAIR_STYLE_INIT(&tag[0], h);
	print_otag(h, TAG_BLOCKQUOTE, 1, tag);

	/* BLOCKQUOTE needs a block body. */

	PAIR_CLASS_INIT(&tag[0], "display");
	print_otag(h, TAG_DIV, 1, tag);

	if (MDOC_Dl == n->tok) {
		PAIR_CLASS_INIT(&tag[0], "lit");
		print_otag(h, TAG_CODE, 1, tag);
	}

	return 1;
}

static int
mdoc_sx_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];

	bufinit(h);
	bufcat(h, "#x");

	for (n = n->child; n; ) {
		bufcat_id(h, n->string);
		if (NULL != (n = n->next))
			bufcat_id(h, " ");
	}

	PAIR_CLASS_INIT(&tag[0], "link-sec");
	PAIR_HREF_INIT(&tag[1], h->buf);

	print_otag(h, TAG_I, 1, tag);
	print_otag(h, TAG_A, 2, tag);
	return 1;
}

static int
mdoc_bd_pre(MDOC_ARGS)
{
	struct htmlpair		 tag[2];
	int			 comp, sv;
	struct roff_node	*nn;
	struct roffsu		 su;

	if (n->type == ROFFT_HEAD)
		return 0;

	if (n->type == ROFFT_BLOCK) {
		comp = n->norm->Bd.comp;
		for (nn = n; nn && ! comp; nn = nn->parent) {
			if (nn->type != ROFFT_BLOCK)
				continue;
			if (MDOC_Ss == nn->tok || MDOC_Sh == nn->tok)
				comp = 1;
			if (nn->prev)
				break;
		}
		if ( ! comp)
			print_paragraph(h);
		return 1;
	}

	/* Handle the -offset argument. */

	if (n->norm->Bd.offs == NULL ||
	    ! strcmp(n->norm->Bd.offs, "left"))
		SCALE_HS_INIT(&su, 0);
	else if ( ! strcmp(n->norm->Bd.offs, "indent"))
		SCALE_HS_INIT(&su, INDENT);
	else if ( ! strcmp(n->norm->Bd.offs, "indent-two"))
		SCALE_HS_INIT(&su, INDENT * 2);
	else
		a2width(n->norm->Bd.offs, &su);

	bufinit(h);
	bufcat_su(h, "margin-left", &su);
	PAIR_STYLE_INIT(&tag[0], h);

	if (DISP_unfilled != n->norm->Bd.type &&
	    DISP_literal != n->norm->Bd.type) {
		PAIR_CLASS_INIT(&tag[1], "display");
		print_otag(h, TAG_DIV, 2, tag);
		return 1;
	}

	PAIR_CLASS_INIT(&tag[1], "lit display");
	print_otag(h, TAG_PRE, 2, tag);

	/* This can be recursive: save & set our literal state. */

	sv = h->flags & HTML_LITERAL;
	h->flags |= HTML_LITERAL;

	for (nn = n->child; nn; nn = nn->next) {
		print_mdoc_node(meta, nn, h);
		/*
		 * If the printed node flushes its own line, then we
		 * needn't do it here as well.  This is hacky, but the
		 * notion of selective eoln whitespace is pretty dumb
		 * anyway, so don't sweat it.
		 */
		switch (nn->tok) {
		case MDOC_Sm:
		case MDOC_br:
		case MDOC_sp:
		case MDOC_Bl:
		case MDOC_D1:
		case MDOC_Dl:
		case MDOC_Lp:
		case MDOC_Pp:
			continue;
		default:
			break;
		}
		if (h->flags & HTML_NONEWLINE ||
		    (nn->next && ! (nn->next->flags & MDOC_LINE)))
			continue;
		else if (nn->next)
			print_text(h, "\n");

		h->flags |= HTML_NOSPACE;
	}

	if (0 == sv)
		h->flags &= ~HTML_LITERAL;

	return 0;
}

static int
mdoc_pa_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "file");
	print_otag(h, TAG_I, 1, &tag);
	return 1;
}

static int
mdoc_ad_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "addr");
	print_otag(h, TAG_I, 1, &tag);
	return 1;
}

static int
mdoc_an_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if (n->norm->An.auth == AUTH_split) {
		h->flags &= ~HTML_NOSPLIT;
		h->flags |= HTML_SPLIT;
		return 0;
	}
	if (n->norm->An.auth == AUTH_nosplit) {
		h->flags &= ~HTML_SPLIT;
		h->flags |= HTML_NOSPLIT;
		return 0;
	}

	if (h->flags & HTML_SPLIT)
		print_otag(h, TAG_BR, 0, NULL);

	if (n->sec == SEC_AUTHORS && ! (h->flags & HTML_NOSPLIT))
		h->flags |= HTML_SPLIT;

	PAIR_CLASS_INIT(&tag, "author");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_cd_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	synopsis_pre(h, n);
	PAIR_CLASS_INIT(&tag, "config");
	print_otag(h, TAG_B, 1, &tag);
	return 1;
}

static int
mdoc_dv_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "define");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_ev_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "env");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_er_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "errno");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_fa_pre(MDOC_ARGS)
{
	const struct roff_node	*nn;
	struct htmlpair		 tag;
	struct tag		*t;

	PAIR_CLASS_INIT(&tag, "farg");
	if (n->parent->tok != MDOC_Fo) {
		print_otag(h, TAG_I, 1, &tag);
		return 1;
	}

	for (nn = n->child; nn; nn = nn->next) {
		t = print_otag(h, TAG_I, 1, &tag);
		print_text(h, nn->string);
		print_tagq(h, t);
		if (nn->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
		}
	}

	if (n->child && n->next && n->next->tok == MDOC_Fa) {
		h->flags |= HTML_NOSPACE;
		print_text(h, ",");
	}

	return 0;
}

static int
mdoc_fd_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];
	char		 buf[BUFSIZ];
	size_t		 sz;
	int		 i;
	struct tag	*t;

	synopsis_pre(h, n);

	if (NULL == (n = n->child))
		return 0;

	assert(n->type == ROFFT_TEXT);

	if (strcmp(n->string, "#include")) {
		PAIR_CLASS_INIT(&tag[0], "macro");
		print_otag(h, TAG_B, 1, tag);
		return 1;
	}

	PAIR_CLASS_INIT(&tag[0], "includes");
	print_otag(h, TAG_B, 1, tag);
	print_text(h, n->string);

	if (NULL != (n = n->next)) {
		assert(n->type == ROFFT_TEXT);

		/*
		 * XXX This is broken and not easy to fix.
		 * When using -Oincludes, truncation may occur.
		 * Dynamic allocation wouldn't help because
		 * passing long strings to buffmt_includes()
		 * does not work either.
		 */

		strlcpy(buf, '<' == *n->string || '"' == *n->string ?
		    n->string + 1 : n->string, BUFSIZ);

		sz = strlen(buf);
		if (sz && ('>' == buf[sz - 1] || '"' == buf[sz - 1]))
			buf[sz - 1] = '\0';

		PAIR_CLASS_INIT(&tag[0], "link-includes");

		i = 1;
		if (h->base_includes) {
			buffmt_includes(h, buf);
			PAIR_HREF_INIT(&tag[i], h->buf);
			i++;
		}

		t = print_otag(h, TAG_A, i, tag);
		print_text(h, n->string);
		print_tagq(h, t);

		n = n->next;
	}

	for ( ; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
		print_text(h, n->string);
	}

	return 0;
}

static int
mdoc_vt_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (n->type == ROFFT_BLOCK) {
		synopsis_pre(h, n);
		return 1;
	} else if (n->type == ROFFT_ELEM) {
		synopsis_pre(h, n);
	} else if (n->type == ROFFT_HEAD)
		return 0;

	PAIR_CLASS_INIT(&tag, "type");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_ft_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	synopsis_pre(h, n);
	PAIR_CLASS_INIT(&tag, "ftype");
	print_otag(h, TAG_I, 1, &tag);
	return 1;
}

static int
mdoc_fn_pre(MDOC_ARGS)
{
	struct tag	*t;
	struct htmlpair	 tag[2];
	char		 nbuf[BUFSIZ];
	const char	*sp, *ep;
	int		 sz, i, pretty;

	pretty = MDOC_SYNPRETTY & n->flags;
	synopsis_pre(h, n);

	/* Split apart into type and name. */
	assert(n->child->string);
	sp = n->child->string;

	ep = strchr(sp, ' ');
	if (NULL != ep) {
		PAIR_CLASS_INIT(&tag[0], "ftype");
		t = print_otag(h, TAG_I, 1, tag);

		while (ep) {
			sz = MIN((int)(ep - sp), BUFSIZ - 1);
			(void)memcpy(nbuf, sp, (size_t)sz);
			nbuf[sz] = '\0';
			print_text(h, nbuf);
			sp = ++ep;
			ep = strchr(sp, ' ');
		}
		print_tagq(h, t);
	}

	PAIR_CLASS_INIT(&tag[0], "fname");

	/*
	 * FIXME: only refer to IDs that we know exist.
	 */

#if 0
	if (MDOC_SYNPRETTY & n->flags) {
		nbuf[0] = '\0';
		html_idcat(nbuf, sp, BUFSIZ);
		PAIR_ID_INIT(&tag[1], nbuf);
	} else {
		strlcpy(nbuf, "#", BUFSIZ);
		html_idcat(nbuf, sp, BUFSIZ);
		PAIR_HREF_INIT(&tag[1], nbuf);
	}
#endif

	t = print_otag(h, TAG_B, 1, tag);

	if (sp)
		print_text(h, sp);

	print_tagq(h, t);

	h->flags |= HTML_NOSPACE;
	print_text(h, "(");
	h->flags |= HTML_NOSPACE;

	PAIR_CLASS_INIT(&tag[0], "farg");
	bufinit(h);
	bufcat_style(h, "white-space", "nowrap");
	PAIR_STYLE_INIT(&tag[1], h);

	for (n = n->child->next; n; n = n->next) {
		i = 1;
		if (MDOC_SYNPRETTY & n->flags)
			i = 2;
		t = print_otag(h, TAG_I, i, tag);
		print_text(h, n->string);
		print_tagq(h, t);
		if (n->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
		}
	}

	h->flags |= HTML_NOSPACE;
	print_text(h, ")");

	if (pretty) {
		h->flags |= HTML_NOSPACE;
		print_text(h, ";");
	}

	return 0;
}

static int
mdoc_sm_pre(MDOC_ARGS)
{

	if (NULL == n->child)
		h->flags ^= HTML_NONOSPACE;
	else if (0 == strcmp("on", n->child->string))
		h->flags &= ~HTML_NONOSPACE;
	else
		h->flags |= HTML_NONOSPACE;

	if ( ! (HTML_NONOSPACE & h->flags))
		h->flags &= ~HTML_NOSPACE;

	return 0;
}

static int
mdoc_skip_pre(MDOC_ARGS)
{

	return 0;
}

static int
mdoc_pp_pre(MDOC_ARGS)
{

	print_paragraph(h);
	return 0;
}

static int
mdoc_sp_pre(MDOC_ARGS)
{
	struct roffsu	 su;
	struct htmlpair	 tag;

	SCALE_VS_INIT(&su, 1);

	if (MDOC_sp == n->tok) {
		if (NULL != (n = n->child)) {
			if ( ! a2roffsu(n->string, &su, SCALE_VS))
				su.scale = 1.0;
			else if (su.scale < 0.0)
				su.scale = 0.0;
		}
	} else
		su.scale = 0.0;

	bufinit(h);
	bufcat_su(h, "height", &su);
	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);

	/* So the div isn't empty: */
	print_text(h, "\\~");

	return 0;

}

static int
mdoc_lk_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];

	if (NULL == (n = n->child))
		return 0;

	assert(n->type == ROFFT_TEXT);

	PAIR_CLASS_INIT(&tag[0], "link-ext");
	PAIR_HREF_INIT(&tag[1], n->string);

	print_otag(h, TAG_A, 2, tag);

	if (NULL == n->next)
		print_text(h, n->string);

	for (n = n->next; n; n = n->next)
		print_text(h, n->string);

	return 0;
}

static int
mdoc_mt_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];
	struct tag	*t;

	PAIR_CLASS_INIT(&tag[0], "link-mail");

	for (n = n->child; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);

		bufinit(h);
		bufcat(h, "mailto:");
		bufcat(h, n->string);

		PAIR_HREF_INIT(&tag[1], h->buf);
		t = print_otag(h, TAG_A, 2, tag);
		print_text(h, n->string);
		print_tagq(h, t);
	}

	return 0;
}

static int
mdoc_fo_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;
	struct tag	*t;

	if (n->type == ROFFT_BODY) {
		h->flags |= HTML_NOSPACE;
		print_text(h, "(");
		h->flags |= HTML_NOSPACE;
		return 1;
	} else if (n->type == ROFFT_BLOCK) {
		synopsis_pre(h, n);
		return 1;
	}

	if (n->child == NULL)
		return 0;

	assert(n->child->string);
	PAIR_CLASS_INIT(&tag, "fname");
	t = print_otag(h, TAG_B, 1, &tag);
	print_text(h, n->child->string);
	print_tagq(h, t);
	return 0;
}

static void
mdoc_fo_post(MDOC_ARGS)
{

	if (n->type != ROFFT_BODY)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, ")");
	h->flags |= HTML_NOSPACE;
	print_text(h, ";");
}

static int
mdoc_in_pre(MDOC_ARGS)
{
	struct tag	*t;
	struct htmlpair	 tag[2];
	int		 i;

	synopsis_pre(h, n);

	PAIR_CLASS_INIT(&tag[0], "includes");
	print_otag(h, TAG_B, 1, tag);

	/*
	 * The first argument of the `In' gets special treatment as
	 * being a linked value.  Subsequent values are printed
	 * afterward.  groff does similarly.  This also handles the case
	 * of no children.
	 */

	if (MDOC_SYNPRETTY & n->flags && MDOC_LINE & n->flags)
		print_text(h, "#include");

	print_text(h, "<");
	h->flags |= HTML_NOSPACE;

	if (NULL != (n = n->child)) {
		assert(n->type == ROFFT_TEXT);

		PAIR_CLASS_INIT(&tag[0], "link-includes");

		i = 1;
		if (h->base_includes) {
			buffmt_includes(h, n->string);
			PAIR_HREF_INIT(&tag[i], h->buf);
			i++;
		}

		t = print_otag(h, TAG_A, i, tag);
		print_text(h, n->string);
		print_tagq(h, t);

		n = n->next;
	}

	h->flags |= HTML_NOSPACE;
	print_text(h, ">");

	for ( ; n; n = n->next) {
		assert(n->type == ROFFT_TEXT);
		print_text(h, n->string);
	}

	return 0;
}

static int
mdoc_ic_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "cmd");
	print_otag(h, TAG_B, 1, &tag);
	return 1;
}

static int
mdoc_rv_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;
	struct tag	*t;
	int		 nchild;

	if (n->prev)
		print_otag(h, TAG_BR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "fname");

	nchild = n->nchild;
	if (nchild > 0) {
		print_text(h, "The");

		for (n = n->child; n; n = n->next) {
			t = print_otag(h, TAG_B, 1, &tag);
			print_text(h, n->string);
			print_tagq(h, t);

			h->flags |= HTML_NOSPACE;
			print_text(h, "()");

			if (n->next == NULL)
				continue;

			if (nchild > 2) {
				h->flags |= HTML_NOSPACE;
				print_text(h, ",");
			}
			if (n->next->next == NULL)
				print_text(h, "and");
		}

		if (nchild > 1)
			print_text(h, "functions return");
		else
			print_text(h, "function returns");

		print_text(h, "the value\\~0 if successful;");
	} else
		print_text(h, "Upon successful completion,"
                    " the value\\~0 is returned;");

	print_text(h, "otherwise the value\\~\\-1 is returned"
	   " and the global variable");

	PAIR_CLASS_INIT(&tag, "var");
	t = print_otag(h, TAG_B, 1, &tag);
	print_text(h, "errno");
	print_tagq(h, t);
	print_text(h, "is set to indicate the error.");
	return 0;
}

static int
mdoc_va_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "var");
	print_otag(h, TAG_B, 1, &tag);
	return 1;
}

static int
mdoc_ap_pre(MDOC_ARGS)
{

	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(aq");
	h->flags |= HTML_NOSPACE;
	return 1;
}

static int
mdoc_bf_pre(MDOC_ARGS)
{
	struct htmlpair	 tag[2];
	struct roffsu	 su;

	if (n->type == ROFFT_HEAD)
		return 0;
	else if (n->type != ROFFT_BODY)
		return 1;

	if (FONT_Em == n->norm->Bf.font)
		PAIR_CLASS_INIT(&tag[0], "emph");
	else if (FONT_Sy == n->norm->Bf.font)
		PAIR_CLASS_INIT(&tag[0], "symb");
	else if (FONT_Li == n->norm->Bf.font)
		PAIR_CLASS_INIT(&tag[0], "lit");
	else
		PAIR_CLASS_INIT(&tag[0], "none");

	/*
	 * We want this to be inline-formatted, but needs to be div to
	 * accept block children.
	 */
	bufinit(h);
	bufcat_style(h, "display", "inline");
	SCALE_HS_INIT(&su, 1);
	/* Needs a left-margin for spacing. */
	bufcat_su(h, "margin-left", &su);
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
	return 1;
}

static int
mdoc_ms_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "symb");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_igndelim_pre(MDOC_ARGS)
{

	h->flags |= HTML_IGNDELIM;
	return 1;
}

static void
mdoc_pf_post(MDOC_ARGS)
{

	if ( ! (n->next == NULL || n->next->flags & MDOC_LINE))
		h->flags |= HTML_NOSPACE;
}

static int
mdoc_rs_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (n->type != ROFFT_BLOCK)
		return 1;

	if (n->prev && SEC_SEE_ALSO == n->sec)
		print_paragraph(h);

	PAIR_CLASS_INIT(&tag, "ref");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_no_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "none");
	print_otag(h, TAG_CODE, 1, &tag);
	return 1;
}

static int
mdoc_li_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "lit");
	print_otag(h, TAG_CODE, 1, &tag);
	return 1;
}

static int
mdoc_sy_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	PAIR_CLASS_INIT(&tag, "symb");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc_bt_pre(MDOC_ARGS)
{

	print_text(h, "is currently in beta test.");
	return 0;
}

static int
mdoc_ud_pre(MDOC_ARGS)
{

	print_text(h, "currently under development.");
	return 0;
}

static int
mdoc_lb_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if (SEC_LIBRARY == n->sec && MDOC_LINE & n->flags && n->prev)
		print_otag(h, TAG_BR, 0, NULL);

	PAIR_CLASS_INIT(&tag, "lib");
	print_otag(h, TAG_SPAN, 1, &tag);
	return 1;
}

static int
mdoc__x_pre(MDOC_ARGS)
{
	struct htmlpair	tag[2];
	enum htmltag	t;

	t = TAG_SPAN;

	switch (n->tok) {
	case MDOC__A:
		PAIR_CLASS_INIT(&tag[0], "ref-auth");
		if (n->prev && MDOC__A == n->prev->tok)
			if (NULL == n->next || MDOC__A != n->next->tok)
				print_text(h, "and");
		break;
	case MDOC__B:
		PAIR_CLASS_INIT(&tag[0], "ref-book");
		t = TAG_I;
		break;
	case MDOC__C:
		PAIR_CLASS_INIT(&tag[0], "ref-city");
		break;
	case MDOC__D:
		PAIR_CLASS_INIT(&tag[0], "ref-date");
		break;
	case MDOC__I:
		PAIR_CLASS_INIT(&tag[0], "ref-issue");
		t = TAG_I;
		break;
	case MDOC__J:
		PAIR_CLASS_INIT(&tag[0], "ref-jrnl");
		t = TAG_I;
		break;
	case MDOC__N:
		PAIR_CLASS_INIT(&tag[0], "ref-num");
		break;
	case MDOC__O:
		PAIR_CLASS_INIT(&tag[0], "ref-opt");
		break;
	case MDOC__P:
		PAIR_CLASS_INIT(&tag[0], "ref-page");
		break;
	case MDOC__Q:
		PAIR_CLASS_INIT(&tag[0], "ref-corp");
		break;
	case MDOC__R:
		PAIR_CLASS_INIT(&tag[0], "ref-rep");
		break;
	case MDOC__T:
		PAIR_CLASS_INIT(&tag[0], "ref-title");
		break;
	case MDOC__U:
		PAIR_CLASS_INIT(&tag[0], "link-ref");
		break;
	case MDOC__V:
		PAIR_CLASS_INIT(&tag[0], "ref-vol");
		break;
	default:
		abort();
	}

	if (MDOC__U != n->tok) {
		print_otag(h, t, 1, tag);
		return 1;
	}

	PAIR_HREF_INIT(&tag[1], n->child->string);
	print_otag(h, TAG_A, 2, tag);

	return 1;
}

static void
mdoc__x_post(MDOC_ARGS)
{

	if (MDOC__A == n->tok && n->next && MDOC__A == n->next->tok)
		if (NULL == n->next->next || MDOC__A != n->next->next->tok)
			if (NULL == n->prev || MDOC__A != n->prev->tok)
				return;

	/* TODO: %U */

	if (NULL == n->parent || MDOC_Rs != n->parent->tok)
		return;

	h->flags |= HTML_NOSPACE;
	print_text(h, n->next ? "," : ".");
}

static int
mdoc_bk_pre(MDOC_ARGS)
{

	switch (n->type) {
	case ROFFT_BLOCK:
		break;
	case ROFFT_HEAD:
		return 0;
	case ROFFT_BODY:
		if (n->parent->args || 0 == n->prev->nchild)
			h->flags |= HTML_PREKEEP;
		break;
	default:
		abort();
	}

	return 1;
}

static void
mdoc_bk_post(MDOC_ARGS)
{

	if (n->type == ROFFT_BODY)
		h->flags &= ~(HTML_KEEP | HTML_PREKEEP);
}

static int
mdoc_quote_pre(MDOC_ARGS)
{
	struct htmlpair	tag;

	if (n->type != ROFFT_BODY)
		return 1;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		print_text(h, n->nchild == 1 &&
		    n->child->tok == MDOC_Mt ?  "<" : "\\(la");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		print_text(h, "\\(lC");
		break;
	case MDOC_Bo:
	case MDOC_Bq:
		print_text(h, "\\(lB");
		break;
	case MDOC_Oo:
	case MDOC_Op:
		print_text(h, "\\(lB");
		h->flags |= HTML_NOSPACE;
		PAIR_CLASS_INIT(&tag, "opt");
		print_otag(h, TAG_SPAN, 1, &tag);
		break;
	case MDOC_En:
		if (NULL == n->norm->Es ||
		    NULL == n->norm->Es->child)
			return 1;
		print_text(h, n->norm->Es->child->string);
		break;
	case MDOC_Do:
	case MDOC_Dq:
	case MDOC_Qo:
	case MDOC_Qq:
		print_text(h, "\\(lq");
		break;
	case MDOC_Po:
	case MDOC_Pq:
		print_text(h, "(");
		break;
	case MDOC_Ql:
		print_text(h, "\\(oq");
		h->flags |= HTML_NOSPACE;
		PAIR_CLASS_INIT(&tag, "lit");
		print_otag(h, TAG_CODE, 1, &tag);
		break;
	case MDOC_So:
	case MDOC_Sq:
		print_text(h, "\\(oq");
		break;
	default:
		abort();
	}

	h->flags |= HTML_NOSPACE;
	return 1;
}

static void
mdoc_quote_post(MDOC_ARGS)
{

	if (n->type != ROFFT_BODY && n->type != ROFFT_ELEM)
		return;

	h->flags |= HTML_NOSPACE;

	switch (n->tok) {
	case MDOC_Ao:
	case MDOC_Aq:
		print_text(h, n->nchild == 1 &&
		    n->child->tok == MDOC_Mt ?  ">" : "\\(ra");
		break;
	case MDOC_Bro:
	case MDOC_Brq:
		print_text(h, "\\(rC");
		break;
	case MDOC_Oo:
	case MDOC_Op:
	case MDOC_Bo:
	case MDOC_Bq:
		print_text(h, "\\(rB");
		break;
	case MDOC_En:
		if (n->norm->Es == NULL ||
		    n->norm->Es->child == NULL ||
		    n->norm->Es->child->next == NULL)
			h->flags &= ~HTML_NOSPACE;
		else
			print_text(h, n->norm->Es->child->next->string);
		break;
	case MDOC_Qo:
	case MDOC_Qq:
	case MDOC_Do:
	case MDOC_Dq:
		print_text(h, "\\(rq");
		break;
	case MDOC_Po:
	case MDOC_Pq:
		print_text(h, ")");
		break;
	case MDOC_Ql:
	case MDOC_So:
	case MDOC_Sq:
		print_text(h, "\\(cq");
		break;
	default:
		abort();
	}
}

static int
mdoc_eo_pre(MDOC_ARGS)
{

	if (n->type != ROFFT_BODY)
		return 1;

	if (n->end == ENDBODY_NOT &&
	    n->parent->head->child == NULL &&
	    n->child != NULL &&
	    n->child->end != ENDBODY_NOT)
		print_text(h, "\\&");
	else if (n->end != ENDBODY_NOT ? n->child != NULL :
	    n->parent->head->child != NULL && (n->child != NULL ||
	    (n->parent->tail != NULL && n->parent->tail->child != NULL)))
		h->flags |= HTML_NOSPACE;
	return 1;
}

static void
mdoc_eo_post(MDOC_ARGS)
{
	int	 body, tail;

	if (n->type != ROFFT_BODY)
		return;

	if (n->end != ENDBODY_NOT) {
		h->flags &= ~HTML_NOSPACE;
		return;
	}

	body = n->child != NULL || n->parent->head->child != NULL;
	tail = n->parent->tail != NULL && n->parent->tail->child != NULL;

	if (body && tail)
		h->flags |= HTML_NOSPACE;
	else if ( ! tail)
		h->flags &= ~HTML_NOSPACE;
}
@


1.237
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.236 2015/09/26 00:54:04 schwarze Exp $ */
a301 1
		/* FALLTHROUGH */
a302 1
		/* FALLTHROUGH */
a303 1
		/* FALLTHROUGH */
a304 1
		/* FALLTHROUGH */
a824 1
			/* FALLTHROUGH */
a825 1
			/* FALLTHROUGH */
a826 1
			/* FALLTHROUGH */
a827 1
			/* FALLTHROUGH */
a830 1
			/* FALLTHROUGH */
a831 1
			/* FALLTHROUGH */
a832 1
			/* FALLTHROUGH */
a833 1
			/* FALLTHROUGH */
a851 1
			/* FALLTHROUGH */
a852 1
			/* FALLTHROUGH */
a853 1
			/* FALLTHROUGH */
a854 1
			/* FALLTHROUGH */
a861 1
			/* FALLTHROUGH */
a862 1
			/* FALLTHROUGH */
a863 1
			/* FALLTHROUGH */
a864 1
			/* FALLTHROUGH */
a955 1
		/* FALLTHROUGH */
a956 1
		/* FALLTHROUGH */
a957 1
		/* FALLTHROUGH */
a964 1
		/* FALLTHROUGH */
a965 1
		/* FALLTHROUGH */
a966 1
		/* FALLTHROUGH */
a967 1
		/* FALLTHROUGH */
a1148 1
			/* FALLTHROUGH */
a1149 1
			/* FALLTHROUGH */
a1150 1
			/* FALLTHROUGH */
a1151 1
			/* FALLTHROUGH */
a1152 1
			/* FALLTHROUGH */
a1153 1
			/* FALLTHROUGH */
a1154 1
			/* FALLTHROUGH */
a2033 1
		/* FALLTHROUGH */
a2038 1
		/* FALLTHROUGH */
a2042 1
		/* FALLTHROUGH */
a2046 1
		/* FALLTHROUGH */
a2059 1
		/* FALLTHROUGH */
a2060 1
		/* FALLTHROUGH */
a2061 1
		/* FALLTHROUGH */
a2065 1
		/* FALLTHROUGH */
a2075 1
		/* FALLTHROUGH */
a2097 1
		/* FALLTHROUGH */
a2102 1
		/* FALLTHROUGH */
a2106 1
		/* FALLTHROUGH */
a2107 1
		/* FALLTHROUGH */
a2108 1
		/* FALLTHROUGH */
a2120 1
		/* FALLTHROUGH */
a2121 1
		/* FALLTHROUGH */
a2122 1
		/* FALLTHROUGH */
a2126 1
		/* FALLTHROUGH */
a2130 1
		/* FALLTHROUGH */
a2131 1
		/* FALLTHROUGH */
@


1.236
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.235 2015/09/26 00:32:35 schwarze Exp $ */
d527 1
a527 1
	return(1);
d539 1
a539 1
		return(1);
d543 1
a543 1
		return(1);
d563 1
a563 1
	return(1);
d574 1
a574 1
		return(1);
d576 1
a576 1
		return(1);
d593 1
a593 1
	return(1);
d607 1
a607 1
		return(1);
d617 1
a617 1
	return(1);
d626 1
a626 1
		return(1);
d633 1
a633 1
	return(1);
d652 1
a652 1
		return(1);
d655 1
a655 1
		return(1);
d679 1
a679 1
	return(1);
d688 1
a688 1
		return(0);
d705 1
a705 1
		return(0);
d713 1
a713 1
	return(0);
d722 1
a722 1
	return(1);
d732 1
a732 1
	return(1);
d762 1
a762 1
		return(1);
d775 1
a775 1
	return(0);
d792 1
a792 1
		return(0);
d802 1
a802 1
	return(0);
d837 1
a837 1
			return(0);
d914 1
a914 1
	return(1);
d928 1
a928 1
		return(1);
d933 1
a933 1
			return(0);
d953 1
a953 1
		return(0);
d1005 1
a1005 1
	return(1);
d1045 1
a1045 1
	return(0);
d1055 1
a1055 1
	return(1);
d1065 1
a1065 1
		return(1);
d1084 1
a1084 1
	return(1);
d1106 1
a1106 1
	return(1);
d1118 1
a1118 1
		return(0);
d1132 1
a1132 1
		return(1);
d1155 1
a1155 1
		return(1);
d1206 1
a1206 1
	return(0);
d1216 1
a1216 1
	return(1);
d1226 1
a1226 1
	return(1);
d1237 1
a1237 1
		return(0);
d1242 1
a1242 1
		return(0);
d1253 1
a1253 1
	return(1);
d1264 1
a1264 1
	return(1);
d1274 1
a1274 1
	return(1);
d1284 1
a1284 1
	return(1);
d1294 1
a1294 1
	return(1);
d1307 1
a1307 1
		return(1);
d1325 1
a1325 1
	return(0);
d1340 1
a1340 1
		return(0);
d1347 1
a1347 1
		return(1);
d1393 1
a1393 1
	return(0);
d1403 1
a1403 1
		return(1);
d1407 1
a1407 1
		return(0);
d1411 1
a1411 1
	return(1);
d1422 1
a1422 1
	return(1);
d1512 1
a1512 1
	return(0);
d1529 1
a1529 1
	return(0);
d1536 1
a1536 1
	return(0);
d1544 1
a1544 1
	return(0);
d1573 1
a1573 1
	return(0);
d1583 1
a1583 1
		return(0);
d1598 1
a1598 1
	return(0);
d1622 1
a1622 1
	return(0);
d1635 1
a1635 1
		return(1);
d1638 1
a1638 1
		return(1);
d1642 1
a1642 1
		return(0);
d1649 1
a1649 1
	return(0);
d1716 1
a1716 1
	return(0);
d1726 1
a1726 1
	return(1);
d1782 1
a1782 1
	return(0);
d1792 1
a1792 1
	return(1);
d1802 1
a1802 1
	return(1);
d1812 1
a1812 1
		return(0);
d1814 1
a1814 1
		return(1);
d1836 1
a1836 1
	return(1);
d1846 1
a1846 1
	return(1);
d1854 1
a1854 1
	return(1);
d1871 1
a1871 1
		return(1);
d1878 1
a1878 1
	return(1);
d1888 1
a1888 1
	return(1);
d1898 1
a1898 1
	return(1);
d1908 1
a1908 1
	return(1);
d1916 1
a1916 1
	return(0);
d1924 1
a1924 1
	return(0);
d1937 1
a1937 1
	return(1);
d2003 1
a2003 1
		return(1);
d2009 1
a2009 1
	return(1);
d2038 1
a2038 1
		return(0);
d2047 1
a2047 1
	return(1);
d2064 1
a2064 1
		return(1);
d2094 1
a2094 1
			return(1);
d2127 1
a2127 1
	return(1);
d2199 1
a2199 1
		return(1);
d2210 1
a2210 1
	return(1);
@


1.235
log
@resolve code duplication and do style cleanup in mdoc_nm_pre(),
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.234 2015/09/26 00:22:07 schwarze Exp $ */
a1002 1
		/* NOTREACHED */
a1998 1
		/* NOTREACHED */
a2044 1
		/* NOTREACHED */
a2123 1
		/* NOTREACHED */
a2190 1
		/* NOTREACHED */
@


1.234
log
@Fix multiple aspects of SYNOPSIS .Nm formatting:
* Don't break lines before non-block .Nm elements.
* Use proper <b> markup for the heads of .Nm blocks.
* Make the width measurements work by doing them on the head children.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.233 2015/08/30 19:00:14 schwarze Exp $ */
a643 6
	case ROFFT_ELEM:
		PAIR_CLASS_INIT(&tag, "name");
		print_otag(h, TAG_B, 1, &tag);
		if (NULL == n->child && meta->name)
			print_text(h, meta->name);
		return(1);
d646 2
d650 1
a650 1
		if (NULL == n->child && meta->name)
d668 1
a668 1
	if (0 == len && meta->name)
@


1.233
log
@If an .Fo macro lacks its mandatory argument, don't die on an assertion.
Bug found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.232 2015/04/18 17:53:21 schwarze Exp $ */
a644 1
		synopsis_pre(h, n);
d652 2
d668 1
a668 1
	for (len = 0, n = n->child; n; n = n->next)
@


1.232
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.231 2015/04/18 16:06:40 schwarze Exp $ */
d1645 2
a1646 1
	/* XXX: we drop non-initial arguments as per groff. */
a1647 1
	assert(n->child);
a1648 1

@


1.231
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.230 2015/04/16 20:22:27 schwarze Exp $ */
a50 1
static	void		  print_mdoc(MDOC_ARGS);
a265 9
void
html_mdoc(void *arg, const struct roff_man *mdoc)
{

	print_mdoc(mdoc_meta(mdoc), mdoc_node(mdoc)->child,
	    (struct html *)arg);
	putchar('\n');
}

d324 2
a325 2
static void
print_mdoc(MDOC_ARGS)
d327 2
a329 1
	struct htmlpair	 tag;
d332 1
d338 1
a338 1
		print_mdoc_head(meta, n, h);
d345 3
a347 3
	mdoc_root_pre(meta, n, h);
	print_mdoc_nodelist(meta, n, h);
	mdoc_root_post(meta, n, h);
d349 1
@


1.230
log
@Restore the page headers and page footers that accidentally got lost
in rev. 1.225.  Regression reported by florian@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.229 2015/04/02 23:48:20 schwarze Exp $ */
d268 1
a268 1
html_mdoc(void *arg, const struct mdoc *mdoc)
@


1.229
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.228 2015/04/02 22:48:17 schwarze Exp $ */
d353 1
d355 1
a395 3
	case ROFFT_ROOT:
		child = mdoc_root_pre(meta, n, h);
		break;
a452 3
	case ROFFT_ROOT:
		mdoc_root_post(meta, n, h);
		break;
@


1.228
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.227 2015/04/02 21:36:50 schwarze Exp $ */
d38 1
a38 1
#define	MDOC_ARGS	  const struct mdoc_meta *meta, \
@


1.227
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.226 2015/03/03 21:11:34 schwarze Exp $ */
d39 1
a39 1
			  struct mdoc_node *n, \
d56 1
a56 1
				const struct mdoc_node *);
d296 1
a296 1
synopsis_pre(struct html *h, const struct mdoc_node *n)
d825 1
a825 1
	const struct mdoc_node *bl;
d1129 1
a1129 1
	struct mdoc_node	*nn;
d1315 1
a1315 1
	const struct mdoc_node	*nn;
@


1.226
log
@If an eqn(7) starts on a new input line, be sure to output whitespace
in front of it.  Issue found by tedu@@ in glOrtho(3).

There are also cases of excessive whitespace before and after
equations.  This patch neither fixes them nor makes them worse.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.225 2015/02/12 12:24:33 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d30 1
d394 1
a394 1
	case MDOC_ROOT:
d397 1
a397 1
	case MDOC_TEXT:
d414 1
a414 1
	case MDOC_EQN:
d419 1
a419 1
	case MDOC_TBL:
d454 1
a454 1
	case MDOC_ROOT:
d457 1
a457 1
	case MDOC_EQN:
d547 1
a547 1
	case MDOC_BLOCK:
d551 1
a551 1
	case MDOC_BODY:
d562 1
a562 1
	for (n = n->child; n && MDOC_TEXT == n->type; ) {
d582 1
a582 1
	if (MDOC_BLOCK == n->type) {
d586 1
a586 1
	} else if (MDOC_BODY == n->type)
d592 1
a592 1
	for (n = n->child; n && MDOC_TEXT == n->type; ) {
d624 1
a624 1
	     n->next->type == MDOC_TEXT ||
d636 1
a636 1
	if (MDOC_BODY != n->type)
d655 1
a655 1
	case MDOC_ELEM:
d662 1
a662 1
	case MDOC_HEAD:
d667 1
a667 1
	case MDOC_BODY:
d679 1
a679 1
		if (MDOC_TEXT == n->type)
d840 1
a840 1
	if (MDOC_HEAD == n->type) {
d875 1
a875 1
	} else if (MDOC_BODY == n->type) {
d939 1
a939 1
	if (MDOC_BODY == n->type) {
d945 1
a945 1
	if (MDOC_HEAD == n->type) {
d1039 1
a1039 1
		assert(MDOC_TEXT == n->type);
d1079 1
a1079 1
	if (MDOC_BLOCK != n->type)
d1132 1
a1132 1
	if (MDOC_HEAD == n->type)
d1135 1
a1135 1
	if (MDOC_BLOCK == n->type) {
d1138 1
a1138 1
			if (MDOC_BLOCK != nn->type)
d1357 1
a1357 1
	assert(MDOC_TEXT == n->type);
d1370 1
a1370 1
		assert(MDOC_TEXT == n->type);
d1404 1
a1404 1
		assert(MDOC_TEXT == n->type);
d1416 1
a1416 1
	if (MDOC_BLOCK == n->type) {
d1419 1
a1419 1
	} else if (MDOC_ELEM == n->type) {
d1421 1
a1421 1
	} else if (MDOC_HEAD == n->type)
d1600 1
a1600 1
	assert(MDOC_TEXT == n->type);
d1625 1
a1625 1
		assert(MDOC_TEXT == n->type);
d1646 1
a1646 1
	if (MDOC_BODY == n->type) {
d1651 1
a1651 1
	} else if (MDOC_BLOCK == n->type) {
d1672 1
a1672 1
	if (MDOC_BODY != n->type)
d1706 1
a1706 1
		assert(MDOC_TEXT == n->type);
d1728 1
a1728 1
		assert(MDOC_TEXT == n->type);
d1827 1
a1827 1
	if (MDOC_HEAD == n->type)
d1829 1
a1829 1
	else if (MDOC_BODY != n->type)
d1886 1
a1886 1
	if (MDOC_BLOCK != n->type)
d2052 1
a2052 1
	case MDOC_BLOCK:
d2054 1
a2054 1
	case MDOC_HEAD:
d2056 1
a2056 1
	case MDOC_BODY:
d2072 1
a2072 1
	if (MDOC_BODY == n->type)
d2081 1
a2081 1
	if (MDOC_BODY != n->type)
d2153 1
a2153 1
	if (n->type != MDOC_BODY && n->type != MDOC_ELEM)
d2218 1
a2218 1
	if (n->type != MDOC_BODY)
d2238 1
a2238 1
	if (n->type != MDOC_BODY)
@


1.225
log
@Delete the mdoc_node.pending pointer and the function calculating
it, make_pending(), which was the most difficult function of the
whole mdoc(7) parser.  After almost five years of maintaining this
hellhole, i just noticed the pointer isn't needed after all.

Blocks are always rewound in the reverse order they were opened;
that even holds for broken blocks.  Consequently, it is sufficient
to just mark broken blogs with the flag MDOC_BROKEN and breaking
blocks with the flag MDOC_ENDED.  When rewinding, instead of iterating
the pending pointers, just iterate from each broken block to its
parents, rewinding all that are MDOC_ENDED and stopping after
processing the first ancestor that it not MDOC_BROKEN.  For ENDBODY
markers, use the mdoc_node.body pointer in place of the former
mdoc_node.pending.

This also fixes an assertion failure found by jsg@@ with afl,
test case #467 (Bo Bl It Bd Bc It), where (surprise surprise)
the pending pointer got corrupted.

Improved functionality, minus one function, minus one struct field,
minus 50 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.224 2015/02/11 14:15:12 schwarze Exp $ */
d414 2
@


1.224
log
@do not access a NULL pointer if an .Eo block lacks a tail;
found by jsg@@ with afl, test case #16
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.223 2015/02/05 01:46:56 schwarze Exp $ */
d38 1
a38 1
			  const struct mdoc_node *n, \
d270 1
a270 1
	print_mdoc(mdoc_meta(mdoc), mdoc_node(mdoc),
d390 1
d461 1
a461 1
			n->pending->flags |= MDOC_ENDED;
d1126 1
a1126 1
	const struct mdoc_node	*nn;
@


1.223
log
@fix handling of empty .An macros
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.222 2015/02/05 00:14:13 schwarze Exp $ */
d2223 2
a2224 3
	    n->parent->head->child != NULL &&
	    (n->parent->body->child != NULL ||
	     n->parent->tail->child != NULL))
@


1.222
log
@Simplify by deleting the "lastline" member of struct mdoc_node.
Minus one struct member, minus 17 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.221 2015/02/01 23:10:35 schwarze Exp $ */
a1255 3
	if (n->child == NULL)
		return(0);

@


1.221
log
@fix .Eo/.Ec spacing
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.220 2015/01/30 22:04:44 schwarze Exp $ */
d439 3
a441 6
	if (HTML_KEEP & h->flags) {
		if (n->prev ? (n->prev->lastline != n->line) :
		    (n->parent && n->parent->line != n->line)) {
			h->flags &= ~HTML_KEEP;
			h->flags |= HTML_PREKEEP;
		}
@


1.220
log
@Have pity on the poor stack.
Replace tail recursion by iteration when walking the syntax trees.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.219 2015/01/23 14:21:01 schwarze Exp $ */
d84 2
d194 1
a194 1
	{mdoc_quote_pre, mdoc_quote_post}, /* Eo */
a2116 2
	case MDOC_Eo:
		break;
d2158 1
a2158 3
	if ( ! (n->tok == MDOC_En ||
	    (n->tok == MDOC_Eo && n->end == ENDBODY_SPACE)))
		h->flags |= HTML_NOSPACE;
d2182 5
a2186 4
		if (NULL != n->norm->Es &&
		    NULL != n->norm->Es->child &&
		    NULL != n->norm->Es->child->next) {
			h->flags |= HTML_NOSPACE;
a2187 3
		}
		break;
	case MDOC_Eo:
d2215 42
@


1.219
log
@Let .Aq/.Ao/.Ac print "<>" instead of the normal "\(la\(ra"
when the only child is .Mt, not when the preceding node is .An,
to improve robustness.  Triggered by a question from Svyatoslav
Mishyn <juef at openmailbox dot org> (Crux Linux).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.218 2014/12/23 13:48:57 schwarze Exp $ */
d374 4
a377 3
	print_mdoc_node(meta, n, h);
	if (n->next)
		print_mdoc_nodelist(meta, n->next, h);
@


1.218
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.217 2014/12/23 09:31:46 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
d2087 2
a2088 2
		print_text(h, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  "<" : "\\(la");
d2165 2
a2166 2
		print_text(h, n->parent->prev != NULL &&
		    n->parent->prev->tok == MDOC_An ?  ">" : "\\(ra");
@


1.217
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.216 2014/12/02 10:08:06 schwarze Exp $ */
d285 2
a286 1
	}
d1570 1
a1570 1
		if (NULL != (n = n->child))
d1573 3
@


1.216
log
@Fix the implementation and documentation of \c (continue text input line).
In particular, make it work in no-fill mode, too.
Reminded by Carsten dot Kunze at arcor dot de (Heirloom roff).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.215 2014/12/01 08:05:52 schwarze Exp $ */
d282 1
a282 1
	if ( ! a2roffsu(p, su, SCALE_MAX)) {
d1571 1
a1571 1
				SCALE_VS_INIT(&su, atoi(n->string));
@


1.215
log
@header cleanup:
* add missing forward declarations
* remove needless header inclusions
* some style unification
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.214 2014/11/30 05:29:00 schwarze Exp $ */
d1204 2
a1205 1
		if (nn->next && nn->next->line == nn->line)
@


1.214
log
@Multiple fixes with respect to .Pf:
* The first argument of .Pf is not parsed.
* Normal delimiter handling does not apply to the first argument of .Pf.
* Warn if nothing follows a prefix (inspired by groff_mdoc(7)).
* In that case, do not suppress spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.213 2014/11/27 22:27:56 schwarze Exp $ */
a28 1
#include "mandoc.h"
d30 1
a32 1
#include "mdoc.h"
@


1.213
log
@Multiple fixes with respect to .Eo:
1. Correctly parse stray .Ec without preceding .Eo,
avoiding an assertion violation found by jsg@@ with afl.
2. Correctly parse .Ec arguments when breaking another block.
3. Correct spacing around closing delimiter when breaking another block.
4. Sync some related formatting control from -Tascii to -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.212 2014/11/27 16:20:31 schwarze Exp $ */
d1872 2
a1873 1
	h->flags |= HTML_NOSPACE;
@


1.212
log
@Fix the obsolete .Db (toggle debug mode) macro to ignore its arguments
and not trigger an assertion when there is more than one argument;
the latter found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.211 2014/11/19 22:00:37 schwarze Exp $ */
d426 1
a426 1
		if (h->tblt) {
d430 2
a431 3

		assert(NULL == h->tblt);
		if (mdocs[n->tok].pre && ENDBODY_NOT == n->end)
d456 7
a462 2
		if (mdocs[n->tok].post && ENDBODY_NOT == n->end)
			(*mdocs[n->tok].post)(meta, n, h);
d2149 1
a2149 1
	if (MDOC_BODY != n->type)
d2152 2
a2153 1
	if (MDOC_En != n->tok)
@


1.211
log
@Let .Ao and .Aq render as "<>" after .An and as "\(la\(ra" elsewhere,
just like groff; minibug noticed by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.210 2014/11/17 06:44:58 schwarze Exp $ */
d186 1
a186 1
	{NULL, NULL}, /* Db */
@


1.210
log
@Multiple fixes with respect to in-line macros:
* .No selects the default font; relevant e.g. in .Bf blocks
* no need to force empty .Li elements
* closing delimiters as leading macro arguments do not suppress space
* opening delimiters at the end of a macro line do not suppress space
* correctly handle delimiter spacing in -Tman
As a side effect, these fixes let mandoc warn about empty .No macros
as requested by bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.209 2014/10/30 20:10:02 schwarze Exp $ */
d2078 2
a2079 1
		print_text(h, "\\(la");
d2155 2
a2156 1
		print_text(h, "\\(ra");
@


1.209
log
@Major bugsquashing with respect to -offset and -width:
1. Support specifying the .Bd and .Bl -offset as a macro default width;
while here, simplify the code handling the same for .Bl -width.
2. Correct handling of .Bl -offset arguments:  unlike .Bd -offset, the
arguments "left", "indent", and "indent-two" have no special meaning.
3. Fix the scaling of string length -offset and -width arguments in -Thtml.
Triggered by an incomplete documentation patch from bentley@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.208 2014/10/10 15:26:29 schwarze Exp $ */
d101 1
d196 1
a196 1
	{mdoc_igndelim_pre, NULL}, /* No */
d1888 10
@


1.208
log
@sync Copyright years after merge to OpenBSD; no code change
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.207 2014/09/27 11:17:19 kristaps Exp $ */
a58 1
static	void		  a2offs(const char *, struct roffsu *);
d283 1
a283 1
		su->unit = SCALE_BU;
a329 21
/*
 * Calculate the scaling unit passed in an `-offset' argument.  This
 * uses either a native scaling unit (e.g., 1i, 2m), one of a set of
 * predefined strings (indent, etc.), or the string length of the value.
 */
static void
a2offs(const char *p, struct roffsu *su)
{

	/* FIXME: "right"? */

	if (0 == strcmp(p, "left"))
		SCALE_HS_INIT(su, 0);
	else if (0 == strcmp(p, "indent"))
		SCALE_HS_INIT(su, INDENT);
	else if (0 == strcmp(p, "indent-two"))
		SCALE_HS_INIT(su, INDENT * 2);
	else if ( ! a2roffsu(p, su, SCALE_MAX))
		SCALE_HS_INIT(su, html_strlen(p));
}

d975 1
a975 1
		a2offs(n->norm->Bl.offs, &su);
d1141 11
a1151 3
	SCALE_HS_INIT(&su, 0);
	if (n->norm->Bd.offs)
		a2offs(n->norm->Bd.offs, &su);
@


1.207
log
@Don't pretend we have a separate XHTML and HTML mode any more.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.206 2014/09/27 10:56:18 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.206
log
@Remove <p> in favour of <div class="spacer">.
This is good because <p> is brittle: it can't appear within other block
macros.
This fixes a regression of the original HTML5 patch as noted by schwarze@@
on the tech@@ list, 14/8/2014.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.205 2014/09/27 09:26:01 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.205
log
@Remove last hard-coded width attribute.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.204 2014/09/27 09:20:03 kristaps Exp $ */
d317 1
a317 1
		print_otag(h, TAG_P, 0, NULL);
d321 1
a321 1
			print_otag(h, TAG_P, 0, NULL);
d1159 1
a1159 1
			print_otag(h, TAG_P, 0, NULL);
d1565 1
a1565 1
	print_otag(h, TAG_P, 0, NULL);
d1893 1
a1893 1
		print_otag(h, TAG_P, 0, NULL);
@


1.204
log
@HTML5-isation: remove more alignments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.203 2014/09/27 09:13:39 kristaps Exp $ */
a491 3
	PAIR_INIT(&tag, ATTR_WIDTH, "50%");
	print_otag(h, TAG_COL, 1, &tag);
	print_otag(h, TAG_COL, 1, &tag);
a528 4
	PAIR_INIT(&tag, ATTR_WIDTH, "30%");
	print_otag(h, TAG_COL, 1, &tag);
	print_otag(h, TAG_COL, 1, &tag);
	print_otag(h, TAG_COL, 1, &tag);
@


1.203
log
@Continue in HTML5-ing by kicking out some hard-coded alignments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.202 2014/09/27 09:05:57 kristaps Exp $ */
d487 1
a487 1
	struct htmlpair	 tag[2];
d490 5
a494 5
	PAIR_CLASS_INIT(&tag[0], "foot");
	t = print_otag(h, TAG_TABLE, 1, tag);
	PAIR_INIT(&tag[0], ATTR_WIDTH, "50%");
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
d500 2
a501 2
	PAIR_CLASS_INIT(&tag[0], "foot-date");
	print_otag(h, TAG_TD, 1, tag);
d505 2
a506 2
	PAIR_CLASS_INIT(&tag[0], "foot-os");
	print_otag(h, TAG_TD, 1, tag);
d514 1
a514 1
	struct htmlpair	 tag[2];
d530 6
a535 6
	PAIR_CLASS_INIT(&tag[0], "head");
	t = print_otag(h, TAG_TABLE, 1, tag);
	PAIR_INIT(&tag[0], ATTR_WIDTH, "30%");
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
	print_otag(h, TAG_COL, 1, tag);
d541 2
a542 2
	PAIR_CLASS_INIT(&tag[0], "head-ltitle");
	print_otag(h, TAG_TD, 1, tag);
d546 2
a547 3
	PAIR_CLASS_INIT(&tag[0], "head-vol");
	PAIR_INIT(&tag[1], ATTR_ALIGN, "center");
	print_otag(h, TAG_TD, 2, tag);
d551 2
a552 2
	PAIR_CLASS_INIT(&tag[0], "head-rtitle");
	print_otag(h, TAG_TD, 1, tag);
@


1.202
log
@Kick out "summary" attribute, which isn't HTML5.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.201 2014/09/27 09:02:19 kristaps Exp $ */
d506 1
a506 2
	PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
	print_otag(h, TAG_TD, 2, tag);
d553 1
a553 2
	PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
	print_otag(h, TAG_TD, 2, tag);
@


1.201
log
@First, add space for default styling for HTML5 (non-fragment) output.
This uses a <style /> block right before the <link /> for the stylesheet.
Use this to kick out hardcoded header and footer table widths.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.200 2014/09/17 19:55:59 schwarze Exp $ */
d490 2
a491 3
	PAIR_SUMMARY_INIT(&tag[0], "Document Footer");
	PAIR_CLASS_INIT(&tag[1], "foot");
	t = print_otag(h, TAG_TABLE, 2, tag);
d531 2
a532 3
	PAIR_SUMMARY_INIT(&tag[0], "Document Header");
	PAIR_CLASS_INIT(&tag[1], "head");
	t = print_otag(h, TAG_TABLE, 2, tag);
@


1.200
log
@implement .An -[no]split for -Thtml
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.199 2014/08/21 12:57:17 schwarze Exp $ */
d487 1
a487 1
	struct htmlpair	 tag[3];
d492 1
a492 2
	PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
	t = print_otag(h, TAG_TABLE, 3, tag);
d516 1
a516 1
	struct htmlpair	 tag[3];
d534 1
a534 2
	PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
	t = print_otag(h, TAG_TABLE, 3, tag);
@


1.199
log
@Right after .Fl, a middle delimiter triggers an empty scope,
just like a closing delimiter.  This didn't work in groff-1.15,
but it now works in groff-1.22.

After being closed by delimiters, .Nm scopes do not reopen.

Do not suppress white space after .Fl if the next node is a text node
on the same input line; that can happen for middle delimiters.

Fixing an issue reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.198 2014/08/14 00:31:43 schwarze Exp $ */
d573 2
a574 1
	if (MDOC_BLOCK == n->type) {
d578 3
a580 1
	} else if (MDOC_BODY == n->type)
d582 3
d1267 19
a1285 1
	/* TODO: -split and -nosplit (see termp_an_pre()). */
@


1.198
log
@Revert previous, as requested by kristaps@@.
The .Bf block can contain subblocks, so it has to render as an
element that can contain flow content.  But <em> cannot contain
flow content, only phrasing content.  Rendering .Em and .Bf differently
would by unfortunate, and closing out .Bf before subblocks and
re-opening it afterwards would merely complicate both the C code
of the program and the generated HTML code.  Besides, converting
.Em to semantic HTML markup would require some content to be put
into <em> and some into <i>, but we cannot automatically distinguish
which is which, so strictly speaking, we can't use semantic HTML
here but have to fall back to physical markup.  Wonders of HTML...
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.197 2014/08/13 15:25:22 schwarze Exp $ */
d643 4
a646 3
	if (n->child)
		h->flags |= HTML_NOSPACE;
	else if (n->next && n->next->line == n->line)
@


1.197
log
@Use <em> for .Em and .Bf -emphasis.

The vast majority of .Em in real-world manuals is stress emphasis,
for which <em> is the correct markup.  Admittedly, there are some
instances of .Em usage for alternate quality, for which <i> would
be a better match.  Most of these are technical terms that neither
allow semantic markup nor are keywords - for the latter, .Sy would
be preferable.  A typical example is that the shell breaks input into
.Em words .
Alternate voice or mood, which would also require <i>, is almost
absent from manuals.
We cannot satisfy both stress emphasis and alternate quality, so
pick the one that fits more often and looks less wrong when off.

Patch from Guy Harris <guy at alum dot mit dot edu>.
ok joerg@@ bentley@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.196 2014/08/10 23:54:41 schwarze Exp $ */
d1086 1
d1088 2
a1089 1
	print_otag(h, TAG_EM, 0, NULL);
d1825 3
a1827 1
	if (FONT_Sy == n->norm->Bf.font)
a1844 2
	if (FONT_Em == n->norm->Bf.font)
		print_otag(h, TAG_EM, 0, NULL);
@


1.196
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.195 2014/08/06 15:09:05 schwarze Exp $ */
a1085 1
	struct htmlpair	tag;
d1087 1
a1087 2
	PAIR_CLASS_INIT(&tag, "emph");
	print_otag(h, TAG_SPAN, 1, &tag);
d1823 1
a1823 3
	if (FONT_Em == n->norm->Bf.font)
		PAIR_CLASS_INIT(&tag[0], "emph");
	else if (FONT_Sy == n->norm->Bf.font)
d1841 2
@


1.195
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.194 2014/08/01 19:25:52 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
@


1.194
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.193 2014/07/30 00:19:16 schwarze Exp $ */
d383 3
a385 2
	bufcat_fmt(h, "%s(%s)", meta->title, meta->msec);

d529 5
a533 1
	mandoc_asprintf(&title, "%s(%s)", meta->title, meta->msec);
@


1.193
log
@Various improvements related to .Ex and .Rv:
* let .Nm fall back to the empty string, not to UNKNOWN
* never let .Rv copy an argument from .Nm
* avoid spurious \fR after empty .Nm in -Tman
* correct handling of .Ex and .Rv in -Tman
* correct the wording of the output for .Rv without arguments
* use non-breaking spaces in .Ex and .Rv output where required
* split MANDOCERR_NONAME into a warning for .Ex and an error for .Nm
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.192 2014/07/02 19:55:10 schwarze Exp $ */
d702 1
a702 1
	SCALE_HS_INIT(&su, (double)len);
d1568 1
a1568 1
		su.scale = 0;
@


1.192
log
@When .Sm is called without an argument, groff toggles the spacing mode,
so let us do the same for compatibility.  Using this feature is of
course not recommended except in manual page obfuscation contests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.191 2014/07/02 03:48:07 schwarze Exp $ */
d1072 1
a1072 1
		print_text(h, "utilities exit");
d1074 1
a1074 1
		print_text(h, "utility exits");
d1076 1
a1076 1
	print_text(h, "0 on success, and >0 if an error occurs.");
d1747 3
a1749 1
	print_text(h, "The");
d1751 4
a1754 3
	nchild = n->nchild;
	for (n = n->child; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
d1756 2
a1757 3
		t = print_otag(h, TAG_B, 1, &tag);
		print_text(h, n->string);
		print_tagq(h, t);
d1759 2
a1760 2
		h->flags |= HTML_NOSPACE;
		print_text(h, "()");
d1762 6
a1767 3
		if (nchild > 2 && n->next) {
			h->flags |= HTML_NOSPACE;
			print_text(h, ",");
d1770 4
a1773 3
		if (n->next && NULL == n->next->next)
			print_text(h, "and");
	}
d1775 4
a1778 4
	if (nchild > 1)
		print_text(h, "functions return");
	else
		print_text(h, "function returns");
d1780 2
a1781 2
	print_text(h, "the value 0 if successful; otherwise the "
	    "value -1 is returned and the global variable");
@


1.191
log
@Implement the obsolete macros .En .Es .Fr .Ot for backward compatibility,
since this is hardly more complicated than explicitly ignoring them
as we did in the past.  Of course, do not use them!
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.190 2014/04/23 16:08:33 schwarze Exp $ */
d1527 3
a1529 13
	assert(n->child && MDOC_TEXT == n->child->type);
	if (0 == strcmp("on", n->child->string)) {
		/*
		 * FIXME: no p->col to check.  Thus, if we have
		 *  .Bd -literal
		 *  .Sm off
		 *  1 2
		 *  .Sm on
		 *  3
		 *  .Ed
		 * the "3" is preceded by a space.
		 */
		h->flags &= ~HTML_NOSPACE;
d1531 1
a1531 1
	} else
d1534 3
@


1.190
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.189 2014/04/20 20:18:12 schwarze Exp $ */
a99 1
static	int		  mdoc_ll_pre(MDOC_ARGS);
d113 1
d160 1
a160 1
	{NULL, NULL}, /* Ot */
d230 1
a230 1
	{NULL, NULL}, /* Fr */
d240 2
a241 2
	{NULL, NULL}, /* Es */  /* TODO */
	{NULL, NULL}, /* En */  /* TODO */
d248 1
a248 1
	{mdoc_ll_pre, NULL}, /* ll */
d1548 1
a1548 1
mdoc_ll_pre(MDOC_ARGS)
d2088 6
d2137 2
a2138 1
	h->flags |= HTML_NOSPACE;
d2160 8
@


1.189
log
@fix unchecked snprintf(3) in page header printing:
the length of the title is unknown, and speed doesn't matter here,
so use asprintf/free rather than a static buffer
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.188 2014/04/20 16:46:05 schwarze Exp $ */
a517 1
	char		 b[BUFSIZ];
d520 1
a520 1
	char		*title;
d522 5
a526 7
	strlcpy(b, meta->vol, BUFSIZ);

	if (meta->arch) {
		strlcat(b, " (", BUFSIZ);
		strlcat(b, meta->arch, BUFSIZ);
		strlcat(b, ")", BUFSIZ);
	}
d551 1
a551 1
	print_text(h, b);
d561 1
d994 2
a995 2
	strlcpy(buf, "list ", BUFSIZ);
	strlcat(buf, lists[n->norm->Bl.type], BUFSIZ);
d1364 9
d1485 2
a1486 4
	if (sp) {
		strlcpy(nbuf, sp, BUFSIZ);
		print_text(h, nbuf);
	}
@


1.188
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.187 2014/03/30 19:47:48 schwarze Exp $ */
d32 1
d518 1
d521 1
a521 1
	char		 b[BUFSIZ], title[BUFSIZ];
d531 1
a531 1
	snprintf(title, BUFSIZ - 1, "%s(%s)", meta->title, meta->msec);
d562 2
@


1.187
log
@Implement the roff(7) .ll (line length) request.
Found by naddy@@ in the textproc/enchant(1) port.
Of course, do not use this in new manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.186 2013/12/24 20:45:27 schwarze Exp $ */
d56 1
a56 1
static	void	  	  synopsis_pre(struct html *, 
d130 2
a131 2
	{mdoc_ss_pre, NULL }, /* Ss */ 
	{mdoc_pp_pre, NULL}, /* Pp */ 
d139 1
a139 1
	{mdoc_ad_pre, NULL}, /* Ad */ 
d144 3
a146 3
	{mdoc_dv_pre, NULL}, /* Dv */ 
	{mdoc_er_pre, NULL}, /* Er */ 
	{mdoc_ev_pre, NULL}, /* Ev */ 
d148 2
a149 2
	{mdoc_fa_pre, NULL}, /* Fa */ 
	{mdoc_fd_pre, NULL}, /* Fd */ 
d151 4
a154 4
	{mdoc_fn_pre, NULL}, /* Fn */ 
	{mdoc_ft_pre, NULL}, /* Ft */ 
	{mdoc_ic_pre, NULL}, /* Ic */ 
	{mdoc_in_pre, NULL}, /* In */ 
d156 2
a157 2
	{mdoc_nd_pre, NULL}, /* Nd */ 
	{mdoc_nm_pre, NULL}, /* Nm */ 
d162 1
a162 1
	{NULL, NULL}, /* St */ 
d164 1
a164 1
	{mdoc_vt_pre, NULL}, /* Vt */ 
d182 1
a182 1
	{mdoc_bf_pre, NULL}, /* Bf */ 
d193 1
a193 1
	{mdoc_em_pre, NULL}, /* Em */ 
d214 1
a214 1
	{mdoc_sm_pre, NULL}, /* Sm */ 
d221 2
a222 2
	{mdoc_fo_pre, mdoc_fo_post}, /* Fo */ 
	{NULL, NULL}, /* Fc */ 
d232 7
a238 7
	{mdoc_pp_pre, NULL}, /* Lp */ 
	{mdoc_lk_pre, NULL}, /* Lk */ 
	{mdoc_mt_pre, NULL}, /* Mt */ 
	{mdoc_quote_pre, mdoc_quote_post}, /* Brq */ 
	{mdoc_quote_pre, mdoc_quote_post}, /* Bro */ 
	{NULL, NULL}, /* Brc */ 
	{mdoc__x_pre, mdoc__x_post}, /* %C */ 
d241 2
a242 2
	{mdoc_xx_pre, NULL}, /* Dx */ 
	{mdoc__x_pre, mdoc__x_post}, /* %Q */ 
d244 3
a246 3
	{mdoc_sp_pre, NULL}, /* sp */ 
	{mdoc__x_pre, mdoc__x_post}, /* %U */ 
	{NULL, NULL}, /* Ta */ 
d265 1
d271 1
a271 1
			(struct html *)arg);
a274 1

a289 1

d300 4
a303 4
	if (n->prev->tok == n->tok && 
			MDOC_Fo != n->tok && 
			MDOC_Ft != n->tok && 
			MDOC_Fn != n->tok) {
d309 1
a309 1
	case (MDOC_Fd):
d311 1
a311 1
	case (MDOC_Fn):
d313 1
a313 1
	case (MDOC_Fo):
d315 1
a315 1
	case (MDOC_In):
d317 1
a317 1
	case (MDOC_Vt):
d320 1
a320 1
	case (MDOC_Ft):
a331 1

a352 1

d369 1
a369 1
	} else 
a375 2

/* ARGSUSED */
a390 1

a399 1

d410 1
a410 1
	case (MDOC_ROOT):
d413 1
a413 1
	case (MDOC_TEXT):
d430 1
a430 1
	case (MDOC_EQN):
d433 1
a433 1
	case (MDOC_TBL):
d472 1
a472 1
	case (MDOC_ROOT):
d475 1
a475 1
	case (MDOC_EQN):
a483 1
/* ARGSUSED */
a513 2

/* ARGSUSED */
a562 2

/* ARGSUSED */
a592 1
/* ARGSUSED */
a622 2

/* ARGSUSED */
a645 2

/* ARGSUSED */
a661 1

d670 1
a670 1
	case (MDOC_ELEM):
d677 1
a677 1
	case (MDOC_HEAD):
d682 1
a682 1
	case (MDOC_BODY):
a710 2

/* ARGSUSED */
d722 3
a724 3
		buffmt_man(h, n->child->string, 
				n->child->next ? 
				n->child->next->string : NULL);
a744 2

/* ARGSUSED */
a753 2

/* ARGSUSED */
a763 2

/* ARGSUSED */
d772 1
a772 1
	case (MDOC_Bsx):
d775 1
a775 1
	case (MDOC_Dx):
d778 1
a778 1
	case (MDOC_Fx):
d781 1
a781 1
	case (MDOC_Nx):
d784 1
a784 1
	case (MDOC_Ox):
d787 1
a787 1
	case (MDOC_Ux):
a806 2

/* ARGSUSED */
a833 1
/* ARGSUSED */
d857 1
a857 1
		case(LIST_bullet):
d859 1
a859 1
		case(LIST_dash):
d861 1
a861 1
		case(LIST_item):
d863 1
a863 1
		case(LIST_hyphen):
d865 1
a865 1
		case(LIST_enum):
d867 1
a867 1
		case(LIST_diag):
d869 1
a869 1
		case(LIST_hang):
d871 1
a871 1
		case(LIST_inset):
d873 1
a873 1
		case(LIST_ohang):
d875 1
a875 1
		case(LIST_tag):
d885 1
a885 1
		case(LIST_column):
d892 1
a892 1
		case(LIST_bullet):
d894 1
a894 1
		case(LIST_hyphen):
d896 1
a896 1
		case(LIST_dash):
d898 1
a898 1
		case(LIST_enum):
d900 1
a900 1
		case(LIST_item):
d906 1
a906 1
		case(LIST_diag):
d908 1
a908 1
		case(LIST_hang):
d910 1
a910 1
		case(LIST_inset):
d912 1
a912 1
		case(LIST_ohang):
d914 1
a914 1
		case(LIST_tag):
d924 1
a924 1
		case(LIST_column):
d935 1
a935 1
		case (LIST_column):
a945 1
/* ARGSUSED */
d1004 1
a1004 1
	case(LIST_bullet):
d1006 1
a1006 1
	case(LIST_dash):
d1008 1
a1008 1
	case(LIST_hyphen):
d1010 1
a1010 1
	case(LIST_item):
d1013 1
a1013 1
	case(LIST_enum):
d1016 1
a1016 1
	case(LIST_diag):
d1018 1
a1018 1
	case(LIST_hang):
d1020 1
a1020 1
	case(LIST_inset):
d1022 1
a1022 1
	case(LIST_ohang):
d1024 1
a1024 1
	case(LIST_tag):
d1027 1
a1027 1
	case(LIST_column):
a1037 1
/* ARGSUSED */
d1074 1
a1074 1
       	print_text(h, "0 on success, and >0 if an error occurs.");
a1077 2

/* ARGSUSED */
a1087 2

/* ARGSUSED */
d1112 1
a1112 1
	} 
a1116 2

/* ARGSUSED */
a1138 2

/* ARGSUSED */
d1142 2
a1143 2
	struct htmlpair	 	 tag[2];
	int		 	 comp, sv;
d1168 1
a1168 1
	
d1173 2
a1174 2
	if (DISP_unfilled != n->norm->Bd.type && 
			DISP_literal != n->norm->Bd.type) {
d1197 1
a1197 1
		case (MDOC_Sm):
d1199 1
a1199 1
		case (MDOC_br):
d1201 1
a1201 1
		case (MDOC_sp):
d1203 1
a1203 1
		case (MDOC_Bl):
d1205 1
a1205 1
		case (MDOC_D1):
d1207 1
a1207 1
		case (MDOC_Dl):
d1209 1
a1209 1
		case (MDOC_Lp):
d1211 1
a1211 1
		case (MDOC_Pp):
a1229 2

/* ARGSUSED */
a1239 2

/* ARGSUSED */
a1249 2

/* ARGSUSED */
a1261 2

/* ARGSUSED */
a1272 2

/* ARGSUSED */
a1282 2

/* ARGSUSED */
a1292 2

/* ARGSUSED */
a1302 2

/* ARGSUSED */
a1333 2

/* ARGSUSED */
d1362 2
a1363 2
		strlcpy(buf, '<' == *n->string || '"' == *n->string ? 
				n->string + 1 : n->string, BUFSIZ);
d1370 1
a1370 1
		
d1376 1
a1376 1
		} 
a1392 2

/* ARGSUSED */
a1410 2

/* ARGSUSED */
a1421 2

/* ARGSUSED */
d1442 1
a1442 1
	
a1513 2

/* ARGSUSED */
d1520 1
a1520 1
		/* 
a1537 1
/* ARGSUSED */
a1544 1
/* ARGSUSED */
a1552 1
/* ARGSUSED */
a1579 1
/* ARGSUSED */
a1603 2

/* ARGSUSED */
d1624 1
a1624 1
	
a1627 2

/* ARGSUSED */
a1655 2

/* ARGSUSED */
a1667 2

/* ARGSUSED */
d1703 1
a1703 1
		} 
a1722 2

/* ARGSUSED */
a1732 2

/* ARGSUSED */
d1772 2
a1773 2
       	print_text(h, "the value 0 if successful; otherwise the value "
			"-1 is returned and the global variable");
d1779 1
a1779 1
       	print_text(h, "is set to indicate the error.");
a1782 2

/* ARGSUSED */
a1792 2

/* ARGSUSED */
d1796 1
a1796 1
	
a1802 2

/* ARGSUSED */
d1814 1
a1814 1
	if (FONT_Em == n->norm->Bf.font) 
d1816 1
a1816 1
	else if (FONT_Sy == n->norm->Bf.font) 
d1818 1
a1818 1
	else if (FONT_Li == n->norm->Bf.font) 
d1823 1
a1823 1
	/* 
d1825 1
a1825 1
	 * accept block children. 
a1836 2

/* ARGSUSED */
a1846 2

/* ARGSUSED */
a1854 2

/* ARGSUSED */
a1861 2

/* ARGSUSED */
a1877 3


/* ARGSUSED */
a1887 2

/* ARGSUSED */
a1897 2

/* ARGSUSED */
a1905 2

/* ARGSUSED */
a1913 2

/* ARGSUSED */
a1926 2

/* ARGSUSED */
d1936 1
a1936 1
	case(MDOC__A):
d1942 1
a1942 1
	case(MDOC__B):
d1946 1
a1946 1
	case(MDOC__C):
d1949 1
a1949 1
	case(MDOC__D):
d1952 1
a1952 1
	case(MDOC__I):
d1956 1
a1956 1
	case(MDOC__J):
d1960 1
a1960 1
	case(MDOC__N):
d1963 1
a1963 1
	case(MDOC__O):
d1966 1
a1966 1
	case(MDOC__P):
d1969 1
a1969 1
	case(MDOC__Q):
d1972 1
a1972 1
	case(MDOC__R):
d1975 1
a1975 1
	case(MDOC__T):
d1978 1
a1978 1
	case(MDOC__U):
d1981 1
a1981 1
	case(MDOC__V):
a1999 2

/* ARGSUSED */
a2017 2

/* ARGSUSED */
d2023 1
a2023 1
	case (MDOC_BLOCK):
d2025 1
a2025 1
	case (MDOC_HEAD):
d2027 1
a2027 1
	case (MDOC_BODY):
a2038 2

/* ARGSUSED */
a2046 2

/* ARGSUSED */
d2056 1
a2056 1
	case (MDOC_Ao):
d2058 1
a2058 1
	case (MDOC_Aq):
d2061 1
a2061 1
	case (MDOC_Bro):
d2063 1
a2063 1
	case (MDOC_Brq):
d2066 1
a2066 1
	case (MDOC_Bo):
d2068 1
a2068 1
	case (MDOC_Bq):
d2071 1
a2071 1
	case (MDOC_Oo):
d2073 1
a2073 1
	case (MDOC_Op):
d2079 1
a2079 1
	case (MDOC_Eo):
d2081 1
a2081 1
	case (MDOC_Do):
d2083 1
a2083 1
	case (MDOC_Dq):
d2085 1
a2085 1
	case (MDOC_Qo):
d2087 1
a2087 1
	case (MDOC_Qq):
d2090 1
a2090 1
	case (MDOC_Po):
d2092 1
a2092 1
	case (MDOC_Pq):
d2095 1
a2095 1
	case (MDOC_Ql):
d2101 1
a2101 1
	case (MDOC_So):
d2103 1
a2103 1
	case (MDOC_Sq):
a2114 2

/* ARGSUSED */
d2125 1
a2125 1
	case (MDOC_Ao):
d2127 1
a2127 1
	case (MDOC_Aq):
d2130 1
a2130 1
	case (MDOC_Bro):
d2132 1
a2132 1
	case (MDOC_Brq):
d2135 1
a2135 1
	case (MDOC_Oo):
d2137 1
a2137 1
	case (MDOC_Op):
d2139 1
a2139 1
	case (MDOC_Bo):
d2141 1
a2141 1
	case (MDOC_Bq):
d2144 1
a2144 1
	case (MDOC_Eo):
d2146 1
a2146 1
	case (MDOC_Qo):
d2148 1
a2148 1
	case (MDOC_Qq):
d2150 1
a2150 1
	case (MDOC_Do):
d2152 1
a2152 1
	case (MDOC_Dq):
d2155 1
a2155 1
	case (MDOC_Po):
d2157 1
a2157 1
	case (MDOC_Pq):
d2160 1
a2160 1
	case (MDOC_Ql):
d2162 1
a2162 1
	case (MDOC_So):
d2164 1
a2164 1
	case (MDOC_Sq):
a2171 2


@


1.186
log
@It turns out SYNOPSIS mode does not imply .Bk in general,
but only within .Nm blocks.  Simplify the code accordingly.

Triggered by research done by Franco Fichtner.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.185 2013/12/24 19:11:46 schwarze Exp $ */
d4 1
d99 1
d247 1
d1605 8
a1617 1

@


1.185
log
@When deciding whether two consecutive macros are on the same input line,
we have to compare the line where the first one *ends* (not where it begins)
to the line where the second one starts.
This fixes the bug that .Bk allowed output line breaks right after block
macros spanning more than one input line, even when the next macro follows
on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.184 2012/11/17 00:26:33 schwarze Exp $ */
d462 1
a462 1
	if (HTML_KEEP & h->flags || MDOC_SYNPRETTY & n->flags) {
@


1.184
log
@Cleanup naming of local variables to make the code easier on the eye:
Settle for "struct man *man", "struct mdoc *mdoc", "struct meta *meta"
and avoid the confusing "*m" which was sometimes this, sometimes that.
No functional change.

ok kristaps@@ some time ago
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.183 2012/08/12 10:04:09 schwarze Exp $ */
d462 3
a464 2
	if (HTML_KEEP & h->flags) {
		if (n->prev && n->prev->line != n->line) {
a466 5
		} else if (NULL == n->prev) {
			if (n->parent && n->parent->line != n->line) {
				h->flags &= ~HTML_KEEP;
				h->flags |= HTML_PREKEEP;
			}
@


1.183
log
@.Sq should use curly right quotes in HTML output to match its curly
left quotes.

Also, properly reinitialize the styles attribute string buffer for
each column in a table so that the attributes don't accumulate.

Patch from Matthew@@ Dempsky, tweaked by me; OpenBSD rev. 1.66.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.182 2011/11/03 20:37:00 schwarze Exp $ */
d38 1
a38 1
#define	MDOC_ARGS	  const struct mdoc_meta *m, \
d263 1
a263 1
html_mdoc(void *arg, const struct mdoc *m)
d266 2
a267 1
	print_mdoc(mdoc_meta(m), mdoc_node(m), (struct html *)arg);
d365 1
a365 1
		print_mdoc_head(m, n, h);
d372 1
a372 1
	print_mdoc_nodelist(m, n, h);
d384 1
a384 1
	bufcat_fmt(h, "%s(%s)", m->title, m->msec);
d386 2
a387 2
	if (m->arch)
		bufcat_fmt(h, " (%s)", m->arch);
d398 1
a398 1
	print_mdoc_node(m, n, h);
d400 1
a400 1
		print_mdoc_nodelist(m, n->next, h);
d415 1
a415 1
		child = mdoc_root_pre(m, n, h);
d458 1
a458 1
			child = (*mdocs[n->tok].pre)(m, n, h);
d475 1
a475 1
		print_mdoc_nodelist(m, n->child, h);
d481 1
a481 1
		mdoc_root_post(m, n, h);
d487 1
a487 1
			(*mdocs[n->tok].post)(m, n, h);
d513 1
a513 1
	print_text(h, m->date);
d519 1
a519 1
	print_text(h, m->os);
d532 1
a532 1
	strlcpy(b, m->vol, BUFSIZ);
d534 1
a534 1
	if (m->arch) {
d536 1
a536 1
		strlcat(b, m->arch, BUFSIZ);
d540 1
a540 1
	snprintf(title, BUFSIZ - 1, "%s(%s)", m->title, m->msec);
d693 2
a694 2
		if (NULL == n->child && m->name)
			print_text(h, m->name);
d698 2
a699 2
		if (NULL == n->child && m->name)
			print_text(h, m->name);
d716 2
a717 2
	if (0 == len && m->name)
		len = html_strlen(m->name);
d1229 1
a1229 1
		print_mdoc_node(m, nn, h);
@


1.182
log
@Correct .Eo spacing:
no space between the delimiters and the enclosed text.
The mdoc_html.c part was added by kristaps; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.181 2011/10/16 12:20:34 schwarze Exp $ */
a983 2
	bufinit(h);

d1002 1
d1016 1
d2276 1
a2276 1
		print_text(h, "\\(aq");
@


1.181
log
@Remove a bunch of useless assignments,
and assert that print_bvspace cannot be called on NULL pointers.
No change in behaviour, none of these were bugs,
but the code becomes easier to understand.
Based on a clang report posted by joerg@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.180 2011/10/09 22:10:53 schwarze Exp $ */
d192 1
a192 1
	{NULL, NULL}, /* Eo */
d2188 2
d2255 2
@


1.180
log
@Always print <table> column widths in -T[x]html;
if desired, they can be overridden in the CSS file.
Suggested by kristaps@@, and i always like to simplify code.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.179 2011/10/05 21:35:17 kristaps Exp $ */
d506 1
a506 1
	t = print_otag(h, TAG_TBODY, 0, NULL);
@


1.179
log
@Add the -Ofragment option to -T[]x]html.  This accomodates for embedding
manual output in existing HTML or XHTML documents, e.g., when invoking
mandoc from an SSI or CGI.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.178 2011/08/26 09:03:17 kristaps Exp $ */
d500 5
a504 8
	if (NULL == h->style) {
		PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 3, tag);
		PAIR_INIT(&tag[0], ATTR_WIDTH, "50%");
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
	} else
		t = print_otag(h, TAG_TABLE, 2, tag);
a511 1

d516 2
a517 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

d543 6
a548 9
	if (NULL == h->style) {
		PAIR_INIT(&tag[2], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 3, tag);
		PAIR_INIT(&tag[0], ATTR_WIDTH, "30%");
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
		print_otag(h, TAG_COL, 1, tag);
	} else
		t = print_otag(h, TAG_TABLE, 2, tag);
a555 1

d560 2
a561 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "center");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

d566 2
a567 6
	if (NULL == h->style) {
		PAIR_INIT(&tag[1], ATTR_ALIGN, "right");
		print_otag(h, TAG_TD, 2, tag);
	} else 
		print_otag(h, TAG_TD, 1, tag);

@


1.178
log
@Make sure that `Ql' literalises its arguments in -T[x]html.  Found when
doing manpages.bsd.lv stuff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.177 2011/08/18 09:16:01 kristaps Exp $ */
a264 9
	struct html 	*h;
	struct tag	*t;

	h = (struct html *)arg;

	print_gen_decls(h);
	t = print_otag(h, TAG_HTML, 0, NULL);
	print_mdoc(mdoc_meta(m), mdoc_node(m), h);
	print_tagq(h, t);
d266 2
a267 1
	printf("\n");
d355 4
a358 1
	struct tag	*t;
d360 10
a369 3
	t = print_otag(h, TAG_HEAD, 0, NULL);
	print_mdoc_head(m, n, h);
	print_tagq(h, t);
a370 1
	t = print_otag(h, TAG_BODY, 0, NULL);
@


1.177
log
@Align `-offset indent' and `D1' by forcing BLOCKQUOTE to have a 5ex
margin.  This is dubious: the HTML4 spec specifically says that
BLOCKQUOTE shouldn't be abused for indentation, which is exactly what we
do.  However, `D1' needs indentation and it's the only way to force text
browsers to do so.  Alternatives?

Also remove the unused HALFINDENT defines while here.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.176 2011/08/18 09:02:22 kristaps Exp $ */
d2222 5
a2226 1
		/* FALLTHROUGH */
@


1.176
log
@Have `Li' be correctly monospaced in -T[x]html.  Also make sure that
`Li' prints as a CODE tag and the style-sheet has the `lit' class apply
to multiple tag types.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.175 2011/08/10 14:07:23 kristaps Exp $ */
a36 1
#define	HALFINDENT	 3
d355 2
a356 4
	else if ( ! a2roffsu(p, su, SCALE_MAX)) {
		su->unit = SCALE_BU;
		su->scale = html_strlen(p);
	}
@


1.175
log
@Allow `Sx' and `Ss' to have child nodes.  Fixes manuals in NetBSD.
Originally pointed out by joerg@@ then again by Thomas Klausner by way of
Nicolas Joy.  Note: don't use these constructions as you can't link to
the sections with `Sx'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.174 2011/07/23 22:57:13 kristaps Exp $ */
d1997 1
a1997 1
	print_otag(h, TAG_SPAN, 1, &tag);
@


1.174
log
@Flip on equation printing for -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.173 2011/07/21 11:34:53 kristaps Exp $ */
d611 2
a612 1
	for (n = n->child; n; n = n->next) {
d614 1
a614 1
		if (n->next)
d618 6
a623 2
	PAIR_ID_INIT(&tag, h->buf);
	print_otag(h, TAG_H1, 1, &tag);
a626 1

d642 2
a643 1
	for (n = n->child; n; n = n->next) {
d645 1
a645 1
		if (n->next)
d649 6
a654 2
	PAIR_ID_INIT(&tag, h->buf);
	print_otag(h, TAG_H2, 1, &tag);
d1183 2
a1184 1
	for (n = n->child; n; n = n->next) {
d1186 1
a1186 1
		if (n->next)
@


1.173
log
@Flip eqn into using parsed nodes.  I've temporarily disabled printing
these in the front-ends except for -Ttree, which will display the parsed
tree.

While here, fix that quoted strings aren't scanned for replacement parts.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.172 2011/07/04 09:42:38 kristaps Exp $ */
a409 1
	struct htmlpair	 tag;
d436 1
a436 3
		PAIR_CLASS_INIT(&tag, "eqn");
		/*print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, n->eqn->data);*/
@


1.172
log
@The bufcat() function in -T[x]html was eating one byte off the end of its
concatenated string.  This for some reason hasn't been found before now... ?
Anyway, fixed, and make the IDs created again be correctly prefixed by a
letter as per the HTML spec.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.171 2011/06/29 15:38:09 kristaps Exp $ */
d438 2
a439 2
		print_otag(h, TAG_SPAN, 1, &tag);
		print_text(h, n->eqn->data);
@


1.171
log
@First fix how `sp 1' doesn't imply `1v' (it now does) and that 1
followed by non-digits, e.g. `1g', really means `1'.  Next, fix some
spacing issues where `sp' was invoked in -man after sections or
subsections.  Make sure this behaviour is mirrored in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.170 2011/06/16 22:21:28 kristaps Exp $ */
d613 1
d640 1
@


1.170
log
@Have -T[x]html print out the link target for `Lk' if no link title is
provided.  From a patch by Tim van der Molen.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.169 2011/05/17 11:38:18 kristaps Exp $ */
d1636 3
a1638 2
		if (n->child)
			a2roffsu(n->child->string, &su, SCALE_VS);
@


1.169
log
@Clean-up fallout: differentiate ID's and HREF's (where to put the `#').
Make buffmt functions internally bufinit(), too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.168 2011/05/17 11:34:31 kristaps Exp $ */
d1669 4
a1672 2
	for (n = n->next; n; n = n->next) {
		assert(MDOC_TEXT == n->type);
a1673 1
	}
@


1.168
log
@Cleanups in -T[x]html: make html_idcat() use the buffer and be called
bufcat_id(), then collapse it into a little function without so much
crap.  Next, make bufinit() only be called when we really need to do so,
and not simply before pre/post calls.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.167 2011/05/17 11:19:45 kristaps Exp $ */
d1174 1
@


1.167
log
@Clean-ups in -T[x]html: inline print_num(), as it was just a single
conditional; same for print_xmltype() and print_doctype(), same reason;
make bufncat() be static, as it was only being called from html.c;
have bufcat() simply call through to strlcat().  Finally, assert()
whenever we truncate.

Also rename buffmt() -> bufcat_fmt() to differentiate from buffmt_man et
al., which do not concatenate.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.166 2011/05/14 16:28:23 kristaps Exp $ */
d387 2
a388 5
	if (m->arch) {
		bufcat(h, " (");
		bufcat(h, m->arch);
		bufcat(h, ")");
	}
a414 1
	bufinit(h);
a482 1
	bufinit(h);
a603 1
	char		 buf[BUFSIZ];
d612 1
a612 1
	buf[0] = '\0';
d614 1
a614 1
		html_idcat(buf, n->string, BUFSIZ);
d616 1
a616 1
			html_idcat(buf, " ", BUFSIZ);
d619 1
a619 1
	PAIR_ID_INIT(&tag, buf);
a629 1
	char		 buf[BUFSIZ];
d638 1
a638 1
	buf[0] = '\0';
d640 1
a640 1
		html_idcat(buf, n->string, BUFSIZ);
d642 1
a642 1
			html_idcat(buf, " ", BUFSIZ);
d645 1
a645 1
	PAIR_ID_INIT(&tag, buf);
d733 1
d896 2
d998 2
a1018 1
			bufinit(h);
d1147 1
a1171 1
	char		 buf[BUFSIZ];
d1173 1
a1173 1
	strlcpy(buf, "#", BUFSIZ);
d1175 1
a1175 1
		html_idcat(buf, n->string, BUFSIZ);
d1177 1
a1177 1
			html_idcat(buf, " ", BUFSIZ);
d1181 1
a1181 1
	PAIR_HREF_INIT(&tag[1], buf);
d1219 2
a1220 1

a1438 1
		bufinit(h);
d1560 1
a1561 1
	PAIR_CLASS_INIT(&tag[0], "farg");
d1640 1
a1776 1
		bufinit(h);
a1778 1

d1917 1
@


1.166
log
@Give -Thtml and -Txhtml the gift of recognising escapes when calculating
widths (e.g., `Bl -tag -width "\s[blahblah]bar").  This has long since
been done for -Tascii but escaped noticed with -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.165 2011/04/23 09:10:50 kristaps Exp $ */
d385 1
a385 1
	buffmt(h, "%s(%s)", m->title, m->msec);
@


1.165
log
@Revert last change: this screwed up displaying in other pages (didn't
test it enough).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.164 2011/04/23 08:56:29 kristaps Exp $ */
d291 1
a291 1
		su->scale = (int)strlen(p);
d358 1
a358 1
		su->scale = (int)strlen(p);
d706 1
a706 1
	size_t		 len;
d734 1
a734 1
			len += strlen(n->string);
d737 1
a737 1
		len = strlen(m->name);
@


1.164
log
@Make the `Nm' -Thtml attribute be min-width instead of width.  This is a
quick fix for, say, rc.d(8) in OpenBSD, which has nested macros on the
`Nm' SYNOPSIS line that were skipped over by the length calculator.  This
should [maybe?] be a recursive length check, but still it'd need to be
a min-width to accomodate for (say) `Qq' and the like printing excess
characters post-length-calculation.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.163 2011/04/04 22:38:26 kristaps Exp $ */
d740 1
a740 1
	bufcat_su(h, "min-width", &su);
@


1.163
log
@Suppress a space following the "(" for -T[x]html `Fn'.  Found by random
perusal of online manuals.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.162 2011/04/04 16:48:18 kristaps Exp $ */
d740 1
a740 1
	bufcat_su(h, "width", &su);
@


1.162
log
@Have `Fd' in -T[x]html generate an "include" link if it detects one
being used.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.161 2011/04/04 16:44:56 kristaps Exp $ */
d1561 1
@


1.161
log
@Fix a bug that slip in: PAIR_XXXX macros expanded to run the increment
twice.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.160 2011/04/04 16:15:58 kristaps Exp $ */
d1408 5
a1412 1
	struct htmlpair	 tag;
d1416 47
a1462 3
	PAIR_CLASS_INIT(&tag, "macro");
	print_otag(h, TAG_B, 1, &tag);
	return(1);
@


1.160
log
@Fully fix the `Rv' and `Ex' handlers for -T[x]html and -Tascii.  This
includes an unreported bug where `Ex' wasn't properly adding a newline.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.159 2011/04/04 16:01:47 kristaps Exp $ */
d1736 2
a1737 1
			PAIR_HREF_INIT(&tag[i++], h->buf);
@


1.159
log
@Make `Rv' do the Right Thing regarding commas and "and" when listing its
output.  This also makes it easier to read.  While here, remove
superfluous assignment to local variables for this and `Mt'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.158 2011/04/04 15:45:12 kristaps Exp $ */
d1089 3
a1091 3
	const struct mdoc_node	*nn;
	struct tag		*t;
	struct htmlpair		 tag;
d1099 5
a1103 1
	for (nn = n->child; nn; nn = nn->next) {
d1105 1
a1105 1
		print_text(h, nn->string);
d1108 4
a1111 1
		h->flags |= HTML_NOSPACE;
d1113 2
a1114 6
		if (nn->next && NULL == nn->next->next)
			print_text(h, ", and");
		else if (nn->next)
			print_text(h, ",");
		else
			h->flags &= ~HTML_NOSPACE;
d1117 1
a1117 1
	if (n->child && n->child->next)
d1781 2
a1787 1
		PAIR_CLASS_INIT(&tag, "fname");
d1792 1
@


1.158
log
@Fix possible segfaults in `Lk' -T[x]html handler, which made some
assumptions about its children.  Also remove superfluous reassignment to
local variable.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.157 2011/04/04 15:41:05 kristaps Exp $ */
d1631 2
a1632 3
	struct htmlpair	 	 tag[2];
	struct tag		*t;
	const struct mdoc_node	*nn;
d1636 3
a1638 1
	for (nn = n->child; nn; nn = nn->next) {
d1641 2
a1642 1
		bufcat(h, nn->string);
d1645 1
a1645 1
		print_text(h, nn->string);
d1771 3
a1773 3
	const struct mdoc_node	*nn;
	struct htmlpair		 tag;
	struct tag		*t;
d1780 3
a1782 1
	for (nn = n->child; nn; nn = nn->next) {
d1784 1
d1786 1
a1786 1
		print_text(h, nn->string);
d1788 7
d1796 2
a1797 7
		h->flags |= HTML_NOSPACE;
		if (nn->next && NULL == nn->next->next)
			print_text(h, "(), and");
		else if (nn->next)
			print_text(h, "(),");
		else
			print_text(h, "()");
d1800 1
a1800 1
	if (n->child && n->child->next)
@


1.157
log
@Clean-up in -T[x]html: remove some unnecessary assignments to local
variables.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.156 2011/04/04 15:33:03 kristaps Exp $ */
d1606 4
a1609 2
	const struct mdoc_node	*nn;
	struct htmlpair		 tag[2];
d1611 1
a1611 1
	nn = n->child;
d1614 2
a1615 1
	PAIR_HREF_INIT(&tag[1], nn->string);
d1618 4
a1621 5
	if (NULL == nn || NULL == nn->next) 
		return(1);

	for (nn = nn->next; nn; nn = nn->next) 
		print_text(h, nn->string);
@


1.156
log
@Clean up handling of `In' for -T[x]html such that it only links to the
first argument.  groff of course doesn't do links, but it will uglify
subsequent arguments in the list (we warn about >1, anyway).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.155 2011/03/22 14:05:45 kristaps Exp $ */
d754 1
a754 2
	struct htmlpair	 	 tag[2];
	const struct mdoc_node	*nn;
d770 2
a771 2
	nn = n->child;
	print_text(h, nn->string);
d773 1
a773 1
	if (NULL == (nn = nn->next))
d779 1
a779 1
	print_text(h, nn->string);
d1170 2
a1171 3
	struct htmlpair		 tag[2];
	const struct mdoc_node	*nn;
	char			 buf[BUFSIZ];
d1174 3
a1176 3
	for (nn = n->child; nn; nn = nn->next) {
		html_idcat(buf, nn->string, BUFSIZ);
		if (nn->next)
d1452 5
a1456 6
	struct tag		*t;
	struct htmlpair	 	 tag[2];
	const struct mdoc_node	*nn;
	char			 nbuf[BUFSIZ];
	const char		*sp, *ep;
	int			 sz, i;
d1458 1
d1516 1
a1516 1
	for (nn = n->child->next; nn; nn = nn->next) {
d1521 1
a1521 1
		print_text(h, nn->string);
d1523 1
a1523 1
		if (nn->next) {
d1532 1
a1532 1
	if (MDOC_SYNPRETTY & n->flags) {
@


1.155
log
@Move mandoc_isdelim() back into libmdoc.h.  This fixes an unreported
error where (1) -man pages were punctuating delimiters (e.g., `.B a ;')
and where (2) standalone punctuation in -mdoc or -man (e.g., ";" on its
own line) would also be punctuated.  This introduces a small amount of
complexity of mdoc_{html,term}.c must manage their own spacing with
running print_word() or print_text().  The check for delimiting now
happens in mdoc_macro.c's dword().
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.154 2011/03/07 01:35:51 schwarze Exp $ */
d1699 3
a1701 4
	const struct mdoc_node	*nn;
	struct tag		*t;
	struct htmlpair		 tag[2];
	int			 i;
d1708 7
d1721 3
a1723 1
	for (nn = n->child; nn; nn = nn->next) {
d1725 2
d1728 1
a1728 1
		bufinit(h);
d1730 4
a1733 4
			buffmt_includes(h, nn->string);
			PAIR_HREF_INIT(&tag[i], h->buf);
			i++;
		}
d1735 1
a1735 1
		print_mdoc_node(m, nn, h);
d1737 2
d1744 5
@


1.154
log
@Clean up date handling,
as a first step to get rid of the frequent petty warnings in this area:
 - always store dates as strings, not as seconds since the Epoch
 - for input, try the three most common formats everywhere
 - for unrecognized format, just pass the date though verbatim
 - when there is no date at all, still use the current date
Originally triggered by a one-line patch from Tim van der Molen,
<tbvdm at xs4all dot nl>, which is included here.
Feedback and OK on manual parts from jmc@@.
"please check this in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.153 2011/02/09 09:52:47 kristaps Exp $ */
d434 2
d437 2
d1388 2
a1389 1
		if (nn->next)
d1391 1
d1394 2
a1395 1
	if (n->child && n->next && n->next->tok == MDOC_Fa)
d1397 1
d1525 2
a1526 1
		if (nn->next)
d1528 1
d1531 1
d1533 3
a1535 1
	if (MDOC_SYNPRETTY & n->flags)
d1537 1
d1688 1
d1690 1
d2051 1
@


1.153
log
@EQN blocks are now printed in all modes.  This is simply a printing of
the concatenated string (in -T[x]html, it gets a SPAN, too).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.152 2011/02/06 23:02:31 schwarze Exp $ */
a502 3
	char		 b[DATESIZ];

	time2a(m->date, b, DATESIZ);
d522 1
a522 1
	print_text(h, b);
@


1.152
log
@Fix a regression caused by mdoc_term.c 1.214 / mdoc_html.c 1.148:
Inside .Bk or inside the SYNOPSIS, Unix variant macros cleared
the keep flag.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.151 2011/02/06 21:44:36 kristaps Exp $ */
d413 1
d437 4
a440 1
		return;
d488 2
@


1.151
log
@Add initial libmdoc and libman top-most machinery for accepting TBL
directives.  For now this will just ignore them (except for -Ttree,
which just notes that an EQN's been accepted).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.150 2011/02/02 21:40:45 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d809 1
d839 1
d842 1
a842 1
		h->flags &= ~HTML_KEEP;
@


1.150
log
@If `Ns' is specified on its own line, it should be ignored.  This is
shitty groff behaviour.  Do the same, but raise a warning to this
effect.  This from a TODO noted by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.149 2011/01/29 14:49:44 kristaps Exp $ */
d435 2
@


1.149
log
@When in a <PRE>, don't print out the <BR> before lines that have leading
whitespace.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.148 2011/01/25 16:20:24 kristaps Exp $ */
d783 2
a784 1
	h->flags |= HTML_NOSPACE;
@


1.148
log
@Arguments to `Bsx' and friends are separated by a non-breaking space.
This removes a TODO raised by schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.147 2011/01/25 15:46:05 kristaps Exp $ */
d425 5
d431 2
a432 1
			print_otag(h, TAG_BR, 0, NULL);
d1184 1
a1184 1
	int		 	 comp;
d1223 5
d1264 3
@


1.147
log
@Push capitalisation of `Bx' second argument into validator, where it belongs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.146 2011/01/25 15:28:56 kristaps Exp $ */
d826 1
d828 6
a833 1
	return(1);
@


1.146
log
@Properly uppercase the first-letter of the `Bx' second argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.145 2011/01/25 15:17:18 kristaps Exp $ */
a835 1
	char		 buf[3];
a849 4
		buf[0] = '-';
		buf[1] = toupper((unsigned char)*n->string);
		buf[2] = '\0';

d851 1
a851 1
		print_text(h, buf);
d853 1
a853 1
		print_text(h, n->string + 1);
@


1.145
log
@Have `Bx' accept two arguments, not just one, and join these arguments
with "xxBSD-yy"
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.144 2011/01/13 14:30:13 kristaps Exp $ */
d835 2
a836 1
	struct htmlpair		tag;
d851 4
d856 1
a856 1
		print_text(h, "-");
d858 1
a858 1
		print_text(h, n->string);
@


1.144
log
@Change how -Thtml behaves with tables: use multiple rows, with widths
set by COL, until an external macro is encountered.  At this point in
time, close out the table and process the macro.  When the first table
row is again re-encountered, re-start the table.  This requires a bit of
tracking added to "struct html", but the change is very small and
follows the logic of meta-fonts.  This all follows a bug-report by
joerg@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.143 2011/01/12 10:43:22 kristaps Exp $ */
d835 1
a835 2
	const struct mdoc_node	*nn;
	struct htmlpair		 tag;
d840 8
a847 2
	for (nn = n->child; nn; nn = nn->next)
		print_mdoc_node(m, nn, h);
d849 3
a851 1
	if (n->child)
d853 2
a855 1
	print_text(h, "BSD");
@


1.143
log
@If the first character of free-form text is whitespace, then a newline
shall precede outputted text (surprise!).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.142 2011/01/07 13:20:58 kristaps Exp $ */
d423 2
d430 5
d436 1
a436 1
		break;
d438 11
a475 2
	case (MDOC_TBL):
		break;
@


1.142
log
@Quiesce lint with some type handling.  Does not change anything.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.141 2011/01/04 10:29:41 kristaps Exp $ */
d423 2
@


1.141
log
@Add skeleton for -T[x]html tbl stuff.  Also start to put in some bits about
the up-coming version, although we're not quite there yet.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.140 2011/01/01 12:18:37 kristaps Exp $ */
d833 1
d948 1
a948 1
	size_t		 i;
d970 1
a970 1
		for (i = 0; i < n->norm->Bl.ncols; i++) {
d973 1
a973 1
			if (i < n->norm->Bl.ncols - 1)
@


1.140
log
@Add table processing structures to -mdoc.  This consists of an
external-facing function mdoc_addspan(), then various bits to prohibit
printing and scanning (this requires some if's to be converted into
switch's).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.139 2010/12/24 22:47:37 kristaps Exp $ */
d426 2
a427 1
		return;
d456 2
@


1.139
log
@Make `Fo' use a B instead of SPAN (left-over).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.138 2010/12/24 14:14:00 kristaps Exp $ */
d425 2
@


1.138
log
@Apparently the U tag is deprecated, so use a SPAN instead (blah).  Bump
version date for release.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.137 2010/12/24 14:00:40 kristaps Exp $ */
d1600 1
a1600 1
	t = print_otag(h, TAG_SPAN, 1, &tag);
d1687 1
a1687 1
		t = print_otag(h, TAG_SPAN, 1, &tag);
@


1.137
log
@As per schwarze@@'s suggestions, roll back the refcount structure in
favour of a simpler shim for normalised data in the node allocation and
free routines.  This removes the need to bump and copy references within
validator handlers, removes a pointer redirect, and also kills the
refcount structure itself.  Data is assumed to "live" either in a
MDOC_BLOCK or MDOC_ELEM and is copied accordingly.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.136 2010/12/23 00:45:03 kristaps Exp $ */
a1935 1
		t = TAG_U;
@


1.136
log
@Ensure -Thtml has DIV as child of BLOCKQUOTE.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.135 2010/12/22 11:15:16 kristaps Exp $ */
d842 1
a842 1
	type = bl->norm->d.Bl.type;
d868 1
a868 1
			SCALE_VS_INIT(&su, ! bl->norm->d.Bl.comp);
d893 1
a893 1
			SCALE_VS_INIT(&su, ! bl->norm->d.Bl.comp);
d907 1
a907 1
			if (NULL == bl->norm->d.Bl.width) {
d911 1
a911 1
			a2width(bl->norm->d.Bl.width, &su);
d917 1
a917 1
			SCALE_VS_INIT(&su, ! bl->norm->d.Bl.comp);
d948 1
a948 1
		if (LIST_column == n->norm->d.Bl.type)
d954 1
a954 1
		if (LIST_column != n->norm->d.Bl.type)
d964 2
a965 2
		for (i = 0; i < n->norm->d.Bl.ncols; i++) {
			a2width(n->norm->d.Bl.cols[i], &su);
d967 1
a967 1
			if (i < n->norm->d.Bl.ncols - 1)
d983 1
a983 1
	assert(lists[n->norm->d.Bl.type]);
d985 1
a985 1
	strlcat(buf, lists[n->norm->d.Bl.type], BUFSIZ);
d990 2
a991 2
	if (n->norm->d.Bl.offs) {
		a2offs(n->norm->d.Bl.offs, &su);
d995 1
a995 1
	switch (n->norm->d.Bl.type) {
d1148 1
a1148 1
		comp = n->norm->d.Bd.comp;
d1163 2
a1164 2
	if (n->norm->d.Bd.offs)
		a2offs(n->norm->d.Bd.offs, &su);
d1169 2
a1170 2
	if (DISP_unfilled != n->norm->d.Bd.type && 
			DISP_literal != n->norm->d.Bd.type) {
d1753 1
a1753 1
	if (FONT_Em == n->norm->d.Bf.font) 
d1755 1
a1755 1
	else if (FONT_Sy == n->norm->d.Bf.font) 
d1757 1
a1757 1
	else if (FONT_Li == n->norm->d.Bf.font) 
@


1.135
log
@Implement reference-counted version of original union mdoc_data.  This
simplifies clean-up and allows for more types without extra hassle.

Also made in-line literal types in -T[x]html use CODE instead of SPAN to
match how literal blocks use PRE.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.134 2010/12/20 13:39:24 kristaps Exp $ */
d1099 3
d1103 1
a1103 1
		PAIR_CLASS_INIT(&tag[0], "lit display");
d1105 1
a1105 4
	} else {
		PAIR_CLASS_INIT(&tag[0], "display");
		print_otag(h, TAG_DIV, 1, tag);
	}
@


1.134
log
@Fix list-type being clobbered by margins.  Last default styles in place.
Added `Sx' to be default-italic (as in OpenBSD's cvsweb).  Added `diag'
formatting, which had been lost.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.133 2010/12/20 13:07:55 kristaps Exp $ */
d473 2
a474 2
		PAIR_INIT(&tag[1], ATTR_WIDTH, "100%");
		t = print_otag(h, TAG_TABLE, 2, tag);
d842 1
a842 1
	type = bl->data.Bl->type;
d868 1
a868 1
			SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
d893 1
a893 1
			SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
d907 1
a907 1
			if (NULL == bl->data.Bl->width) {
d911 1
a911 1
			a2width(bl->data.Bl->width, &su);
d917 1
a917 1
			SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
d948 1
a948 1
		if (LIST_column == n->data.Bl->type)
d954 1
a954 1
		if (LIST_column != n->data.Bl->type)
d964 2
a965 2
		for (i = 0; i < n->data.Bl->ncols; i++) {
			a2width(n->data.Bl->cols[i], &su);
d967 1
a967 1
			if (i < n->data.Bl->ncols - 1)
d983 1
a983 1
	assert(lists[n->data.Bl->type]);
d985 1
a985 1
	strlcat(buf, lists[n->data.Bl->type], BUFSIZ);
d990 2
a991 2
	if (n->data.Bl->offs) {
		a2offs(n->data.Bl->offs, &su);
d995 1
a995 1
	switch (n->data.Bl->type) {
d1099 1
a1099 1
	if (MDOC_Dl == n->tok)
d1101 2
a1102 1
	else
d1104 2
a1106 1
	print_otag(h, TAG_DIV, 1, tag);
d1148 1
a1148 1
		comp = n->data.Bd->comp;
d1163 2
a1164 2
	if (n->data.Bd->offs)
		a2offs(n->data.Bd->offs, &su);
d1169 2
a1170 2
	if (DISP_unfilled != n->data.Bd->type && 
			DISP_literal != n->data.Bd->type) {
d1753 1
a1753 3
	assert(n->data.Bf);

	if (FONT_Em == n->data.Bf->font) 
d1755 1
a1755 1
	else if (FONT_Sy == n->data.Bf->font) 
d1757 1
a1757 1
	else if (FONT_Li == n->data.Bf->font) 
@


1.133
log
@More use default tags, this time I and U.  Also fix a stack overflow
segfault in the last commit.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.132 2010/12/20 10:40:11 kristaps Exp $ */
a859 1
			/* FIXME: STYLE for diag! */
d872 4
d945 1
d984 3
a986 5
	bufinit(h);
	bufcat(h, "list ");
	bufcat(h, lists[n->data.Bl->type]);
	PAIR_INIT(&tag[1], ATTR_CLASS, h->buf);
	i = 2;
a992 2
		PAIR_STYLE_INIT(&tag[2], h);
		i = 3;
d1003 1
a1003 1
		print_otag(h, TAG_UL, i, tag);
d1006 1
a1006 1
		print_otag(h, TAG_OL, i, tag);
d1017 1
a1017 1
		print_otag(h, TAG_DL, i, tag);
d1020 1
a1020 1
		print_otag(h, TAG_TABLE, i, tag);
d1127 1
@


1.132
log
@Give header and footer table cells default widths (using WIDTH and ALIGN
atttributes) if no style is specified.

Give the default-bold elements a B tag instead of a SPAN tag, as this
can be overriden in the stylesheet.

Prune some unused attributes from html.h.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.131 2010/12/19 12:14:36 kristaps Exp $ */
d474 1
a474 1
		t = print_otag(h, TAG_TABLE, 3, tag);
d766 1
a766 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1223 1
a1223 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1235 1
a1235 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1313 1
a1313 1
		print_otag(h, TAG_SPAN, 1, &tag);
d1318 1
a1318 1
		t = print_otag(h, TAG_SPAN, 1, &tag);
d1374 1
a1374 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1399 1
a1399 1
		t = print_otag(h, TAG_SPAN, 1, tag);
d1451 1
a1451 1
		t = print_otag(h, TAG_SPAN, i, tag);
d1889 3
d1902 1
d1912 1
d1916 1
d1935 1
d1949 1
a1949 1
		print_otag(h, TAG_SPAN, 1, tag);
@


1.131
log
@Migrate schwarze@@'s `Bk' argument patch to -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.130 2010/12/17 12:57:49 kristaps Exp $ */
d464 1
a464 1
	struct htmlpair	 tag[2];
d470 12
a481 3
	PAIR_CLASS_INIT(&tag[0], "foot");
	PAIR_SUMMARY_INIT(&tag[1], "Document Footer");
	t = print_otag(h, TAG_TABLE, 2, tag);
d492 5
a496 1
	print_otag(h, TAG_TD, 1, tag);
d521 13
a533 3
	PAIR_CLASS_INIT(&tag[0], "head");
	PAIR_SUMMARY_INIT(&tag[1], "Document Header");
	t = print_otag(h, TAG_TABLE, 2, tag);
d544 5
a548 1
	print_otag(h, TAG_TD, 1, tag);
d554 5
a558 1
	print_otag(h, TAG_TD, 1, tag);
d627 1
a627 1
	print_otag(h, TAG_SPAN, 1, &tag);
d674 1
a674 1
		print_otag(h, TAG_SPAN, 1, &tag);
d860 1
d1045 1
a1045 1
		t = print_otag(h, TAG_SPAN, 1, &tag);
d1262 1
a1262 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1341 1
a1341 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1430 1
a1430 1
	t = print_otag(h, TAG_SPAN, 1, tag);
d1628 1
a1628 1
	print_otag(h, TAG_SPAN, 1, tag);
d1664 1
a1664 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1706 1
a1706 1
	t = print_otag(h, TAG_SPAN, 1, &tag);
d1721 1
a1721 1
	print_otag(h, TAG_SPAN, 1, &tag);
@


1.130
log
@Don't use EM for default widths; use BU instead.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.129 2010/12/17 11:19:42 kristaps Exp $ */
d1951 2
a1952 1
		h->flags |= HTML_PREKEEP;
@


1.129
log
@Prevent double-printing of `D1' or `Dl' DIV.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.128 2010/12/17 11:01:24 kristaps Exp $ */
d290 1
a290 1
		su->unit = SCALE_EM;
d357 1
a357 1
		su->unit = SCALE_EM;
@


1.128
log
@Add a "list" top-level tag, too.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.127 2010/12/17 10:43:51 kristaps Exp $ */
d1067 1
a1067 1
	if (MDOC_Dl == n->tok) {
d1069 1
a1069 2
		print_otag(h, TAG_DIV, 1, tag);
	} else
a1070 1
		print_otag(h, TAG_DIV, 1, tag);
d1072 1
@


1.127
log
@Remove useless DIVs in favour of BRs.  Fix `Ex' by having it print a prior
BR.  Fix `Rv' by only having it print a BR if there's a prior.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.126 2010/12/17 10:37:26 kristaps Exp $ */
d948 4
a951 1
	PAIR_CLASS_INIT(&tag[1], lists[n->data.Bl->type]);
@


1.126
log
@Make literal `Bd' use a PRE in -Thtml.  Make `Bd' output in general use
only a single DIV or PRE.  Tag all displays with display class.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.125 2010/12/17 08:17:40 kristaps Exp $ */
d1003 3
d1643 3
a1645 1
	print_otag(h, TAG_DIV, 0, NULL);
d1841 3
a1843 2
	if (SEC_LIBRARY == n->sec && MDOC_LINE & n->flags)
		print_otag(h, TAG_DIV, 0, NULL);
@


1.125
log
@Have synopsis_pre() in -Thtml emit P or BR, not DIVs.

Banish header and footer TABLE styling to example.style.css.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.124 2010/12/17 01:02:00 kristaps Exp $ */
d1062 1
a1062 1
		PAIR_CLASS_INIT(&tag[1], "lit");
d1065 2
a1066 1
		print_otag(h, TAG_DIV, 0, tag);
a1106 11
	SCALE_VS_INIT(&su, 0);

	assert(n->data.Bd);
	if (n->data.Bd->offs)
		a2offs(n->data.Bd->offs, &su);

	comp = n->data.Bd->comp;

	/* FIXME: -centered, etc. formatting. */
	/* FIXME: does not respect -offset ??? */

d1108 1
a1108 1
		bufcat_su(h, "margin-left", &su);
d1117 2
a1118 9
		if (comp) {
			PAIR_STYLE_INIT(&tag[0], h);
			print_otag(h, TAG_DIV, 1, tag);
			return(1);
		}
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		PAIR_STYLE_INIT(&tag[0], h);
		print_otag(h, TAG_DIV, 1, tag);
d1122 7
d1130 3
a1132 1
			DISP_literal != n->data.Bd->type)
d1134 1
d1136 2
a1137 4
	PAIR_CLASS_INIT(&tag[0], "lit");
	bufcat_style(h, "white-space", "pre");
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
d1169 2
a1171 1
		print_text(h, "\n");
@


1.124
log
@Make SYNOPSIS `Nm' use a TABLE in -T[x]html mode.  Also fix `Nd' using
desc-body instead of desc as its CSS key.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.123 2010/12/17 00:18:29 kristaps Exp $ */
a301 2
	struct roffsu	 su;
	struct htmlpair	 tag;
a305 4
	SCALE_VS_INIT(&su, 1);
	bufcat_su(h, "margin-top", &su);
	PAIR_STYLE_INIT(&tag, h);

d310 1
a310 1
		print_otag(h, TAG_DIV, 0, NULL);
d324 1
a324 1
		print_otag(h, TAG_DIV, 1, &tag);
d328 1
a328 1
			print_otag(h, TAG_DIV, 1, &tag);
d333 1
a333 1
		print_otag(h, TAG_DIV, 0, NULL);
a459 1

d464 1
a464 1
	struct htmlpair	 tag[3];
d470 3
a472 4
	PAIR_CLASS_INIT(&tag[0], "footer");
	bufcat_style(h, "width", "100%");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_SUMMARY_INIT(&tag[2], "footer");
a473 1
	t = print_otag(h, TAG_TABLE, 3, tag);
d476 1
a476 3
	bufinit(h);
	bufcat_style(h, "width", "50%");
	PAIR_STYLE_INIT(&tag[0], h);
d478 1
d482 1
a482 4
	bufinit(h);
	bufcat_style(h, "width", "50%");
	bufcat_style(h, "text-align", "right");
	PAIR_STYLE_INIT(&tag[0], h);
d484 1
d508 3
a510 6
	PAIR_CLASS_INIT(&tag[0], "header");
	bufcat_style(h, "width", "100%");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_SUMMARY_INIT(&tag[2], "header");

	t = print_otag(h, TAG_TABLE, 3, tag);
d514 1
a514 3
	bufinit(h);
	bufcat_style(h, "width", "10%");
	PAIR_STYLE_INIT(&tag[0], h);
d516 1
d520 1
a520 5
	bufinit(h);
	bufcat_style(h, "text-align", "center");
	bufcat_style(h, "white-space", "nowrap");
	bufcat_style(h, "width", "80%");
	PAIR_STYLE_INIT(&tag[0], h);
d522 1
d526 1
a526 4
	bufinit(h);
	bufcat_style(h, "text-align", "right");
	bufcat_style(h, "width", "10%");
	PAIR_STYLE_INIT(&tag[0], h);
d528 1
d1178 1
@


1.123
log
@Significantly clean up Sh, Ss, SH, and SS handling in -Thtml.  Now a
top-level DIV is used with only an H1 or H2 as the section header.  This
makes manuals much more readable in lynx, less complicated, and
relegates left-margin widths to example.style.css.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.122 2010/12/16 22:57:20 kristaps Exp $ */
d647 1
a647 1
	PAIR_CLASS_INIT(&tag, "desc-body");
d658 1
a658 1
	const char	*cp;
d660 2
a661 10
	/*
	 * Accomodate for `Nm' being both an element (which may have
	 * NULL children AND no m->name) and a block.
	 */

	cp = NULL;

	if (MDOC_ELEM == n->type) {
		if (NULL == n->child && NULL == m->name)
			return(1);
d665 6
a670 1
		if (NULL == n->child)
d672 7
a678 2
	} else if (MDOC_BLOCK == n->type) {
		synopsis_pre(h, n);
d680 3
a682 11
		bufcat_style(h, "clear", "both");
		if (n->head->child || m->name) {
			if (n->head->child && MDOC_TEXT == 
					n->head->child->type)
				cp = n->head->child->string;
			if (NULL == cp || '\0' == *cp)
				cp = m->name;

			SCALE_HS_INIT(&su, (double)strlen(cp));
			bufcat_su(h, "padding-left", &su);
		}
d684 3
a686 5
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
	} else if (MDOC_HEAD == n->type) { 
		if (NULL == n->child && NULL == m->name)
			return(1);
d688 2
a689 23
		if (n->child && MDOC_TEXT == n->child->type)
			cp = n->child->string;
		if (NULL == cp || '\0' == *cp)
			cp = m->name;

		SCALE_HS_INIT(&su, (double)strlen(cp));

		bufcat_style(h, "float", "left");
		bufcat_su(h, "min-width", &su);
		SCALE_INVERT(&su);
		bufcat_su(h, "margin-left", &su);

		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);

		if (NULL == n->child)
			print_text(h, m->name);
	} else if (MDOC_BODY == n->type) {
		SCALE_HS_INIT(&su, 2);
		bufcat_su(h, "margin-left", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
	}
d691 7
@


1.122
log
@Get widths to be propertly represented in -T[x]html.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.121 2010/12/15 23:44:02 kristaps Exp $ */
d560 2
a561 4
	struct htmlpair		 tag[2];
	const struct mdoc_node	*nn;
	char			 buf[BUFSIZ];
	struct roffsu		 su;
d563 3
a565 6
	if (MDOC_BODY == n->type) {
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		PAIR_CLASS_INIT(&tag[0], "sec-body");
		PAIR_STYLE_INIT(&tag[1], h);
		print_otag(h, TAG_DIV, 2, tag);
d567 1
a567 14
	} else if (MDOC_BLOCK == n->type) {
		PAIR_CLASS_INIT(&tag[0], "sec-block");
		if (n->prev && NULL == n->prev->body->child) {
			print_otag(h, TAG_DIV, 1, tag);
			return(1);
		}
		
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		if (NULL == n->next)
			bufcat_su(h, "margin-bottom", &su);

		PAIR_STYLE_INIT(&tag[1], h);
		print_otag(h, TAG_DIV, 2, tag);
a568 1
	}
d571 3
a573 3
	for (nn = n->child; nn; nn = nn->next) {
		html_idcat(buf, nn->string, BUFSIZ);
		if (nn->next)
d577 2
a578 4
	PAIR_CLASS_INIT(&tag[0], "sec-head");
	PAIR_ID_INIT(&tag[1], buf);

	print_otag(h, TAG_DIV, 2, tag);
d587 2
a588 4
	struct htmlpair	 	 tag[3];
	const struct mdoc_node	*nn;
	char			 buf[BUFSIZ];
	struct roffsu		 su;
d590 3
a592 10
	SCALE_VS_INIT(&su, 1);

	if (MDOC_BODY == n->type) {
		PAIR_CLASS_INIT(&tag[0], "ssec-body");
		if (n->parent->next && n->child) {
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DIV, 2, tag);
		} else
			print_otag(h, TAG_DIV, 1, tag);
d594 1
a594 8
	} else if (MDOC_BLOCK == n->type) {
		PAIR_CLASS_INIT(&tag[0], "ssec-block");
		if (n->prev) {
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag[1], h);
			print_otag(h, TAG_DIV, 2, tag);
		} else
			print_otag(h, TAG_DIV, 1, tag);
a595 3
	}

	/* TODO: see note in mdoc_sh_pre() about duplicates. */
d598 3
a600 3
	for (nn = n->child; nn; nn = nn->next) {
		html_idcat(buf, nn->string, BUFSIZ);
		if (nn->next)
d604 2
a605 9
	SCALE_HS_INIT(&su, INDENT - HALFINDENT);
	su.scale = -su.scale;
	bufcat_su(h, "margin-left", &su);

	PAIR_CLASS_INIT(&tag[0], "ssec-head");
	PAIR_STYLE_INIT(&tag[1], h);
	PAIR_ID_INIT(&tag[2], buf);

	print_otag(h, TAG_DIV, 3, tag);
@


1.121
log
@Remove `Pp' and `Lp' checks in front-ends to make sure we're not
printing as the first or last child of an `Ss' or `Sh': this is now
ensured within the validator.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.120 2010/12/15 17:19:41 kristaps Exp $ */
a905 4
	SCALE_VS_INIT(&su, ! bl->data.Bl->comp);
	bufcat_su(h, "margin-top", &su);
	PAIR_STYLE_INIT(&tag[1], h);

d927 3
d948 3
a950 1
			/* FALLTHROUGH */
d962 8
a969 1
			print_otag(h, TAG_DD, 1, tag);
d972 3
@


1.120
log
@Use a single P tag for paragraph breaks (which can be configured for
paragraph breaking in CSS).

Use -man's handling of `sp' and `br', which accomodates for scaling
widths (-mdoc wasn't).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.119 2010/12/15 16:35:21 kristaps Exp $ */
a1544 5
	if ((NULL == n->next || NULL == n->prev) &&
			(MDOC_Ss == n->parent->tok ||
			 MDOC_Sh == n->parent->tok))
		return(0);

@


1.119
log
@Make sure that new list types don't emit whitespace before or after (we
have to do this manually).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.118 2010/12/15 16:08:18 kristaps Exp $ */
d106 1
d130 1
a130 1
	{mdoc_sp_pre, NULL}, /* Pp */ 
d231 1
a231 1
	{mdoc_sp_pre, NULL}, /* Lp */ 
d1136 3
d1142 1
a1142 1
		print_otag(h, TAG_BLOCKQUOTE, 2, tag);
d1144 1
a1144 1
		print_otag(h, TAG_BLOCKQUOTE, 1, tag);
d1540 14
d1559 1
a1559 1
	int		 len;
a1560 1
	struct roffsu	 su;
d1562 7
a1568 17
	switch (n->tok) {
	case (MDOC_sp):
		/* FIXME: can this have a scaling indicator? */
		len = n->child ? atoi(n->child->string) : 1;
		break;
	case (MDOC_br):
		len = 0;
		break;
	default:
		assert(n->parent);
		if ((NULL == n->next || NULL == n->prev) &&
				(MDOC_Ss == n->parent->tok ||
				 MDOC_Sh == n->parent->tok))
			return(0);
		len = 1;
		break;
	}
a1569 1
	SCALE_VS_INIT(&su, len);
d1573 1
a1580 1

d1867 2
a1868 4
	if (n->prev && SEC_SEE_ALSO == n->sec) {
		print_otag(h, TAG_BR, 0, NULL);
		print_otag(h, TAG_BR, 0, NULL);
	} 
@


1.118
log
@Clarify purpose of "lit".

Make `Dl' and `D1' both use BLOCKQUOTE instead of DIVs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.117 2010/12/15 15:59:23 kristaps Exp $ */
a377 1

a475 6
	/*
	 * XXX: this should use divs, but in Firefox, divs with nested
	 * divs for some reason puke when trying to put a border line
	 * below.  So I use tables, instead.
	 */

d509 1
a509 1
	(void)strlcpy(b, m->vol, BUFSIZ);
d512 3
a514 3
		(void)strlcat(b, " (", BUFSIZ);
		(void)strlcat(b, m->arch, BUFSIZ);
		(void)strlcat(b, ")", BUFSIZ);
d517 1
a517 4
	(void)snprintf(title, BUFSIZ - 1, 
			"%s(%s)", m->title, m->msec);

	/* XXX: see note in mdoc_root_post() about divs. */
d986 1
a986 1
	struct htmlpair	 tag[2];
d1020 5
d1026 2
a1027 2
	PAIR_CLASS_INIT(&tag[0], lists[n->data.Bl->type]);
	i = 1;
d1034 2
a1035 2
		PAIR_STYLE_INIT(&tag[1], h);
		i = 2;
@


1.117
log
@Remove stupid outer DIV tag in favour of regular BODY and HTML that can
be handled in CSS.

Clarified "lit" tag (will be the subject of future clarification).

Removed CSS2 note in mandoc.1, which is no longer the case.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.116 2010/12/15 15:32:01 kristaps Exp $ */
d1136 10
a1145 1
	/* FIXME: D1 shouldn't be literal. */
a1146 5
	SCALE_VS_INIT(&su, INDENT - 2);
	bufcat_su(h, "margin-left", &su);
	PAIR_CLASS_INIT(&tag[0], "lit");
	PAIR_STYLE_INIT(&tag[1], h);
	print_otag(h, TAG_DIV, 2, tag);
@


1.116
log
@Added list-type style tips.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.115 2010/12/15 14:52:16 kristaps Exp $ */
a371 1
	struct htmlpair	 tag;
a378 4
	tag.key = ATTR_CLASS;
	tag.val = "body";
	print_otag(h, TAG_DIV, 1, &tag);

a1040 1

@


1.115
log
@In-progress move from -T[x]html using DIVs for its lists to using DL,
OL, and UL.  Issue raised by Will Backman, solution proposed by
schwarze@@.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.114 2010/12/05 15:37:30 kristaps Exp $ */
d249 2
a250 2
	"list-bullet",
	"list-column",
d255 1
a255 1
	"list-hyphen",
d906 1
a906 1
	struct htmlpair	 tag;
d917 2
a918 1
	/* Whether we're top-padded (not "compact"). */
d922 1
a922 1
	PAIR_STYLE_INIT(&tag, h);
d945 1
a945 1
			print_otag(h, TAG_DT, 1, &tag);
d964 1
a964 1
			print_otag(h, TAG_LI, 1, &tag);
d975 1
a975 1
			print_otag(h, TAG_DD, 0, NULL);
d978 1
a978 1
			print_otag(h, TAG_TD, 1, &tag);
d986 1
a986 1
			print_otag(h, TAG_TR, 0, NULL);
@


1.114
log
@Merge schwarze@@'s changes allowing nested displays.  Tweak the patch by
making sure output doesn't add a superfluous newline with the nested displays.
Also add a COMPATIBILITY note.

Rename a macro (DATESIZ) to be in line with OpenBSD (DATESIZE).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.113 2010/11/29 13:02:47 kristaps Exp $ */
a74 1
static	void		  mdoc_bl_post(MDOC_ARGS);
a94 6
static	int		  mdoc_it_block_pre(MDOC_ARGS, enum mdoc_list,
				int, struct roffsu *, struct roffsu *);
static	int		  mdoc_it_head_pre(MDOC_ARGS, enum mdoc_list, 
				struct roffsu *);
static	int		  mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list,
				struct roffsu *);
d134 1
a134 1
	{mdoc_bl_pre, mdoc_bl_post}, /* Bl */
d247 14
a900 2

/* ARGSUSED */
d902 1
a902 2
mdoc_it_block_pre(MDOC_ARGS, enum mdoc_list type, int comp,
		struct roffsu *offs, struct roffsu *width)
d904 8
a911 3
	struct htmlpair	 	 tag;
	const struct mdoc_node	*nn;
	struct roffsu		 su;
d913 1
a913 1
	nn = n->parent->parent;
d915 1
a915 1
	/* XXX: see notes in mdoc_it_pre(). */
d917 1
a917 16
	if (LIST_column == type) {
		/* Don't width-pad on the left. */
		SCALE_HS_INIT(width, 0);
		/* Also disallow non-compact. */
		comp = 1;
	}
	if (LIST_diag == type)
		/* Mandate non-compact with empty prior. */
		if (n->prev && NULL == n->prev->body->child)
			comp = 1;

	bufcat_style(h, "clear", "both");
	if (offs->scale > 0)
		bufcat_su(h, "margin-left", offs);
	if (width->scale > 0)
		bufcat_su(h, "padding-left", width);
d919 2
d923 65
a987 8
	/* Mandate compact following `Ss' and `Sh' starts. */

	for (nn = n; nn && ! comp; nn = nn->parent) {
		if (MDOC_BLOCK != nn->type)
			continue;
		if (MDOC_Ss == nn->tok || MDOC_Sh == nn->tok)
			comp = 1;
		if (nn->prev)
d989 1
a991 7
	if ( ! comp) {
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "padding-top", &su);
	}

	PAIR_STYLE_INIT(&tag, h);
	print_otag(h, TAG_DIV, 1, &tag);
a994 1

d997 1
a997 1
mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list type, struct roffsu *width)
d999 2
a1000 1
	struct htmlpair	 tag;
d1003 4
a1006 23
	switch (type) {
	case (LIST_item):
		/* FALLTHROUGH */
	case (LIST_ohang):
		/* FALLTHROUGH */
	case (LIST_column):
		bufcat_su(h, "min-width", width);
		bufcat_style(h, "clear", "none");
		if (n->next)
			bufcat_style(h, "float", "left");
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
		break;
	default:
		/* 
		 * XXX: this tricks CSS into aligning the bodies with
		 * the right-padding in the head. 
		 */
		SCALE_HS_INIT(&su, 2);
		bufcat_su(h, "margin-left", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
		break;
d1009 3
a1011 2
	return(1);
}
d1013 6
d1020 10
a1029 7
/* ARGSUSED */
static int
mdoc_it_head_pre(MDOC_ARGS, enum mdoc_list type, struct roffsu *width)
{
	struct htmlpair	 tag;
	struct ord	*ord;
	char		 nbuf[BUFSIZ];
a1030 2
	switch (type) {
	case (LIST_item):
a1031 18
	case (LIST_ohang):
		print_otag(h, TAG_DIV, 0, &tag);
		return(1);
	case (LIST_column):
		break;
	default:
		bufcat_su(h, "min-width", width);
		SCALE_INVERT(width);
		bufcat_su(h, "margin-left", width);
		if (n->next && n->next->child)
			bufcat_style(h, "float", "left");

		/* XXX: buffer if we run into body. */
		SCALE_HS_INIT(width, 1);
		bufcat_su(h, "margin-right", width);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
		break;
d1034 3
a1036 24
	switch (type) {
	case (LIST_diag):
		PAIR_CLASS_INIT(&tag, "diag");
		print_otag(h, TAG_SPAN, 1, &tag);
		break;
	case (LIST_enum):
		ord = h->ords.head;
		assert(ord);
		nbuf[BUFSIZ - 1] = 0;
		(void)snprintf(nbuf, BUFSIZ - 1, "%d.", ord->pos++);
		print_text(h, nbuf);
		return(0);
	case (LIST_dash):
		print_text(h, "\\(en");
		return(0);
	case (LIST_hyphen):
		print_text(h, "\\(hy");
		return(0);
	case (LIST_bullet):
		print_text(h, "\\(bu");
		return(0);
	default:
		break;
	}
d1038 1
a1038 2
	return(1);
}
d1040 5
d1046 1
a1046 7
static int
mdoc_it_pre(MDOC_ARGS)
{
	int			 i, comp;
	const struct mdoc_node	*bl, *nn;
	struct roffsu		 width, offs;
	enum mdoc_list		 type;
d1048 2
a1049 21
	/* 
	 * XXX: be very careful in changing anything, here.  Lists in
	 * mandoc have many peculiarities; furthermore, they don't
	 * translate well into HTML and require a bit of mangling.
	 */

	bl = n->parent->parent;
	if (MDOC_BLOCK != n->type)
		bl = bl->parent;

	SCALE_HS_INIT(&offs, 0);

	assert(bl->data.Bl);
	type = bl->data.Bl->type;
	comp = bl->data.Bl->comp;

	if (bl->data.Bl->offs)
		a2offs(bl->data.Bl->offs, &offs);

	switch (type) {
	case (LIST_enum):
d1051 1
a1051 1
	case (LIST_dash):
d1053 1
a1053 1
	case (LIST_hyphen):
d1055 2
a1056 2
	case (LIST_bullet):
		SCALE_HS_INIT(&width, 2);
d1058 2
a1059 2
	default:
		SCALE_HS_INIT(&width, INDENT);
d1061 3
a1063 9
	}

	if (bl->data.Bl->width)
		a2width(bl->data.Bl->width, &width);

	/* Override width in some cases. */

	switch (type) {
	case (LIST_ohang):
d1065 1
a1065 1
	case (LIST_item):
d1067 1
a1067 1
	case (LIST_inset):
d1069 5
a1073 2
	case (LIST_diag):
		SCALE_HS_INIT(&width, 0);
d1076 2
a1077 12
		if (0 == width.scale)
			SCALE_HS_INIT(&width, INDENT);
		break;
	}

	if (LIST_column == type && MDOC_BODY == n->type) {
		nn = n->parent->child;
		for (i = 0; nn && nn != n; nn = nn->next)
			if (MDOC_BODY == nn->type)
				i++;
		if (i < (int)bl->data.Bl->ncols)
			a2width(bl->data.Bl->cols[i], &width);
a1079 32
	if (MDOC_HEAD == n->type)
		return(mdoc_it_head_pre(m, n, h, type, &width));
	else if (MDOC_BODY == n->type)
		return(mdoc_it_body_pre(m, n, h, type, &width));

	return(mdoc_it_block_pre(m, n, h, type, comp, &offs, &width));
}


/* ARGSUSED */
static int
mdoc_bl_pre(MDOC_ARGS)
{
	struct ord	*ord;

	if (MDOC_HEAD == n->type)
		return(0);
	if (MDOC_BLOCK != n->type)
		return(1);
	assert(n->data.Bl);
	if (LIST_enum != n->data.Bl->type)
		return(1);

	ord = malloc(sizeof(struct ord));
	if (NULL == ord) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
	ord->cookie = n;
	ord->pos = 1;
	ord->next = h->ords.head;
	h->ords.head = ord;
a1082 19

/* ARGSUSED */
static void
mdoc_bl_post(MDOC_ARGS)
{
	struct ord	*ord;

	if (MDOC_BLOCK != n->type)
		return;
	if (LIST_enum != n->data.Bl->type)
		return;

	ord = h->ords.head;
	assert(ord);
	h->ords.head = ord->next;
	free(ord);
}


@


1.113
log
@Move `Mt', `Ar', and `Li' handling from mdoc_action.c into mdoc_validate.c.

Clarify that `Mt' gets a default `~' (as per groff 1.20) and document it
in mdoc.7.

Made `Lk' be removed in mdoc_macro.c if it has no arguments.  This fixes
segfaults in mdoc_{term,html}.c that nobody's managed to raise yet.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.112 2010/10/23 23:31:10 schwarze Exp $ */
d1334 4
@


1.112
log
@let .Bsx print just "BSD/OS" like in modern groff
from Ulrich Spoerlein <uqs at spoerlein dot net>
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.111 2010/10/10 09:59:48 kristaps Exp $ */
d1678 1
a1678 1
	if (NULL == nn->next) 
@


1.111
log
@`Sm' no longer produces a linebreak when used in `Bd'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.110 2010/10/01 21:51:13 schwarze Exp $ */
d846 1
a846 1
		pp = "BSDI BSD/OS";
@


1.110
log
@* need a space before .No even if it starts with a closing delimiter
* slightly simplify .Pf *_IGNDELIM code, and share part of it with .No
* do not let opening delimiters fall out of the front of .Ns (from kristaps@@)
This fixes a few spacing issues in csh(1) and ksh(1).
OK kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.109 2010/10/01 12:09:55 kristaps Exp $ */
d1326 2
d1608 10
a1617 1
		/* FIXME: no p->col to check... */
@


1.109
log
@Fix small regression where `Op' had an extra space between the "[" and the SPAN.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.108 2010/09/27 11:21:39 kristaps Exp $ */
d94 1
a112 1
static	int		  mdoc_pf_pre(MDOC_ARGS);
d202 1
a202 1
	{NULL, NULL}, /* No */
d207 1
a207 1
	{mdoc_pf_pre, mdoc_pf_post}, /* Pf */
d1914 1
a1914 1
mdoc_pf_pre(MDOC_ARGS)
a1926 1
	h->flags &= ~HTML_IGNDELIM;
@


1.108
log
@Suppress whitespace following Pp, Lp, sp, and the other newline-emitting
macros within an unfilled or literal `Bd'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.107 2010/09/26 10:32:14 kristaps Exp $ */
d2160 1
@


1.107
log
@Consolidated all -T[x]html punctuation macros into one function.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.106 2010/09/25 16:41:33 kristaps Exp $ */
d1319 20
@


1.106
log
@A `%T' invoked outside of `Rs' should not produce trailing punctuation.
This from a TODO entry.  Also stripped the superfluous NOSPACE, which is
handled in term_word() or print_text() anyway.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.105 2010/09/25 15:51:30 kristaps Exp $ */
a69 2
static	void		  mdoc_aq_post(MDOC_ARGS);
static	int		  mdoc_aq_pre(MDOC_ARGS);
a76 4
static	void		  mdoc_bq_post(MDOC_ARGS);
static	int		  mdoc_bq_pre(MDOC_ARGS);
static	void		  mdoc_brq_post(MDOC_ARGS);
static	int		  mdoc_brq_pre(MDOC_ARGS);
a80 2
static	void		  mdoc_dq_post(MDOC_ARGS);
static	int		  mdoc_dq_pre(MDOC_ARGS);
a109 2
static	void		  mdoc_op_post(MDOC_ARGS);
static	int		  mdoc_op_pre(MDOC_ARGS);
d113 2
a114 2
static	void		  mdoc_pq_post(MDOC_ARGS);
static	int		  mdoc_pq_pre(MDOC_ARGS);
a119 2
static	void		  mdoc_sq_post(MDOC_ARGS);
static	int		  mdoc_sq_pre(MDOC_ARGS);
d163 1
a163 1
	{mdoc_op_pre, mdoc_op_post}, /* Op */
d183 2
a184 2
	{mdoc_aq_pre, mdoc_aq_post}, /* Ao */
	{mdoc_aq_pre, mdoc_aq_post}, /* Aq */
d188 2
a189 2
	{mdoc_bq_pre, mdoc_bq_post}, /* Bo */
	{mdoc_bq_pre, mdoc_bq_post}, /* Bq */
d194 2
a195 2
	{mdoc_dq_pre, mdoc_dq_post}, /* Do */
	{mdoc_dq_pre, mdoc_dq_post}, /* Dq */
d208 2
a209 2
	{mdoc_pq_pre, mdoc_pq_post}, /* Po */
	{mdoc_pq_pre, mdoc_pq_post}, /* Pq */
d211 3
a213 3
	{mdoc_sq_pre, mdoc_sq_post}, /* Ql */
	{mdoc_dq_pre, mdoc_dq_post}, /* Qo */
	{mdoc_dq_pre, mdoc_dq_post}, /* Qq */
d217 2
a218 2
	{mdoc_sq_pre, mdoc_sq_post}, /* So */
	{mdoc_sq_pre, mdoc_sq_post}, /* Sq */
d228 1
a228 1
	{mdoc_op_pre, mdoc_op_post}, /* Oo */
d240 2
a241 2
	{mdoc_brq_pre, mdoc_brq_post}, /* Brq */ 
	{mdoc_brq_pre, mdoc_brq_post}, /* Bro */ 
a706 31
/* ARGSUSED */
static int
mdoc_op_pre(MDOC_ARGS)
{
	struct htmlpair	 tag;

	if (MDOC_BODY != n->type)
		return(1);

	/* XXX: this tag in theory can contain block elements. */

	print_text(h, "\\(lB");
	h->flags |= HTML_NOSPACE;
	PAIR_CLASS_INIT(&tag, "opt");
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
}


/* ARGSUSED */
static void
mdoc_op_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type) 
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rB");
}


a1208 74
mdoc_dq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lq");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_dq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rq");
}


/* ARGSUSED */
static int
mdoc_pq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\&(");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_pq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	print_text(h, ")");
}


/* ARGSUSED */
static int
mdoc_sq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(oq");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_sq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(aq");
}


/* ARGSUSED */
static int
a1264 25
mdoc_aq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(la");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_aq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(ra");
}


/* ARGSUSED */
static int
a1635 25
mdoc_brq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lC");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_brq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rC");
}


/* ARGSUSED */
static int
a1717 1
	h->flags |= HTML_NOSPACE;
a1718 1
	h->flags |= HTML_NOSPACE;
a1832 25
mdoc_bq_pre(MDOC_ARGS)
{
	
	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\(lB");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_bq_post(MDOC_ARGS)
{
	
	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\(rB");
}


/* ARGSUSED */
static int
d2109 123
@


1.105
log
@Add `Rs' vertical-space in -T[x]html "SEE ALSO" section.  Remove
corresponding TODO entry.

Also have the "." after an `Rs' block trigger inter-sentence spacing.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.104 2010/09/04 20:18:53 kristaps Exp $ */
d2266 3
a2268 1
	h->flags |= HTML_NOSPACE;
@


1.104
log
@Churny commit to quiet lint.  No functional changes.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.103 2010/09/04 19:01:52 kristaps Exp $ */
a2110 1
	struct roffsu	 su;
d2116 3
a2118 5
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
	}
@


1.103
log
@Properly handle -mdoc %A in all outputs.  This has two-author entires
separated by only "and" while two or more are with ", and" for the last
author.

Also remove relevant TODO and add regression tests.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.102 2010/08/20 01:02:07 schwarze Exp $ */
d1186 1
a1186 1
		exit(MANDOCLEVEL_SYSERR);
@


1.102
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.101 2010/08/07 17:20:17 schwarze Exp $ */
d2197 3
d2252 1
d2262 5
@


1.101
log
@same as mdoc_term.c rev. 1.180:
preserve blank lines at the end of .Bd -literal
patch from kristaps@@, who asked me to commit this
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.100 2010/07/27 08:38:04 kristaps Exp $ */
d1186 1
a1186 1
		exit(EXIT_FAILURE);
@


1.100
log
@Fix how `Bd -unfilled' and `Bd -literal' break lines.  This unbreaks
displays to work as old groff shows them; however, new groff still does
some fancy shit.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.99 2010/07/23 00:08:57 kristaps Exp $ */
a1459 4
		if (nn->prev && nn->prev->line < nn->line) {
			print_text(h, "\n");
			h->flags |= HTML_NOSPACE;
		}
d1461 4
@


1.99
log
@Add support for `Sm' in -T[x]html -mdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.98 2010/07/19 11:11:54 kristaps Exp $ */
d1460 4
a1463 1
		h->flags |= HTML_NOSPACE;
a1464 6
		if (NULL == nn->next)
			continue;
		if (nn->prev && nn->prev->line < nn->line)
			print_text(h, "\n");
		else if (NULL == nn->prev)
			print_text(h, "\n");
@


1.98
log
@Remove some FIXMEs: `Ms' accepts arbitrary text, so it can't/shouldn't
be converted into a symbol.

The `Pp' issue has also been fixed.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.97 2010/07/19 11:06:31 kristaps Exp $ */
d128 1
d231 1
a231 1
	{NULL, NULL}, /* Sm */ /* FIXME - no idea. */
d1726 17
@


1.97
log
@Fix spurrious newline emitted by `Pp' when specified before or after
`Sh'/`Ss'.  Reported by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.96 2010/07/13 23:53:20 schwarze Exp $ */
d212 1
a212 1
	{mdoc_ms_pre, NULL}, /* Ms */ /* FIXME: convert to symbol? */
@


1.96
log
@correct lots of copyright notices;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.95 2010/07/07 15:04:54 kristaps Exp $ */
d1740 5
@


1.95
log
@Re-constitution of `ds' symbol processing.  First, push the
roff_getstr() family of functions into roff.c with the "first_string"
directly in struct roff.  Second, pre-process each line for reserved
words in libroff, splicing and re-running a line if it has one (this
allows defined symbols to be macros).  Remove term.c's invocation of the
roff_getstrn() function.  Removed function documentation in roff.3 and
added roff.7 `ds' documentation.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.94 2010/07/06 12:37:17 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.94
log
@Give -T[x]html `Bk -words' capability.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.93 2010/07/04 21:59:30 kristaps Exp $ */
a32 1
#include "regs.h"
@


1.93
log
@Cache column sizes and char pointer into mdoc_bl.  Finally get rid of
the loops here and there to track down the MDOC_Column arguments.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.92 2010/07/02 12:54:33 kristaps Exp $ */
d76 2
d242 1
a242 1
	{NULL, NULL}, /* Bk */
d447 12
d2244 32
@


1.92
log
@Stash `Bf' parameters into struct mdoc_bf.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.91 2010/07/02 10:42:46 kristaps Exp $ */
d1077 1
a1077 1
	int			 i, wp, comp;
a1118 10
	wp = -1;
	for (i = 0; bl->args && i < (int)bl->args->argc; i++) 
		switch (bl->args->argv[i].arg) {
		case (MDOC_Column):
			wp = i; /* Save for later. */
			break;
		default:
			break;
		}

d1142 2
a1143 2
		if (i < (int)bl->args->argv[wp].sz)
			a2width(bl->args->argv[wp].value[i], &width);
@


1.91
log
@Implemented -Thtml bits for handling `Nm' blocks.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.90 2010/07/01 22:56:17 kristaps Exp $ */
a2017 1
	int		 i;
d2023 1
a2023 1
	else if (MDOC_BLOCK != n->type)
d2026 1
a2026 1
	PAIR_CLASS_INIT(&tag[0], "lit");
d2028 8
a2035 25
	if (n->head->child) {
		if ( ! strcmp("Em", n->head->child->string))
			PAIR_CLASS_INIT(&tag[0], "emph");
		else if ( ! strcmp("Sy", n->head->child->string))
			PAIR_CLASS_INIT(&tag[0], "symb");
		else if ( ! strcmp("Li", n->head->child->string))
			PAIR_CLASS_INIT(&tag[0], "lit");
	} else {
		for (i = 0; n->args && i < (int)n->args->argc; i++) 
			switch (n->args->argv[i].arg) {
			case (MDOC_Symbolic):
				PAIR_CLASS_INIT(&tag[0], "symb");
				break;
			case (MDOC_Literal):
				PAIR_CLASS_INIT(&tag[0], "lit");
				break;
			case (MDOC_Emphasis):
				PAIR_CLASS_INIT(&tag[0], "emph");
				break;
			default:
				break;
			}
	}

	/* FIXME: div's have spaces stripped--we want them. */
d2037 4
d2043 2
a2044 1
	bufcat_su(h, "margin-right", &su);
@


1.90
log
@Make struct_bl and struct_bd into pointers.  This removes the need to do
copying on internals after modification.  Even more importantly, if an
ENDBODY token is provided, it would have been impossible for post-change
copying of the data to take place in the BLOCK.  This allows it to
happen by dint of pointers.

Also did some bikeshedding in mdoc_term.c: checking against enum type
and explicitly casting to the "post" function to void.  This is for my
own readability.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.89 2010/07/01 14:34:03 kristaps Exp $ */
d739 51
a789 1
	struct htmlpair	tag;
d791 2
a792 2
	if (NULL == n->child && NULL == m->name)
		return(1);
d794 8
a801 1
	synopsis_pre(h, n);
a802 4
	PAIR_CLASS_INIT(&tag, "name");
	print_otag(h, TAG_SPAN, 1, &tag);
	if (NULL == n->child)
		print_text(h, m->name);
@


1.89
log
@More reality-checks for the p->end type.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.88 2010/06/29 19:20:38 schwarze Exp $ */
d1041 3
a1043 2
	type = bl->data.Bl.type;
	comp = bl->data.Bl.comp;
d1045 2
a1046 2
	if (bl->data.Bl.offs)
		a2offs(bl->data.Bl.offs, &offs);
d1063 2
a1064 2
	if (bl->data.Bl.width)
		a2width(bl->data.Bl.width, &width);
d1122 2
a1123 1
	if (LIST_enum != n->data.Bl.type)
d1147 1
a1147 1
	if (LIST_enum != n->data.Bl.type)
d1362 3
a1364 2
	if (n->data.Bd.offs)
		a2offs(n->data.Bd.offs, &su);
d1366 1
a1366 1
	comp = n->data.Bd.comp;
d1393 2
a1394 2
	if (DISP_unfilled != n->data.Bd.type && 
			DISP_literal != n->data.Bd.type)
@


1.88
log
@Support for badly nested blocks, written around the time of
the Rostock mandoc hackathon and tested and polished since,
supporting constructs like:

.Ao Bo    Ac    Bc        (exp breaking exp)
.Aq Bo    eol   Bc        (imp breaking exp)
.Ao Bq    Ac    eol       (exp breaking imp)
.Ao Bo So Bc    Ac  Sc    (double break, inner before outer)
.Ao Bo So Ac    Bc  Sc    (double break, outer before inner)
.Ao Bo    Ac So Bc  Sc    (broken breaker)
.Ao Bo So Bc Do Ac  Sc Dc (broken double breaker)

There are still two known issues which are tricky:

1) Breaking two identical explicit blocks (Ao Bo Bo Ac or Aq Bo Bo eol)
fails outright, triggering a bogus syntax error.
2) Breaking a block by two identical explicit blocks (Ao Ao Bo Ac Ac Bc
or Ao Ao Bq Ac Ac eol) still has a minor rendering error left:
"<ao1 <ao2 [bo ac2> ac1> bc]>" should not have the final ">".

We can fix these later in the tree, let's not grow this diff too large.

"get it in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.87 2010/06/27 16:18:13 kristaps Exp $ */
d440 1
a440 1
		if (mdocs[n->tok].pre && !n->end)
d456 1
a456 1
		if (mdocs[n->tok].post && !n->end)
@


1.87
log
@Following clue-stick applied by schwarze@@, back out const-ness of regset
passed in to libmdoc and libman.

Fix mdoc.3 and man.3 EXAMPLE sections to include regset.

Add MDOC_SYNPRETTY flag cueing front-end to nicely format certain values
as if SEC_SYNOPSIS were the current section.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.86 2010/06/26 15:36:37 kristaps Exp $ */
d440 1
a440 1
		if (mdocs[n->tok].pre)
d456 1
a456 1
		if (mdocs[n->tok].post)
@


1.86
log
@Churn-ish check-in getting mdoc_parseln() and man_parseln() to accept a
const struct regset pointer.  No functionality.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.85 2010/06/19 20:46:28 kristaps Exp $ */
d307 1
a307 1
	if (NULL == n->prev || SEC_SYNOPSIS != n->sec)
d1617 1
a1617 1
	if (SEC_SYNOPSIS == n->sec) {
d1647 1
a1647 1
		if (SEC_SYNOPSIS == n->sec)
d1657 1
a1657 1
	if (SEC_SYNOPSIS == n->sec)
d1827 1
a1827 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
@


1.85
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.84 2010/06/13 21:41:58 kristaps Exp $ */
d33 1
@


1.84
log
@Switch on cached -width usage in front-ends.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.83 2010/06/12 12:38:01 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.83
log
@Cached `Bl -offset' into mdoc_bl.  Removed erroneous "-offset defaults
to 6n if no value is specified" and added regression tests for `Bl'
testing against the empty -offset argument.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.82 2010/06/12 12:10:55 kristaps Exp $ */
d1061 3
a1069 3
		case (MDOC_Width):
			a2width(bl->args->argv[i].value[0], &width);
			break;
@


1.82
log
@Moved `Bl -compact' into cached data.  This allowed the removal of
scanning the argv list in print_bvspace(), and thus the parent pointer.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.81 2010/06/12 11:58:22 kristaps Exp $ */
d1038 2
d1043 2
a1044 3
	/* Set default width and offset. */

	SCALE_HS_INIT(&offs, 0);
a1060 2
	/* Get width, offset, and compact arguments. */

a1069 3
		case (MDOC_Offset):
			a2offs(bl->args->argv[i].value[0], &offs);
			break;
@


1.81
log
@`Bl' is now using a struct instead of a single enum mdoc_list for its
cached values.  You can probably guess where this is going.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.80 2010/06/12 11:21:44 kristaps Exp $ */
d1039 1
d1063 1
a1063 1
	for (comp = i = 0; bl->args && i < (int)bl->args->argc; i++) 
a1073 3
		case (MDOC_Compact):
			comp = 1;
			break;
@


1.80
log
@Cache all of `Bd's resolved arguments into mdoc_bd, which is stashed in
the "data" union in mdoc_node.  Allows me to remove some ugly loops in
the front-end and duplicate tests in mdoc_action.c.  Add a regression
test to make sure we're not doing anything bad (more to come).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.79 2010/06/12 10:09:19 kristaps Exp $ */
d1038 1
a1038 1
	type = bl->data.list;
d1126 1
a1126 1
	if (LIST_enum != n->data.list)
d1150 1
a1150 1
	if (LIST_enum != n->data.list)
@


1.79
log
@Added enum mdoc_disp (similar to enum mdoc_list).  Display types are now
only calculated once in mdoc_validate.c.

Noted that `Bd -file xxx' is not supported:  it now raises a fatal
warning.  This is noted in mdoc.7.

Empty `Bd' now defaults to LIST_ragged, which is not quite what groff
does, but close enough (gross just throws away the `Bd' and gets upset
when it encounters an `Ed').
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.78 2010/06/07 11:01:15 kristaps Exp $ */
d1356 2
a1357 2
	int		 	 comp, i;
	const struct mdoc_node	*bl, *nn;
d1360 1
a1360 3
	if (MDOC_BLOCK == n->type)
		bl = n;
	else if (MDOC_HEAD == n->type)
a1361 2
	else
		bl = n->parent;
d1365 4
a1368 12
	comp = 0;
	for (i = 0; bl->args && i < (int)bl->args->argc; i++) 
		switch (bl->args->argv[i].arg) {
		case (MDOC_Offset):
			a2offs(bl->args->argv[i].value[0], &su);
			break;
		case (MDOC_Compact):
			comp = 1;
			break;
		default:
			break;
		}
d1395 2
a1396 2
	if (DISP_unfilled != n->data.disp && 
			DISP_literal != n->data.disp)
@


1.78
log
@Normalise SYNOPSIS behaviour after I gave up on following groff's
inconsistent behaviour.  In short:

       Some macros are displayed differently in the SYNOPSIS
       section, particularly Nm, Cd, Fd, Fn, Fo, In, Vt, and Ft.
       All of these macros are output on their own line.  If two
       such dissimilar macros are pair-wise invoked (except for Ft
       before Fo or Fn), they are separated by a vertical space,
       unless in the case of Fo, Fn, and Ft, which are always
       separated by vertical space.

Behaviour ok Jason McIntyre, ingo@@.  Fallout will be treated
case-by-case.

I had to clear out some regressions that were testing against groff's
stranger behaviours: these will now break, as we don't care about such
invocations.

Also removed the newline for `Cd' invocation in a non-SYNOPSIS context.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.77 2010/06/06 10:50:56 kristaps Exp $ */
d1356 1
a1356 1
	int		 	 type, comp, i;
d1369 1
a1369 1
	type = comp = 0;
a1377 11
		case (MDOC_Centred):
			/* FALLTHROUGH */
		case (MDOC_Ragged):
			/* FALLTHROUGH */
		case (MDOC_Filled):
			/* FALLTHROUGH */
		case (MDOC_Unfilled):
			/* FALLTHROUGH */
		case (MDOC_Literal):
			type = bl->args->argv[i].arg;
			break;
d1407 2
a1408 1
	if (MDOC_Unfilled != type && MDOC_Literal != type)
@


1.77
log
@Fixed -Tascii and -Thtml rendering of `Ft' and `Fo'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.76 2010/06/04 22:26:13 kristaps Exp $ */
d56 2
a88 1
static	void		  mdoc_fd_post(MDOC_ARGS);
d163 1
a163 1
	{mdoc_fd_pre, mdoc_fd_post}, /* Fd */ 
d298 49
d743 1
a743 6
	if (SEC_SYNOPSIS == n->sec && 
			n->prev && MDOC_LINE & n->flags) {
		bufcat_style(h, "clear", "both");
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_BR, 1, &tag);
	}
a748 1

d1485 1
a1485 1
	print_otag(h, TAG_DIV, 0, NULL);
a1557 9
static void
mdoc_fd_post(MDOC_ARGS)
{

	print_otag(h, TAG_BR, 0, NULL);
}


/* ARGSUSED */
d1563 2
a1575 1
	struct roffsu	 su;
d1577 2
a1578 9
	if (SEC_SYNOPSIS == n->sec && MDOC_BLOCK == n->type) {
		if (n->next && MDOC_Vt != n->next->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
		
d1580 2
d1597 1
a1597 3
	if (SEC_SYNOPSIS == n->sec && n->prev)
		print_otag(h, TAG_BR, 0, NULL);

a1613 1
	struct roffsu		 su;
d1615 1
a1615 13
	/* NB: MDOC_LINE has no effect on this macro! */
	if (SEC_SYNOPSIS == n->sec) {
		SCALE_HS_INIT(&su, INDENT);
		bufcat_su(h, "margin-left", &su);
		su.scale = -su.scale;
		bufcat_su(h, "text-indent", &su);
		if (n->prev && MDOC_Ft != n->prev->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-top", &su);
		} 
		PAIR_STYLE_INIT(&tag[0], h);
		print_otag(h, TAG_DIV, 1, tag);
	}
a1800 1
	struct roffsu	 su;
d1809 1
a1809 10
		if (SEC_SYNOPSIS != n->sec)
			return(1);
		if (NULL == n->prev || MDOC_Ft == n->prev->tok) {
			print_otag(h, TAG_DIV, 0, NULL);
			return(1);
		}
		SCALE_VS_INIT(&su, 1);
		bufcat_su(h, "margin-top", &su);
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
d1830 1
d1849 2
a1876 3
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) 
		print_otag(h, TAG_BR, 0, NULL);

@


1.76
log
@Fix following the first: `Ft' is given special treatment if specified before
`Fn'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.75 2010/06/04 22:16:27 kristaps Exp $ */
d1250 1
a1250 1
	SCALE_VS_INIT(&su, INDENT - 1);
d1566 2
a1567 2
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags)
		print_otag(h, TAG_DIV, 0, NULL);
a1596 4
		if (n->next) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
		}
d1784 3
a1786 2
	struct htmlpair	tag;
	struct roffsu	su;
d1793 7
a1799 1
	} else if (MDOC_BLOCK == n->type && n->next) {
d1801 1
a1801 1
		bufcat_su(h, "margin-bottom", &su);
d1807 5
d1813 4
a1816 2
	print_otag(h, TAG_SPAN, 1, &tag);
	return(1);
@


1.75
log
@Fixed `Fn' newline behaviour and added some regression tests to this
extent.

Documented `Fn'.  Please note the COMPATIBILITY note regarding historic
groff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.74 2010/06/04 21:49:39 kristaps Exp $ */
d1593 4
@


1.74
log
@Documented `In' in full.

Fixed `In' to behave properly: it wasn't properly breaking lines,
formatting, or really anything else.  Noted COMPATIBILITY with
OpenBSD's groff, which pukes all over `In'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.73 2010/06/04 21:05:39 kristaps Exp $ */
d1587 2
a1588 1
	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
@


1.73
log
@Fixed `Fd' to format in the right way.  Found when confused by what the
hell `Fd' is supposed to do anyway (answer: it's a historical macro and
we shouldn't be doing anything with it anyway).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.72 2010/06/03 13:44:36 kristaps Exp $ */
a1825 13
	struct roffsu		 su;

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
		if (n->next && MDOC_In != n->next->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag[0], h);
			print_otag(h, TAG_DIV, 1, tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}

	/* FIXME: there's a buffer bug in here somewhere. */
d1830 1
a1830 1
	if (SEC_SYNOPSIS == n->sec)
a1835 2
	/* XXX -- see warning in termp_in_post(). */

d1853 3
@


1.72
log
@Consolidated list processing to a single loop in mdoc_validate.c.  This
relieves having to repeat running over the argument list in
mdoc_action.c and mdoc_validate.c.

Default to LIST_item for type-less lists (groff technically doesn't do
this: it just ignores the `It' lines altogether).

Make MANDOC_LISTTYPE be a recoverable error.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.71 2010/05/31 10:28:04 kristaps Exp $ */
d87 1
d162 1
a162 1
	{mdoc_fd_pre, NULL}, /* Fd */ 
d1514 9
a1526 11
	struct roffsu	 su;

	if (SEC_SYNOPSIS == n->sec && MDOC_LINE & n->flags) {
		if (n->next && MDOC_Fd != n->next->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-bottom", &su);
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}
@


1.71
log
@Remove enum mdocargerr from phrase() (unused).

Add `Ta' macro, which is basically a NULL case everywhere but in
mdoc_macro.c, where it closes out an existing `It' body scope and opens
a new one, then continues parsing as in phrase() (TODO: merge these
two?).

Fix where scope-breaking was silently just dying instead of printing an
error.

Fix where trailing `Ta' or tab weren't creating a new MDOC_BODY context.

We now support arbitrarily complex `It' contents for `Bl -column'.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.70 2010/05/30 22:56:02 kristaps Exp $ */
a834 1
	assert(nn->args);
d1016 2
a1017 1
	for (wp = -1, comp = i = 0; i < (int)bl->args->argc; i++) 
d1325 1
a1325 1
	for (i = 0; i < (int)bl->args->argc; i++) 
d2000 1
a2000 2
		assert(n->args);
		for (i = 0; i < (int)n->args->argc; i++) 
@


1.70
log
@Migrate `Bl -column' phrases to be MDOC_BODY instead of MDOC_HEAD.  This
will make it easy for re-entrant parsing of `Ta' macros to fit in with
standard closure rules.

Added some more regressions for `Bl -column'.  Note that one should
fail, as documented in the TODO file.

Recorded change of AST BNF in mdoc.3.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.69 2010/05/29 18:58:52 kristaps Exp $ */
d258 1
@


1.69
log
@Moved printing of empty word [back] into mdoc_action.c so that it's not
mirrored across front-ends.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.68 2010/05/29 18:47:54 kristaps Exp $ */
d103 2
a104 1
static	int		  mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list);
d881 1
a881 1
mdoc_it_body_pre(MDOC_ARGS, enum mdoc_list type)
d892 6
a929 6
		bufcat_su(h, "min-width", width);
		bufcat_style(h, "clear", "none");
		if (n->next && MDOC_HEAD == n->next->type)
			bufcat_style(h, "float", "left");
		PAIR_STYLE_INIT(&tag, h);
		print_otag(h, TAG_DIV, 1, &tag);
d1052 1
a1052 11
	/* Flip to body/block processing. */

	if (MDOC_BODY == n->type)
		return(mdoc_it_body_pre(m, n, h, type));
	if (MDOC_BLOCK == n->type)
		return(mdoc_it_block_pre(m, n, h, type, comp,
					&offs, &width));

	/* Override column widths. */

	if (LIST_column == type) {
d1054 3
a1056 2
		for (i = 0; nn && nn != n; nn = nn->next, i++)
			/* Counter... */ ;
d1061 6
a1066 1
	return(mdoc_it_head_pre(m, n, h, type, &width));
@


1.68
log
@Commit of patch floated on discuss@@ a few days ago: if an in_line scope
has not been opened and closing punctuation is encountered AND the macro
is marked as accepting no-content (or `Li'), then open an empty scope.

Added regression tests for `Fl' and `Li' testing this behaviour.

Also, squeeze hyph0.in tests into the last characters of each line so
that groff doesn't hyphenate and break the test.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.67 2010/05/24 12:17:09 kristaps Exp $ */
a2093 2
	if (NULL == n->child)
		print_text(h, "");
@


1.67
log
@Fix segfault in mixing old enum types for -Thtml -mdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.66 2010/05/17 23:57:06 kristaps Exp $ */
d2094 2
@


1.66
log
@Increase performance by stashing the list type in struct mdoc_node.
This will eventually be used so that mdoc_macro can known whether to
dump list line arguments into the body (`Bl -column' overflowing).

Remove a2list() and arg_listtype() because of this.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.65 2010/05/17 22:11:42 kristaps Exp $ */
d1083 1
a1083 1
	if (MDOC_Enum != n->data.list)
d1107 1
a1107 1
	if (MDOC_Enum != n->data.list)
@


1.65
log
@Enable the unified error/warning enumeration in mandoc.h that's
stringified in main.c.

Allow `An' to handle an argument and child (with a warning).

Allow `Rv' and `Ex' to work without a prior `Nm' as groff does (with a
warning).

Allow inconsistent column syntax to only raise a warning.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.64 2010/05/17 02:38:13 kristaps Exp $ */
a59 2
static	int		  a2list(const struct mdoc_node *);

d99 3
a101 3
static	int		  mdoc_it_block_pre(MDOC_ARGS, int, int,
				struct roffsu *, struct roffsu *);
static	int		  mdoc_it_head_pre(MDOC_ARGS, int, 
d103 1
a103 1
static	int		  mdoc_it_body_pre(MDOC_ARGS, int);
a277 44
 * Return the list type for `Bl', e.g., `Bl -column' returns 
 * MDOC_Column.  This can ONLY be run for lists; it will abort() if no
 * list type is found. 
 */
static int
a2list(const struct mdoc_node *n)
{
	int		 i;

	assert(n->args);
	for (i = 0; i < (int)n->args->argc; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	abort();
	/* NOTREACHED */
}


/*
d825 1
a825 1
mdoc_it_block_pre(MDOC_ARGS, int type, int comp,
d837 1
a837 1
	if (MDOC_Column == type) {
d843 1
a843 1
	if (MDOC_Diag == type)
d880 1
a880 1
mdoc_it_body_pre(MDOC_ARGS, int type)
d886 1
a886 1
	case (MDOC_Item):
d888 1
a888 1
	case (MDOC_Ohang):
d890 1
a890 1
	case (MDOC_Column):
d910 1
a910 1
mdoc_it_head_pre(MDOC_ARGS, int type, struct roffsu *width)
d917 1
a917 1
	case (MDOC_Item):
d919 1
a919 1
	case (MDOC_Ohang):
d922 1
a922 1
	case (MDOC_Column):
d946 1
a946 1
	case (MDOC_Diag):
d950 1
a950 1
	case (MDOC_Enum):
d957 1
a957 1
	case (MDOC_Dash):
d960 1
a960 1
	case (MDOC_Hyphen):
d963 1
a963 1
	case (MDOC_Bullet):
d977 1
a977 1
	int			 i, type, wp, comp;
d980 1
d992 1
a992 1
	type = a2list(bl);
d999 1
a999 1
	case (MDOC_Enum):
d1001 1
a1001 1
	case (MDOC_Dash):
d1003 1
a1003 1
	case (MDOC_Hyphen):
d1005 1
a1005 1
	case (MDOC_Bullet):
d1036 1
a1036 1
	case (MDOC_Ohang):
d1038 1
a1038 1
	case (MDOC_Item):
d1040 1
a1040 1
	case (MDOC_Inset):
d1042 1
a1042 1
	case (MDOC_Diag):
d1061 1
a1061 1
	if (MDOC_Column == type) {
d1083 1
a1083 1
	if (MDOC_Enum != a2list(n))
d1107 1
a1107 1
	if (MDOC_Enum != a2list(n))
@


1.64
log
@Documented ie/el.
Installing roff.7 and added it to index.sgml.
Small fix for `D1' and `Bd' in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.63 2010/05/15 16:24:38 kristaps Exp $ */
d30 1
d733 3
d1188 1
a1188 1
	if (n->child->next)
d1958 1
a1958 1
	if (n->child->next)
@


1.63
log
@LIBRARY can also occur in section 9.
All manual sections (unknown, 3p, 3f, etc.) correctly handled by -mdoc.
Useful warning printed if unknown manual section.
Checking for manual sections (e.g., LIBRARY) checks only first character, so 3p, 3f, etc. are free.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.62 2010/05/13 06:22:11 kristaps Exp $ */
d1292 1
a1292 1
	SCALE_VS_INIT(&su, INDENT - 2);
d1405 2
a1406 1
			print_otag(h, TAG_DIV, 0, tag);
@


1.62
log
@Fixed bug in -Thtml -mdoc where `Lb' would line-break in LIBRARY section.
Fixed assumption that parse-point == 1 equates to beginning of line (false if whitespace separates macro and control character).
Fixed line-break for non-first-macro in several SYNOPSIS macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.61 2010/04/08 08:17:55 kristaps Exp $ */
d390 1
a390 1
	buffmt(h, "%s(%d)", m->title, m->msec);
d512 1
a512 1
			"%s(%d)", m->title, m->msec);
@


1.61
log
@Fixed %T: it now correctly underlines, instead of quoting (noted by Jason McIntyre and posted on Ingo Schwarze' mandoc-todo list).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.60 2010/04/07 07:49:38 kristaps Exp $ */
d732 2
a733 1
	if (SEC_SYNOPSIS == n->sec && n->prev) {
d1561 1
a1561 1
	if (SEC_SYNOPSIS == n->sec) {
d1609 1
a1609 1
	if (SEC_SYNOPSIS == n->sec)
d1630 1
a1630 1
	if (SEC_SYNOPSIS == n->sec) {
d1871 1
a1871 1
	if (SEC_SYNOPSIS == n->sec) {
d2176 1
a2176 1
	if (SEC_SYNOPSIS == n->sec)
@


1.60
log
@Bug in printing of reserved words with form \*[xxx] fixed (found by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.59 2010/04/06 11:28:17 kristaps Exp $ */
a2224 2
		print_text(h, "\\(lq");
		h->flags |= HTML_NOSPACE;
d2253 2
a2255 8
	switch (n->tok) {
	case (MDOC__T):
		print_text(h, "\\(rq");
		h->flags |= HTML_NOSPACE;
		break;
	default:
		break;
	}
@


1.59
log
@Let `Bl' accept arguments on the head line with a warning (these are ignored in the front-end device) (noted by Theo de Raadt).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.58 2010/04/06 07:27:42 kristaps Exp $ */
d1391 1
@


1.58
log
@`Fl' now correctly suppresses the trailing space if followed by macros on the same line.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.57 2010/04/05 08:51:56 kristaps Exp $ */
d1119 2
@


1.57
log
@Fix in `Mt' mailto from a patch by Tim van der Molen.
Fixed PAIR_xxx_INIT macros -- this are to be unified.
Have `Vt', `Fn', `Ft', and `Fo' print whitespace afterward, instead of before.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.56 2010/04/03 14:25:12 kristaps Exp $ */
a668 2
	/* A blank `Fl' should incur a subsequent space. */

d671 2
@


1.56
log
@Merged patch by Ingo Schwarze allowing `Xr' to pass through with no arguments (emits warning of course).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.55 2010/03/29 19:28:04 kristaps Exp $ */
d592 2
a593 4
	/* 
	 * TODO: make sure there are no duplicates, as HTML does not
	 * allow for multiple `id' tags of the same name.
	 */
a594 3
	PAIR_CLASS_INIT(&tag[0], "sec-head");
	tag[1].key = ATTR_ID;
	tag[1].val = buf;
d646 2
a647 2
	tag[2].key = ATTR_ID;
	tag[2].val = buf;
d763 1
a763 2
		tag[1].key = ATTR_HREF;
		tag[1].val = h->buf;
a1305 2
	/* FIXME: duplicates? */

d1314 1
a1314 2
	tag[1].key = ATTR_HREF;
	tag[1].val = buf;
d1580 2
a1581 2
	if (MDOC_BLOCK == n->type) {
		if (n->prev && MDOC_Vt != n->prev->tok) {
d1583 1
a1583 1
			bufcat_su(h, "margin-top", &su);
d1588 1
a1588 1

a1603 1
	struct roffsu	 su;
d1605 2
a1606 9
	if (SEC_SYNOPSIS == n->sec) {
		if (n->prev && MDOC_Fo == n->prev->tok) {
			SCALE_VS_INIT(&su, 1);
			bufcat_su(h, "margin-top", &su);
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
	}
d1660 17
d1680 1
a1680 1
		(void)strlcpy(nbuf, sp, BUFSIZ);
d1781 1
a1781 2
	tag[1].key = ATTR_HREF;
	tag[1].val = nn->string;
d1808 1
a1808 1
		PAIR_STYLE_INIT(&tag[1], h);
d1823 1
d1830 5
a1834 1
	} else if (MDOC_BLOCK == n->type)
d1836 1
d1896 2
a1897 2
			tag[i].key = ATTR_HREF;
			tag[i++].val = h->buf;
@


1.55
log
@Integrate Ingo Schwarze's patch for mdoc_iscdelim() (tri-state for opening and closing macro punctuation).
Modify blk_part_exp() to correctly handle leading punctuation before HEAD.
Significantly clean up and document blk_part_exp().
Modify blk_part_imp() for to correctly handle leading punctuation before HEAD.
Significantly clean up and document blk_part_imp().
Integrate Ingo Schwarze's patch for args() (using new mdoc_iscdelim() format).
Documented bad `Ec' handling for later work in mdoc_term.c/mdoc_html.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.54 2010/01/30 08:42:20 kristaps Exp $ */
d759 3
@


1.54
log
@Fix in handling Vt in SYNOPSIS with trailing punctuation.  Spotted by Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.53 2010/01/29 14:39:38 kristaps Exp $ */
d203 1
a203 1
	{NULL, NULL}, /* Ec */
@


1.53
log
@Fixed Makefile for `make lint' dep. on config.h
Added -Txhtml for XHTML output (minimal increase to programme logic).  Because groff has it and it bothers me that we don't.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.52 2010/01/01 17:14:29 kristaps Exp $ */
d1586 1
a1586 1
	if (SEC_SYNOPSIS == n->sec) {
d1594 4
a1597 1
	}
@


1.52
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.51 2010/01/01 13:35:30 kristaps Exp $ */
d269 1
a269 1
	print_gen_doctype(h);
@


1.51
log
@Documented `Fl' in mdoc.7.
Backed out stipulation that `Fl ""' is ignored: this is not the case in !OpenBSD groffs.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.50 2010/01/01 13:17:58 kristaps Exp $ */
d17 4
a21 1
#include <sys/param.h>
d42 4
a135 5
#ifdef __linux__
extern	size_t	  	  strlcpy(char *, const char *, size_t);
extern	size_t	  	  strlcat(char *, const char *, size_t);
#endif

@


1.50
log
@`Fl' has each argument be in a separate scope (thanks Ingo Schwarze).
Situation of `Fl [arg]* "" [arg]*' is fixed: empty arguments are ignored.  Note that OpenBSD crashes when this happens.
Situation of `Fl' is fixed wrt trailing whitespace.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.49 2009/12/02 10:16:55 kristaps Exp $ */
d662 3
d667 1
a667 3
	if (MDOC_Cm == n->tok) {
		PAIR_CLASS_INIT(&tag, "flag");
		print_otag(h, TAG_SPAN, 1, &tag);
a668 13
	}

	/* A zero-length child shouldn't get a dash. */

	if (n->child) {
		assert(MDOC_TEXT == n->child->type);
		assert(n->child->string);
		if ('\0' == *n->child->string)
			return(0);
	}

	PAIR_CLASS_INIT(&tag, "flag");
	print_otag(h, TAG_SPAN, 1, &tag);
@


1.49
log
@Fixed handling of exampledir (pointed out by Ulrich Sporlein, forgotten, discovered again).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.48 2009/11/16 08:46:59 kristaps Exp $ */
d662 17
d681 6
a686 2
	if (MDOC_Fl == n->tok) {
		print_text(h, "\\-");
d688 1
a688 1
	}
@


1.48
log
@Enabled -Thtml -mdoc to work with \f (see compat notes in mandoc.1).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.47 2009/11/14 12:04:59 kristaps Exp $ */
d1576 1
a1576 1
		if (n->next && MDOC_Vt != n->next->tok) {
d1578 1
a1578 1
			bufcat_su(h, "margin-bottom", &su);
@


1.47
log
@Removed superfluous HTML_NEWLINE.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.46 2009/10/31 08:34:12 kristaps Exp $ */
d427 1
a427 1
		break;
a443 2
	case (MDOC_TEXT):
		break;
@


1.46
log
@Fixed -Thtml printing of -ohang lists (-mdoc).
Fixed validation of -ohang lists as having no widths.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.45 2009/10/31 06:50:25 kristaps Exp $ */
d728 5
a732 6
	if ( ! (HTML_NEWLINE & h->flags))
		if (SEC_SYNOPSIS == n->sec) {
			bufcat_style(h, "clear", "both");
			PAIR_STYLE_INIT(&tag, h);
			print_otag(h, TAG_BR, 1, &tag);
		}
@


1.45
log
@Patch on DragonFly BSD syntax (thanks Sascha Wildner).
Noted inclusion into DragonFly BSD (thanks Sascha Wildner).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.44 2009/10/31 06:10:58 kristaps Exp $ */
d954 1
a954 1
		/* FALLTHROUGH */
d956 2
a957 1
		return(0);
d1071 2
@


1.44
log
@Using perror() instead of fprintf for failure from library functions.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.43 2009/10/30 18:53:08 kristaps Exp $ */
d813 1
a813 1
		pp = "DragonFlyBSD";
@


1.43
log
@More lint fixes.
Removed err.h from inclusions (less main.c--still in progress).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.42 2009/10/28 08:00:18 kristaps Exp $ */
d1118 1
a1118 1
		fprintf(stderr, "memory exhausted\n");
@


1.42
log
@Fixed `sp', `br', `Pp', etc. so as not to have an empty div (-Thtml, -man, -mdoc).
Made html_idcat be completely correct (messy standard) (-Thtml).
Fixed warnings about -ohang and -item lists (-Thtml, -mdoc).
Fixed typo in index.sgml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.41 2009/10/28 05:08:17 kristaps Exp $ */
a21 1
#include <err.h>
d1117 4
a1120 2
	if (NULL == ord)
		err(EXIT_FAILURE, "malloc");
@


1.41
log
@Fixed un-reset buffer in `.In', -Thtml, -mdoc.
Added html_id[cat,cpy] for transforming id's into well-formed attribute strings (no %s, etc.).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.40 2009/10/27 04:50:15 kristaps Exp $ */
d586 1
a586 1
	html_idcpy(buf, "id_", BUFSIZ);
d590 1
a590 1
			html_idcat(buf, "_", BUFSIZ);
d639 1
a639 1
	html_idcpy(buf, "id_", BUFSIZ);
d643 1
a643 1
			html_idcat(buf, "_", BUFSIZ);
d957 1
a957 2
		print_otag(h, TAG_DIV, 0, NULL);
		break;
a1299 1
	html_idcat(buf, "id_", BUFSIZ);
d1303 1
a1303 1
			html_idcat(buf, "_", BUFSIZ);
d1720 4
a1723 1
	return(1);
@


1.40
log
@Added "summary" tag to tables in order to silence HTML-tidy's complaints.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.39 2009/10/26 08:18:16 kristaps Exp $ */
d559 1
a559 1
	char			 lbuf[BUFSIZ];
d586 1
a586 1
	lbuf[0] = 0;
d588 1
a588 1
		(void)strlcat(lbuf, nn->string, BUFSIZ);
d590 1
a590 1
			(void)strlcat(lbuf, "_", BUFSIZ);
d600 1
a600 1
	tag[1].val = lbuf;
d612 1
a612 1
	char			 lbuf[BUFSIZ];
d639 1
a639 1
	lbuf[0] = 0;
d641 1
a641 1
		(void)strlcat(lbuf, nn->string, BUFSIZ);
d643 1
a643 1
			(void)strlcat(lbuf, "_", BUFSIZ);
d653 1
a653 1
	tag[2].val = lbuf;
d1300 2
a1301 1
	(void)strlcpy(buf, "#", BUFSIZ);
d1303 1
a1303 1
		(void)strlcat(buf, nn->string, BUFSIZ);
d1305 1
a1305 1
			(void)strlcat(buf, "_", BUFSIZ);
d1869 1
@


1.39
log
@Portability: replaced queue macros in html.c (Joerg Sonnenberger).
Fixed "-o" residue.
Added "-O" to usage() (-o didn't appear there either).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.38 2009/10/26 04:09:45 kristaps Exp $ */
d459 1
a459 1
	struct htmlpair	 tag[2];
d474 3
a476 1
	t = print_otag(h, TAG_TABLE, 2, tag);
d500 1
a500 1
	struct htmlpair	 tag[2];
d520 4
a523 1
	t = print_otag(h, TAG_TABLE, 2, tag);
@


1.38
log
@Full `%U' support.
`Lk' display fixed.
Renamed arg2xxxx as a2xxxx for consistency.
Renamed print_foot to print_man_foot for consistency.
Removed default printing of `~' when `Lk' not provided (not sure where I got that from).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.37 2009/10/24 05:52:13 kristaps Exp $ */
a18 1
#include <sys/queue.h>
d419 1
a419 1
	t = SLIST_FIRST(&h->tags);
d983 1
a983 1
		ord = SLIST_FIRST(&h->ords);
d1118 2
a1119 1
	SLIST_INSERT_HEAD(&h->ords, ord, entry);
d1135 1
a1135 1
	ord = SLIST_FIRST(&h->ords);
d1137 1
a1137 1
	SLIST_REMOVE_HEAD(&h->ords, entry);
@


1.37
log
@Added `%U' to -mdoc (doesn't render in a nice way yet).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.36 2009/10/22 18:55:32 kristaps Exp $ */
d1760 3
d2153 1
a2153 3
	struct htmlpair	tag;

	/* TODO: %U. */
d2157 1
a2157 1
		PAIR_CLASS_INIT(&tag, "ref-auth");
d2160 1
a2160 1
		PAIR_CLASS_INIT(&tag, "ref-book");
d2163 1
a2163 1
		PAIR_CLASS_INIT(&tag, "ref-city");
d2166 1
a2166 1
		PAIR_CLASS_INIT(&tag, "ref-date");
d2169 1
a2169 1
		PAIR_CLASS_INIT(&tag, "ref-issue");
d2172 1
a2172 1
		PAIR_CLASS_INIT(&tag, "ref-jrnl");
d2175 1
a2175 1
		PAIR_CLASS_INIT(&tag, "ref-num");
d2178 1
a2178 1
		PAIR_CLASS_INIT(&tag, "ref-opt");
d2181 1
a2181 1
		PAIR_CLASS_INIT(&tag, "ref-page");
d2184 1
a2184 1
		PAIR_CLASS_INIT(&tag, "ref-corp");
d2187 1
a2187 1
		PAIR_CLASS_INIT(&tag, "ref-rep");
d2190 1
a2190 1
		PAIR_CLASS_INIT(&tag, "ref-title");
d2194 3
d2198 1
a2198 1
		PAIR_CLASS_INIT(&tag, "ref-vol");
d2205 7
a2211 1
	print_otag(h, TAG_SPAN, 1, &tag);
@


1.36
log
@Fixed maddening mismatch between groff and strftime mismatch of day ("%e").  Noted by Ulrich Sporlein.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.35 2009/10/20 05:45:21 kristaps Exp $ */
d257 1
d2152 2
@


1.35
log
@More updates to mdoc.7.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.34 2009/10/19 11:02:24 kristaps Exp $ */
a458 1
	struct tm	 tm;
d461 3
a463 1
	char		 b[BUFSIZ];
a470 5
	(void)localtime_r(&m->date, &tm);

	if (0 == strftime(b, BUFSIZ - 1, "%B %e, %Y", &tm))
		err(EXIT_FAILURE, "strftime");

@


1.34
log
@Continued work on mdoc.7.
Noted buffer overwrite bug in -Thtml -mdoc (will fix later).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.33 2009/10/19 10:18:06 kristaps Exp $ */
d1277 2
d1294 1
a1294 1
	char			 lbuf[BUFSIZ];
d1298 1
a1298 1
	(void)strlcpy(lbuf, "#", BUFSIZ);
d1300 1
a1300 1
		(void)strlcat(lbuf, nn->string, BUFSIZ);
d1302 1
a1302 1
			(void)strlcat(lbuf, "_", BUFSIZ);
d1307 1
a1307 1
	tag[1].val = lbuf;
@


1.33
log
@Fixed -mdoc -Thtml with -item lists not to default-indent when width isn't specified.
Many more cleanups to mdoc.7 (ongoing completion and documentation of all macros).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.32 2009/10/18 19:03:37 kristaps Exp $ */
d1845 2
@


1.32
log
@Made sure devices and formats recognise that -man and -mdoc have different syntax for scaling widths: -mdoc assumes no unit means that the value is a string literal while -man instead uses the default vertical/horizontal scale.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.31 2009/10/18 11:14:04 kristaps Exp $ */
d1071 2
@


1.31
log
@Added horizontal scaling units to -Tman -Tascii.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.30 2009/10/15 01:33:12 kristaps Exp $ */
d330 4
a333 4
	if (a2roffsu(p, su))
		return;
	su->unit = SCALE_EM;
	su->scale = (int)strlen(p);
d354 1
a354 1
	else if ( ! a2roffsu(p, su)) {
@


1.30
log
@Added support for `Bd -centered', which appears in newer groffs (not yet implemented in centre-capable front-ends, i.e., -Thtml).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.29 2009/10/13 10:57:25 kristaps Exp $ */
d346 2
d1377 2
@


1.29
log
@Moved output definitions into main.h.
Pushed terminal_{mdoc,man} into {mdoc,man}_term.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.28 2009/10/10 10:05:12 kristaps Exp $ */
d1360 2
d1371 2
@


1.28
log
@`Cd' in -Thtml -mdoc correctly breaks lines.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.27 2009/10/08 23:00:15 kristaps Exp $ */
d32 1
@


1.27
log
@Consolidated some -man -Tascii functions.
Added many -man -Thtml functions (almost complete).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.26 2009/10/07 15:06:03 kristaps Exp $ */
d1458 1
@


1.26
log
@Lint-ified.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.25 2009/10/07 14:50:28 kristaps Exp $ */
d52 1
a56 6
static	int		  mdoc_it_block_pre(MDOC_ARGS, int, 
				struct roffsu *, int, 
				struct roffsu *);
static	int		  mdoc_it_head_pre(MDOC_ARGS, int, 
				struct roffsu *);
static	int		  mdoc_it_body_pre(MDOC_ARGS, int);
d94 5
d858 2
a859 2
mdoc_it_block_pre(MDOC_ARGS, int type, struct roffsu *offs, 
		int comp, struct roffsu *width)
d1084 2
a1085 2
		return(mdoc_it_block_pre(m, n, h, type, 
					&offs, comp, &width));
@


1.25
log
@Lint-ified.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.24 2009/10/07 14:39:00 kristaps Exp $ */
d1627 2
a1628 1
	if ((ep = strchr(sp, ' '))) {
@


1.24
log
@Made default string units (-Thtml -mdoc) to use `m' and not `n' scaling (better more than less).
Fixed -column widths for -Thtml -mdoc.
Fixed left-hand margin padding for -Thtml -mdoc.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.23 2009/10/07 12:35:24 kristaps Exp $ */
d555 1
a555 1
	char			 link[BUFSIZ];
d582 1
a582 1
	link[0] = 0;
d584 1
a584 1
		(void)strlcat(link, nn->string, BUFSIZ);
d586 1
a586 1
			(void)strlcat(link, "_", BUFSIZ);
d596 1
a596 1
	tag[1].val = link;
d608 1
a608 1
	char			 link[BUFSIZ];
d635 1
a635 1
	link[0] = 0;
d637 1
a637 1
		(void)strlcat(link, nn->string, BUFSIZ);
d639 1
a639 1
			(void)strlcat(link, "_", BUFSIZ);
d649 1
a649 1
	tag[2].val = link;
d911 1
d941 1
d1287 1
a1287 1
	char			 link[BUFSIZ];
d1291 1
a1291 1
	(void)strlcpy(link, "#", BUFSIZ);
d1293 1
a1293 1
		(void)strlcat(link, nn->string, BUFSIZ);
d1295 1
a1295 1
			(void)strlcat(link, "_", BUFSIZ);
d1300 1
a1300 1
	tag[1].val = link;
@


1.23
log
@Additions to -Tman -Thtml: all structural components tested & in place.
Fitted both -Thtml with handling of arbitrary vertical and horizontal scaling units (see groff(7)).  Undocumented until fitted into -Tascii (next release).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.22 2009/10/04 15:24:54 kristaps Exp $ */
d329 4
a332 2
	if ( ! a2roffsu(p, su))
		SCALE_HS_INIT(su, (int)strlen(p));
d351 4
a354 2
	else if ( ! a2roffsu(p, su))
		SCALE_HS_INIT(su, (int)strlen(p));
d680 2
a681 1
	/* XXX - this can contain block elements! */
d698 2
a699 1
	/* XXX - this can contain block elements! */
d868 8
a875 2
	if (MDOC_Column == type)
		comp = 0;
d877 1
d881 1
d889 2
d925 4
d967 2
d1012 5
a1016 1
	/* This is the `Bl' block parent. */
d1026 2
a1042 2
	SCALE_HS_INIT(&offs, 0);

d1047 3
a1050 1
			wp = i; /* Save offset. */
d1091 1
a1091 1
		if (wp >= 0 && i < (int)bl->args[wp].argv->sz)
d1346 2
a1352 1
			bufcat_su(h, "margin-left", &su);
d1369 1
@


1.22
log
@Structural components of -man -Thtml in place (note that HP is the same as IP, as HTML doesn't "do" this construction without fixed page widths).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.21 2009/10/04 09:00:40 kristaps Exp $ */
d29 1
d50 2
a51 2
static	int		  a2width(const char *);
static	int		  a2offs(const char *);
d56 6
a61 4
static	int		  mdoc_tbl_pre(MDOC_ARGS, int);
static	int		  mdoc_tbl_block_pre(MDOC_ARGS, int, int, int, int);
static	int		  mdoc_tbl_body_pre(MDOC_ARGS, int, int);
static	int		  mdoc_tbl_head_pre(MDOC_ARGS, int, int);
d276 5
a285 1
	assert(MDOC_BLOCK == n->type && MDOC_Bl == n->tok);
a286 1

d320 7
a326 2
static int
a2width(const char *p)
a327 7
	int		 i, len;

	if (0 == (len = (int)strlen(p)))
		return(0);
	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;
d329 2
a330 5
	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p) + 2);

	return(len + 2);
d334 7
a340 2
static int
a2offs(const char *p)
a341 1
	int		 len, i;
d344 7
a350 18
		return(0);
	if (0 == strcmp(p, "indent"))
		return(INDENT + 1);
	if (0 == strcmp(p, "indent-two"))
		return((INDENT + 1) * 2);

	if (0 == (len = (int)strlen(p)))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p));

	return(len);
a414 1

a433 1

d457 6
d468 3
a470 4
	tag[0].key = ATTR_CLASS;
	tag[0].val = "footer";
	tag[1].key = ATTR_STYLE;
	tag[1].val = "width: 100%;";
d474 3
a476 2
	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 50%;";
d481 4
a484 2
	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 50%; text-align: right;";
d510 5
a514 4
	tag[0].key = ATTR_CLASS;
	tag[0].val = "header";
	tag[1].key = ATTR_STYLE;
	tag[1].val = "width: 100%;";
d518 3
a520 2
	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 10%;";
d525 5
a529 2
	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 80%; white-space: nowrap; text-align: center;";
d534 4
a537 2
	tag[0].key = ATTR_STYLE;
	tag[0].val = "width: 10%; text-align: right;";
a540 1

d552 1
d555 4
a558 7
		buffmt(h, "margin-left: %dem;", INDENT);

		tag[0].key = ATTR_CLASS;
		tag[0].val = "sec-body";
		tag[1].key = ATTR_STYLE;
		tag[1].val = h->buf;

d562 1
a562 3
		tag[0].key = ATTR_CLASS;
		tag[0].val = "sec-block";

d567 3
a569 2

		bufcat(h, "margin-top: 1em;");
d571 1
a571 1
			bufcat(h, "margin-bottom: 1em;");
d573 1
a573 2
		tag[1].key = ATTR_STYLE;
		tag[1].val = h->buf;
d585 4
a588 1
	/* FIXME: make sure no duplicates! */
d590 1
a590 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = "sec-head";
a592 1

a602 1
	int		 	 i;
d605 1
d607 1
a607 1
	i = 0;
d610 1
a610 3
		tag[i].key = ATTR_CLASS;
		tag[i++].val = "ssec-body";

d612 5
a616 6
			bufcat(h, "margin-bottom: 1em;");
			tag[i].key = ATTR_STYLE;
			tag[i++].val = h->buf;
		}

		print_otag(h, TAG_DIV, i, tag);
d619 1
a619 3
		tag[i].key = ATTR_CLASS;
		tag[i++].val = "ssec-block";

d621 5
a625 6
			bufcat(h, "margin-top: 1em;");
			tag[i].key = ATTR_STYLE;
			tag[i++].val = h->buf;
		}

		print_otag(h, TAG_DIV, i, tag);
d629 2
d638 3
a640 3
	buffmt(h, "margin-left: -%dem;", INDENT - HALFINDENT);

	/* FIXME: make sure no duplicates! */
d642 2
a643 4
	tag[0].key = ATTR_CLASS;
	tag[0].val = "ssec-head";
	tag[1].key = ATTR_STYLE;
	tag[1].val = h->buf;
a645 1

d657 1
a657 3
	tag.key = ATTR_CLASS;
	tag.val = "flag";

d678 1
a678 2
	tag.key = ATTR_CLASS;
	tag.val = "desc-body";
d696 1
a696 2
	tag.key = ATTR_CLASS;
	tag.val = "opt";
d721 2
a722 2
			tag.key = ATTR_STYLE;
			tag.val = "clear: both;";
d726 1
a726 3
	tag.key = ATTR_CLASS;
	tag.val = "name";

a740 1
	int			 i;
d742 1
a742 3
	i = 0;
	tag[i].key = ATTR_CLASS;
	tag[i++].val = "link-man";
d745 2
a746 1
		buffmt_man(h, n->child->string, n->child->next ? 
d748 5
a752 5
		tag[i].key = ATTR_HREF;
		tag[i++].val = h->buf;
	}

	print_otag(h, TAG_A, i, tag);
a765 1

d786 1
a786 3
	tag.key = ATTR_CLASS;
	tag.val = "arg";

d822 1
a822 3
	tag.key = ATTR_CLASS;
	tag.val = "unix";

d836 1
a836 3
	tag.key = ATTR_CLASS;
	tag.val = "unix";

d852 2
a853 1
mdoc_tbl_block_pre(MDOC_ARGS, int t, int w, int o, int c)
d857 15
d873 9
a881 11
	switch (t) {
	case (MDOC_Column):
		/* FALLTHROUGH */
	case (MDOC_Item):
		/* FALLTHROUGH */
	case (MDOC_Ohang):
		buffmt(h, "margin-left: %dem; clear: both;", o);
		break;
	default:
		buffmt(h, "margin-left: %dem; clear: both;", w + o);
		break;
d884 3
a886 21
	if ( ! c && MDOC_Column != t) {
		for (nn = n; nn; nn = nn->parent) {
			if (MDOC_BLOCK != nn->type)
				continue;
			switch (nn->tok) {
			case (MDOC_Ss):
				/* FALLTHROUGH */
			case (MDOC_Sh):
				c = 1;
				break;
			default:
				break;
			}
			if (nn->prev)
				break;
		}
		if (MDOC_Diag == t && n->prev)
			if (NULL == n->prev->body->child)
				c = 1;
		if ( ! c)
			bufcat(h, "padding-top: 1em;");
d889 1
a889 2
	tag.key = ATTR_STYLE;
	tag.val = h->buf;
a894 1
/* ARGSUSED */
d896 1
a896 1
mdoc_tbl_body_pre(MDOC_ARGS, int t, int w)
d898 17
a915 1
	print_otag(h, TAG_DIV, 0, NULL);
a919 1
/* ARGSUSED */
d921 1
a921 1
mdoc_tbl_head_pre(MDOC_ARGS, int t, int w)
d927 1
a927 1
	switch (t) {
d934 2
a935 2
		buffmt(h, "min-width: %dem;", w);
		bufcat(h, "clear: none;");
d937 2
a938 3
			bufcat(h, "float: left;");
		tag.key = ATTR_STYLE;
		tag.val = h->buf;
d942 3
a944 3
		buffmt(h, "margin-left: -%dem; min-width: %dem;", 
				w, w ? w - 1 : 0);
		bufcat(h, "clear: left;");
d946 4
a949 4
			bufcat(h, "float: left;");
		bufcat(h, "padding-right: 1em;");
		tag.key = ATTR_STYLE;
		tag.val = h->buf;
d954 1
a954 1
	switch (t) {
d956 1
a956 2
		tag.key = ATTR_CLASS;
		tag.val = "diag";
d984 1
a984 1
mdoc_tbl_pre(MDOC_ARGS, int type)
d986 1
a986 1
	int			 i, w, o, c, wp;
d988 3
d993 1
a993 1
	if (MDOC_BLOCK != n->type) 
d996 1
a996 4
	assert(bl->args);

	w = o = c = 0;
	wp = -1;
d998 1
a998 20
	for (i = 0; i < (int)bl->args->argc; i++) 
		if (MDOC_Width == bl->args->argv[i].arg) {
			assert(bl->args->argv[i].sz);
			wp = i;
			w = a2width(bl->args->argv[i].value[0]);
		} else if (MDOC_Offset == bl->args->argv[i].arg) {
			assert(bl->args->argv[i].sz);
			o = a2offs(bl->args->argv[i].value[0]);
		} else if (MDOC_Compact == bl->args->argv[i].arg) 
			c = 1;
	
	if (MDOC_HEAD == n->type && MDOC_Column == type) {
		nn = n->parent->child;
		assert(nn && MDOC_HEAD == nn->type);
		for (i = 0; nn && nn != n; nn = nn->next, i++)
			/* Counter... */ ;
		assert(nn);
		if (wp >= 0 && i < (int)bl->args[wp].argv->sz)
			w = a2width(bl->args->argv[wp].value[i]);
	}
d1008 1
a1008 2
		if (w < 4)
			w = 4;
d1010 28
d1041 1
a1041 1
		w = 1;
d1044 2
a1045 2
		if (0 == w)
			w = 10;
d1049 16
a1064 10
	switch (n->type) {
	case (MDOC_BLOCK):
		break;
	case (MDOC_HEAD):
		return(mdoc_tbl_head_pre(m, n, h, type, w));
	case (MDOC_BODY):
		return(mdoc_tbl_body_pre(m, n, h, type, w));
	default:
		abort();
		/* NOTREACHED */
d1067 1
a1067 1
	return(mdoc_tbl_block_pre(m, n, h, type, w, o, c));
a1081 2
	/* Allocate an -enum on the stack of indices. */

a1087 1

a1109 14
static int
mdoc_it_pre(MDOC_ARGS)
{
	int		 type;

	if (MDOC_BLOCK == n->type)
		type = a2list(n->parent->parent);
	else
		type = a2list(n->parent->parent->parent);

	return(mdoc_tbl_pre(m, n, h, type));
}


d1118 2
a1120 4

	tag.key = ATTR_CLASS;
	tag.val = "utility";

d1226 1
a1226 3
	tag.key = ATTR_CLASS;
	tag.val = "emph";

d1236 2
a1237 1
	struct htmlpair	tag[2];
d1242 4
a1245 7
	buffmt(h, "margin-left: %dem;", INDENT);

	tag[0].key = ATTR_CLASS;
	tag[0].val = "lit";
	tag[1].key = ATTR_STYLE;
	tag[1].val = h->buf;

d1259 2
d1268 1
a1268 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = "link-sec";
d1307 1
a1307 1
	int		 	 t, c, o, i;
d1309 1
d1318 1
a1318 2
	t = o = c = 0;

d1322 2
a1323 2
			assert(bl->args->argv[i].sz);
			o = a2offs(bl->args->argv[i].value[0]);
d1326 1
a1326 1
			c = 1;
d1335 1
a1335 1
			t = bl->args->argv[i].arg;
d1340 11
a1350 20
		if (o)
			buffmt(h, "margin-left: %dem;", o);
		if ( ! c) {
			for (nn = n; nn; nn = nn->parent) {
				if (MDOC_BLOCK != nn->type)
					continue;
				switch (nn->tok) {
				case (MDOC_Ss):
					/* FALLTHROUGH */
				case (MDOC_Sh):
					c = 1;
					break;
				default:
					break;
				}
				if (nn->prev)
					break;
			}
			if ( ! c) 
				bufcat(h, "margin-top: 1em;");
d1352 3
a1354 2
		tag[0].key = ATTR_STYLE;
		tag[0].val = h->buf;
d1359 1
a1359 1
	if (MDOC_Unfilled != t && MDOC_Literal != t)
d1362 3
a1364 6
	bufcat(h, "white-space: pre;");
	tag[0].key = ATTR_STYLE;
	tag[0].val = h->buf;
	tag[1].key = ATTR_CLASS;
	tag[1].val = "lit";

d1368 1
d1374 2
d1388 1
a1388 3
	tag.key = ATTR_CLASS;
	tag.val = "file";

d1400 1
a1400 2
	tag.key = ATTR_CLASS;
	tag.val = "addr";
d1414 1
a1414 2
	tag.key = ATTR_CLASS;
	tag.val = "author";
d1426 1
a1426 2
	tag.key = ATTR_CLASS;
	tag.val = "config";
d1438 1
a1438 2
	tag.key = ATTR_CLASS;
	tag.val = "define";
d1450 1
a1450 2
	tag.key = ATTR_CLASS;
	tag.val = "env";
d1462 1
a1462 2
	tag.key = ATTR_CLASS;
	tag.val = "errno";
d1476 1
a1476 3
	tag.key = ATTR_CLASS;
	tag.val = "farg";

d1501 2
a1502 1
	struct htmlpair	tag;
d1506 3
a1508 2
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em;";
d1514 1
a1514 2
	tag.key = ATTR_CLASS;
	tag.val = "macro";
d1524 2
a1525 1
	struct htmlpair	tag;
d1529 3
a1531 2
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em;";
d1537 1
a1537 2
	tag.key = ATTR_CLASS;
	tag.val = "type";
d1547 2
a1548 1
	struct htmlpair	tag;
d1552 3
a1554 2
			tag.key = ATTR_STYLE;
			tag.val = "margin-top: 1em;";
d1560 1
a1560 2
	tag.key = ATTR_CLASS;
	tag.val = "ftype";
d1576 1
d1579 9
a1587 6
		bufcat(h, "margin-left: 6em;");
		bufcat(h, "text-indent: -6em;");
		if (n->next) 
			bufcat(h, "margin-bottom: 1em;");
		tag[0].key = ATTR_STYLE;
		tag[0].val = h->buf;
d1596 1
a1596 3
		tag[0].key = ATTR_CLASS;
		tag[0].val = "ftype";
	
d1610 1
a1610 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = "fname";
d1623 5
d1629 3
a1631 8
		i = 0;
		tag[i].key = ATTR_CLASS;
		tag[i++].val = "farg";
		if (SEC_SYNOPSIS == n->sec) {
			tag[i].key = ATTR_STYLE;
			tag[i++].val = "white-space: nowrap;";
		}
			
a1639 1

d1651 3
a1653 2
	int		len;
	struct htmlpair	tag;
d1657 1
d1668 3
a1670 3
	buffmt(h, "height: %dem;", len);
	tag.key = ATTR_STYLE;
	tag.val = h->buf;
d1711 1
a1711 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = "link-ext";
a1713 1

a1715 3
	if (NULL == nn->next)
		return(1);

d1731 1
a1731 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = "link-mail";
d1737 1
a1737 4

		tag[1].key = ATTR_HREF;
		tag[1].val = h->buf;

d1761 1
a1761 2
	tag.key = ATTR_CLASS;
	tag.val = "fname";
d1785 1
a1786 1
	struct tag		*t;
d1788 1
d1792 3
a1794 2
			tag[0].key = ATTR_STYLE;
			tag[0].val = "margin-bottom: 1em;";
d1800 1
a1800 3
	tag[0].key = ATTR_CLASS;
	tag[0].val = "includes";

d1812 2
a1813 4
		assert(MDOC_TEXT == nn->type);
		i = 0;
		tag[i].key = ATTR_CLASS;
		tag[i++].val = "link-includes";
d1837 1
a1837 3
	tag.key = ATTR_CLASS;
	tag.val = "cmd";

a1851 1

d1855 1
a1855 2
		tag.key = ATTR_CLASS;
		tag.val = "fname";
d1877 1
a1877 2
	tag.key = ATTR_CLASS;
	tag.val = "var";
d1892 1
a1892 2
	tag.key = ATTR_CLASS;
	tag.val = "var";
d1939 3
a1941 2
	int		i;
	struct htmlpair	tag[2];
d1948 1
a1948 2
	tag[0].key = ATTR_CLASS;
	tag[0].val = NULL;
d1952 1
a1952 1
			tag[0].val = "emph";
d1954 1
a1954 1
			tag[0].val = "symb";
d1956 1
a1956 1
			tag[0].val = "lit";
d1962 1
a1962 1
				tag[0].val = "symb";
d1965 1
a1965 1
				tag[0].val = "lit";
d1968 1
a1968 1
				tag[0].val = "emph";
d1977 4
a1980 3
	assert(tag[0].val);
	tag[1].key = ATTR_STYLE;
	tag[1].val = "display: inline; margin-right: 1em;";
d1992 1
a1992 2
	tag.key = ATTR_CLASS;
	tag.val = "symb";
d2022 2
a2023 1
	struct htmlpair	tag;
d2029 3
a2031 2
		tag.key = ATTR_STYLE;
		tag.val = "margin-top: 1em;";
d2035 1
a2035 2
	tag.key = ATTR_CLASS;
	tag.val = "ref";
d2048 1
a2048 3
	tag.key = ATTR_CLASS;
	tag.val = "lit";

d2060 1
a2060 3
	tag.key = ATTR_CLASS;
	tag.val = "symb";

a2091 3
	tag.key = ATTR_CLASS;
	tag.val = "lib";

d2094 1
a2094 1

a2105 2
	tag.key = ATTR_CLASS;

d2108 1
a2108 1
		tag.val = "ref-auth";
d2111 1
a2111 1
		tag.val = "ref-book";
d2114 1
a2114 1
		tag.val = "ref-city";
d2117 1
a2117 1
		tag.val = "ref-date";
d2120 1
a2120 1
		tag.val = "ref-issue";
d2123 1
a2123 1
		tag.val = "ref-jrnl";
d2126 1
a2126 1
		tag.val = "ref-num";
d2129 1
a2129 1
		tag.val = "ref-opt";
d2132 1
a2132 1
		tag.val = "ref-page";
d2135 1
a2135 1
		tag.val = "ref-corp";
d2138 1
a2138 1
		tag.val = "ref-rep";
d2141 1
a2143 1
		tag.val = "ref-title";
d2146 1
a2146 1
		tag.val = "ref-vol";
@


1.21
log
@Section/subsection anchor names (<a name=xxx>) replaced with (div id=xxx) (noted by joerg@@netbsd.org)
Removed superfluous span tags within section/subsection divs (noted by joerg@@netbsd.org).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.20 2009/10/03 19:57:53 kristaps Exp $ */
d583 2
d641 2
@


1.20
log
@Added initial -man framework for -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.19 2009/10/03 19:02:45 kristaps Exp $ */
d545 4
a549 1
	if (MDOC_HEAD == n->type) {
d551 3
a553 3
		tag[0].val = "sec-head";
		print_otag(h, TAG_DIV, 1, tag);
		print_otag(h, TAG_SPAN, 1, tag);
d555 1
a555 8
		for (nn = n->child; nn; nn = nn->next) {
			bufcat(h, nn->string);
			if (nn->next)
				bufncat(h, " ", 1);
		}
		tag[0].key = ATTR_NAME;
		tag[0].val = h->buf;
		print_otag(h, TAG_A, 1, tag);
a571 1

d576 7
a582 2
	buffmt(h, "margin-left: %dem;", INDENT);
	
d584 3
a586 3
	tag[0].val = "sec-body";
	tag[1].key = ATTR_STYLE;
	tag[1].val = h->buf;
d597 1
a597 1
	struct htmlpair	 	 tag[2];
d600 1
d607 1
d613 1
d619 1
d625 1
d630 7
d643 2
d646 1
a646 13
	print_otag(h, TAG_DIV, 2, tag);
	print_otag(h, TAG_SPAN, 1, tag);

	bufinit(h);
	for (nn = n->child; nn; nn = nn->next) {
		bufcat(h, nn->string);
		if (nn->next)
			bufcat(h, " ");
	}
	tag[0].key = ATTR_NAME;
	tag[0].val = h->buf;
	print_otag(h, TAG_A, 1, tag);

d1274 1
d1276 1
a1276 1
	bufcat(h, "#");
d1278 1
a1278 1
		bufcat(h, nn->string);
d1280 1
a1280 1
			bufcat(h, " ");
d1283 4
a1286 4
	tag[0].key = ATTR_HREF;
	tag[0].val = h->buf;
	tag[1].key = ATTR_CLASS;
	tag[1].val = "link-sec";
d1697 1
a1697 1
	buffmt(h, "height: %dem", len);
@


1.19
log
@`Fn' does not print empty ftype span.
-Tascii `node' and `meta' args in DECL_ARGS renamed to `n' and `m' to be more coherent with -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.18 2009/10/03 16:36:06 kristaps Exp $ */
a37 3
#define	MAN_ARGS	  const struct man_meta *m, \
			  const struct man_node *n, \
			  struct html *h
a384 1
	char		b[BUFSIZ];
d387 2
a388 3

	(void)snprintf(b, BUFSIZ - 1, 
			"%s(%d)", m->title, m->msec);
d391 3
a393 3
		(void)strlcat(b, " (", BUFSIZ);
		(void)strlcat(b, m->arch, BUFSIZ);
		(void)strlcat(b, ")", BUFSIZ);
d397 1
a397 1
	print_text(h, b);
@


1.18
log
@Fixed mandoc.1 examples (new -Thtml options).
Fixed manuals to use `In', not `Fd'.
Moved buf* functions into html.c.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.17 2009/10/03 15:26:26 kristaps Exp $ */
d1441 2
a1620 5

	tag[0].key = ATTR_CLASS;
	tag[0].val = "ftype";
	t = print_otag(h, TAG_SPAN, 1, tag);

d1623 16
a1638 6
	while (NULL != (ep = strchr(sp, ' '))) {
		sz = MIN((int)(ep - sp), BUFSIZ - 1);
		(void)memcpy(nbuf, sp, (size_t)sz);
		nbuf[sz] = '\0';
		print_text(h, nbuf);
		sp = ++ep;
a1640 2
	print_tagq(h, t);

@


1.17
log
@Added the -oincludes=FMT option.
The `In' handler now decorates with a hyperlink.
If no -oman= or -oincludes= is stipulated, no link is printed (but the text is still style-decorated).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.16 2009/10/03 15:08:09 kristaps Exp $ */
a23 1
#include <stdarg.h>
a55 8
static	void		  buffmt_man(struct html *, 
				const char *, const char *);
static	void		  buffmt_includes(struct html *, const char *);
static	void		  buffmt(struct html *, const char *, ...);
static	void		  bufcat(struct html *, const char *);
static	void		  bufncat(struct html *, const char *, size_t);


a275 94
static void
bufinit(struct html *h)
{

	h->buf[0] = '\0';
	h->buflen = 0;
}


static void
bufcat(struct html *h, const char *p)
{

	bufncat(h, p, strlen(p));
}


static void
buffmt(struct html *h, const char *fmt, ...)
{
	va_list		 ap;

	va_start(ap, fmt);
	(void)vsnprintf(h->buf + h->buflen, 
			BUFSIZ - h->buflen - 1, fmt, ap);
	va_end(ap);
	h->buflen = strlen(h->buf);
	assert('\0' == h->buf[h->buflen]);
}


static void
bufncat(struct html *h, const char *p, size_t sz)
{

	if (h->buflen + sz > BUFSIZ - 1)
		sz = BUFSIZ - 1 - h->buflen;

	(void)strncat(h->buf, p, sz);
	h->buflen += sz;
	assert('\0' == h->buf[h->buflen]);
}


static void
buffmt_includes(struct html *h, const char *name)
{
	const char	*p, *pp;

	pp = h->base_includes;
	while ((p = strchr(pp, '%'))) {
		bufncat(h, pp, p - pp);
		switch (*(p + 1)) {
		case('I'):
			bufcat(h, name);
			break;
		default:
			bufncat(h, p, 2);
			break;
		}
		pp = p + 2;
	}
	if (pp)
		bufcat(h, pp);
}


static void
buffmt_man(struct html *h, 
		const char *name, const char *sec)
{
	const char	*p, *pp;

	pp = h->base_man;
	while ((p = strchr(pp, '%'))) {
		bufncat(h, pp, p - pp);
		switch (*(p + 1)) {
		case('S'):
			bufcat(h, sec);
			break;
		case('N'):
			buffmt(h, name ? name : "1");
			break;
		default:
			bufncat(h, p, 2);
			break;
		}
		pp = p + 2;
	}
	if (pp)
		bufcat(h, pp);
}


d1275 1
a1275 1
	struct htmlpair		 tag[3];
a1288 2
	tag[2].key = ATTR_TARGET;
	tag[2].val = "_self";
d1290 1
a1290 1
	print_otag(h, TAG_A, 3, tag);
@


1.16
log
@Element tag buffer is now part of struct html.
buffmt() can be called in sequence.
Noted BUFSIZ-sized buffer in CAVEATS (attribute length for link formats).
Added -oman=FMT -Thtml option for `Xr' manual links.
Removed -obase=URI -Thtml option (obsolete).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.15 2009/09/26 18:31:36 kristaps Exp $ */
d59 1
d330 23
a358 3

	/* FIXME: URL-encode contents. */

d853 5
d859 6
a864 3
	buffmt_man(h, n->child->string, 
			n->child->next ? 
			n->child->next->string : NULL);
d866 1
a866 5
	tag[0].key = ATTR_CLASS;
	tag[0].val = "link-man";
	tag[1].key = ATTR_HREF;
	tag[1].val = h->buf;
	print_otag(h, TAG_A, 2, tag);
d1378 1
a1378 1
	struct htmlpair		 tag[2];
d1392 2
d1395 1
a1395 1
	print_otag(h, TAG_A, 2, tag);
d1926 3
a1928 1
	struct htmlpair		 tag;
d1932 3
a1934 3
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em;";
			print_otag(h, TAG_DIV, 1, &tag);
d1939 2
a1940 2
	tag.key = ATTR_CLASS;
	tag.val = "includes";
d1942 1
a1942 1
	print_otag(h, TAG_SPAN, 1, &tag);
d1952 11
a1962 1
	for (nn = n->child; nn; nn = nn->next)
d1964 2
@


1.15
log
@SYNOPSIS functions in -Thtml text-indent and group paramters (as nroff does).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.14 2009/09/26 18:02:51 kristaps Exp $ */
d24 1
d57 7
a265 5
static	char		  buf[BUFSIZ]; /* XXX */

#define	bufcat(x)	  (void)strlcat(buf, (x), BUFSIZ) 
#define	bufinit()	  buf[0] = 0
#define	buffmt(...)	  (void)snprintf(buf, BUFSIZ - 1, __VA_ARGS__)
d284 74
d507 1
a507 1
	bufinit();
d527 1
a527 1
	bufinit();
d640 1
a640 1
			bufcat(nn->string);
d642 1
a642 1
				bufcat(" ");
d645 1
a645 1
		tag[0].val = buf;
d657 1
a657 1
		bufcat("margin-top: 1em;");
d659 1
a659 1
			bufcat("margin-bottom: 1em;");
d662 1
a662 1
		tag[1].val = buf;
d668 1
a668 1
	buffmt("margin-left: %dem;", INDENT);
d673 1
a673 1
	tag[1].val = buf;
d694 1
a694 1
			bufcat("margin-bottom: 1em;");
d696 1
a696 1
			tag[i++].val = buf;
d704 1
a704 1
			bufcat("margin-top: 1em;");
d706 1
a706 1
			tag[i++].val = buf;
d712 1
a712 1
	buffmt("margin-left: -%dem;", INDENT - HALFINDENT);
d717 1
a717 1
	tag[1].val = buf;
d722 1
a722 1
	bufinit();
d724 1
a724 1
		bufcat(nn->string);
d726 1
a726 1
			bufcat(" ");
d729 1
a729 1
	tag[0].val = buf;
a830 1
	const char		*name, *sec;
d833 3
a835 6
	nn = n->child;
	name = nn && nn->string ? nn->string : "";
	nn = nn ? nn->next : NULL;
	sec = nn && nn->string ? nn->string : "";

	buffmt("%s%s%s.html", name, name && sec ? "." : "", sec);
d840 1
a840 1
	tag[1].val = buf;
d845 1
d959 1
a959 1
		buffmt("margin-left: %dem; clear: both;", o);
d962 1
a962 1
		buffmt("margin-left: %dem; clear: both;", w + o);
d986 1
a986 1
			bufcat("padding-top: 1em;");
d990 1
a990 1
	tag.val = buf;
d1021 2
a1022 2
		buffmt("min-width: %dem;", w);
		bufcat("clear: none;");
d1024 1
a1024 1
			bufcat("float: left;");
d1026 1
a1026 1
		tag.val = buf;
d1030 1
a1030 1
		buffmt("margin-left: -%dem; min-width: %dem;", 
d1032 1
a1032 1
		bufcat("clear: left;");
d1034 2
a1035 2
			bufcat("float: left;");
		bufcat("padding-right: 1em;");
d1037 1
a1037 1
		tag.val = buf;
d1337 1
a1337 1
	buffmt("margin-left: %dem;", INDENT);
d1342 1
a1342 1
	tag[1].val = buf;
d1356 1
a1356 1
	bufcat("#");
d1358 1
a1358 1
		bufcat(nn->string);
d1360 1
a1360 1
			bufcat(" ");
d1364 1
a1364 1
	tag[0].val = buf;
d1437 1
a1437 1
			buffmt("margin-left: %dem;", o);
d1455 1
a1455 1
				bufcat("margin-top: 1em;");
d1458 1
a1458 1
		tag[0].val = buf;
d1466 1
a1466 1
	bufcat("white-space: pre;");
d1468 1
a1468 1
	tag[0].val = buf;
d1687 2
a1688 2
		bufcat("margin-left: 6em;");
		bufcat("text-indent: -6em;");
d1690 1
a1690 1
			bufcat("margin-bottom: 1em;");
d1692 1
a1692 1
		tag[0].val = buf;
d1772 1
a1772 1
	buffmt("height: %dem", len);
d1774 1
a1774 1
	tag.val = buf;
d1844 3
a1846 3
		bufinit();
		bufcat("mailto:");
		bufcat(nn->string);
d1849 1
a1849 1
		tag[1].val = buf;
@


1.14
log
@Fixed -Thtml handling of -compact lists.
Fixed -Thtml handling of `Bd' prior vspace and embedded macros.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.12 2009/09/25 13:00:13 kristaps Exp $ */
d1606 1
a1606 1
	struct htmlpair	 	 tag;
d1610 1
a1610 1
	int			 sz;
d1613 7
a1619 6
		if (n->next) {
			tag.key = ATTR_STYLE;
			tag.val = "margin-bottom: 1em";
			print_otag(h, TAG_DIV, 1, &tag);
		} else
			print_otag(h, TAG_DIV, 0, NULL);
d1624 3
a1626 3
	tag.key = ATTR_CLASS;
	tag.val = "ftype";
	t = print_otag(h, TAG_SPAN, 1, &tag);
d1640 3
a1642 3
	tag.key = ATTR_CLASS;
	tag.val = "fname";
	t = print_otag(h, TAG_SPAN, 1, &tag);
d1655 9
a1663 3
		tag.key = ATTR_CLASS;
		tag.val = "farg";
		t = print_otag(h, TAG_SPAN, 1, &tag);
@


1.13
log
@Fixed `Bd' prior vertical space (was ignoring -compact).
Fixed effect of embedding macros in `Bd' (was printing all on each line instead of grouping).
@
text
@d876 2
a877 1
	struct htmlpair	 tag;
d893 20
a912 4
	       if (n->prev && n->prev->body->child)
		       bufcat("padding-top: 1em;");
	       else if (NULL == n->prev)
		       bufcat("padding-top: 1em;");
a1007 2
	/* FIXME: fmt_vspace() equivalent. */

d1083 2
d1330 1
a1330 3
	const struct mdoc_node	*bl;

	/* FIXME: fmt_vspace() shit. */
d1364 19
a1382 1
		bufcat("margin-top: 1em;");
d1389 1
a1389 5
	switch (t) {
	case (MDOC_Unfilled):
	case (MDOC_Literal):
		break;
	default:
a1390 1
	}
d1400 5
a1404 4
	for (n = n->child; n; n = n->next) {
		h->flags |= HTML_NOSPACE;
		print_mdoc_node(m, n, h);
		if (n->next)
@


1.12
log
@Lint check (noop).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.11 2009/09/25 12:43:05 kristaps Exp $ */
d1330 1
a1330 1
			o = a2offs (bl->args->argv[i].value[0]);
@


1.11
log
@Changed -Thtml document header to be 10/80/10 with no wrapping of the middle.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.10 2009/09/24 23:54:43 kristaps Exp $ */
d1600 1
a1600 1
	while ((ep = strchr(sp, ' '))) {
@


1.10
log
@-Tascii correctly prints `%T' in `Rs' with quotes.
-Thtml behaves like -Tascii for printing.
Printing of `Rs' elements cross-checked with new groff.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.9 2009/09/24 15:05:56 kristaps Exp $ */
d528 1
a528 1
	tag[0].val = "width: 33%;";
d534 1
a534 1
	tag[0].val = "width: 33%; text-align: center;";
d540 1
a540 1
	tag[0].val = "width: 33%; text-align: right;";
@


1.9
log
@Lint-fixes (noop).
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.8 2009/09/24 13:18:37 kristaps Exp $ */
d63 2
d177 11
a187 11
	{NULL, NULL}, /* %A */
	{NULL, NULL}, /* %B */
	{NULL, NULL}, /* %D */
	{NULL, NULL}, /* %I */
	{NULL, NULL}, /* %J */
	{NULL, NULL}, /* %N */
	{NULL, NULL}, /* %O */
	{NULL, NULL}, /* %P */
	{NULL, NULL}, /* %R */
	{NULL, NULL}, /* %T */
	{NULL, NULL}, /* %V */
d249 1
a249 1
	{NULL, NULL}, /* %C */ 
d253 1
a253 1
	{NULL, NULL}, /* %Q */ 
d2102 78
@


1.8
log
@Proper handling of `Rs' blocks in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.7 2009/09/24 11:55:28 kristaps Exp $ */
d1599 2
a1600 2
		sz = MIN(ep - sp, BUFSIZ - 1);
		(void)memcpy(nbuf, sp, sz);
@


1.7
log
@Fix in -Tascii where `Lb' causes line-break in any section (should only happen in LIBRARY).
`Fn' first parameter is broken apart into ftype and fname in -Thtml (for correct style application).
Fixed \0 special character.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.6 2009/09/24 11:05:45 kristaps Exp $ */
d2018 1
a2018 2
	struct htmlpair	tag[2];
	int		i;
d2023 4
a2026 9
	tag[i = 0].key = ATTR_CLASS;
	tag[i++].val = "ref";

	if (n->prev && SEC_SYNOPSIS == n->sec) {
		tag[i].key = ATTR_STYLE;
		tag[i++].val = "margin-top: 1em;";
	} else if (SEC_SYNOPSIS != n->sec) {
		tag[i].key = ATTR_STYLE;
		tag[i++].val = "display: inline; margin-right: 1em";
d2029 3
a2031 3
	/* FIXME: div's have spaces stripped--we want them. */

	print_otag(h, TAG_DIV, i, tag);
@


1.6
log
@Sync'd example style-sheet to be more like OpenBSD's default (KISS).
-Thtml and -Tascii now have equivalent functionality.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.5 2009/09/24 09:50:31 kristaps Exp $ */
d18 1
d1564 1
a1564 1
	tag.val = "type";
d1577 3
d1590 2
d1593 12
a1604 1
	tag.val = "type";
d1606 1
a1606 1
	/* FIXME: can be "type funcname" "type varname"... */
d1608 2
d1611 6
a1616 1
	print_text(h, n->child->string);
@


1.5
log
@Added Bf, Pf, etc. to -Thtml.
Fixed Rs in -Tascii to behave properly when not in "SEE ALSO" section.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.4 2009/09/24 09:20:02 kristaps Exp $ */
d76 1
d97 2
d120 2
d163 1
a163 1
	{NULL, NULL}, /* Li */
d222 1
a222 1
	{NULL, NULL}, /* Sm */
d224 1
a224 1
	{NULL, NULL}, /* Sy */
d235 1
a235 1
	{NULL, NULL}, /* Bt */
d238 2
a239 2
	{NULL, NULL}, /* Ud */
	{NULL, NULL}, /* Lb */
d2016 66
@


1.4
log
@Many more macros added to -Thtml.
Minor space issues fixed in -Tascii.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.3 2009/09/22 16:10:52 kristaps Exp $ */
d64 1
d69 1
d98 1
d105 2
d109 1
a109 2
static	void		  mdoc_qq_post(MDOC_ARGS);
static	int		  mdoc_qq_pre(MDOC_ARGS);
d128 1
a128 1
	{NULL, NULL}, /* Ap */
d185 1
a185 1
	{NULL, NULL}, /* Bf */ 
d199 1
a199 1
	{NULL, NULL}, /* Ms */
d205 1
a205 1
	{NULL, NULL}, /* Pf */
d210 2
a211 2
	{mdoc_qq_pre, mdoc_qq_post}, /* Qo */
	{mdoc_qq_pre, mdoc_qq_post}, /* Qq */
d213 1
a213 1
	{NULL, NULL}, /* Rs */
d1241 1
a1241 1
	tag[0].val = "lit-block";
d1360 1
a1360 1
	tag[1].val = "lit-block";
a1390 25
mdoc_qq_pre(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return(1);
	print_text(h, "\\*q");
	h->flags |= HTML_NOSPACE;
	return(1);
}


/* ARGSUSED */
static void
mdoc_qq_post(MDOC_ARGS)
{

	if (MDOC_BODY != n->type)
		return;
	h->flags |= HTML_NOSPACE;
	print_text(h, "\\*q");
}


/* ARGSUSED */
static int
d1888 123
@


1.3
log
@Fix segfault in -Thtml column lists.
Added some more UTF-8 chars.
mandoc_char.7 now has all special characters rendered.
Fixed column layout in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.2 2009/09/21 23:12:08 kristaps Exp $ */
d70 2
d74 1
d89 4
d106 1
d113 1
d152 2
a153 2
	{NULL, NULL}, /* Ic */ 
	{NULL, NULL}, /* In */ 
d160 1
a160 1
	{NULL, NULL}, /* Rv */
d162 1
a162 1
	{NULL, NULL}, /* Va */
d182 2
a183 2
	{NULL, NULL}, /* Bo */
	{NULL, NULL}, /* Bq */
d185 1
a185 1
	{NULL, NULL}, /* Bx */
d188 1
a188 1
	{NULL, NULL}, /* Do */
d205 1
a205 1
	{NULL, NULL}, /* Ql */
d220 1
a220 1
	{NULL, NULL}, /* Fo */ 
d222 1
a222 1
	{NULL, NULL}, /* Oo */
d839 23
d927 2
a928 1
		buffmt("margin-left: -%dem; width: %dem;", w, w);
d956 1
a956 1
		print_text(h, "\\-");
d1572 1
a1572 1
			tag.val = "magin-bottom: 1em;";
d1605 2
d1738 171
@


1.2
log
@A few more macros in -Thtml.
@
text
@d1 1
a1 1
/*	$Id: mdoc_html.c,v 1.1 2009/09/21 14:56:57 kristaps Exp $ */
d895 1
a895 1
		buffmt("margin-left: -%dem;", w);
@


1.1
log
@Split html.c into html.h, mdoc_html.c, man_html.c.
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.50 2009/09/21 14:40:31 kristaps Exp $ */
d70 2
d87 2
d223 4
a226 4
	{NULL, NULL}, /* Lk */ 
	{NULL, NULL}, /* Mt */ 
	{NULL, NULL}, /* Brq */ 
	{NULL, NULL}, /* Bro */ 
d229 2
a230 2
	{NULL, NULL}, /* Es */ 
	{NULL, NULL}, /* En */ 
d509 1
a509 1
	print_text(h, b);
d515 1
a515 1
	print_text(h, title);
d521 1
a521 1
	print_text(h, b);
d897 2
a898 1
		bufcat("float: left;");
d1529 1
d1624 79
@
