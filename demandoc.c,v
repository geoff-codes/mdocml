head	1.24;
access;
symbols
	VERSION_1_13_3:1.15
	VERSION_1_13_2:1.12
	VERSION_1_12_4:1.11
	VERSION_1_13_1:1.10
	VERSION_1_12_3:1.7
	VERSION_1_12_2:1.7
	VERSION_1_12:1.11.0.2
	VERSION_1_12_1:1.6
	VERSION_1_12_0:1.6
	VERSION_1_11_7:1.6;
locks; strict;
comment	@ * @;


1.24
date	2015.10.22.22.06.43;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2015.10.20.02.01.31;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2015.04.18.17.53.21;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2015.04.18.16.34.25;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2015.04.18.16.06.39;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2015.04.02.21.36.49;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2015.02.10.08.05.30;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2015.02.07.06.28.08;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2015.01.15.04.26.39;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2014.03.19.22.20.43;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2014.03.19.22.05.10;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.01.05.20.41.04;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.31.22.27.14;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.01.22.25.53;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.09.01.22.09.50;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.09.01.20.55.50;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.09.01.10.49.13;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.09.01.10.47.47;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.09.01.10.46.28;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.24
log
@use the new function man_validate() here, too
@
text
@/*	$Id: demandoc.c,v 1.23 2015/10/20 02:01:31 schwarze Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "roff.h"
#include "man.h"
#include "mdoc.h"
#include "mandoc.h"

static	void	 pline(int, int *, int *, int);
static	void	 pman(const struct roff_node *, int *, int *, int);
static	void	 pmandoc(struct mparse *, int, const char *, int);
static	void	 pmdoc(const struct roff_node *, int *, int *, int);
static	void	 pstring(const char *, int, int *, int);
static	void	 usage(void);

static	const char	 *progname;

int
main(int argc, char *argv[])
{
	struct mparse	*mp;
	int		 ch, fd, i, list;
	extern int	 optind;

	if (argc < 1)
		progname = "demandoc";
	else if ((progname = strrchr(argv[0], '/')) == NULL)
		progname = argv[0];
	else
		++progname;

	mp = NULL;
	list = 0;

	while (-1 != (ch = getopt(argc, argv, "ikm:pw")))
		switch (ch) {
		case ('i'):
			/* FALLTHROUGH */
		case ('k'):
			/* FALLTHROUGH */
		case ('m'):
			/* FALLTHROUGH */
		case ('p'):
			break;
		case ('w'):
			list = 1;
			break;
		default:
			usage();
			return (int)MANDOCLEVEL_BADARG;
		}

	argc -= optind;
	argv += optind;

	mchars_alloc();
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_BADARG, NULL, NULL);
	assert(mp);

	if (argc < 1)
		pmandoc(mp, STDIN_FILENO, "<stdin>", list);

	for (i = 0; i < argc; i++) {
		mparse_reset(mp);
		if (mparse_open(mp, &fd, argv[i]) != MANDOCLEVEL_OK) {
			perror(argv[i]);
			continue;
		}
		pmandoc(mp, fd, argv[i], list);
	}

	mparse_free(mp);
	mchars_free();
	return (int)MANDOCLEVEL_OK;
}

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-w] [files...]\n", progname);
}

static void
pmandoc(struct mparse *mp, int fd, const char *fn, int list)
{
	struct roff_man	*man;
	int		 line, col;

	mparse_readfd(mp, fd, fn);
	mparse_result(mp, &man, NULL);
	line = 1;
	col = 0;

	if (man == NULL)
		return;
	if (man->macroset == MACROSET_MDOC) {
		mdoc_validate(man);
		pmdoc(man->first->child, &line, &col, list);
	} else {
		man_validate(man);
		pman(man->first->child, &line, &col, list);
	}

	if ( ! list)
		putchar('\n');
}

/*
 * Strip the escapes out of a string, emitting the results.
 */
static void
pstring(const char *p, int col, int *colp, int list)
{
	enum mandoc_esc	 esc;
	const char	*start, *end;
	int		 emit;

	/*
	 * Print as many column spaces til we achieve parity with the
	 * input document.
	 */

again:
	if (list && '\0' != *p) {
		while (isspace((unsigned char)*p))
			p++;

		while ('\'' == *p || '(' == *p || '"' == *p)
			p++;

		emit = isalpha((unsigned char)p[0]) &&
			isalpha((unsigned char)p[1]);

		for (start = p; '\0' != *p; p++)
			if ('\\' == *p) {
				p++;
				esc = mandoc_escape(&p, NULL, NULL);
				if (ESCAPE_ERROR == esc)
					return;
				emit = 0;
			} else if (isspace((unsigned char)*p))
				break;

		end = p - 1;

		while (end > start)
			if ('.' == *end || ',' == *end ||
					'\'' == *end || '"' == *end ||
					')' == *end || '!' == *end ||
					'?' == *end || ':' == *end ||
					';' == *end)
				end--;
			else
				break;

		if (emit && end - start >= 1) {
			for ( ; start <= end; start++)
				if (ASCII_HYPH == *start)
					putchar('-');
				else
					putchar((unsigned char)*start);
			putchar('\n');
		}

		if (isspace((unsigned char)*p))
			goto again;

		return;
	}

	while (*colp < col) {
		putchar(' ');
		(*colp)++;
	}

	/*
	 * Print the input word, skipping any special characters.
	 */
	while ('\0' != *p)
		if ('\\' == *p) {
			p++;
			esc = mandoc_escape(&p, NULL, NULL);
			if (ESCAPE_ERROR == esc)
				break;
		} else {
			putchar((unsigned char )*p++);
			(*colp)++;
		}
}

static void
pline(int line, int *linep, int *col, int list)
{

	if (list)
		return;

	/*
	 * Print out as many lines as needed to reach parity with the
	 * original input.
	 */

	while (*linep < line) {
		putchar('\n');
		(*linep)++;
	}

	*col = 0;
}

static void
pmdoc(const struct roff_node *p, int *line, int *col, int list)
{

	for ( ; p; p = p->next) {
		if (MDOC_LINE & p->flags)
			pline(p->line, line, col, list);
		if (ROFFT_TEXT == p->type)
			pstring(p->string, p->pos, col, list);
		if (p->child)
			pmdoc(p->child, line, col, list);
	}
}

static void
pman(const struct roff_node *p, int *line, int *col, int list)
{

	for ( ; p; p = p->next) {
		if (MAN_LINE & p->flags)
			pline(p->line, line, col, list);
		if (ROFFT_TEXT == p->type)
			pstring(p->string, p->pos, col, list);
		if (p->child)
			pman(p->child, line, col, list);
	}
}
@


1.23
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.22 2015/10/13 22:59:54 schwarze Exp $ */
d125 2
a126 1
	} else
d128 1
@


1.22
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.21 2015/10/06 18:32:19 schwarze Exp $ */
d122 2
a123 1
	if (man->macroset == MACROSET_MDOC)
d125 1
a125 1
	else
@


1.21
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.20 2015/04/18 17:53:21 schwarze Exp $ */
a46 1
	struct mchars	*mchars;
d81 2
a82 2
	mchars = mchars_alloc();
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_BADARG, NULL, mchars, NULL);
d98 1
a98 1
	mchars_free(mchars);
@


1.20
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.19 2015/04/18 16:34:25 schwarze Exp $ */
d76 1
a76 1
			return((int)MANDOCLEVEL_BADARG);
d100 1
a100 1
	return((int)MANDOCLEVEL_OK);
@


1.19
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.18 2015/04/18 16:06:39 schwarze Exp $ */
d124 1
a124 1
		pmdoc(mdoc_node(man), &line, &col, list);
d126 1
a126 1
		pman(man_node(man), &line, &col, list);
@


1.18
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.17 2015/04/02 22:48:17 schwarze Exp $ */
a112 1
	struct roff_man	*mdoc;
d117 1
a117 1
	mparse_result(mp, &mdoc, &man, NULL);
d121 5
a125 3
	if (mdoc)
		pmdoc(mdoc_node(mdoc), &line, &col, list);
	else if (man)
a126 2
	else
		return;
@


1.17
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.16 2015/04/02 21:36:49 schwarze Exp $ */
d113 2
a114 2
	struct mdoc	*mdoc;
	struct man	*man;
@


1.16
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.15 2015/02/10 08:05:30 schwarze Exp $ */
d35 1
a35 1
static	void	 pman(const struct man_node *, int *, int *, int);
d37 1
a37 1
static	void	 pmdoc(const struct mdoc_node *, int *, int *, int);
d237 1
a237 1
pmdoc(const struct mdoc_node *p, int *line, int *col, int list)
d251 1
a251 1
pman(const struct man_node *p, int *line, int *col, int list)
@


1.15
log
@trim trailing white space, no code change;
from Svyatoslav Mishyn <juef at openmailboxd dot org>, Crux Linux
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.14 2015/02/07 06:28:08 schwarze Exp $ */
d29 1
d243 1
a243 1
		if (MDOC_TEXT == p->type)
d257 1
a257 1
		if (MAN_TEXT == p->type)
@


1.14
log
@be more careful about argc == 0
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.13 2015/01/15 04:26:39 schwarze Exp $ */
d121 1
a121 1
	if (mdoc) 
d171 1
a171 1
			if ('.' == *end || ',' == *end || 
d203 1
a203 1
	while ('\0' != *p) 
d224 1
a224 1
	 * original input. 
d244 1
a244 1
		if (p->child) 
d258 1
a258 1
		if (p->child) 
@


1.13
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.12 2014/10/28 17:36:19 schwarze Exp $ */
d50 3
a52 2
	progname = strrchr(argv[0], '/');
	if (progname == NULL)
d85 1
a85 1
	if (0 == argc)
@


1.12
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.11 2014/08/10 23:54:41 schwarze Exp $ */
d47 1
a47 1
	int		 ch, i, list;
d81 1
a81 1
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_FATAL, NULL, mchars, NULL);
d89 5
a93 1
		pmandoc(mp, -1, argv[i], list);
d115 1
a115 5
	if (mparse_readfd(mp, fd, fn) >= MANDOCLEVEL_FATAL) {
		fprintf(stderr, "%s: Parse failure\n", fn);
		return;
	}

@


1.11
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.10 2014/03/19 22:20:43 schwarze Exp $ */
d46 1
d80 2
a81 1
	mp = mparse_alloc(MPARSE_SO, MANDOCLEVEL_FATAL, NULL, NULL);
d93 1
@


1.10
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.9 2014/03/19 22:05:10 schwarze Exp $ */
a16 1
#ifdef HAVE_CONFIG_H
d18 2
a19 1
#endif
@


1.9
log
@cope with mparse_alloc() interface change
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.8 2014/01/05 20:41:04 schwarze Exp $ */
d113 1
a113 1
	mparse_result(mp, &mdoc, &man);
@


1.8
log
@Cope with mparse_alloc() interface change.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.7 2012/05/31 22:27:14 schwarze Exp $ */
d79 1
a79 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL, 0);
@


1.7
log
@catch up with the changed interface of mparse_alloc(), see mandoc.h rev 1.100
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.6 2011/09/01 22:25:53 kristaps Exp $ */
d79 1
a79 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL, NULL);
@


1.6
log
@Finishing touches on demandoc.  It now backs over ending punctuation as
well as leading punctuation.  Again, this isn't the same as deroff
(which uses, I think, some punctuation as delimiters), but it's easier
to explain and simpler to audit.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.5 2011/09/01 22:09:50 kristaps Exp $ */
d79 1
a79 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
@


1.5
log
@Make `-w' mode work much better.  This is INCREDIBLY poorly specified in
any other deroff manual, and as I don't think anybody actually uses
deroff, I don't feel compelled to research its behaviour too much and
can just do what's logical.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.4 2011/09/01 20:55:50 kristaps Exp $ */
d135 1
a135 1
	const char	*start;
d164 14
a177 2
		if (emit && p - start >= 2) {
			for ( ; start != p; start++)
@


1.4
log
@Have demandoc throw away deroff's flags.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.3 2011/09/01 10:49:13 kristaps Exp $ */
d124 2
a125 1
	putchar('\n');
d135 43
d184 3
d203 8
@


1.3
log
@Lint checks over demandoc.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.2 2011/09/01 10:47:47 kristaps Exp $ */
d22 1
d33 5
a37 5
static	void	 pline(int, int *, int *);
static	void	 pman(const struct man_node *, int *, int *);
static	void	 pmandoc(struct mparse *, int, const char *);
static	void	 pmdoc(const struct mdoc_node *, int *, int *);
static	void	 pstring(const char *, int, int *);
d46 1
a46 1
	int		 ch, i;
d56 1
d58 1
a58 1
	while (-1 != (ch = getopt(argc, argv, "")))
d60 11
d83 1
a83 1
		pmandoc(mp, STDIN_FILENO, "<stdin>");
d87 1
a87 1
		pmandoc(mp, -1, argv[i]);
d98 1
a98 1
	fprintf(stderr, "usage: %s [files...]\n", progname);
d102 1
a102 1
pmandoc(struct mparse *mp, int fd, const char *fn)
d118 1
a118 1
		pmdoc(mdoc_node(mdoc), &line, &col);
d120 1
a120 1
		pman(man_node(man), &line, &col);
d131 1
a131 1
pstring(const char *p, int col, int *colp)
d140 1
a140 1
	while ('\0' != *p) {
d145 1
a145 1
				return;
a149 1
	}
a151 3
/*
 * Emit lines until we're in sync with our input.
 */
d153 1
a153 1
pline(int line, int *linep, int *col)
d160 1
d165 1
a165 1
pmdoc(const struct mdoc_node *p, int *line, int *col)
d170 1
a170 1
			pline(p->line, line, col);
d172 1
a172 1
			pstring(p->string, p->pos, col);
d174 1
a174 1
			pmdoc(p->child, line, col);
d179 1
a179 1
pman(const struct man_node *p, int *line, int *col)
d184 1
a184 1
			pline(p->line, line, col);
d186 1
a186 1
			pstring(p->string, p->pos, col);
d188 1
a188 1
			pman(p->child, line, col);
@


1.2
log
@Allow compilation on OpenBSD.
@
text
@d1 1
a1 1
/*	$Id: demandoc.c,v 1.1 2011/09/01 10:46:28 kristaps Exp $ */
a46 1
	extern char	*optarg;
d78 1
a78 1
	return(MANDOCLEVEL_OK);
d134 1
a134 1
			putchar(*p++);
@


1.1
log
@Add demandoc utility, a replacement for deroff.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.5 2011/07/15 17:59:29 kristaps Exp $ */
d26 1
@
