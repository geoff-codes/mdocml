head	1.210;
access;
symbols
	VERSION_1_13_3:1.186
	VERSION_1_13_2:1.179
	VERSION_1_12_4:1.49.2.18
	VERSION_1_13_1:1.155
	VERSION_1_12_3:1.49.2.10
	VERSION_1_12_2:1.49.2.7
	VERSION_1_12:1.49.0.2
	VERSION_1_12_1:1.46
	VERSION_1_12_0:1.6
	VERSION_1_11_7:1.5
	VERSION_1_11_6:1.5
	VERSION_1_11_5:1.5;
locks; strict;
comment	@ * @;


1.210
date	2015.12.15.17.38.45;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2015.11.07.17.58.55;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2015.11.07.14.22.29;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2015.11.06.17.33.34;	author schwarze;	state Exp;
branches;
next	1.206;

1.206
date	2015.11.06.16.30.33;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2015.10.22.22.06.43;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2015.10.20.02.01.31;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2015.10.13.15.53.05;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2015.10.12.21.17.15;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2015.10.12.00.32.55;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2015.10.12.00.08.15;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2015.10.11.21.12.54;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2015.09.16.09.50.29;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2015.07.19.06.05.16;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2015.04.23.16.17.44;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2015.04.18.17.53.21;	author schwarze;	state Exp;
branches;
next	1.192;

1.192
date	2015.04.18.16.34.25;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2015.04.18.16.06.40;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2015.04.02.23.48.19;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2015.04.02.22.48.17;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2015.04.02.21.36.50;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2015.03.27.17.37.25;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2015.03.13.00.19.41;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2015.02.27.16.22.09;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2015.01.21.22.41.49;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2015.01.15.04.26.40;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2015.01.03.12.55.25;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2015.01.02.17.02.19;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2014.12.30.20.41.00;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2014.12.09.07.29.42;	author schwarze;	state Exp;
branches;
next	1.178;

1.178
date	2014.12.05.16.18.14;	author schwarze;	state Exp;
branches;
next	1.177;

1.177
date	2014.12.05.15.16.54;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2014.12.05.14.26.40;	author schwarze;	state Exp;
branches;
next	1.175;

1.175
date	2014.12.04.21.48.48;	author schwarze;	state Exp;
branches;
next	1.174;

1.174
date	2014.12.04.20.13.25;	author schwarze;	state Exp;
branches;
next	1.173;

1.173
date	2014.12.04.18.31.20;	author schwarze;	state Exp;
branches;
next	1.172;

1.172
date	2014.12.04.17.36.00;	author schwarze;	state Exp;
branches;
next	1.171;

1.171
date	2014.11.27.01.58.21;	author schwarze;	state Exp;
branches;
next	1.170;

1.170
date	2014.11.26.21.40.17;	author schwarze;	state Exp;
branches;
next	1.169;

1.169
date	2014.11.19.20.40.51;	author schwarze;	state Exp;
branches;
next	1.168;

1.168
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.167;

1.167
date	2014.10.27.13.31.04;	author schwarze;	state Exp;
branches;
next	1.166;

1.166
date	2014.10.12.20.32.39;	author schwarze;	state Exp;
branches;
next	1.165;

1.165
date	2014.09.09.19.35.25;	author schwarze;	state Exp;
branches;
next	1.164;

1.164
date	2014.09.07.03.08.47;	author schwarze;	state Exp;
branches;
next	1.163;

1.163
date	2014.09.07.03.00.21;	author schwarze;	state Exp;
branches;
next	1.162;

1.162
date	2014.09.03.23.21.47;	author schwarze;	state Exp;
branches;
next	1.161;

1.161
date	2014.09.03.18.09.14;	author schwarze;	state Exp;
branches;
next	1.160;

1.160
date	2014.09.01.23.47.59;	author schwarze;	state Exp;
branches;
next	1.159;

1.159
date	2014.08.23.18.13.47;	author schwarze;	state Exp;
branches;
next	1.158;

1.158
date	2014.08.16.19.00.01;	author schwarze;	state Exp;
branches;
next	1.157;

1.157
date	2014.08.11.01.39.00;	author schwarze;	state Exp;
branches;
next	1.156;

1.156
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.155;

1.155
date	2014.08.06.15.09.05;	author schwarze;	state Exp;
branches;
next	1.154;

1.154
date	2014.08.05.14.43.10;	author schwarze;	state Exp;
branches;
next	1.153;

1.153
date	2014.06.21.16.18.25;	author schwarze;	state Exp;
branches;
next	1.152;

1.152
date	2014.06.20.02.24.40;	author schwarze;	state Exp;
branches;
next	1.151;

1.151
date	2014.06.20.01.21.48;	author schwarze;	state Exp;
branches;
next	1.150;

1.150
date	2014.06.19.00.45.37;	author schwarze;	state Exp;
branches;
next	1.149;

1.149
date	2014.06.18.19.34.04;	author schwarze;	state Exp;
branches;
next	1.148;

1.148
date	2014.05.07.16.19.03;	author schwarze;	state Exp;
branches;
next	1.147;

1.147
date	2014.05.07.15.10.36;	author schwarze;	state Exp;
branches;
next	1.146;

1.146
date	2014.04.27.23.08.56;	author schwarze;	state Exp;
branches;
next	1.145;

1.145
date	2014.04.25.12.13.15;	author schwarze;	state Exp;
branches;
next	1.144;

1.144
date	2014.04.23.21.06.41;	author schwarze;	state Exp;
branches;
next	1.143;

1.143
date	2014.04.23.19.09.16;	author schwarze;	state Exp;
branches;
next	1.142;

1.142
date	2014.04.23.16.34.50;	author schwarze;	state Exp;
branches;
next	1.141;

1.141
date	2014.04.20.16.46.04;	author schwarze;	state Exp;
branches;
next	1.140;

1.140
date	2014.04.19.02.56.54;	author schwarze;	state Exp;
branches;
next	1.139;

1.139
date	2014.04.19.02.30.19;	author schwarze;	state Exp;
branches;
next	1.138;

1.138
date	2014.04.18.21.55.38;	author schwarze;	state Exp;
branches;
next	1.137;

1.137
date	2014.04.16.21.36.18;	author schwarze;	state Exp;
branches;
next	1.136;

1.136
date	2014.04.16.18.59.43;	author schwarze;	state Exp;
branches;
next	1.135;

1.135
date	2014.04.13.22.03.04;	author schwarze;	state Exp;
branches;
next	1.134;

1.134
date	2014.04.13.20.55.45;	author schwarze;	state Exp;
branches;
next	1.133;

1.133
date	2014.04.10.02.46.21;	author schwarze;	state Exp;
branches;
next	1.132;

1.132
date	2014.04.09.21.50.08;	author schwarze;	state Exp;
branches;
next	1.131;

1.131
date	2014.04.04.18.23.30;	author schwarze;	state Exp;
branches;
next	1.130;

1.130
date	2014.04.04.16.43.16;	author schwarze;	state Exp;
branches;
next	1.129;

1.129
date	2014.04.04.15.55.19;	author schwarze;	state Exp;
branches;
next	1.128;

1.128
date	2014.04.04.02.31.07;	author schwarze;	state Exp;
branches;
next	1.127;

1.127
date	2014.04.03.21.45.31;	author schwarze;	state Exp;
branches;
next	1.126;

1.126
date	2014.04.03.16.27.28;	author schwarze;	state Exp;
branches;
next	1.125;

1.125
date	2014.04.03.15.37.19;	author schwarze;	state Exp;
branches;
next	1.124;

1.124
date	2014.03.26.21.39.38;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2014.03.26.20.53.36;	author schwarze;	state Exp;
branches;
next	1.122;

1.122
date	2014.03.23.12.44.56;	author schwarze;	state Exp;
branches;
next	1.121;

1.121
date	2014.03.23.12.26.58;	author schwarze;	state Exp;
branches;
next	1.120;

1.120
date	2014.03.23.12.11.18;	author schwarze;	state Exp;
branches;
next	1.119;

1.119
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2014.03.19.22.33.09;	author schwarze;	state Exp;
branches;
next	1.117;

1.117
date	2014.03.19.22.20.43;	author schwarze;	state Exp;
branches;
next	1.116;

1.116
date	2014.03.19.21.51.20;	author schwarze;	state Exp;
branches;
next	1.115;

1.115
date	2014.03.18.16.56.10;	author schwarze;	state Exp;
branches;
next	1.114;

1.114
date	2014.01.22.20.58.39;	author schwarze;	state Exp;
branches;
next	1.113;

1.113
date	2014.01.19.22.48.16;	author schwarze;	state Exp;
branches;
next	1.112;

1.112
date	2014.01.19.22.41.25;	author schwarze;	state Exp;
branches;
next	1.111;

1.111
date	2014.01.19.00.09.38;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2014.01.18.08.55.17;	author schwarze;	state Exp;
branches;
next	1.109;

1.109
date	2014.01.18.08.21.03;	author schwarze;	state Exp;
branches;
next	1.108;

1.108
date	2014.01.18.08.19.18;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2014.01.06.20.53.40;	author schwarze;	state Exp;
branches;
next	1.106;

1.106
date	2014.01.06.15.32.47;	author schwarze;	state Exp;
branches;
next	1.105;

1.105
date	2014.01.06.13.54.17;	author schwarze;	state Exp;
branches;
next	1.104;

1.104
date	2014.01.06.03.52.13;	author schwarze;	state Exp;
branches;
next	1.103;

1.103
date	2014.01.06.03.02.46;	author schwarze;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.05.20.26.36;	author schwarze;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.05.04.48.40;	author schwarze;	state Exp;
branches;
next	1.100;

1.100
date	2014.01.05.04.13.52;	author schwarze;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.05.03.25.51;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2014.01.05.03.06.43;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2014.01.05.00.29.54;	author schwarze;	state Exp;
branches;
next	1.96;

1.96
date	2014.01.02.22.44.10;	author schwarze;	state Exp;
branches;
next	1.95;

1.95
date	2014.01.02.22.19.41;	author schwarze;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.02.20.24.39;	author schwarze;	state Exp;
branches;
next	1.93;

1.93
date	2014.01.02.18.52.15;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2013.12.31.19.40.20;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2013.12.31.18.07.42;	author schwarze;	state Exp;
branches;
next	1.90;

1.90
date	2013.12.27.23.41.55;	author schwarze;	state Exp;
branches;
next	1.89;

1.89
date	2013.12.27.20.35.51;	author schwarze;	state Exp;
branches;
next	1.88;

1.88
date	2013.12.27.18.42.25;	author schwarze;	state Exp;
branches;
next	1.87;

1.87
date	2013.12.27.16.40.35;	author schwarze;	state Exp;
branches;
next	1.86;

1.86
date	2013.12.27.16.17.32;	author schwarze;	state Exp;
branches;
next	1.85;

1.85
date	2013.12.27.15.48.09;	author schwarze;	state Exp;
branches;
next	1.84;

1.84
date	2013.12.27.15.39.03;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2013.12.27.14.29.28;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2013.12.27.03.06.17;	author schwarze;	state Exp;
branches;
next	1.81;

1.81
date	2013.12.27.01.16.54;	author schwarze;	state Exp;
branches;
next	1.80;

1.80
date	2013.12.26.23.35.59;	author schwarze;	state Exp;
branches;
next	1.79;

1.79
date	2013.12.26.22.30.41;	author schwarze;	state Exp;
branches;
next	1.78;

1.78
date	2013.12.26.22.12.46;	author schwarze;	state Exp;
branches;
next	1.77;

1.77
date	2013.12.26.19.02.04;	author schwarze;	state Exp;
branches;
next	1.76;

1.76
date	2013.10.27.17.01.18;	author schwarze;	state Exp;
branches;
next	1.75;

1.75
date	2013.10.27.16.41.31;	author schwarze;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.27.16.09.44;	author schwarze;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.18.23.07.23;	author schwarze;	state Exp;
branches;
next	1.72;

1.72
date	2013.10.18.21.10.07;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2013.07.02.13.26.52;	author schwarze;	state Exp;
branches;
next	1.70;

1.70
date	2013.07.02.12.58.54;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2013.07.02.11.40.40;	author schwarze;	state Exp;
branches;
next	1.68;

1.68
date	2013.06.07.05.27.50;	author schwarze;	state Exp;
branches;
next	1.67;

1.67
date	2013.06.07.04.51.26;	author schwarze;	state Exp;
branches;
next	1.66;

1.66
date	2013.06.07.01.01.34;	author schwarze;	state Exp;
branches;
next	1.65;

1.65
date	2013.06.06.19.00.28;	author schwarze;	state Exp;
branches;
next	1.64;

1.64
date	2013.06.06.17.51.31;	author schwarze;	state Exp;
branches;
next	1.63;

1.63
date	2013.06.06.15.15.07;	author schwarze;	state Exp;
branches;
next	1.62;

1.62
date	2013.06.06.02.40.37;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2013.06.05.21.21.08;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.05.20.27.11;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2013.06.05.17.48.14;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2013.06.05.02.00.26;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2013.06.03.22.51.14;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2013.06.03.19.01.31;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2012.06.09.14.11.16;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2012.06.09.11.21.12;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2012.06.09.11.00.13;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2012.06.08.15.06.28;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2012.06.08.12.05.27;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2012.06.08.10.43.01;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2012.05.27.17.48.57;	author schwarze;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2012.05.27.17.39.28;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2012.04.15.13.30.38;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2012.03.23.06.52.17;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2012.03.23.05.45.45;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.23.05.07.35;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2011.12.31.18.47.52;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2011.12.28.00.32.13;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2011.12.25.19.31.25;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2011.12.25.16.53.51;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2011.12.25.14.58.39;	author schwarze;	state Exp;
branches;
next	1.38;

1.38
date	2011.12.25.13.08.12;	author schwarze;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.20.21.41.11;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.16.12.06.35;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2011.12.16.08.04.34;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.12.02.00.49;	author schwarze;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.10.22.01.06;	author schwarze;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.10.16.53.39;	author schwarze;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.09.11.16.34;	author schwarze;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.09.01.21.10;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.09.00.49.01;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.08.09.19.13;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2011.12.08.02.24.31;	author schwarze;	state Exp;
branches;
next	1.26;

1.26
date	2011.12.08.01.00.58;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.07.01.57.20;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.04.14.23.29;	author schwarze;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.03.18.47.09;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.03.12.09.07;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.02.00.21.56;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.01.23.55.58;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.01.23.46.26;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.01.21.05.49;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.29.00.34.50;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.27.23.27.31;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.27.23.11.37;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2011.11.27.22.57.53;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2011.11.26.22.38.11;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.11.26.11.23.56;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.11.24.12.54.19;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2011.11.23.09.52.20;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.20.12.39.08;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.13.10.49.57;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2011.11.13.00.53.13;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2011.09.17.13.54.27;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.15.17.59.29;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.15.10.15.24;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.15.09.06.23;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.14.14.36.37;	author schwarze;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.14.10.57.02;	author kristaps;	state Exp;
branches;
next	;

1.49.2.1
date	2013.09.17.21.32.07;	author schwarze;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2013.09.17.22.48.53;	author schwarze;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2013.09.17.23.07.22;	author schwarze;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2013.09.17.23.12.21;	author schwarze;	state Exp;
branches;
next	1.49.2.5;

1.49.2.5
date	2013.09.18.00.54.20;	author schwarze;	state Exp;
branches;
next	1.49.2.6;

1.49.2.6
date	2013.10.01.00.52.58;	author schwarze;	state Exp;
branches;
next	1.49.2.7;

1.49.2.7
date	2013.10.02.21.03.26;	author schwarze;	state Exp;
branches;
next	1.49.2.8;

1.49.2.8
date	2013.10.05.20.30.05;	author schwarze;	state Exp;
branches;
next	1.49.2.9;

1.49.2.9
date	2013.10.10.23.43.04;	author schwarze;	state Exp;
branches;
next	1.49.2.10;

1.49.2.10
date	2013.11.21.01.53.48;	author schwarze;	state Exp;
branches;
next	1.49.2.11;

1.49.2.11
date	2014.01.05.21.30.57;	author schwarze;	state Exp;
branches;
next	1.49.2.12;

1.49.2.12
date	2014.03.19.22.09.29;	author schwarze;	state Exp;
branches;
next	1.49.2.13;

1.49.2.13
date	2014.03.19.22.24.12;	author schwarze;	state Exp;
branches;
next	1.49.2.14;

1.49.2.14
date	2014.03.23.12.04.54;	author schwarze;	state Exp;
branches;
next	1.49.2.15;

1.49.2.15
date	2014.03.23.12.37.58;	author schwarze;	state Exp;
branches;
next	1.49.2.16;

1.49.2.16
date	2014.04.23.21.31.38;	author schwarze;	state Exp;
branches;
next	1.49.2.17;

1.49.2.17
date	2014.08.11.00.31.13;	author schwarze;	state Exp;
branches;
next	1.49.2.18;

1.49.2.18
date	2014.08.14.04.13.30;	author schwarze;	state Exp;
branches;
next	;


desc
@@


1.210
log
@pledge(2) style:
Make sure to always use the idiom 'if (pledge("'
such that it can easily be searched for.
No functional change.
Requested by deraadt@@ some time ago.
@
text
@/*	$Id: mandocdb.c,v 1.209 2015/11/07 17:58:55 schwarze Exp $ */
/*
 * Copyright (c) 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011-2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>

#include <assert.h>
#include <ctype.h>
#if HAVE_ERR
#include <err.h>
#endif
#include <errno.h>
#include <fcntl.h>
#if HAVE_FTS
#include <fts.h>
#else
#include "compat_fts.h"
#endif
#include <getopt.h>
#include <limits.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sqlite3.h>

#include "mandoc_aux.h"
#include "mandoc_ohash.h"
#include "mandoc.h"
#include "roff.h"
#include "mdoc.h"
#include "man.h"
#include "manconf.h"
#include "mansearch.h"

extern int mansearch_keymax;
extern const char *const mansearch_keynames[];

#define	SQL_EXEC(_v) \
	if (SQLITE_OK != sqlite3_exec(db, (_v), NULL, NULL, NULL)) \
		say("", "%s: %s", (_v), sqlite3_errmsg(db))
#define	SQL_BIND_TEXT(_s, _i, _v) \
	if (SQLITE_OK != sqlite3_bind_text \
		((_s), (_i)++, (_v), -1, SQLITE_STATIC)) \
		say(mlink->file, "%s", sqlite3_errmsg(db))
#define	SQL_BIND_INT(_s, _i, _v) \
	if (SQLITE_OK != sqlite3_bind_int \
		((_s), (_i)++, (_v))) \
		say(mlink->file, "%s", sqlite3_errmsg(db))
#define	SQL_BIND_INT64(_s, _i, _v) \
	if (SQLITE_OK != sqlite3_bind_int64 \
		((_s), (_i)++, (_v))) \
		say(mlink->file, "%s", sqlite3_errmsg(db))
#define SQL_STEP(_s) \
	if (SQLITE_DONE != sqlite3_step((_s))) \
		say(mlink->file, "%s", sqlite3_errmsg(db))

enum	op {
	OP_DEFAULT = 0, /* new dbs from dir list or default config */
	OP_CONFFILE, /* new databases from custom config file */
	OP_UPDATE, /* delete/add entries in existing database */
	OP_DELETE, /* delete entries from existing database */
	OP_TEST /* change no databases, report potential problems */
};

struct	str {
	const struct mpage *mpage; /* if set, the owning parse */
	uint64_t	 mask; /* bitmask in sequence */
	char		 key[]; /* rendered text */
};

struct	inodev {
	ino_t		 st_ino;
	dev_t		 st_dev;
};

struct	mpage {
	struct inodev	 inodev;  /* used for hashing routine */
	int64_t		 pageid;  /* pageid in mpages SQL table */
	char		*sec;     /* section from file content */
	char		*arch;    /* architecture from file content */
	char		*title;   /* title from file content */
	char		*desc;    /* description from file content */
	struct mlink	*mlinks;  /* singly linked list */
	int		 form;    /* format from file content */
	int		 name_head_done;
};

struct	mlink {
	char		 file[PATH_MAX]; /* filename rel. to manpath */
	char		*dsec;    /* section from directory */
	char		*arch;    /* architecture from directory */
	char		*name;    /* name from file name (not empty) */
	char		*fsec;    /* section from file name suffix */
	struct mlink	*next;    /* singly linked list */
	struct mpage	*mpage;   /* parent */
	int		 dform;   /* format from directory */
	int		 fform;   /* format from file name suffix */
	int		 gzip;	  /* filename has a .gz suffix */
};

enum	stmt {
	STMT_DELETE_PAGE = 0,	/* delete mpage */
	STMT_INSERT_PAGE,	/* insert mpage */
	STMT_INSERT_LINK,	/* insert mlink */
	STMT_INSERT_NAME,	/* insert name */
	STMT_SELECT_NAME,	/* retrieve existing name flags */
	STMT_INSERT_KEY,	/* insert parsed key */
	STMT__MAX
};

typedef	int (*mdoc_fp)(struct mpage *, const struct roff_meta *,
			const struct roff_node *);

struct	mdoc_handler {
	mdoc_fp		 fp; /* optional handler */
	uint64_t	 mask;  /* set unless handler returns 0 */
};

static	void	 dbclose(int);
static	void	 dbadd(struct mpage *);
static	void	 dbadd_mlink(const struct mlink *mlink);
static	void	 dbadd_mlink_name(const struct mlink *mlink);
static	int	 dbopen(int);
static	void	 dbprune(void);
static	void	 filescan(const char *);
static	void	 mlink_add(struct mlink *, const struct stat *);
static	void	 mlink_check(struct mpage *, struct mlink *);
static	void	 mlink_free(struct mlink *);
static	void	 mlinks_undupe(struct mpage *);
static	void	 mpages_free(void);
static	void	 mpages_merge(struct mparse *);
static	void	 names_check(void);
static	void	 parse_cat(struct mpage *, int);
static	void	 parse_man(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	void	 parse_mdoc(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_body(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_head(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Fd(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	void	 parse_mdoc_fname(struct mpage *, const struct roff_node *);
static	int	 parse_mdoc_Fn(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Fo(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Nd(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Nm(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Sh(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	int	 parse_mdoc_Xr(struct mpage *, const struct roff_meta *,
			const struct roff_node *);
static	void	 putkey(const struct mpage *, char *, uint64_t);
static	void	 putkeys(const struct mpage *, char *, size_t, uint64_t);
static	void	 putmdockey(const struct mpage *,
			const struct roff_node *, uint64_t);
static	int	 render_string(char **, size_t *);
static	void	 say(const char *, const char *, ...);
static	int	 set_basedir(const char *, int);
static	int	 treescan(void);
static	size_t	 utf8(unsigned int, char [7]);

static	char		 tempfilename[32];
static	int		 nodb; /* no database changes */
static	int		 mparse_options; /* abort the parse early */
static	int		 use_all; /* use all found files */
static	int		 debug; /* print what we're doing */
static	int		 warnings; /* warn about crap */
static	int		 write_utf8; /* write UTF-8 output; else ASCII */
static	int		 exitcode; /* to be returned by main */
static	enum op		 op; /* operational mode */
static	char		 basedir[PATH_MAX]; /* current base directory */
static	struct ohash	 mpages; /* table of distinct manual pages */
static	struct ohash	 mlinks; /* table of directory entries */
static	struct ohash	 names; /* table of all names */
static	struct ohash	 strings; /* table of all strings */
static	sqlite3		*db = NULL; /* current database */
static	sqlite3_stmt	*stmts[STMT__MAX]; /* current statements */
static	uint64_t	 name_mask;

static	const struct mdoc_handler mdocs[MDOC_MAX] = {
	{ NULL, 0 },  /* Ap */
	{ NULL, 0 },  /* Dd */
	{ NULL, 0 },  /* Dt */
	{ NULL, 0 },  /* Os */
	{ parse_mdoc_Sh, TYPE_Sh }, /* Sh */
	{ parse_mdoc_head, TYPE_Ss }, /* Ss */
	{ NULL, 0 },  /* Pp */
	{ NULL, 0 },  /* D1 */
	{ NULL, 0 },  /* Dl */
	{ NULL, 0 },  /* Bd */
	{ NULL, 0 },  /* Ed */
	{ NULL, 0 },  /* Bl */
	{ NULL, 0 },  /* El */
	{ NULL, 0 },  /* It */
	{ NULL, 0 },  /* Ad */
	{ NULL, TYPE_An },  /* An */
	{ NULL, TYPE_Ar },  /* Ar */
	{ NULL, TYPE_Cd },  /* Cd */
	{ NULL, TYPE_Cm },  /* Cm */
	{ NULL, TYPE_Dv },  /* Dv */
	{ NULL, TYPE_Er },  /* Er */
	{ NULL, TYPE_Ev },  /* Ev */
	{ NULL, 0 },  /* Ex */
	{ NULL, TYPE_Fa },  /* Fa */
	{ parse_mdoc_Fd, 0 },  /* Fd */
	{ NULL, TYPE_Fl },  /* Fl */
	{ parse_mdoc_Fn, 0 },  /* Fn */
	{ NULL, TYPE_Ft },  /* Ft */
	{ NULL, TYPE_Ic },  /* Ic */
	{ NULL, TYPE_In },  /* In */
	{ NULL, TYPE_Li },  /* Li */
	{ parse_mdoc_Nd, 0 },  /* Nd */
	{ parse_mdoc_Nm, 0 },  /* Nm */
	{ NULL, 0 },  /* Op */
	{ NULL, 0 },  /* Ot */
	{ NULL, TYPE_Pa },  /* Pa */
	{ NULL, 0 },  /* Rv */
	{ NULL, TYPE_St },  /* St */
	{ NULL, TYPE_Va },  /* Va */
	{ parse_mdoc_body, TYPE_Va },  /* Vt */
	{ parse_mdoc_Xr, 0 },  /* Xr */
	{ NULL, 0 },  /* %A */
	{ NULL, 0 },  /* %B */
	{ NULL, 0 },  /* %D */
	{ NULL, 0 },  /* %I */
	{ NULL, 0 },  /* %J */
	{ NULL, 0 },  /* %N */
	{ NULL, 0 },  /* %O */
	{ NULL, 0 },  /* %P */
	{ NULL, 0 },  /* %R */
	{ NULL, 0 },  /* %T */
	{ NULL, 0 },  /* %V */
	{ NULL, 0 },  /* Ac */
	{ NULL, 0 },  /* Ao */
	{ NULL, 0 },  /* Aq */
	{ NULL, TYPE_At },  /* At */
	{ NULL, 0 },  /* Bc */
	{ NULL, 0 },  /* Bf */
	{ NULL, 0 },  /* Bo */
	{ NULL, 0 },  /* Bq */
	{ NULL, TYPE_Bsx },  /* Bsx */
	{ NULL, TYPE_Bx },  /* Bx */
	{ NULL, 0 },  /* Db */
	{ NULL, 0 },  /* Dc */
	{ NULL, 0 },  /* Do */
	{ NULL, 0 },  /* Dq */
	{ NULL, 0 },  /* Ec */
	{ NULL, 0 },  /* Ef */
	{ NULL, TYPE_Em },  /* Em */
	{ NULL, 0 },  /* Eo */
	{ NULL, TYPE_Fx },  /* Fx */
	{ NULL, TYPE_Ms },  /* Ms */
	{ NULL, 0 },  /* No */
	{ NULL, 0 },  /* Ns */
	{ NULL, TYPE_Nx },  /* Nx */
	{ NULL, TYPE_Ox },  /* Ox */
	{ NULL, 0 },  /* Pc */
	{ NULL, 0 },  /* Pf */
	{ NULL, 0 },  /* Po */
	{ NULL, 0 },  /* Pq */
	{ NULL, 0 },  /* Qc */
	{ NULL, 0 },  /* Ql */
	{ NULL, 0 },  /* Qo */
	{ NULL, 0 },  /* Qq */
	{ NULL, 0 },  /* Re */
	{ NULL, 0 },  /* Rs */
	{ NULL, 0 },  /* Sc */
	{ NULL, 0 },  /* So */
	{ NULL, 0 },  /* Sq */
	{ NULL, 0 },  /* Sm */
	{ NULL, 0 },  /* Sx */
	{ NULL, TYPE_Sy },  /* Sy */
	{ NULL, TYPE_Tn },  /* Tn */
	{ NULL, 0 },  /* Ux */
	{ NULL, 0 },  /* Xc */
	{ NULL, 0 },  /* Xo */
	{ parse_mdoc_Fo, 0 },  /* Fo */
	{ NULL, 0 },  /* Fc */
	{ NULL, 0 },  /* Oo */
	{ NULL, 0 },  /* Oc */
	{ NULL, 0 },  /* Bk */
	{ NULL, 0 },  /* Ek */
	{ NULL, 0 },  /* Bt */
	{ NULL, 0 },  /* Hf */
	{ NULL, 0 },  /* Fr */
	{ NULL, 0 },  /* Ud */
	{ NULL, TYPE_Lb },  /* Lb */
	{ NULL, 0 },  /* Lp */
	{ NULL, TYPE_Lk },  /* Lk */
	{ NULL, TYPE_Mt },  /* Mt */
	{ NULL, 0 },  /* Brq */
	{ NULL, 0 },  /* Bro */
	{ NULL, 0 },  /* Brc */
	{ NULL, 0 },  /* %C */
	{ NULL, 0 },  /* Es */
	{ NULL, 0 },  /* En */
	{ NULL, TYPE_Dx },  /* Dx */
	{ NULL, 0 },  /* %Q */
	{ NULL, 0 },  /* br */
	{ NULL, 0 },  /* sp */
	{ NULL, 0 },  /* %U */
	{ NULL, 0 },  /* Ta */
	{ NULL, 0 },  /* ll */
};


int
mandocdb(int argc, char *argv[])
{
	struct manconf	  conf;
	struct mparse	 *mp;
	const char	 *path_arg, *progname;
	size_t		  j, sz;
	int		  ch, i;

#if HAVE_PLEDGE
	if (pledge("stdio rpath wpath cpath fattr flock proc exec", NULL) == -1) {
		perror("pledge");
		return (int)MANDOCLEVEL_SYSERR;
	}
#endif

	memset(&conf, 0, sizeof(conf));
	memset(stmts, 0, STMT__MAX * sizeof(sqlite3_stmt *));

	/*
	 * We accept a few different invocations.
	 * The CHECKOP macro makes sure that invocation styles don't
	 * clobber each other.
	 */
#define	CHECKOP(_op, _ch) do \
	if (OP_DEFAULT != (_op)) { \
		warnx("-%c: Conflicting option", (_ch)); \
		goto usage; \
	} while (/*CONSTCOND*/0)

	path_arg = NULL;
	op = OP_DEFAULT;

	while (-1 != (ch = getopt(argc, argv, "aC:Dd:npQT:tu:v")))
		switch (ch) {
		case 'a':
			use_all = 1;
			break;
		case 'C':
			CHECKOP(op, ch);
			path_arg = optarg;
			op = OP_CONFFILE;
			break;
		case 'D':
			debug++;
			break;
		case 'd':
			CHECKOP(op, ch);
			path_arg = optarg;
			op = OP_UPDATE;
			break;
		case 'n':
			nodb = 1;
			break;
		case 'p':
			warnings = 1;
			break;
		case 'Q':
			mparse_options |= MPARSE_QUICK;
			break;
		case 'T':
			if (strcmp(optarg, "utf8")) {
				warnx("-T%s: Unsupported output format",
				    optarg);
				goto usage;
			}
			write_utf8 = 1;
			break;
		case 't':
			CHECKOP(op, ch);
			dup2(STDOUT_FILENO, STDERR_FILENO);
			op = OP_TEST;
			nodb = warnings = 1;
			break;
		case 'u':
			CHECKOP(op, ch);
			path_arg = optarg;
			op = OP_DELETE;
			break;
		case 'v':
			/* Compatibility with espie@@'s makewhatis. */
			break;
		default:
			goto usage;
		}

	argc -= optind;
	argv += optind;

#if HAVE_PLEDGE
	if (nodb) {
		if (pledge("stdio rpath", NULL) == -1) {
			perror("pledge");
			return (int)MANDOCLEVEL_SYSERR;
		}
	}
#endif

	if (OP_CONFFILE == op && argc > 0) {
		warnx("-C: Too many arguments");
		goto usage;
	}

	exitcode = (int)MANDOCLEVEL_OK;
	mchars_alloc();
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_BADARG, NULL, NULL);
	mandoc_ohash_init(&mpages, 6, offsetof(struct mpage, inodev));
	mandoc_ohash_init(&mlinks, 6, offsetof(struct mlink, file));

	if (OP_UPDATE == op || OP_DELETE == op || OP_TEST == op) {

		/*
		 * Most of these deal with a specific directory.
		 * Jump into that directory first.
		 */
		if (OP_TEST != op && 0 == set_basedir(path_arg, 1))
			goto out;

		if (dbopen(1)) {
			/*
			 * The existing database is usable.  Process
			 * all files specified on the command-line.
			 */
#if HAVE_PLEDGE
			if (!nodb) {
				if (pledge("stdio rpath wpath cpath fattr flock", NULL) == -1) {
					perror("pledge");
					exitcode = (int)MANDOCLEVEL_SYSERR;
					goto out;
				}
			}
#endif
			use_all = 1;
			for (i = 0; i < argc; i++)
				filescan(argv[i]);
			if (OP_TEST != op)
				dbprune();
		} else {
			/*
			 * Database missing or corrupt.
			 * Recreate from scratch.
			 */
			exitcode = (int)MANDOCLEVEL_OK;
			op = OP_DEFAULT;
			if (0 == treescan())
				goto out;
			if (0 == dbopen(0))
				goto out;
		}
		if (OP_DELETE != op)
			mpages_merge(mp);
		dbclose(OP_DEFAULT == op ? 0 : 1);
	} else {
		/*
		 * If we have arguments, use them as our manpaths.
		 * If we don't, grok from manpath(1) or however else
		 * manconf_parse() wants to do it.
		 */
		if (argc > 0) {
			conf.manpath.paths = mandoc_reallocarray(NULL,
			    argc, sizeof(char *));
			conf.manpath.sz = (size_t)argc;
			for (i = 0; i < argc; i++)
				conf.manpath.paths[i] = mandoc_strdup(argv[i]);
		} else
			manconf_parse(&conf, path_arg, NULL, NULL);

		if (conf.manpath.sz == 0) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say("", "Empty manpath");
		}

		/*
		 * First scan the tree rooted at a base directory, then
		 * build a new database and finally move it into place.
		 * Ignore zero-length directories and strip trailing
		 * slashes.
		 */
		for (j = 0; j < conf.manpath.sz; j++) {
			sz = strlen(conf.manpath.paths[j]);
			if (sz && conf.manpath.paths[j][sz - 1] == '/')
				conf.manpath.paths[j][--sz] = '\0';
			if (0 == sz)
				continue;

			if (j) {
				mandoc_ohash_init(&mpages, 6,
				    offsetof(struct mpage, inodev));
				mandoc_ohash_init(&mlinks, 6,
				    offsetof(struct mlink, file));
			}

			if ( ! set_basedir(conf.manpath.paths[j], argc > 0))
				continue;
			if (0 == treescan())
				continue;
			if (0 == dbopen(0))
				continue;

			mpages_merge(mp);
			if (warnings && !nodb &&
			    ! (MPARSE_QUICK & mparse_options))
				names_check();
			dbclose(0);

			if (j + 1 < conf.manpath.sz) {
				mpages_free();
				ohash_delete(&mpages);
				ohash_delete(&mlinks);
			}
		}
	}
out:
	manconf_free(&conf);
	mparse_free(mp);
	mchars_free();
	mpages_free();
	ohash_delete(&mpages);
	ohash_delete(&mlinks);
	return exitcode;
usage:
	progname = getprogname();
	fprintf(stderr, "usage: %s [-aDnpQ] [-C file] [-Tutf8]\n"
			"       %s [-aDnpQ] [-Tutf8] dir ...\n"
			"       %s [-DnpQ] [-Tutf8] -d dir [file ...]\n"
			"       %s [-Dnp] -u dir [file ...]\n"
			"       %s [-Q] -t file ...\n",
		        progname, progname, progname, progname, progname);

	return (int)MANDOCLEVEL_BADARG;
}

/*
 * Scan a directory tree rooted at "basedir" for manpages.
 * We use fts(), scanning directory parts along the way for clues to our
 * section and architecture.
 *
 * If use_all has been specified, grok all files.
 * If not, sanitise paths to the following:
 *
 *   [./]man*[/<arch>]/<name>.<section>
 *   or
 *   [./]cat<section>[/<arch>]/<name>.0
 *
 * TODO: accomodate for multi-language directories.
 */
static int
treescan(void)
{
	char		 buf[PATH_MAX];
	FTS		*f;
	FTSENT		*ff;
	struct mlink	*mlink;
	int		 dform, gzip;
	char		*dsec, *arch, *fsec, *cp;
	const char	*path;
	const char	*argv[2];

	argv[0] = ".";
	argv[1] = (char *)NULL;

	f = fts_open((char * const *)argv,
	    FTS_PHYSICAL | FTS_NOCHDIR, NULL);
	if (f == NULL) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&fts_open");
		return 0;
	}

	dsec = arch = NULL;
	dform = FORM_NONE;

	while ((ff = fts_read(f)) != NULL) {
		path = ff->fts_path + 2;
		switch (ff->fts_info) {

		/*
		 * Symbolic links require various sanity checks,
		 * then get handled just like regular files.
		 */
		case FTS_SL:
			if (realpath(path, buf) == NULL) {
				if (warnings)
					say(path, "&realpath");
				continue;
			}
			if (strstr(buf, basedir) != buf
#ifdef HOMEBREWDIR
			    && strstr(buf, HOMEBREWDIR) != buf
#endif
			) {
				if (warnings) say("",
				    "%s: outside base directory", buf);
				continue;
			}
			/* Use logical inode to avoid mpages dupe. */
			if (stat(path, ff->fts_statp) == -1) {
				if (warnings)
					say(path, "&stat");
				continue;
			}
			/* FALLTHROUGH */

		/*
		 * If we're a regular file, add an mlink by using the
		 * stored directory data and handling the filename.
		 */
		case FTS_F:
			if ( ! strcmp(path, MANDOC_DB))
				continue;
			if ( ! use_all && ff->fts_level < 2) {
				if (warnings)
					say(path, "Extraneous file");
				continue;
			}
			gzip = 0;
			fsec = NULL;
			while (fsec == NULL) {
				fsec = strrchr(ff->fts_name, '.');
				if (fsec == NULL || strcmp(fsec+1, "gz"))
					break;
				gzip = 1;
				*fsec = '\0';
				fsec = NULL;
			}
			if (fsec == NULL) {
				if ( ! use_all) {
					if (warnings)
						say(path,
						    "No filename suffix");
					continue;
				}
			} else if ( ! strcmp(++fsec, "html")) {
				if (warnings)
					say(path, "Skip html");
				continue;
			} else if ( ! strcmp(fsec, "ps")) {
				if (warnings)
					say(path, "Skip ps");
				continue;
			} else if ( ! strcmp(fsec, "pdf")) {
				if (warnings)
					say(path, "Skip pdf");
				continue;
			} else if ( ! use_all &&
			    ((dform == FORM_SRC &&
			      strncmp(fsec, dsec, strlen(dsec))) ||
			     (dform == FORM_CAT && strcmp(fsec, "0")))) {
				if (warnings)
					say(path, "Wrong filename suffix");
				continue;
			} else
				fsec[-1] = '\0';

			mlink = mandoc_calloc(1, sizeof(struct mlink));
			if (strlcpy(mlink->file, path,
			    sizeof(mlink->file)) >=
			    sizeof(mlink->file)) {
				say(path, "Filename too long");
				free(mlink);
				continue;
			}
			mlink->dform = dform;
			mlink->dsec = dsec;
			mlink->arch = arch;
			mlink->name = ff->fts_name;
			mlink->fsec = fsec;
			mlink->gzip = gzip;
			mlink_add(mlink, ff->fts_statp);
			continue;

		case FTS_D:
		case FTS_DP:
			break;

		default:
			if (warnings)
				say(path, "Not a regular file");
			continue;
		}

		switch (ff->fts_level) {
		case 0:
			/* Ignore the root directory. */
			break;
		case 1:
			/*
			 * This might contain manX/ or catX/.
			 * Try to infer this from the name.
			 * If we're not in use_all, enforce it.
			 */
			cp = ff->fts_name;
			if (ff->fts_info == FTS_DP) {
				dform = FORM_NONE;
				dsec = NULL;
				break;
			}

			if ( ! strncmp(cp, "man", 3)) {
				dform = FORM_SRC;
				dsec = cp + 3;
			} else if ( ! strncmp(cp, "cat", 3)) {
				dform = FORM_CAT;
				dsec = cp + 3;
			} else {
				dform = FORM_NONE;
				dsec = NULL;
			}

			if (dsec != NULL || use_all)
				break;

			if (warnings)
				say(path, "Unknown directory part");
			fts_set(f, ff, FTS_SKIP);
			break;
		case 2:
			/*
			 * Possibly our architecture.
			 * If we're descending, keep tabs on it.
			 */
			if (ff->fts_info != FTS_DP && dsec != NULL)
				arch = ff->fts_name;
			else
				arch = NULL;
			break;
		default:
			if (ff->fts_info == FTS_DP || use_all)
				break;
			if (warnings)
				say(path, "Extraneous directory part");
			fts_set(f, ff, FTS_SKIP);
			break;
		}
	}

	fts_close(f);
	return 1;
}

/*
 * Add a file to the mlinks table.
 * Do not verify that it's a "valid" looking manpage (we'll do that
 * later).
 *
 * Try to infer the manual section, architecture, and page name from the
 * path, assuming it looks like
 *
 *   [./]man*[/<arch>]/<name>.<section>
 *   or
 *   [./]cat<section>[/<arch>]/<name>.0
 *
 * See treescan() for the fts(3) version of this.
 */
static void
filescan(const char *file)
{
	char		 buf[PATH_MAX];
	struct stat	 st;
	struct mlink	*mlink;
	char		*p, *start;

	assert(use_all);

	if (0 == strncmp(file, "./", 2))
		file += 2;

	/*
	 * We have to do lstat(2) before realpath(3) loses
	 * the information whether this is a symbolic link.
	 * We need to know that because for symbolic links,
	 * we want to use the orginal file name, while for
	 * regular files, we want to use the real path.
	 */
	if (-1 == lstat(file, &st)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "&lstat");
		return;
	} else if (0 == ((S_IFREG | S_IFLNK) & st.st_mode)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "Not a regular file");
		return;
	}

	/*
	 * We have to resolve the file name to the real path
	 * in any case for the base directory check.
	 */
	if (NULL == realpath(file, buf)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "&realpath");
		return;
	}

	if (OP_TEST == op)
		start = buf;
	else if (strstr(buf, basedir) == buf)
		start = buf + strlen(basedir);
#ifdef HOMEBREWDIR
	else if (strstr(buf, HOMEBREWDIR) == buf)
		start = buf;
#endif
	else {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say("", "%s: outside base directory", buf);
		return;
	}

	/*
	 * Now we are sure the file is inside our tree.
	 * If it is a symbolic link, ignore the real path
	 * and use the original name.
	 * This implies passing stuff like "cat1/../man1/foo.1"
	 * on the command line won't work.  So don't do that.
	 * Note the stat(2) can still fail if the link target
	 * doesn't exist.
	 */
	if (S_IFLNK & st.st_mode) {
		if (-1 == stat(buf, &st)) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say(file, "&stat");
			return;
		}
		if (strlcpy(buf, file, sizeof(buf)) >= sizeof(buf)) {
			say(file, "Filename too long");
			return;
		}
		start = buf;
		if (OP_TEST != op && strstr(buf, basedir) == buf)
			start += strlen(basedir);
	}

	mlink = mandoc_calloc(1, sizeof(struct mlink));
	mlink->dform = FORM_NONE;
	if (strlcpy(mlink->file, start, sizeof(mlink->file)) >=
	    sizeof(mlink->file)) {
		say(start, "Filename too long");
		free(mlink);
		return;
	}

	/*
	 * First try to guess our directory structure.
	 * If we find a separator, try to look for man* or cat*.
	 * If we find one of these and what's underneath is a directory,
	 * assume it's an architecture.
	 */
	if (NULL != (p = strchr(start, '/'))) {
		*p++ = '\0';
		if (0 == strncmp(start, "man", 3)) {
			mlink->dform = FORM_SRC;
			mlink->dsec = start + 3;
		} else if (0 == strncmp(start, "cat", 3)) {
			mlink->dform = FORM_CAT;
			mlink->dsec = start + 3;
		}

		start = p;
		if (NULL != mlink->dsec && NULL != (p = strchr(start, '/'))) {
			*p++ = '\0';
			mlink->arch = start;
			start = p;
		}
	}

	/*
	 * Now check the file suffix.
	 * Suffix of `.0' indicates a catpage, `.1-9' is a manpage.
	 */
	p = strrchr(start, '\0');
	while (p-- > start && '/' != *p && '.' != *p)
		/* Loop. */ ;

	if ('.' == *p) {
		*p++ = '\0';
		mlink->fsec = p;
	}

	/*
	 * Now try to parse the name.
	 * Use the filename portion of the path.
	 */
	mlink->name = start;
	if (NULL != (p = strrchr(start, '/'))) {
		mlink->name = p + 1;
		*p = '\0';
	}
	mlink_add(mlink, &st);
}

static void
mlink_add(struct mlink *mlink, const struct stat *st)
{
	struct inodev	 inodev;
	struct mpage	*mpage;
	unsigned int	 slot;

	assert(NULL != mlink->file);

	mlink->dsec = mandoc_strdup(mlink->dsec ? mlink->dsec : "");
	mlink->arch = mandoc_strdup(mlink->arch ? mlink->arch : "");
	mlink->name = mandoc_strdup(mlink->name ? mlink->name : "");
	mlink->fsec = mandoc_strdup(mlink->fsec ? mlink->fsec : "");

	if ('0' == *mlink->fsec) {
		free(mlink->fsec);
		mlink->fsec = mandoc_strdup(mlink->dsec);
		mlink->fform = FORM_CAT;
	} else if ('1' <= *mlink->fsec && '9' >= *mlink->fsec)
		mlink->fform = FORM_SRC;
	else
		mlink->fform = FORM_NONE;

	slot = ohash_qlookup(&mlinks, mlink->file);
	assert(NULL == ohash_find(&mlinks, slot));
	ohash_insert(&mlinks, slot, mlink);

	memset(&inodev, 0, sizeof(inodev));  /* Clear padding. */
	inodev.st_ino = st->st_ino;
	inodev.st_dev = st->st_dev;
	slot = ohash_lookup_memory(&mpages, (char *)&inodev,
	    sizeof(struct inodev), inodev.st_ino);
	mpage = ohash_find(&mpages, slot);
	if (NULL == mpage) {
		mpage = mandoc_calloc(1, sizeof(struct mpage));
		mpage->inodev.st_ino = inodev.st_ino;
		mpage->inodev.st_dev = inodev.st_dev;
		ohash_insert(&mpages, slot, mpage);
	} else
		mlink->next = mpage->mlinks;
	mpage->mlinks = mlink;
	mlink->mpage = mpage;
}

static void
mlink_free(struct mlink *mlink)
{

	free(mlink->dsec);
	free(mlink->arch);
	free(mlink->name);
	free(mlink->fsec);
	free(mlink);
}

static void
mpages_free(void)
{
	struct mpage	*mpage;
	struct mlink	*mlink;
	unsigned int	 slot;

	mpage = ohash_first(&mpages, &slot);
	while (NULL != mpage) {
		while (NULL != (mlink = mpage->mlinks)) {
			mpage->mlinks = mlink->next;
			mlink_free(mlink);
		}
		free(mpage->sec);
		free(mpage->arch);
		free(mpage->title);
		free(mpage->desc);
		free(mpage);
		mpage = ohash_next(&mpages, &slot);
	}
}

/*
 * For each mlink to the mpage, check whether the path looks like
 * it is formatted, and if it does, check whether a source manual
 * exists by the same name, ignoring the suffix.
 * If both conditions hold, drop the mlink.
 */
static void
mlinks_undupe(struct mpage *mpage)
{
	char		  buf[PATH_MAX];
	struct mlink	**prev;
	struct mlink	 *mlink;
	char		 *bufp;

	mpage->form = FORM_CAT;
	prev = &mpage->mlinks;
	while (NULL != (mlink = *prev)) {
		if (FORM_CAT != mlink->dform) {
			mpage->form = FORM_NONE;
			goto nextlink;
		}
		(void)strlcpy(buf, mlink->file, sizeof(buf));
		bufp = strstr(buf, "cat");
		assert(NULL != bufp);
		memcpy(bufp, "man", 3);
		if (NULL != (bufp = strrchr(buf, '.')))
			*++bufp = '\0';
		(void)strlcat(buf, mlink->dsec, sizeof(buf));
		if (NULL == ohash_find(&mlinks,
		    ohash_qlookup(&mlinks, buf)))
			goto nextlink;
		if (warnings)
			say(mlink->file, "Man source exists: %s", buf);
		if (use_all)
			goto nextlink;
		*prev = mlink->next;
		mlink_free(mlink);
		continue;
nextlink:
		prev = &(*prev)->next;
	}
}

static void
mlink_check(struct mpage *mpage, struct mlink *mlink)
{
	struct str	*str;
	unsigned int	 slot;

	/*
	 * Check whether the manual section given in a file
	 * agrees with the directory where the file is located.
	 * Some manuals have suffixes like (3p) on their
	 * section number either inside the file or in the
	 * directory name, some are linked into more than one
	 * section, like encrypt(1) = makekey(8).
	 */

	if (FORM_SRC == mpage->form &&
	    strcasecmp(mpage->sec, mlink->dsec))
		say(mlink->file, "Section \"%s\" manual in %s directory",
		    mpage->sec, mlink->dsec);

	/*
	 * Manual page directories exist for each kernel
	 * architecture as returned by machine(1).
	 * However, many manuals only depend on the
	 * application architecture as returned by arch(1).
	 * For example, some (2/ARM) manuals are shared
	 * across the "armish" and "zaurus" kernel
	 * architectures.
	 * A few manuals are even shared across completely
	 * different architectures, for example fdformat(1)
	 * on amd64, i386, sparc, and sparc64.
	 */

	if (strcasecmp(mpage->arch, mlink->arch))
		say(mlink->file, "Architecture \"%s\" manual in "
		    "\"%s\" directory", mpage->arch, mlink->arch);

	/*
	 * XXX
	 * parse_cat() doesn't set NAME_TITLE yet.
	 */

	if (FORM_CAT == mpage->form)
		return;

	/*
	 * Check whether this mlink
	 * appears as a name in the NAME section.
	 */

	slot = ohash_qlookup(&names, mlink->name);
	str = ohash_find(&names, slot);
	assert(NULL != str);
	if ( ! (NAME_TITLE & str->mask))
		say(mlink->file, "Name missing in NAME section");
}

/*
 * Run through the files in the global vector "mpages"
 * and add them to the database specified in "basedir".
 *
 * This handles the parsing scheme itself, using the cues of directory
 * and filename to determine whether the file is parsable or not.
 */
static void
mpages_merge(struct mparse *mp)
{
	char			 any[] = "any";
	struct mpage		*mpage, *mpage_dest;
	struct mlink		*mlink, *mlink_dest;
	struct roff_man		*man;
	char			*sodest;
	char			*cp;
	int			 fd;
	unsigned int		 pslot;

	if ( ! nodb)
		SQL_EXEC("BEGIN TRANSACTION");

	mpage = ohash_first(&mpages, &pslot);
	while (mpage != NULL) {
		mlinks_undupe(mpage);
		if ((mlink = mpage->mlinks) == NULL) {
			mpage = ohash_next(&mpages, &pslot);
			continue;
		}

		name_mask = NAME_MASK;
		mandoc_ohash_init(&names, 4, offsetof(struct str, key));
		mandoc_ohash_init(&strings, 6, offsetof(struct str, key));
		mparse_reset(mp);
		man = NULL;
		sodest = NULL;

		mparse_open(mp, &fd, mlink->file);
		if (fd == -1) {
			say(mlink->file, "&open");
			goto nextpage;
		}

		/*
		 * Interpret the file as mdoc(7) or man(7) source
		 * code, unless it is known to be formatted.
		 */
		if (mlink->dform != FORM_CAT || mlink->fform != FORM_CAT) {
			mparse_readfd(mp, fd, mlink->file);
			mparse_result(mp, &man, &sodest);
		}

		if (sodest != NULL) {
			mlink_dest = ohash_find(&mlinks,
			    ohash_qlookup(&mlinks, sodest));
			if (mlink_dest == NULL) {
				mandoc_asprintf(&cp, "%s.gz", sodest);
				mlink_dest = ohash_find(&mlinks,
				    ohash_qlookup(&mlinks, cp));
				free(cp);
			}
			if (mlink_dest != NULL) {

				/* The .so target exists. */

				mpage_dest = mlink_dest->mpage;
				while (1) {
					mlink->mpage = mpage_dest;

					/*
					 * If the target was already
					 * processed, add the links
					 * to the database now.
					 * Otherwise, this will
					 * happen when we come
					 * to the target.
					 */

					if (mpage_dest->pageid)
						dbadd_mlink_name(mlink);

					if (mlink->next == NULL)
						break;
					mlink = mlink->next;
				}

				/* Move all links to the target. */

				mlink->next = mlink_dest->next;
				mlink_dest->next = mpage->mlinks;
				mpage->mlinks = NULL;
			}
			goto nextpage;
		} else if (man != NULL && man->macroset == MACROSET_MDOC) {
			mdoc_validate(man);
			mpage->form = FORM_SRC;
			mpage->sec = man->meta.msec;
			mpage->sec = mandoc_strdup(
			    mpage->sec == NULL ? "" : mpage->sec);
			mpage->arch = man->meta.arch;
			mpage->arch = mandoc_strdup(
			    mpage->arch == NULL ? "" : mpage->arch);
			mpage->title = mandoc_strdup(man->meta.title);
		} else if (man != NULL && man->macroset == MACROSET_MAN) {
			man_validate(man);
			mpage->form = FORM_SRC;
			mpage->sec = mandoc_strdup(man->meta.msec);
			mpage->arch = mandoc_strdup(mlink->arch);
			mpage->title = mandoc_strdup(man->meta.title);
		} else {
			mpage->form = FORM_CAT;
			mpage->sec = mandoc_strdup(mlink->dsec);
			mpage->arch = mandoc_strdup(mlink->arch);
			mpage->title = mandoc_strdup(mlink->name);
		}
		putkey(mpage, mpage->sec, TYPE_sec);
		if (*mpage->arch != '\0')
			putkey(mpage, mpage->arch, TYPE_arch);

		for ( ; mlink != NULL; mlink = mlink->next) {
			if ('\0' != *mlink->dsec)
				putkey(mpage, mlink->dsec, TYPE_sec);
			if ('\0' != *mlink->fsec)
				putkey(mpage, mlink->fsec, TYPE_sec);
			putkey(mpage, '\0' == *mlink->arch ?
			    any : mlink->arch, TYPE_arch);
			putkey(mpage, mlink->name, NAME_FILE);
		}

		assert(mpage->desc == NULL);
		if (man != NULL && man->macroset == MACROSET_MDOC)
			parse_mdoc(mpage, &man->meta, man->first);
		else if (man != NULL)
			parse_man(mpage, &man->meta, man->first);
		else
			parse_cat(mpage, fd);
		if (mpage->desc == NULL)
			mpage->desc = mandoc_strdup(mpage->mlinks->name);

		if (warnings && !use_all)
			for (mlink = mpage->mlinks; mlink;
			     mlink = mlink->next)
				mlink_check(mpage, mlink);

		dbadd(mpage);
		mlink = mpage->mlinks;

nextpage:
		ohash_delete(&strings);
		ohash_delete(&names);
		mpage = ohash_next(&mpages, &pslot);
	}

	if (0 == nodb)
		SQL_EXEC("END TRANSACTION");
}

static void
names_check(void)
{
	sqlite3_stmt	*stmt;
	const char	*name, *sec, *arch, *key;

	sqlite3_prepare_v2(db,
	  "SELECT name, sec, arch, key FROM ("
	    "SELECT name AS key, pageid FROM names "
	    "WHERE bits & ? AND NOT EXISTS ("
	      "SELECT pageid FROM mlinks "
	      "WHERE mlinks.pageid == names.pageid "
	      "AND mlinks.name == names.name"
	    ")"
	  ") JOIN ("
	    "SELECT sec, arch, name, pageid FROM mlinks "
	    "GROUP BY pageid"
	  ") USING (pageid);",
	  -1, &stmt, NULL);

	if (sqlite3_bind_int64(stmt, 1, NAME_TITLE) != SQLITE_OK)
		say("", "%s", sqlite3_errmsg(db));

	while (sqlite3_step(stmt) == SQLITE_ROW) {
		name = (const char *)sqlite3_column_text(stmt, 0);
		sec  = (const char *)sqlite3_column_text(stmt, 1);
		arch = (const char *)sqlite3_column_text(stmt, 2);
		key  = (const char *)sqlite3_column_text(stmt, 3);
		say("", "%s(%s%s%s) lacks mlink \"%s\"", name, sec,
		    '\0' == *arch ? "" : "/",
		    '\0' == *arch ? "" : arch, key);
	}
	sqlite3_finalize(stmt);
}

static void
parse_cat(struct mpage *mpage, int fd)
{
	FILE		*stream;
	char		*line, *p, *title;
	size_t		 linesz, plen, titlesz;
	ssize_t		 len;
	int		 offs;

	stream = (-1 == fd) ?
	    fopen(mpage->mlinks->file, "r") :
	    fdopen(fd, "r");
	if (NULL == stream) {
		if (-1 != fd)
			close(fd);
		if (warnings)
			say(mpage->mlinks->file, "&fopen");
		return;
	}

	line = NULL;
	linesz = 0;

	/* Skip to first blank line. */

	while (getline(&line, &linesz, stream) != -1)
		if (*line == '\n')
			break;

	/*
	 * Assume the first line that is not indented
	 * is the first section header.  Skip to it.
	 */

	while (getline(&line, &linesz, stream) != -1)
		if (*line != '\n' && *line != ' ')
			break;

	/*
	 * Read up until the next section into a buffer.
	 * Strip the leading and trailing newline from each read line,
	 * appending a trailing space.
	 * Ignore empty (whitespace-only) lines.
	 */

	titlesz = 0;
	title = NULL;

	while ((len = getline(&line, &linesz, stream)) != -1) {
		if (*line != ' ')
			break;
		offs = 0;
		while (isspace((unsigned char)line[offs]))
			offs++;
		if (line[offs] == '\0')
			continue;
		title = mandoc_realloc(title, titlesz + len - offs);
		memcpy(title + titlesz, line + offs, len - offs);
		titlesz += len - offs;
		title[titlesz - 1] = ' ';
	}
	free(line);

	/*
	 * If no page content can be found, or the input line
	 * is already the next section header, or there is no
	 * trailing newline, reuse the page title as the page
	 * description.
	 */

	if (NULL == title || '\0' == *title) {
		if (warnings)
			say(mpage->mlinks->file,
			    "Cannot find NAME section");
		fclose(stream);
		free(title);
		return;
	}

	title[titlesz - 1] = '\0';

	/*
	 * Skip to the first dash.
	 * Use the remaining line as the description (no more than 70
	 * bytes).
	 */

	if (NULL != (p = strstr(title, "- "))) {
		for (p += 2; ' ' == *p || '\b' == *p; p++)
			/* Skip to next word. */ ;
	} else {
		if (warnings)
			say(mpage->mlinks->file,
			    "No dash in title line");
		p = title;
	}

	plen = strlen(p);

	/* Strip backspace-encoding from line. */

	while (NULL != (line = memchr(p, '\b', plen))) {
		len = line - p;
		if (0 == len) {
			memmove(line, line + 1, plen--);
			continue;
		}
		memmove(line - 1, line + 1, plen - len);
		plen -= 2;
	}

	mpage->desc = mandoc_strdup(p);
	fclose(stream);
	free(title);
}

/*
 * Put a type/word pair into the word database for this particular file.
 */
static void
putkey(const struct mpage *mpage, char *value, uint64_t type)
{
	char	 *cp;

	assert(NULL != value);
	if (TYPE_arch == type)
		for (cp = value; *cp; cp++)
			if (isupper((unsigned char)*cp))
				*cp = _tolower((unsigned char)*cp);
	putkeys(mpage, value, strlen(value), type);
}

/*
 * Grok all nodes at or below a certain mdoc node into putkey().
 */
static void
putmdockey(const struct mpage *mpage,
	const struct roff_node *n, uint64_t m)
{

	for ( ; NULL != n; n = n->next) {
		if (NULL != n->child)
			putmdockey(mpage, n->child, m);
		if (n->type == ROFFT_TEXT)
			putkey(mpage, n->string, m);
	}
}

static void
parse_man(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	const struct roff_node *head, *body;
	char		*start, *title;
	char		 byte;
	size_t		 sz;

	if (NULL == n)
		return;

	/*
	 * We're only searching for one thing: the first text child in
	 * the BODY of a NAME section.  Since we don't keep track of
	 * sections in -man, run some hoops to find out whether we're in
	 * the correct section or not.
	 */

	if (n->type == ROFFT_BODY && n->tok == MAN_SH) {
		body = n;
		assert(body->parent);
		if (NULL != (head = body->parent->head) &&
		    1 == head->nchild &&
		    NULL != (head = (head->child)) &&
		    head->type == ROFFT_TEXT &&
		    0 == strcmp(head->string, "NAME") &&
		    NULL != body->child) {

			/*
			 * Suck the entire NAME section into memory.
			 * Yes, we might run away.
			 * But too many manuals have big, spread-out
			 * NAME sections over many lines.
			 */

			title = NULL;
			deroff(&title, body);
			if (NULL == title)
				return;

			/*
			 * Go through a special heuristic dance here.
			 * Conventionally, one or more manual names are
			 * comma-specified prior to a whitespace, then a
			 * dash, then a description.  Try to puzzle out
			 * the name parts here.
			 */

			start = title;
			for ( ;; ) {
				sz = strcspn(start, " ,");
				if ('\0' == start[sz])
					break;

				byte = start[sz];
				start[sz] = '\0';

				/*
				 * Assume a stray trailing comma in the
				 * name list if a name begins with a dash.
				 */

				if ('-' == start[0] ||
				    ('\\' == start[0] && '-' == start[1]))
					break;

				putkey(mpage, start, NAME_TITLE);
				if ( ! (mpage->name_head_done ||
				    strcasecmp(start, meta->title))) {
					putkey(mpage, start, NAME_HEAD);
					mpage->name_head_done = 1;
				}

				if (' ' == byte) {
					start += sz + 1;
					break;
				}

				assert(',' == byte);
				start += sz + 1;
				while (' ' == *start)
					start++;
			}

			if (start == title) {
				putkey(mpage, start, NAME_TITLE);
				if ( ! (mpage->name_head_done ||
				    strcasecmp(start, meta->title))) {
					putkey(mpage, start, NAME_HEAD);
					mpage->name_head_done = 1;
				}
				free(title);
				return;
			}

			while (isspace((unsigned char)*start))
				start++;

			if (0 == strncmp(start, "-", 1))
				start += 1;
			else if (0 == strncmp(start, "\\-\\-", 4))
				start += 4;
			else if (0 == strncmp(start, "\\-", 2))
				start += 2;
			else if (0 == strncmp(start, "\\(en", 4))
				start += 4;
			else if (0 == strncmp(start, "\\(em", 4))
				start += 4;

			while (' ' == *start)
				start++;

			mpage->desc = mandoc_strdup(start);
			free(title);
			return;
		}
	}

	for (n = n->child; n; n = n->next) {
		if (NULL != mpage->desc)
			break;
		parse_man(mpage, meta, n);
	}
}

static void
parse_mdoc(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	assert(NULL != n);
	for (n = n->child; NULL != n; n = n->next) {
		switch (n->type) {
		case ROFFT_ELEM:
		case ROFFT_BLOCK:
		case ROFFT_HEAD:
		case ROFFT_BODY:
		case ROFFT_TAIL:
			if (NULL != mdocs[n->tok].fp)
			       if (0 == (*mdocs[n->tok].fp)(mpage, meta, n))
				       break;
			if (mdocs[n->tok].mask)
				putmdockey(mpage, n->child,
				    mdocs[n->tok].mask);
			break;
		default:
			assert(n->type != ROFFT_ROOT);
			continue;
		}
		if (NULL != n->child)
			parse_mdoc(mpage, meta, n);
	}
}

static int
parse_mdoc_Fd(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	char		*start, *end;
	size_t		 sz;

	if (SEC_SYNOPSIS != n->sec ||
	    NULL == (n = n->child) ||
	    n->type != ROFFT_TEXT)
		return 0;

	/*
	 * Only consider those `Fd' macro fields that begin with an
	 * "inclusion" token (versus, e.g., #define).
	 */

	if (strcmp("#include", n->string))
		return 0;

	if ((n = n->next) == NULL || n->type != ROFFT_TEXT)
		return 0;

	/*
	 * Strip away the enclosing angle brackets and make sure we're
	 * not zero-length.
	 */

	start = n->string;
	if ('<' == *start || '"' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return 0;

	end = &start[(int)sz - 1];
	if ('>' == *end || '"' == *end)
		end--;

	if (end > start)
		putkeys(mpage, start, end - start + 1, TYPE_In);
	return 0;
}

static void
parse_mdoc_fname(struct mpage *mpage, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT)
		return;

	/* Skip function pointer punctuation. */

	cp = n->string;
	while (*cp == '(' || *cp == '*')
		cp++;
	sz = strcspn(cp, "()");

	putkeys(mpage, cp, sz, TYPE_Fn);
	if (n->sec == SEC_SYNOPSIS)
		putkeys(mpage, cp, sz, NAME_SYN);
}

static int
parse_mdoc_Fn(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (n->child == NULL)
		return 0;

	parse_mdoc_fname(mpage, n->child);

	for (n = n->child->next; n != NULL; n = n->next)
		if (n->type == ROFFT_TEXT)
			putkey(mpage, n->string, TYPE_Fa);

	return 0;
}

static int
parse_mdoc_Fo(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (n->type != ROFFT_HEAD)
		return 1;

	if (n->child != NULL)
		parse_mdoc_fname(mpage, n->child);

	return 0;
}

static int
parse_mdoc_Xr(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{
	char	*cp;

	if (NULL == (n = n->child))
		return 0;

	if (NULL == n->next) {
		putkey(mpage, n->string, TYPE_Xr);
		return 0;
	}

	mandoc_asprintf(&cp, "%s(%s)", n->string, n->next->string);
	putkey(mpage, cp, TYPE_Xr);
	free(cp);
	return 0;
}

static int
parse_mdoc_Nd(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (n->type == ROFFT_BODY)
		deroff(&mpage->desc, n);
	return 0;
}

static int
parse_mdoc_Nm(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	if (SEC_NAME == n->sec)
		putmdockey(mpage, n->child, NAME_TITLE);
	else if (n->sec == SEC_SYNOPSIS && n->type == ROFFT_HEAD) {
		if (n->child == NULL)
			putkey(mpage, meta->name, NAME_SYN);
		else
			putmdockey(mpage, n->child, NAME_SYN);
	}
	if ( ! (mpage->name_head_done ||
	    n->child == NULL || n->child->string == NULL ||
	    strcasecmp(n->child->string, meta->title))) {
		putkey(mpage, n->child->string, ROFFT_HEAD);
		mpage->name_head_done = 1;
	}
	return 0;
}

static int
parse_mdoc_Sh(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	return n->sec == SEC_CUSTOM && n->type == ROFFT_HEAD;
}

static int
parse_mdoc_head(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	return n->type == ROFFT_HEAD;
}

static int
parse_mdoc_body(struct mpage *mpage, const struct roff_meta *meta,
	const struct roff_node *n)
{

	return n->type == ROFFT_BODY;
}

/*
 * Add a string to the hash table for the current manual.
 * Each string has a bitmask telling which macros it belongs to.
 * When we finish the manual, we'll dump the table.
 */
static void
putkeys(const struct mpage *mpage, char *cp, size_t sz, uint64_t v)
{
	struct ohash	*htab;
	struct str	*s;
	const char	*end;
	unsigned int	 slot;
	int		 i, mustfree;

	if (0 == sz)
		return;

	mustfree = render_string(&cp, &sz);

	if (TYPE_Nm & v) {
		htab = &names;
		v &= name_mask;
		if (v & NAME_FIRST)
			name_mask &= ~NAME_FIRST;
		if (debug > 1)
			say(mpage->mlinks->file,
			    "Adding name %*s, bits=%d", sz, cp, v);
	} else {
		htab = &strings;
		if (debug > 1)
		    for (i = 0; i < mansearch_keymax; i++)
			if ((uint64_t)1 << i & v)
			    say(mpage->mlinks->file,
				"Adding key %s=%*s",
				mansearch_keynames[i], sz, cp);
	}

	end = cp + sz;
	slot = ohash_qlookupi(htab, cp, &end);
	s = ohash_find(htab, slot);

	if (NULL != s && mpage == s->mpage) {
		s->mask |= v;
		return;
	} else if (NULL == s) {
		s = mandoc_calloc(1, sizeof(struct str) + sz + 1);
		memcpy(s->key, cp, sz);
		ohash_insert(htab, slot, s);
	}
	s->mpage = mpage;
	s->mask = v;

	if (mustfree)
		free(cp);
}

/*
 * Take a Unicode codepoint and produce its UTF-8 encoding.
 * This isn't the best way to do this, but it works.
 * The magic numbers are from the UTF-8 packaging.
 * They're not as scary as they seem: read the UTF-8 spec for details.
 */
static size_t
utf8(unsigned int cp, char out[7])
{
	size_t		 rc;

	rc = 0;
	if (cp <= 0x0000007F) {
		rc = 1;
		out[0] = (char)cp;
	} else if (cp <= 0x000007FF) {
		rc = 2;
		out[0] = (cp >> 6  & 31) | 192;
		out[1] = (cp       & 63) | 128;
	} else if (cp <= 0x0000FFFF) {
		rc = 3;
		out[0] = (cp >> 12 & 15) | 224;
		out[1] = (cp >> 6  & 63) | 128;
		out[2] = (cp       & 63) | 128;
	} else if (cp <= 0x001FFFFF) {
		rc = 4;
		out[0] = (cp >> 18 &  7) | 240;
		out[1] = (cp >> 12 & 63) | 128;
		out[2] = (cp >> 6  & 63) | 128;
		out[3] = (cp       & 63) | 128;
	} else if (cp <= 0x03FFFFFF) {
		rc = 5;
		out[0] = (cp >> 24 &  3) | 248;
		out[1] = (cp >> 18 & 63) | 128;
		out[2] = (cp >> 12 & 63) | 128;
		out[3] = (cp >> 6  & 63) | 128;
		out[4] = (cp       & 63) | 128;
	} else if (cp <= 0x7FFFFFFF) {
		rc = 6;
		out[0] = (cp >> 30 &  1) | 252;
		out[1] = (cp >> 24 & 63) | 128;
		out[2] = (cp >> 18 & 63) | 128;
		out[3] = (cp >> 12 & 63) | 128;
		out[4] = (cp >> 6  & 63) | 128;
		out[5] = (cp       & 63) | 128;
	} else
		return 0;

	out[rc] = '\0';
	return rc;
}

/*
 * If the string contains escape sequences,
 * replace it with an allocated rendering and return 1,
 * such that the caller can free it after use.
 * Otherwise, do nothing and return 0.
 */
static int
render_string(char **public, size_t *psz)
{
	const char	*src, *scp, *addcp, *seq;
	char		*dst;
	size_t		 ssz, dsz, addsz;
	char		 utfbuf[7], res[6];
	int		 seqlen, unicode;

	res[0] = '\\';
	res[1] = '\t';
	res[2] = ASCII_NBRSP;
	res[3] = ASCII_HYPH;
	res[4] = ASCII_BREAK;
	res[5] = '\0';

	src = scp = *public;
	ssz = *psz;
	dst = NULL;
	dsz = 0;

	while (scp < src + *psz) {

		/* Leave normal characters unchanged. */

		if (strchr(res, *scp) == NULL) {
			if (dst != NULL)
				dst[dsz++] = *scp;
			scp++;
			continue;
		}

		/*
		 * Found something that requires replacing,
		 * make sure we have a destination buffer.
		 */

		if (dst == NULL) {
			dst = mandoc_malloc(ssz + 1);
			dsz = scp - src;
			memcpy(dst, src, dsz);
		}

		/* Handle single-char special characters. */

		switch (*scp) {
		case '\\':
			break;
		case '\t':
		case ASCII_NBRSP:
			dst[dsz++] = ' ';
			scp++;
			continue;
		case ASCII_HYPH:
			dst[dsz++] = '-';
			/* FALLTHROUGH */
		case ASCII_BREAK:
			scp++;
			continue;
		default:
			abort();
		}

		/*
		 * Found an escape sequence.
		 * Read past the slash, then parse it.
		 * Ignore everything except characters.
		 */

		scp++;
		if (mandoc_escape(&scp, &seq, &seqlen) != ESCAPE_SPECIAL)
			continue;

		/*
		 * Render the special character
		 * as either UTF-8 or ASCII.
		 */

		if (write_utf8) {
			unicode = mchars_spec2cp(seq, seqlen);
			if (unicode <= 0)
				continue;
			addsz = utf8(unicode, utfbuf);
			if (addsz == 0)
				continue;
			addcp = utfbuf;
		} else {
			addcp = mchars_spec2str(seq, seqlen, &addsz);
			if (addcp == NULL)
				continue;
			if (*addcp == ASCII_NBRSP) {
				addcp = " ";
				addsz = 1;
			}
		}

		/* Copy the rendered glyph into the stream. */

		ssz += addsz;
		dst = mandoc_realloc(dst, ssz + 1);
		memcpy(dst + dsz, addcp, addsz);
		dsz += addsz;
	}
	if (dst != NULL) {
		*public = dst;
		*psz = dsz;
	}

	/* Trim trailing whitespace and NUL-terminate. */

	while (*psz > 0 && (*public)[*psz - 1] == ' ')
		--*psz;
	if (dst != NULL) {
		(*public)[*psz] = '\0';
		return 1;
	} else
		return 0;
}

static void
dbadd_mlink(const struct mlink *mlink)
{
	size_t		 i;

	i = 1;
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->dsec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->arch);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->name);
	SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, mlink->mpage->pageid);
	SQL_STEP(stmts[STMT_INSERT_LINK]);
	sqlite3_reset(stmts[STMT_INSERT_LINK]);
}

static void
dbadd_mlink_name(const struct mlink *mlink)
{
	uint64_t	 bits;
	size_t		 i;

	dbadd_mlink(mlink);

	i = 1;
	SQL_BIND_INT64(stmts[STMT_SELECT_NAME], i, mlink->mpage->pageid);
	bits = NAME_FILE & NAME_MASK;
	if (sqlite3_step(stmts[STMT_SELECT_NAME]) == SQLITE_ROW) {
		bits |= sqlite3_column_int64(stmts[STMT_SELECT_NAME], 0);
		sqlite3_reset(stmts[STMT_SELECT_NAME]);
	}

	i = 1;
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, bits);
	SQL_BIND_TEXT(stmts[STMT_INSERT_NAME], i, mlink->name);
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, mlink->mpage->pageid);
	SQL_STEP(stmts[STMT_INSERT_NAME]);
	sqlite3_reset(stmts[STMT_INSERT_NAME]);
}

/*
 * Flush the current page's terms (and their bits) into the database.
 * Wrap the entire set of additions in a transaction to make sqlite be a
 * little faster.
 * Also, handle escape sequences at the last possible moment.
 */
static void
dbadd(struct mpage *mpage)
{
	struct mlink	*mlink;
	struct str	*key;
	char		*cp;
	size_t		 i;
	unsigned int	 slot;
	int		 mustfree;

	mlink = mpage->mlinks;

	if (nodb) {
		for (key = ohash_first(&names, &slot); NULL != key;
		     key = ohash_next(&names, &slot))
			free(key);
		for (key = ohash_first(&strings, &slot); NULL != key;
		     key = ohash_next(&strings, &slot))
			free(key);
		if (0 == debug)
			return;
		while (NULL != mlink) {
			fputs(mlink->name, stdout);
			if (NULL == mlink->next ||
			    strcmp(mlink->dsec, mlink->next->dsec) ||
			    strcmp(mlink->fsec, mlink->next->fsec) ||
			    strcmp(mlink->arch, mlink->next->arch)) {
				putchar('(');
				if ('\0' == *mlink->dsec)
					fputs(mlink->fsec, stdout);
				else
					fputs(mlink->dsec, stdout);
				if ('\0' != *mlink->arch)
					printf("/%s", mlink->arch);
				putchar(')');
			}
			mlink = mlink->next;
			if (NULL != mlink)
				fputs(", ", stdout);
		}
		printf(" - %s\n", mpage->desc);
		return;
	}

	if (debug)
		say(mlink->file, "Adding to database");

	cp = mpage->desc;
	i = strlen(cp);
	mustfree = render_string(&cp, &i);
	i = 1;
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, cp);
	SQL_BIND_INT(stmts[STMT_INSERT_PAGE], i, mpage->form);
	SQL_STEP(stmts[STMT_INSERT_PAGE]);
	mpage->pageid = sqlite3_last_insert_rowid(db);
	sqlite3_reset(stmts[STMT_INSERT_PAGE]);
	if (mustfree)
		free(cp);

	while (NULL != mlink) {
		dbadd_mlink(mlink);
		mlink = mlink->next;
	}
	mlink = mpage->mlinks;

	for (key = ohash_first(&names, &slot); NULL != key;
	     key = ohash_next(&names, &slot)) {
		assert(key->mpage == mpage);
		i = 1;
		SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, key->mask);
		SQL_BIND_TEXT(stmts[STMT_INSERT_NAME], i, key->key);
		SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, mpage->pageid);
		SQL_STEP(stmts[STMT_INSERT_NAME]);
		sqlite3_reset(stmts[STMT_INSERT_NAME]);
		free(key);
	}
	for (key = ohash_first(&strings, &slot); NULL != key;
	     key = ohash_next(&strings, &slot)) {
		assert(key->mpage == mpage);
		i = 1;
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, key->mask);
		SQL_BIND_TEXT(stmts[STMT_INSERT_KEY], i, key->key);
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, mpage->pageid);
		SQL_STEP(stmts[STMT_INSERT_KEY]);
		sqlite3_reset(stmts[STMT_INSERT_KEY]);
		free(key);
	}
}

static void
dbprune(void)
{
	struct mpage	*mpage;
	struct mlink	*mlink;
	size_t		 i;
	unsigned int	 slot;

	if (0 == nodb)
		SQL_EXEC("BEGIN TRANSACTION");

	for (mpage = ohash_first(&mpages, &slot); NULL != mpage;
	     mpage = ohash_next(&mpages, &slot)) {
		mlink = mpage->mlinks;
		if (debug)
			say(mlink->file, "Deleting from database");
		if (nodb)
			continue;
		for ( ; NULL != mlink; mlink = mlink->next) {
			i = 1;
			SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE],
			    i, mlink->dsec);
			SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE],
			    i, mlink->arch);
			SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE],
			    i, mlink->name);
			SQL_STEP(stmts[STMT_DELETE_PAGE]);
			sqlite3_reset(stmts[STMT_DELETE_PAGE]);
		}
	}

	if (0 == nodb)
		SQL_EXEC("END TRANSACTION");
}

/*
 * Close an existing database and its prepared statements.
 * If "real" is not set, rename the temporary file into the real one.
 */
static void
dbclose(int real)
{
	size_t		 i;
	int		 status;
	pid_t		 child;

	if (nodb)
		return;

	for (i = 0; i < STMT__MAX; i++) {
		sqlite3_finalize(stmts[i]);
		stmts[i] = NULL;
	}

	sqlite3_close(db);
	db = NULL;

	if (real)
		return;

	if ('\0' == *tempfilename) {
		if (-1 == rename(MANDOC_DB "~", MANDOC_DB)) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say(MANDOC_DB, "&rename");
		}
		return;
	}

	switch (child = fork()) {
	case -1:
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&fork cmp");
		return;
	case 0:
		execlp("cmp", "cmp", "-s",
		    tempfilename, MANDOC_DB, (char *)NULL);
		say("", "&exec cmp");
		exit(0);
	default:
		break;
	}
	if (-1 == waitpid(child, &status, 0)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&wait cmp");
	} else if (WIFSIGNALED(status)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "cmp died from signal %d", WTERMSIG(status));
	} else if (WEXITSTATUS(status)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB,
		    "Data changed, but cannot replace database");
	}

	*strrchr(tempfilename, '/') = '\0';
	switch (child = fork()) {
	case -1:
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&fork rm");
		return;
	case 0:
		execlp("rm", "rm", "-rf", tempfilename, (char *)NULL);
		say("", "&exec rm");
		exit((int)MANDOCLEVEL_SYSERR);
	default:
		break;
	}
	if (-1 == waitpid(child, &status, 0)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&wait rm");
	} else if (WIFSIGNALED(status) || WEXITSTATUS(status)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "%s: Cannot remove temporary directory",
		    tempfilename);
	}
}

/*
 * This is straightforward stuff.
 * Open a database connection to a "temporary" database, then open a set
 * of prepared statements we'll use over and over again.
 * If "real" is set, we use the existing database; if not, we truncate a
 * temporary one.
 * Must be matched by dbclose().
 */
static int
dbopen(int real)
{
	const char	*sql;
	int		 rc, ofl;

	if (nodb)
		return 1;

	*tempfilename = '\0';
	ofl = SQLITE_OPEN_READWRITE;

	if (real) {
		rc = sqlite3_open_v2(MANDOC_DB, &db, ofl, NULL);
		if (SQLITE_OK != rc) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			if (SQLITE_CANTOPEN != rc)
				say(MANDOC_DB, "%s", sqlite3_errstr(rc));
			return 0;
		}
		goto prepare_statements;
	}

	ofl |= SQLITE_OPEN_CREATE | SQLITE_OPEN_EXCLUSIVE;

	remove(MANDOC_DB "~");
	rc = sqlite3_open_v2(MANDOC_DB "~", &db, ofl, NULL);
	if (SQLITE_OK == rc)
		goto create_tables;
	if (MPARSE_QUICK & mparse_options) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB "~", "%s", sqlite3_errstr(rc));
		return 0;
	}

	(void)strlcpy(tempfilename, "/tmp/mandocdb.XXXXXX",
	    sizeof(tempfilename));
	if (NULL == mkdtemp(tempfilename)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "&%s", tempfilename);
		return 0;
	}
	(void)strlcat(tempfilename, "/" MANDOC_DB,
	    sizeof(tempfilename));
	rc = sqlite3_open_v2(tempfilename, &db, ofl, NULL);
	if (SQLITE_OK != rc) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "%s: %s", tempfilename, sqlite3_errstr(rc));
		return 0;
	}

create_tables:
	sql = "CREATE TABLE \"mpages\" (\n"
	      " \"desc\" TEXT NOT NULL,\n"
	      " \"form\" INTEGER NOT NULL,\n"
	      " \"pageid\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
	      ");\n"
	      "\n"
	      "CREATE TABLE \"mlinks\" (\n"
	      " \"sec\" TEXT NOT NULL,\n"
	      " \"arch\" TEXT NOT NULL,\n"
	      " \"name\" TEXT NOT NULL,\n"
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
		"ON DELETE CASCADE\n"
	      ");\n"
	      "CREATE INDEX mlinks_pageid_idx ON mlinks (pageid);\n"
	      "\n"
	      "CREATE TABLE \"names\" (\n"
	      " \"bits\" INTEGER NOT NULL,\n"
	      " \"name\" TEXT NOT NULL,\n"
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
		"ON DELETE CASCADE,\n"
	      " UNIQUE (\"name\", \"pageid\") ON CONFLICT REPLACE\n"
	      ");\n"
	      "\n"
	      "CREATE TABLE \"keys\" (\n"
	      " \"bits\" INTEGER NOT NULL,\n"
	      " \"key\" TEXT NOT NULL,\n"
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(pageid) "
		"ON DELETE CASCADE\n"
	      ");\n"
	      "CREATE INDEX keys_pageid_idx ON keys (pageid);\n";

	if (SQLITE_OK != sqlite3_exec(db, sql, NULL, NULL, NULL)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB, "%s", sqlite3_errmsg(db));
		sqlite3_close(db);
		return 0;
	}

prepare_statements:
	if (SQLITE_OK != sqlite3_exec(db,
	    "PRAGMA foreign_keys = ON", NULL, NULL, NULL)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB, "PRAGMA foreign_keys: %s",
		    sqlite3_errmsg(db));
		sqlite3_close(db);
		return 0;
	}

	sql = "DELETE FROM mpages WHERE pageid IN "
		"(SELECT pageid FROM mlinks WHERE "
		"sec=? AND arch=? AND name=?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_DELETE_PAGE], NULL);
	sql = "INSERT INTO mpages "
		"(desc,form) VALUES (?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_PAGE], NULL);
	sql = "INSERT INTO mlinks "
		"(sec,arch,name,pageid) VALUES (?,?,?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_LINK], NULL);
	sql = "SELECT bits FROM names where pageid = ?";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_SELECT_NAME], NULL);
	sql = "INSERT INTO names "
		"(bits,name,pageid) VALUES (?,?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_NAME], NULL);
	sql = "INSERT INTO keys "
		"(bits,key,pageid) VALUES (?,?,?)";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_KEY], NULL);

#ifndef __APPLE__
	/*
	 * When opening a new database, we can turn off
	 * synchronous mode for much better performance.
	 */

	if (real && SQLITE_OK != sqlite3_exec(db,
	    "PRAGMA synchronous = OFF", NULL, NULL, NULL)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say(MANDOC_DB, "PRAGMA synchronous: %s",
		    sqlite3_errmsg(db));
		sqlite3_close(db);
		return 0;
	}
#endif

	return 1;
}

static int
set_basedir(const char *targetdir, int report_baddir)
{
	static char	 startdir[PATH_MAX];
	static int	 getcwd_status;  /* 1 = ok, 2 = failure */
	static int	 chdir_status;  /* 1 = changed directory */
	char		*cp;

	/*
	 * Remember the original working directory, if possible.
	 * This will be needed if the second or a later directory
	 * on the command line is given as a relative path.
	 * Do not error out if the current directory is not
	 * searchable: Maybe it won't be needed after all.
	 */
	if (0 == getcwd_status) {
		if (NULL == getcwd(startdir, sizeof(startdir))) {
			getcwd_status = 2;
			(void)strlcpy(startdir, strerror(errno),
			    sizeof(startdir));
		} else
			getcwd_status = 1;
	}

	/*
	 * We are leaving the old base directory.
	 * Do not use it any longer, not even for messages.
	 */
	*basedir = '\0';

	/*
	 * If and only if the directory was changed earlier and
	 * the next directory to process is given as a relative path,
	 * first go back, or bail out if that is impossible.
	 */
	if (chdir_status && '/' != *targetdir) {
		if (2 == getcwd_status) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "getcwd: %s", startdir);
			return 0;
		}
		if (-1 == chdir(startdir)) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "&chdir %s", startdir);
			return 0;
		}
	}

	/*
	 * Always resolve basedir to the canonicalized absolute
	 * pathname and append a trailing slash, such that
	 * we can reliably check whether files are inside.
	 */
	if (NULL == realpath(targetdir, basedir)) {
		if (report_baddir || errno != ENOENT) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say("", "&%s: realpath", targetdir);
		}
		return 0;
	} else if (-1 == chdir(basedir)) {
		if (report_baddir || errno != ENOENT) {
			exitcode = (int)MANDOCLEVEL_BADARG;
			say("", "&chdir");
		}
		return 0;
	}
	chdir_status = 1;
	cp = strchr(basedir, '\0');
	if ('/' != cp[-1]) {
		if (cp - basedir >= PATH_MAX - 1) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "Filename too long");
			return 0;
		}
		*cp++ = '/';
		*cp = '\0';
	}
	return 1;
}

static void
say(const char *file, const char *format, ...)
{
	va_list		 ap;
	int		 use_errno;

	if ('\0' != *basedir)
		fprintf(stderr, "%s", basedir);
	if ('\0' != *basedir && '\0' != *file)
		fputc('/', stderr);
	if ('\0' != *file)
		fprintf(stderr, "%s", file);

	use_errno = 1;
	if (NULL != format) {
		switch (*format) {
		case '&':
			format++;
			break;
		case '\0':
			format = NULL;
			break;
		default:
			use_errno = 0;
			break;
		}
	}
	if (NULL != format) {
		if ('\0' != *basedir || '\0' != *file)
			fputs(": ", stderr);
		va_start(ap, format);
		vfprintf(stderr, format, ap);
		va_end(ap);
	}
	if (use_errno) {
		if ('\0' != *basedir || '\0' != *file || NULL != format)
			fputs(": ", stderr);
		perror(NULL);
	} else
		fputc('\n', stderr);
}
@


1.209
log
@Modernization, no functional change intended:
Use the POSIX function getline(3) rather than the slightly
dangerous BSD function fgetln(3).
Remove the related compatibility code.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.208 2015/11/07 14:22:29 schwarze Exp $ */
d423 5
a427 3
	if (nodb && pledge("stdio rpath", NULL) == -1) {
		perror("pledge");
		return (int)MANDOCLEVEL_SYSERR;
d457 6
a462 5
			if (!nodb && pledge("stdio rpath wpath cpath fattr flock",
			    NULL) == -1) {
				perror("pledge");
				exitcode = (int)MANDOCLEVEL_SYSERR;
				goto out;
@


1.208
log
@Without HAVE_ERR, don't try to include <err.h>, it probably isn't there.
In that case, the required prototypes are in "config.h".
Patch from Peter Bray <pdb_ml at yahoo dot com dot au>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.207 2015/11/06 17:33:34 schwarze Exp $ */
d1294 3
a1296 1
	size_t		 len, plen, titlesz;
d1309 3
d1314 2
a1315 2
	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' == *line)
d1323 2
a1324 2
	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' != *line && ' ' != *line)
d1337 2
a1338 2
	while (NULL != (line = fgetln(stream, &len))) {
		if (' ' != *line || '\n' != line[len - 1])
d1340 4
a1343 5
		while (len > 0 && isspace((unsigned char)*line)) {
			line++;
			len--;
		}
		if (1 == len)
d1345 3
a1347 3
		title = mandoc_realloc(title, titlesz + len);
		memcpy(title + titlesz, line, len);
		titlesz += len;
d1350 1
d1368 1
a1368 2
	title = mandoc_realloc(title, titlesz + 1);
	title[titlesz] = '\0';
@


1.207
log
@merge pledge(2) support from OpenBSD
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.206 2015/11/06 16:30:33 schwarze Exp $ */
d26 1
d28 1
@


1.206
log
@Use getprogname(3) rather than __progname.
Suggested by Joerg@@ Sonnenberger (NetBSD).
Last year, deraadt@@ confirmed on tech@@ that this "has the potential
to be more portable", and micro-optimizing for speed is not relevant
here.  Also gets rid of one global variable.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.205 2015/10/22 22:06:43 schwarze Exp $ */
d340 7
d420 7
d452 8
@


1.205
log
@use the new function man_validate() here, too
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.204 2015/10/20 02:01:31 schwarze Exp $ */
a185 2
extern	char		*__progname;

d336 1
a336 1
	const char	 *path_arg;
d527 1
d533 1
a533 2
		       __progname, __progname, __progname,
		       __progname, __progname);
@


1.204
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.203 2015/10/13 22:59:54 schwarze Exp $ */
d1179 1
@


1.203
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.202 2015/10/13 15:53:05 schwarze Exp $ */
d1169 1
@


1.202
log
@Reduce the amount of code by moving the three copies of the ohash
callback functions into one common place, preparing for the use of
ohash for some additional purposes.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.201 2015/10/12 21:17:15 schwarze Exp $ */
a197 1
static	struct mchars	*mchars; /* table of named characters */
d421 2
a422 3
	mchars = mchars_alloc();
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_BADARG, NULL,
	    mchars, NULL);
d523 1
a523 1
	mchars_free(mchars);
d1929 1
a1929 1
			unicode = mchars_spec2cp(mchars, seq, seqlen);
d1937 1
a1937 1
			addcp = mchars_spec2str(mchars, seq, seqlen, &addsz);
@


1.201
log
@Garbage collect an unused variable, no functional change;
found by Svyatoslav Mishyn <juef at openmailbox dot org> with cppcheck.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.200 2015/10/12 00:32:55 schwarze Exp $ */
a42 5
#if HAVE_OHASH
#include <ohash.h>
#else
#include "compat_ohash.h"
#endif
d46 1
a144 3
static	void	*hash_alloc(size_t, void *);
static	void	 hash_free(void *, void *);
static	void	*hash_calloc(size_t, size_t, void *);
a337 1
	struct ohash_info mpages_info, mlinks_info;
a345 8
	mpages_info.alloc  = mlinks_info.alloc  = hash_alloc;
	mpages_info.calloc = mlinks_info.calloc = hash_calloc;
	mpages_info.free   = mlinks_info.free   = hash_free;
	mpages_info.data   = mlinks_info.data   = NULL;

	mpages_info.key_offset = offsetof(struct mpage, inodev);
	mlinks_info.key_offset = offsetof(struct mlink, file);

d425 2
a426 2
	ohash_init(&mpages, 6, &mpages_info);
	ohash_init(&mlinks, 6, &mlinks_info);
d496 4
a499 2
				ohash_init(&mpages, 6, &mpages_info);
				ohash_init(&mlinks, 6, &mlinks_info);
a1087 1
	struct ohash_info	 str_info;
a1095 6
	str_info.alloc = hash_alloc;
	str_info.calloc = hash_calloc;
	str_info.free = hash_free;
	str_info.data = NULL;
	str_info.key_offset = offsetof(struct str, key);

d1108 2
a1109 2
		ohash_init(&names, 4, &str_info);
		ohash_init(&strings, 6, &str_info);
a2365 21
static void *
hash_calloc(size_t n, size_t sz, void *arg)
{

	return mandoc_calloc(n, sz);
}

static void *
hash_alloc(size_t sz, void *arg)
{

	return mandoc_malloc(sz);
}

static void
hash_free(void *p, void *arg)
{

	free(p);
}

@


1.200
log
@Clear dform and dsec when exiting a first-level directory in treescan().
Fixes a segfault reported by bentley@@.
While here, do some style cleanup in the same function.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.199 2015/10/12 00:08:15 schwarze Exp $ */
a1257 1
	int		 irc;
d1273 1
a1273 1
	if (SQLITE_OK != sqlite3_bind_int64(stmt, 1, NAME_TITLE))
d1276 1
a1276 1
	while (SQLITE_ROW == (irc = sqlite3_step(stmt))) {
@


1.199
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.198 2015/10/11 21:12:54 schwarze Exp $ */
d587 1
a587 1
	if (NULL == f) {
d596 1
a596 1
	while (NULL != (ff = fts_read(f))) {
d605 1
a605 1
			if (NULL == realpath(path, buf)) {
d620 1
a620 1
			if (-1 == stat(path, ff->fts_statp)) {
d632 1
a632 1
			if (0 == strcmp(path, MANDOC_DB))
d641 1
a641 1
			while (NULL == fsec) {
d643 1
a643 1
				if (NULL == fsec || strcmp(fsec+1, "gz"))
d649 1
a649 1
			if (NULL == fsec) {
d656 1
a656 1
			} else if (0 == strcmp(++fsec, "html")) {
d660 1
a660 1
			} else if (0 == strcmp(fsec, "ps")) {
d664 1
a664 1
			} else if (0 == strcmp(fsec, "pdf")) {
d669 1
a669 1
			    ((FORM_SRC == dform &&
d671 1
a671 1
			     (FORM_CAT == dform && strcmp(fsec, "0")))) {
d716 3
a718 1
			if (FTS_DP == ff->fts_info)
d720 1
d722 1
a722 1
			if (0 == strncmp(cp, "man", 3)) {
d725 1
a725 1
			} else if (0 == strncmp(cp, "cat", 3)) {
d733 1
a733 1
			if (NULL != dsec || use_all)
d745 1
a745 1
			if (FTS_DP != ff->fts_info && NULL != dsec)
d751 1
a751 1
			if (FTS_DP == ff->fts_info || use_all)
@


1.198
log
@Finally use __progname, err(3) and warn(3).
That's more readable and less error-prone than fumbling around
with argv[0], fprintf(3), strerror(3), perror(3), and exit(3).

It's a bad idea to boycott good interfaces merely because standards
committees ignore them.  Instead, let's provide compatibility modules
for archaic systems (like commercial Solaris) that still don't have
them.  The compat module has an UCB Copyright (c) 1993...
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.197 2015/10/06 18:32:19 schwarze Exp $ */
a695 1
			/* FALLTHROUGH */
a1564 1
			/* FALLTHROUGH */
a1565 1
			/* FALLTHROUGH */
a1566 1
			/* FALLTHROUGH */
a1567 1
			/* FALLTHROUGH */
a1919 1
			/* FALLTHROUGH */
@


1.197
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.196 2015/09/16 09:50:29 schwarze Exp $ */
d26 1
d193 2
a195 1
static	char		*progname;
a361 6
	progname = strrchr(argv[0], '/');
	if (progname == NULL)
		progname = argv[0];
	else
		++progname;

d369 1
a369 2
		fprintf(stderr, "%s: -%c: Conflicting option\n", \
		    progname, (_ch)); \
d405 2
a406 3
				fprintf(stderr, "%s: -T%s: "
				    "Unsupported output format\n",
				    progname, optarg);
d433 1
a433 2
		fprintf(stderr, "%s: -C: Too many arguments\n",
		    progname);
d550 2
a551 2
		       progname, progname, progname,
		       progname, progname);
@


1.196
log
@for portability, use (char *)NULL in execlp(3) as discussed on tech@@ OpenBSD
(didn't blow up anywhere yet, but better safe than sorry)
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.195 2015/07/19 06:05:16 schwarze Exp $ */
d550 1
a550 1
	return(exitcode);
d560 1
a560 1
	return((int)MANDOCLEVEL_BADARG);
d597 1
a597 1
		return(0);
d766 1
a766 1
	return(1);
d1607 1
a1607 1
		return(0);
d1615 1
a1615 1
		return(0);
d1618 1
a1618 1
		return(0);
d1630 1
a1630 1
		return(0);
d1638 1
a1638 1
	return(0);
d1668 1
a1668 1
		return(0);
d1676 1
a1676 1
	return(0);
d1685 1
a1685 1
		return(1);
d1690 1
a1690 1
	return(0);
d1700 1
a1700 1
		return(0);
d1704 1
a1704 1
		return(0);
d1710 1
a1710 1
	return(0);
d1720 1
a1720 1
	return(0);
d1742 1
a1742 1
	return(0);
d1750 1
a1750 1
	return(n->sec == SEC_CUSTOM && n->type == ROFFT_HEAD);
d1758 1
a1758 1
	return(n->type == ROFFT_HEAD);
d1766 1
a1766 1
	return(n->type == ROFFT_BODY);
d1871 1
a1871 1
		return(0);
d1874 1
a1874 1
	return(rc);
d1998 1
a1998 1
		return(1);
d2000 1
a2000 1
		return(0);
d2267 1
a2267 1
		return(1);
d2278 1
a2278 1
			return(0);
d2292 1
a2292 1
		return(0);
d2300 1
a2300 1
		return(0);
d2308 1
a2308 1
		return(0);
d2347 1
a2347 1
		return(0);
d2357 1
a2357 1
		return(0);
d2391 1
a2391 1
		return(0);
d2395 1
a2395 1
	return(1);
d2402 1
a2402 1
	return(mandoc_calloc(n, sz));
d2409 1
a2409 1
	return(mandoc_malloc(sz));
d2458 1
a2458 1
			return(0);
d2463 1
a2463 1
			return(0);
d2477 1
a2477 1
		return(0);
d2483 1
a2483 1
		return(0);
d2491 1
a2491 1
			return(0);
d2496 1
a2496 1
	return(1);
@


1.195
log
@Do not fork and exec gunzip(1), just link with libz instead.
As discussed with deraadt@@, that's cleaner and will help tame(2).
Something like this was also suggested earlier by bapt at FreeBSD.
Minus 50 lines of code, deleting one interface function (mparse_wait),
no functional change intended.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.194 2015/04/23 16:17:44 schwarze Exp $ */
d2211 1
a2211 1
		    tempfilename, MANDOC_DB, NULL);
d2236 1
a2236 1
		execlp("rm", "rm", "-rf", tempfilename, NULL);
@


1.194
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.193 2015/04/18 17:53:21 schwarze Exp $ */
a1248 4
		if (mparse_wait(mp) != MANDOCLEVEL_OK) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say(mlink->file, "&wait gunzip");
		}
@


1.193
log
@Delete the wrapper functions mdoc_meta(), man_meta(), mdoc_node(),
man_node() from the mandoc(3) semi-public interface and the internal
wrapper functions print_mdoc() and print_man() from the HTML formatters.
Minus 60 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.192 2015/04/18 16:34:25 schwarze Exp $ */
d1479 1
a1479 1
			man_deroff(&title, body);
d1723 1
a1723 1
		mdoc_deroff(&mpage->desc, n);
@


1.192
log
@Profit from the unified struct roff_man and reduce the number of
arguments of mparse_result() by one.  No functional change.
Written on the ICE Bruxelles-Koeln on the way back from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.191 2015/04/18 16:06:40 schwarze Exp $ */
d1198 1
a1198 1
			mpage->sec = mdoc_meta(man)->msec;
d1201 1
a1201 1
			mpage->arch = mdoc_meta(man)->arch;
d1204 1
a1204 2
			mpage->title =
			    mandoc_strdup(mdoc_meta(man)->title);
d1207 1
a1207 1
			mpage->sec = mandoc_strdup(man_meta(man)->msec);
d1209 1
a1209 1
			mpage->title = mandoc_strdup(man_meta(man)->title);
d1232 1
a1232 1
			parse_mdoc(mpage, mdoc_meta(man), mdoc_node(man));
d1234 1
a1234 1
			parse_man(mpage, man_meta(man), man_node(man));
@


1.191
log
@Replace the structs mdoc and man by a unified struct roff_man.
Almost completely mechanical, no functional change.
Written on the train from Exeter to London returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.190 2015/04/02 23:48:19 schwarze Exp $ */
a1109 1
	struct roff_man		*mdoc;
a1136 1
		mdoc = NULL;
d1152 1
a1152 1
			mparse_result(mp, &mdoc, &man, &sodest);
d1196 1
a1196 1
		} else if (mdoc != NULL) {
d1198 1
a1198 1
			mpage->sec = mdoc_meta(mdoc)->msec;
d1201 1
a1201 1
			mpage->arch = mdoc_meta(mdoc)->arch;
d1205 2
a1206 2
			    mandoc_strdup(mdoc_meta(mdoc)->title);
		} else if (man != NULL) {
d1232 2
a1233 2
		if (mdoc != NULL)
			parse_mdoc(mpage, mdoc_meta(mdoc), mdoc_node(mdoc));
@


1.190
log
@Third step towards parser unification:
Replace struct mdoc_meta and struct man_meta by a unified struct roff_meta.
Written of the train from London to Exeter on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.189 2015/04/02 22:48:17 schwarze Exp $ */
d1110 2
a1111 2
	struct mdoc		*mdoc;
	struct man		*man;
@


1.189
log
@Second step towards parser unification:
Replace struct mdoc_node and struct man_node by a unified struct roff_node.
To be able to use the tok member for both mdoc(7) and man(7) without
defining all the macros in roff.h, sacrifice a tiny bit of type safety
and make tok an int rather than an enum.
Almost mechanical, no functional change.
Written on the Eurostar from Bruxelles to London on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.188 2015/04/02 21:36:50 schwarze Exp $ */
d133 1
a133 1
typedef	int (*mdoc_fp)(struct mpage *, const struct mdoc_meta *,
d159 1
a159 1
static	void	 parse_man(struct mpage *, const struct man_meta *,
d161 1
a161 1
static	void	 parse_mdoc(struct mpage *, const struct mdoc_meta *,
d163 1
a163 1
static	int	 parse_mdoc_body(struct mpage *, const struct mdoc_meta *,
d165 1
a165 1
static	int	 parse_mdoc_head(struct mpage *, const struct mdoc_meta *,
d167 1
a167 1
static	int	 parse_mdoc_Fd(struct mpage *, const struct mdoc_meta *,
d170 1
a170 1
static	int	 parse_mdoc_Fn(struct mpage *, const struct mdoc_meta *,
d172 1
a172 1
static	int	 parse_mdoc_Fo(struct mpage *, const struct mdoc_meta *,
d174 1
a174 1
static	int	 parse_mdoc_Nd(struct mpage *, const struct mdoc_meta *,
d176 1
a176 1
static	int	 parse_mdoc_Nm(struct mpage *, const struct mdoc_meta *,
d178 1
a178 1
static	int	 parse_mdoc_Sh(struct mpage *, const struct mdoc_meta *,
d180 1
a180 1
static	int	 parse_mdoc_Xr(struct mpage *, const struct mdoc_meta *,
d1446 1
a1446 1
parse_man(struct mpage *mpage, const struct man_meta *meta,
d1572 1
a1572 1
parse_mdoc(struct mpage *mpage, const struct mdoc_meta *meta,
d1605 1
a1605 1
parse_mdoc_Fd(struct mpage *mpage, const struct mdoc_meta *meta,
d1670 1
a1670 1
parse_mdoc_Fn(struct mpage *mpage, const struct mdoc_meta *meta,
d1687 1
a1687 1
parse_mdoc_Fo(struct mpage *mpage, const struct mdoc_meta *meta,
d1701 1
a1701 1
parse_mdoc_Xr(struct mpage *mpage, const struct mdoc_meta *meta,
d1721 1
a1721 1
parse_mdoc_Nd(struct mpage *mpage, const struct mdoc_meta *meta,
d1731 1
a1731 1
parse_mdoc_Nm(struct mpage *mpage, const struct mdoc_meta *meta,
d1753 1
a1753 1
parse_mdoc_Sh(struct mpage *mpage, const struct mdoc_meta *meta,
d1761 1
a1761 1
parse_mdoc_head(struct mpage *mpage, const struct mdoc_meta *meta,
d1769 1
a1769 1
parse_mdoc_body(struct mpage *mpage, const struct mdoc_meta *meta,
@


1.188
log
@First step towards parser unification:
Replace enum mdoc_type and enum man_type by a unified enum roff_type.
Almost mechanical, no functional change.
Written on the ICE train from Frankfurt to Bruxelles on the way to p2k15.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.187 2015/03/27 17:37:25 schwarze Exp $ */
d134 1
a134 1
			const struct mdoc_node *);
d160 1
a160 1
			const struct man_node *);
d162 1
a162 1
			const struct mdoc_node *);
d164 1
a164 1
			const struct mdoc_node *);
d166 1
a166 1
			const struct mdoc_node *);
d168 2
a169 2
			const struct mdoc_node *);
static	void	 parse_mdoc_fname(struct mpage *, const struct mdoc_node *);
d171 1
a171 1
			const struct mdoc_node *);
d173 1
a173 1
			const struct mdoc_node *);
d175 1
a175 1
			const struct mdoc_node *);
d177 1
a177 1
			const struct mdoc_node *);
d179 1
a179 1
			const struct mdoc_node *);
d181 1
a181 1
			const struct mdoc_node *);
d185 1
a185 1
			const struct mdoc_node *, uint64_t);
d1434 1
a1434 1
	const struct mdoc_node *n, uint64_t m)
d1447 1
a1447 1
	const struct man_node *n)
d1449 1
a1449 1
	const struct man_node *head, *body;
d1573 1
a1573 1
	const struct mdoc_node *n)
d1606 1
a1606 1
	const struct mdoc_node *n)
d1649 1
a1649 1
parse_mdoc_fname(struct mpage *mpage, const struct mdoc_node *n)
d1671 1
a1671 1
	const struct mdoc_node *n)
d1688 1
a1688 1
	const struct mdoc_node *n)
d1702 1
a1702 1
	const struct mdoc_node *n)
d1722 1
a1722 1
	const struct mdoc_node *n)
d1732 1
a1732 1
	const struct mdoc_node *n)
d1754 1
a1754 1
	const struct mdoc_node *n)
d1762 1
a1762 1
	const struct mdoc_node *n)
d1770 1
a1770 1
	const struct mdoc_node *n)
@


1.187
log
@Parse the new man.conf(5) "output" directive.
The next step will be to actually use the parsed data.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.186 2015/03/13 00:19:41 schwarze Exp $ */
d49 3
a53 2
#include "mandoc.h"
#include "mandoc_aux.h"
d1440 1
a1440 1
		if (MDOC_TEXT == n->type)
d1464 1
a1464 1
	if (MAN_BODY == n->type && MAN_SH == n->tok) {
d1470 1
a1470 1
		    MAN_TEXT == head->type &&
d1579 1
a1579 1
		case MDOC_ELEM:
d1581 1
a1581 1
		case MDOC_BLOCK:
d1583 1
a1583 1
		case MDOC_HEAD:
d1585 1
a1585 1
		case MDOC_BODY:
d1587 1
a1587 1
		case MDOC_TAIL:
d1596 1
a1596 1
			assert(MDOC_ROOT != n->type);
d1613 1
a1613 1
	    MDOC_TEXT != n->type)
d1624 1
a1624 1
	if (NULL == (n = n->next) || MDOC_TEXT != n->type)
d1654 1
a1654 1
	if (n->type != MDOC_TEXT)
d1680 1
a1680 1
		if (n->type == MDOC_TEXT)
d1691 1
a1691 1
	if (n->type != MDOC_HEAD)
d1725 1
a1725 1
	if (MDOC_BODY == n->type)
d1737 1
a1737 1
	else if (SEC_SYNOPSIS == n->sec && MDOC_HEAD == n->type) {
d1746 1
a1746 1
		putkey(mpage, n->child->string, NAME_HEAD);
d1757 1
a1757 1
	return(SEC_CUSTOM == n->sec && MDOC_HEAD == n->type);
d1765 1
a1765 1
	return(MDOC_HEAD == n->type);
d1773 1
a1773 1
	return(MDOC_BODY == n->type);
@


1.186
log
@Fix hardlink detection on platforms having padding in struct inodev,
typically 64bit platforms.  This was basically broken since forever.
Not only is the padding used, but it was used uninitialized.
Problem reported by jmc@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.185 2015/02/27 16:22:09 schwarze Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d53 1
a53 1
#include "manpath.h"
d341 5
a346 5
	size_t		  j, sz;
	const char	 *path_arg;
	struct manpaths	  dirs;
	struct mparse	 *mp;
	struct ohash_info mpages_info, mlinks_info;
d348 1
a349 1
	memset(&dirs, 0, sizeof(struct manpaths));
d488 1
a488 1
		 * manpath_parse() wants to do it.
d491 1
a491 1
			dirs.paths = mandoc_reallocarray(NULL,
d493 1
a493 1
			dirs.sz = (size_t)argc;
d495 1
a495 1
				dirs.paths[i] = mandoc_strdup(argv[i]);
d497 1
a497 1
			manpath_parse(&dirs, path_arg, NULL, NULL);
d499 1
a499 1
		if (0 == dirs.sz) {
d510 4
a513 4
		for (j = 0; j < dirs.sz; j++) {
			sz = strlen(dirs.paths[j]);
			if (sz && '/' == dirs.paths[j][sz - 1])
				dirs.paths[j][--sz] = '\0';
d522 1
a522 1
			if (0 == set_basedir(dirs.paths[j], argc > 0))
d535 1
a535 1
			if (j + 1 < dirs.sz) {
d543 1
a543 1
	manpath_free(&dirs);
@


1.185
log
@When makewhatis(8) scans a tree, ignore trailing garbage on filenames.
This is relevant because some ports install files like man1/xsel.1x,
as reported by patrick keshishian <pkeshish at gmail dot com> on misc@@.

We can probably improve functionality and simplify the code by ignoring
file name extensions altogether; we already know the section number from
the name of the directory.  But so close to lock, i'm keeping the fix
minimal.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.184 2015/01/21 22:41:49 schwarze Exp $ */
d945 1
@


1.184
log
@Support homebrew-style linking on Mac OS X.
Idea found together with Alexis Hildebrandt <surryhill at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.183 2015/01/15 04:26:40 schwarze Exp $ */
d675 2
a676 1
			    ((FORM_SRC == dform && strcmp(fsec, dsec)) ||
@


1.183
log
@Fatal errors no longer exist.
If a file can be opened, mandoc will produce some output;
at worst, the output may be almost empty.
Simplifies error handling and frees a message type for future use.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.182 2015/01/03 12:55:25 schwarze Exp $ */
d616 5
a620 1
			if (strstr(buf, basedir) != buf) {
d825 4
@


1.182
log
@Fix a potential NULL pointer access in an error message after waitpid()
failure; found using detailed information provided by Ulrich Spoerlein
<uqs at FreeBSD> about FreeBSD Coverity CID 1261304.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.181 2015/01/02 17:02:19 schwarze Exp $ */
d445 1
a445 1
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_FATAL, NULL,
a1104 1
	enum mandoclevel	 lvl;
d1138 2
a1139 3
		 * Try interpreting the file as mdoc(7) or man(7)
		 * source code, unless it is already known to be
		 * formatted.  Fall back to formatted mode.
d1142 2
a1143 3
			lvl = mparse_readfd(mp, fd, mlink->file);
			if (lvl < MANDOCLEVEL_FATAL)
				mparse_result(mp, &mdoc, &man, &sodest);
@


1.181
log
@Explicitly set the *data member of struct ohash_info to NULL.
It is never dereferenced, but it gets copied around, which worries
static analysis tools and might also confuse human auditors.
FreeBSD Coverity CID 1261298, 1261299, 1261300, reported by
Pedro Giffuni and Ulrich Sp�rlein <pfg@@ and uqs@@ at FreeBSD>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.180 2014/12/30 20:41:00 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d1119 1
a1119 1
		if (mpage->mlinks == NULL) {
d1132 1
a1132 1
		mparse_open(mp, &fd, mpage->mlinks->file);
d1134 1
a1134 1
			say(mpage->mlinks->file, "&open");
d1143 2
a1144 3
		if (mpage->mlinks->dform != FORM_CAT ||
		    mpage->mlinks->fform != FORM_CAT) {
			lvl = mparse_readfd(mp, fd, mpage->mlinks->file);
a1162 1
				mlink = mpage->mlinks;
d1202 3
a1204 6
			mpage->sec =
			    mandoc_strdup(man_meta(man)->msec);
			mpage->arch =
			    mandoc_strdup(mpage->mlinks->arch);
			mpage->title =
			    mandoc_strdup(man_meta(man)->title);
d1207 3
a1209 6
			mpage->sec =
			    mandoc_strdup(mpage->mlinks->dsec);
			mpage->arch =
			    mandoc_strdup(mpage->mlinks->arch);
			mpage->title =
			    mandoc_strdup(mpage->mlinks->name);
d1215 1
a1215 1
		for (mlink = mpage->mlinks; mlink; mlink = mlink->next) {
d1241 1
d1246 1
a1246 1
			say(mpage->mlinks->file, "&wait gunzip");
@


1.180
log
@When a file is given on the command line, actually exists, and its name
relative to the respective manual tree is longer than PATH_MAX, do not
leak the memory allocated to hold the name.  Not sure that can actually
happen, but better safe than sorry.
FreeBSD Coverity Scan CID 1261303, reported by Pedro Giffuni <pfg@@>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.179 2014/12/09 07:29:42 schwarze Exp $ */
d353 2
a354 1
	mpages_info.free  = mlinks_info.free  = hash_free;
d1110 1
@


1.179
log
@Integrate the makewhatis binary into the mandoc binary
just like we do it on OpenBSD.  Smaller and neater.
While here, let ./configure set INSTALL_TARGETS.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.178 2014/12/05 16:18:14 schwarze Exp $ */
d855 1
@


1.178
log
@Improve parsing of function names.
This gets rid of the last bogus entries in base and Xenocara.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.177 2014/12/05 15:16:54 schwarze Exp $ */
d339 1
a339 1
main(int argc, char *argv[])
@


1.177
log
@Do not misinterpret function arguments as function names;
improves semantic analysis of more than 300 manuals.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.176 2014/12/05 14:26:40 schwarze Exp $ */
d168 1
d1644 2
a1645 3
static int
parse_mdoc_Fn(struct mpage *mpage, const struct mdoc_meta *meta,
	const struct mdoc_node *n)
d1648 1
d1650 2
a1651 2
	if (NULL == (n = n->child) || MDOC_TEXT != n->type)
		return(0);
d1653 1
a1653 6
	/*
	 * Parse: .Fn "struct type *name" "char *arg".
	 * First strip away pointer symbol.
	 * Then store the function name, then type.
	 * Finally, store the arguments.
	 */
d1655 2
a1656 4
	if (NULL == (cp = strrchr(n->string, ' ')))
		cp = n->string;

	while ('*' == *cp)
d1658 1
d1660 1
a1660 1
	putkey(mpage, cp, TYPE_Fn);
d1662 2
a1663 1
		putkey(mpage, cp, NAME_SYN);
d1665 9
a1673 2
	if (n->string < cp)
		putkeys(mpage, n->string, cp - n->string, TYPE_Ft);
d1675 2
a1676 2
	for (n = n->next; NULL != n; n = n->next)
		if (MDOC_TEXT == n->type)
d1690 3
a1692 3
	putmdockey(mpage, n->child, TYPE_Fn);
	if (n->sec == SEC_SYNOPSIS)
		putmdockey(mpage, n->child, NAME_SYN);
@


1.176
log
@Render text before, not after accumulating flag bits, such that flags
for different representations of the same string end up in the same
database entry.  Improves name classification for 500 manuals.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.175 2014/12/04 21:48:48 schwarze Exp $ */
d1684 3
@


1.175
log
@When finding a .so link after the page was already processed,
do not clobber the existing names flags;
instead, OR the additional flags into them.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.174 2014/12/04 20:13:25 schwarze Exp $ */
a86 1
	char		*rendered; /* key in UTF-8 or ASCII form */
d89 1
a89 1
	char		 key[]; /* may contain escape sequences */
d141 1
a141 1
static	void	 dbadd(struct mpage *, struct mchars *);
d155 1
a155 1
static	void	 mpages_merge(struct mchars *, struct mparse *);
d181 1
a181 2
static	void	 putkeys(const struct mpage *,
			const char *, size_t, uint64_t);
d184 1
a184 1
static	void	 render_key(struct mchars *, struct str *);
d201 1
a342 1
	struct mchars	 *mc;
d442 1
a442 1
	mc = mchars_alloc();
d444 1
a444 1
	    mc, NULL);
d480 1
a480 1
			mpages_merge(mc, mp);
d527 1
a527 1
			mpages_merge(mc, mp);
d543 1
a543 1
	mchars_free(mc);
d1090 1
a1090 1
mpages_merge(struct mchars *mc, struct mparse *mp)
d1244 1
a1244 1
		dbadd(mpage, mc);
d1603 1
a1603 1
	const char	*start, *end;
d1772 1
a1772 2
putkeys(const struct mpage *mpage,
	const char *cp, size_t sz, uint64_t v)
d1778 1
a1778 1
	int		 i;
d1783 2
d1817 3
d1875 4
a1878 2
 * Store the rendered version of a key, or alias the pointer
 * if the key contains no escape sequences.
d1880 2
a1881 2
static void
render_key(struct mchars *mc, struct str *key)
d1883 3
a1885 1
	size_t		 sz, bsz, pos;
d1887 1
a1887 6
	char		*buf;
	const char	*seq, *cpp, *val;
	int		 len, u;
	enum mandoc_esc	 esc;

	assert(NULL == key->rendered);
d1896 15
a1910 16
	val = key->key;
	bsz = strlen(val);

	/*
	 * Pre-check: if we have no stop-characters, then set the
	 * pointer as ourselvse and get out of here.
	 */
	if (strcspn(val, res) == bsz) {
		key->rendered = key->key;
		return;
	}

	/* Pre-allocate by the length of the input */

	buf = mandoc_malloc(++bsz);
	pos = 0;
a1911 1
	while ('\0' != *val) {
d1913 2
a1914 3
		 * Halt on the first escape sequence.
		 * This also halts on the end of string, in which case
		 * we just copy, fallthrough, and exit the loop.
d1916 5
a1920 4
		if ((sz = strcspn(val, res)) > 0) {
			memcpy(&buf[pos], val, sz);
			pos += sz;
			val += sz;
d1923 5
a1927 5
		switch (*val) {
		case ASCII_HYPH:
			buf[pos++] = '-';
			val++;
			continue;
d1931 5
a1935 2
			buf[pos++] = ' ';
			val++;
d1938 1
d1941 1
a1941 1
			break;
a1942 6
		if ('\\' != *val)
			break;

		/* Read past the slash. */

		val++;
d1945 3
a1947 2
		 * Parse the escape sequence and see if it's a
		 * predefined character or special character.
d1950 2
a1951 5
		esc = mandoc_escape((const char **)&val,
		    &seq, &len);
		if (ESCAPE_ERROR == esc)
			break;
		if (ESCAPE_SPECIAL != esc)
d1960 2
a1961 1
			if ((u = mchars_spec2cp(mc, seq, len)) <= 0)
d1963 2
a1964 2
			cpp = utfbuf;
			if (0 == (sz = utf8(u, utfbuf)))
d1966 1
a1966 1
			sz = strlen(cpp);
d1968 2
a1969 2
			cpp = mchars_spec2str(mc, seq, len, &sz);
			if (NULL == cpp)
d1971 3
a1973 3
			if (ASCII_NBRSP == *cpp) {
				cpp = " ";
				sz = 1;
d1979 19
a1997 8
		bsz += sz;
		buf = mandoc_realloc(buf, bsz);
		memcpy(&buf[pos], cpp, sz);
		pos += sz;
	}

	buf[pos] = '\0';
	key->rendered = buf;
d2045 1
a2045 1
dbadd(struct mpage *mpage, struct mchars *mc)
d2049 1
d2052 1
d2058 1
a2058 3
		     key = ohash_next(&names, &slot)) {
			if (key->rendered != key->key)
				free(key->rendered);
a2059 1
		}
d2061 1
a2061 3
		     key = ohash_next(&strings, &slot)) {
			if (key->rendered != key->key)
				free(key->rendered);
a2062 1
		}
d2091 3
a2093 5
	i = strlen(mpage->desc) + 1;
	key = mandoc_calloc(1, sizeof(struct str) + i);
	memcpy(key->key, mpage->desc, i);
	render_key(mc, key);

d2095 1
a2095 1
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, key->rendered);
d2100 2
a2101 4

	if (key->rendered != key->key)
		free(key->rendered);
	free(key);
a2111 2
		if (NULL == key->rendered)
			render_key(mc, key);
d2114 1
a2114 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_NAME], i, key->rendered);
a2117 2
		if (key->rendered != key->key)
			free(key->rendered);
a2122 2
		if (NULL == key->rendered)
			render_key(mc, key);
d2125 1
a2125 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_KEY], i, key->rendered);
a2128 2
		if (key->rendered != key->key)
			free(key->rendered);
@


1.174
log
@correctly store .Dt and .TH information in the names table
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.173 2014/12/04 18:31:20 schwarze Exp $ */
d128 1
d1793 1
a1793 1
			    "Adding name %*s", sz, cp);
d2010 1
d2016 9
a2024 1
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, NAME_FILE & NAME_MASK);
d2337 2
a2338 1
		"ON DELETE CASCADE\n"
d2376 2
@


1.173
log
@in the SYNOPSIS, add .Fo and first .Fn arguments to the names table
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.172 2014/12/04 17:36:00 schwarze Exp $ */
d107 1
d158 2
a159 1
static	void	 parse_man(struct mpage *, const struct man_node *);
d1230 2
a1231 4
		assert(NULL == mpage->desc);
		if (NULL != mdoc) {
			if (NULL != (cp = mdoc_meta(mdoc)->name))
				putkey(mpage, cp, NAME_HEAD);
d1233 2
a1234 2
		} else if (NULL != man)
			parse_man(mpage, man_node(man));
d1237 1
a1237 1
		if (NULL == mpage->desc)
d1442 2
a1443 1
parse_man(struct mpage *mpage, const struct man_node *n)
d1509 5
d1528 5
d1563 1
a1563 1
		parse_man(mpage, n);
d1734 6
@


1.172
log
@In the SYNOPSIS, if .Nm occurs without argument, give the first .Nm
that occurred in the document a NAME_SYN entry in the names table.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.171 2014/11/27 01:58:21 schwarze Exp $ */
d168 2
d305 1
a305 1
	{ parse_mdoc_head, 0 },  /* Fo */
d1656 2
d1670 11
@


1.171
log
@Make makewhatis(8) understand .so links to .gz pages.
Drop the FORM_GZ annotation in the mpages table; it is conceptually wrong
because it ought to be in the mlinks table: An uncompressed .so link file
can point to a compressed manual page file and vice versa.
Besides, it is no longer needed because mparse_open() handles it all.
Sprinkle some KNF while here.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.170 2014/11/26 21:40:17 schwarze Exp $ */
d131 2
a132 1
typedef	int (*mdoc_fp)(struct mpage *, const struct mdoc_node *);
d158 18
a175 9
static	void	 parse_mdoc(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_body(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_head(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Fd(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Fn(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Nd(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Nm(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Sh(struct mpage *, const struct mdoc_node *);
static	int	 parse_mdoc_Xr(struct mpage *, const struct mdoc_node *);
d1230 1
a1230 1
			parse_mdoc(mpage, mdoc_node(mdoc));
d1555 2
a1556 1
parse_mdoc(struct mpage *mpage, const struct mdoc_node *n)
d1572 1
a1572 1
			       if (0 == (*mdocs[n->tok].fp)(mpage, n))
d1583 1
a1583 1
			parse_mdoc(mpage, n);
d1588 2
a1589 1
parse_mdoc_Fd(struct mpage *mpage, const struct mdoc_node *n)
d1632 2
a1633 1
parse_mdoc_Fn(struct mpage *mpage, const struct mdoc_node *n)
d1666 2
a1667 1
parse_mdoc_Xr(struct mpage *mpage, const struct mdoc_node *n)
d1686 2
a1687 1
parse_mdoc_Nd(struct mpage *mpage, const struct mdoc_node *n)
d1696 2
a1697 1
parse_mdoc_Nm(struct mpage *mpage, const struct mdoc_node *n)
d1702 6
a1707 2
	else if (SEC_SYNOPSIS == n->sec && MDOC_HEAD == n->type)
		putmdockey(mpage, n->child, NAME_SYN);
d1712 2
a1713 1
parse_mdoc_Sh(struct mpage *mpage, const struct mdoc_node *n)
d1720 2
a1721 1
parse_mdoc_head(struct mpage *mpage, const struct mdoc_node *n)
d1728 2
a1729 1
parse_mdoc_body(struct mpage *mpage, const struct mdoc_node *n)
@


1.170
log
@Simplify the mparse_open()/mparse_wait() interface.
Don't bother the user with the PID of the child process,
store it inside the opaque mparse handle.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.169 2014/11/19 20:40:51 schwarze Exp $ */
d1096 1
a1096 1
	if (0 == nodb)
d1100 1
a1100 1
	while (NULL != mpage) {
d1102 1
a1102 1
		if (NULL == mpage->mlinks) {
d1126 2
a1127 2
		if (FORM_CAT != mpage->mlinks->dform ||
		    FORM_CAT != mpage->mlinks->fform) {
d1133 1
a1133 1
		if (NULL != sodest) {
d1136 7
a1142 1
			if (NULL != mlink_dest) {
d1163 1
a1163 1
					if (NULL == mlink->next)
d1175 1
a1175 1
		} else if (NULL != mdoc) {
d1179 1
a1179 1
			    NULL == mpage->sec ? "" : mpage->sec);
d1182 1
a1182 1
			    NULL == mpage->arch ? "" : mpage->arch);
d1185 1
a1185 1
		} else if (NULL != man) {
a1201 2
		if (mpage->mlinks->gzip)
			mpage->form |= FORM_GZ;
@


1.169
log
@Three fixes with respect to the names table:
1. Do not mask out NAME_FIRST before its first use.
2. Avoid duplicate NAME_FILE entries.
3. Correctly mask NAME_FILE for .so links.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.168 2014/10/28 17:36:19 schwarze Exp $ */
a1086 1
	pid_t			 child_pid;
a1113 1
		child_pid = 0;
d1115 1
a1115 1
		mparse_open(mp, &fd, mpage->mlinks->file, &child_pid);
d1232 1
a1232 2
		if (child_pid &&
		    mparse_wait(mp, child_pid) != MANDOCLEVEL_OK) {
@


1.168
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.167 2014/10/27 13:31:04 schwarze Exp $ */
d141 1
d1157 1
a1157 1
						dbadd_mlink(mlink);
d1732 2
a1733 1
		name_mask &= ~NAME_FIRST;
d1948 8
d1958 1
a1958 1
	SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, NAME_FILE);
@


1.167
log
@Fix a regression in term.c rev. 1.229 reported by bentley@@:
In UTF-8 output, do not print anything if mchars_spec2cp() returns 0.
In particular, this repairs handling of zero-width spaces (\&).

While here, let mchars_spec2cp() return 0xFFFD instead of -1
if the character is not found, simplifying the using code.
In HTML output, do not print obfuscated ASCII characters and
do not test for one-char escapes, mchars_spec2cp() already does that.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.166 2014/10/12 20:32:39 schwarze Exp $ */
a427 1
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_FATAL, NULL, NULL);
d429 2
a430 1

d528 1
a529 1
	mparse_free(mp);
@


1.166
log
@add missing entry for .ll to the dispatch table;
patch from Martin <Natano at natano dot net>, thanks
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.165 2014/09/09 19:35:25 schwarze Exp $ */
d1906 1
a1906 1
			if (0 == (u = mchars_spec2cp(mc, seq, len)))
@


1.165
log
@If a manpath directory (for example, a _whatdb entry from man.conf(5)
or an entry in the MANPATH environment variable) does not exist,
silently skip it.  This brings makewhatis(8) back closer to the
behaviour of espie@@'s version and ought to shut up the weekly(8)
whining observed by henning@@ on machines not having xbase installed.
Also, don't error out after the first unusable manpath entry, still
try the others.

Of course, still complain about non-existent directories specified
on the command line and about any directories failing for other
reasons than ENOENT.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.164 2014/09/07 03:08:47 schwarze Exp $ */
d318 1
@


1.164
log
@Do not report a page as arch=any merely because .Dt lacks the third argument.
Pages found outside arch-specific dirs still get arch=any, of course.
Issue reported by justinhenryhaynes at gmail dot com on misc@@, thanks!
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.163 2014/09/07 03:00:21 schwarze Exp $ */
d172 1
a172 1
static	int	 set_basedir(const char *);
d439 1
a439 1
		if (OP_TEST != op && 0 == set_basedir(path_arg))
d505 2
a506 2
			if (0 == set_basedir(dirs.paths[j]))
				goto out;
d508 1
a508 1
				goto out;
d510 1
a510 1
				goto out;
d2346 1
a2346 1
set_basedir(const char *targetdir)
d2399 4
a2402 2
		exitcode = (int)MANDOCLEVEL_BADARG;
		say("", "&%s: realpath", targetdir);
d2405 4
a2408 2
		exitcode = (int)MANDOCLEVEL_BADARG;
		say("", "&chdir");
@


1.163
log
@fix debugging output
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.162 2014/09/03 23:21:47 schwarze Exp $ */
d1199 2
a1200 2
		putkey(mpage, '\0' == *mpage->arch ?
		    any : mpage->arch, TYPE_arch);
@


1.162
log
@Add *.gz support to apropos(1) -a, man(1), and even mandoc(1).
Implemented by moving the zip code from makewhatis(8) to the parser lib.
@
text
@d1 1
a1 1
/*	$Id$ */
d1738 1
a1738 1
			if (1 << i & v)
@


1.161
log
@If a manual page is installed gzip(1)ed, let makewhatis(8) take
note in mandoc.db(5), such that man(1) -w and apropos(1) -w can
report the correct filename.
This is a prerequisite for letting apropos -a and man support
gzip'ed manuals in the future, which doesn't work yet.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d20 1
a21 1
#include <sys/types.h>
a1078 1
	int			 fd[2];
d1086 1
a1086 1
	int			 status;
a1113 2
		fd[0] = -1;
		fd[1] = -1;
d1115 4
a1118 29
		if (mpage->mlinks->gzip) {
			if (-1 == pipe(fd)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file, "&pipe gunzip");
				goto nextpage;
			}
			switch (child_pid = fork()) {
			case -1:
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file, "&fork gunzip");
				child_pid = 0;
				close(fd[1]);
				close(fd[0]);
				goto nextpage;
			case 0:
				close(fd[0]);
				if (-1 == dup2(fd[1], STDOUT_FILENO)) {
					say(mpage->mlinks->file,
					    "&dup gunzip");
					exit(1);
				}
				execlp("gunzip", "gunzip", "-c",
				    mpage->mlinks->file, NULL);
				say(mpage->mlinks->file, "&exec gunzip");
				exit(1);
			default:
				close(fd[1]);
				break;
			}
d1128 1
a1128 1
			lvl = mparse_readfd(mp, fd[0], mpage->mlinks->file);
d1220 1
a1220 1
			parse_cat(mpage, fd[0]);
d1232 4
a1235 15
		if (child_pid) {
			if (-1 == waitpid(child_pid, &status, 0)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file, "&wait gunzip");
			} else if (WIFSIGNALED(status)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file,
				    "gunzip died from signal %d",
				    WTERMSIG(status));
			} else if (WEXITSTATUS(status)) {
				exitcode = (int)MANDOCLEVEL_SYSERR;
				say(mpage->mlinks->file,
				    "gunzip failed with code %d",
				    WEXITSTATUS(status));
			}
d2315 1
a2315 1
		sqlite3_errmsg(db));
@


1.160
log
@When makewhatis(8) finds an .so link after the manual being pointed to
has already been processed, add the file names to the names table, too,
not just to the mlinks table.
This fixes a bug where apropos(1) and the new man(1) wouldn't find some
of the Xenocara manuals via some of their .so links.  After rebuilding,
run "makewhatis /usr/X11R6/man" or just wait for weekly(8).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.159 2014/08/23 18:13:47 schwarze Exp $ */
a85 6
enum	form {
	FORM_NONE,  /* format is unknown */
	FORM_SRC,   /* format is -man or -mdoc */
	FORM_CAT    /* format is cat */
};

a100 1
	enum form	 form;    /* format from file content */
d106 1
a110 2
	enum form	 dform;   /* format from directory */
	enum form	 fform;   /* format from file name suffix */
d117 2
d835 1
d1224 2
d2057 1
a2057 1
	SQL_BIND_INT(stmts[STMT_INSERT_PAGE], i, FORM_SRC == mpage->form);
@


1.159
log
@do not leak a file descriptor on fdopen(3) failure; from doug@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.114 2014/08/23 01:00:20 doug Exp $ */
d1987 7
@


1.158
log
@Improve build system and autodetection.
* Make ./configure standalone, that's what people expect.
* Let people write a ./configure.local from scratch, not edit existing files.
* Autodetect wchar, sqlite3, and manpath and act accordingly.
* Autodetect the need for -L/usr/local/lib and -lutil.
* Get rid of config.h.p{re,ost}, let ./configure only write what's needed.
* Let ./configure write a Makefile.local snippet, that's quite flexible.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.157 2014/08/11 01:39:00 schwarze Exp $ */
d1335 2
@


1.157
log
@Provide a fallback version of fts(3) for systems lacking it.
I chose the OpenBSD version because it apparently contains various
bugfixes that never made it into libnbcompat.  To reduce size and
complexity, i stripped out the features we don't need.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.156 2014/08/10 23:54:41 schwarze Exp $ */
d28 1
a28 1
#ifdef HAVE_FTS
d42 1
a42 1
#ifdef HAVE_OHASH
@


1.156
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.155 2014/08/06 15:09:05 schwarze Exp $ */
d28 1
d30 3
@


1.155
log
@Bring the handling of defective prologues even closer to groff,
in particular relaxing the distinction between prologue and body
and further improving messages.
* The last .Dd wins and the last .Os wins, even in the body.
* The last .Dt before the first body macro wins.
* Missing title in .Dt defaults to UNTITLED.  Warn about it.
* Missing section in .Dt does not default to 1.  But warn about it.
* Do not warn multiple times about the same mdoc(7) prologue macro.
* Warn about missing .Os.
* Incomplete .TH defaults to empty strings.  Warn about it.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.154 2014/08/05 14:43:10 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
d21 1
@


1.154
log
@Absurdly, the return value of sqlite3_column_text()
is "const unsigned char *", which causes warnings with GCC on Linux.
Explicitly cast to "const char *" to avoid this.
Issue noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.153 2014/06/21 16:18:25 schwarze Exp $ */
d1201 3
a1203 2
			mpage->sec =
			    mandoc_strdup(mdoc_meta(mdoc)->msec);
@


1.153
log
@Prefix messages about bad command line options and arguments
with "mandoc: " or "makewhatis: ", respectively,
similar to what we already do for other messages.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.152 2014/06/20 02:24:40 schwarze Exp $ */
d1309 4
a1312 4
		name = sqlite3_column_text(stmt, 0);
		sec  = sqlite3_column_text(stmt, 1);
		arch = sqlite3_column_text(stmt, 2);
		key  = sqlite3_column_text(stmt, 3);
@


1.152
log
@Merge from OpenBSD - Marc Espie improved the ohash interface:
* rename the halloc callback to calloc, provide overflow protection
* rename the hfree callback to free, drop the useless size argument
* prevent integer overflows in ohash_resize
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.151 2014/06/20 01:21:48 schwarze Exp $ */
d358 2
a359 1
		fprintf(stderr, "-%c: Conflicting option\n", (_ch)); \
d395 3
a397 2
				fprintf(stderr, "-T%s: Unsupported "
				    "output format\n", optarg);
d424 2
a425 1
		fprintf(stderr, "-C: Too many arguments\n");
@


1.151
log
@More tweaking of set_basedir().

1) Do not error out when getcwd(3) fails, only fail when inaccessibility
of the cwd prevents processing of relative paths given on the command line.

2) Do not uselessly call set_basedir() twice in a row.
While fts_read(3) in treescan() does cause the cwd to jump around,
fts_close(3) is always called at the end, putting us back
where we came from.  The -d/-u fallback code already relied on this.

3) Fix the man-root-dir indicator in say().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.150 2014/06/19 00:45:37 schwarze Exp $ */
d148 2
a149 2
static	void	 hash_free(void *, size_t, void *);
static	void	*hash_halloc(size_t, void *);
d339 2
a340 2
	mpages_info.halloc = mlinks_info.halloc = hash_halloc;
	mpages_info.hfree  = mlinks_info.hfree  = hash_free;
d1091 2
a1092 2
	str_info.halloc = hash_halloc;
	str_info.hfree = hash_free;
d2351 1
a2351 1
hash_halloc(size_t sz, void *arg)
d2354 1
a2354 1
	return(mandoc_calloc(1, sz));
d2365 1
a2365 1
hash_free(void *p, size_t sz, void *arg)
@


1.150
log
@Some simple set_basedir() cleanup; more to come.

1) Refrain from calling set_basedir() in the -t case,
and do not attempt to strip anything from the file names in that case.
Testing individual files cannot reasonably have any notion of a base dir.

2) Remove the possibility of passing NULL to set_basedir().
It was dangerous because it was not idempotent, and it served no purpose
except closing a file descriptor right before exit(), which is pointless.
Besides, the file descriptor is likely to be removed completely, soon.

3) Make sure that /foobar isn't treated as a subdirectory of /foo;
this fixes a bug reported by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.149 2014/06/18 19:34:04 schwarze Exp $ */
a508 2
			if (0 == set_basedir(dirs.paths[j]))
				goto out;
d2375 2
a2376 1
	static int	 fd;
d2380 25
a2404 4
	 * Remember where we started by keeping a fd open to the origin
	 * path component: throughout this utility, we chdir() a lot to
	 * handle relative paths, and by doing this, we can return to
	 * the starting point.
d2406 2
a2407 2
	if ('\0' == *startdir) {
		if (NULL == getcwd(startdir, PATH_MAX)) {
d2409 1
a2409 1
			say("", "&getcwd");
d2412 1
a2412 11
		if (-1 == (fd = open(startdir, O_RDONLY, 0))) {
			exitcode = (int)MANDOCLEVEL_SYSERR;
			say("", "&open %s", startdir);
			return(0);
		}
	} else {
		if (-1 == fd)
			return(0);
		if (-1 == fchdir(fd)) {
			close(fd);
			basedir[0] = '\0';
d2418 6
a2424 1
		basedir[0] = '\0';
d2433 1
d2456 1
a2456 1
		fputs("//", stderr);
@


1.149
log
@Merge OpenBSD rev. 1.108 by sthen@@; original commit message:
Don't display "unable to open mandoc.db" error messages (SQLITE_CANTOPEN)
in the code which opens mandocdb's sqlite database when updating/deleting
individual files (as used and only really useful for pkg_add/pkg_delete).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.148 2014/05/07 16:19:03 schwarze Exp $ */
d436 1
a436 1
		 * All of these deal with a specific directory.
d439 1
a439 1
		if (0 == set_basedir(path_arg))
a527 1
	set_basedir(NULL);
d802 1
a802 3
	if (strstr(buf, basedir) == buf)
		start = buf + strlen(basedir) + 1;
	else if (OP_TEST == op)
d804 2
d831 3
a833 2
		start = strstr(buf, basedir) == buf ?
		    buf + strlen(basedir) + 1 : buf;
d2378 1
d2389 1
a2389 2
			if (NULL != targetdir)
				say("", "&getcwd");
a2396 2
		if (NULL == targetdir)
			targetdir = startdir;
a2406 4
		if (NULL == targetdir) {
			close(fd);
			return(1);
		}
d2418 10
@


1.148
log
@Render roff escape sequences contained in manual page descriptions
before putting them into the mpages table.
Issue found by bentley@@ in OpenBSD::Getopt(3p).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.147 2014/05/07 15:10:36 schwarze Exp $ */
d2233 2
a2234 1
			say(MANDOC_DB, "%s", sqlite3_errstr(rc));
@


1.147
log
@Fix two memory leaks in makewhatis -n:
1. As found by nigel@@, names_check() requires database access.
2. Do not leak names and strings in -n mode.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.146 2014/04/27 23:08:56 schwarze Exp $ */
d2039 5
d2045 1
a2045 1
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->desc);
d2051 4
@


1.146
log
@Improve error handling in dbopen().  If PRAGMA SQL statements fail,
report the error, close the database, and return failure from dbopen(),
such that the main program can recover and rebuild the database.

As noticed by stsp@@, this can happen when database files are
accessible, but corrupt or in the wrong format, which will now
automatically be repaired.

Besides, use a safer idiom after sqlite3_open*() failure that also
handles out-of-memory situations correctly, and do not forget to
close the database after CREATE TABLE failure.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.145 2014/04/25 12:13:15 schwarze Exp $ */
d515 1
a515 1
			if (warnings &&
d1999 12
@


1.145
log
@Reduce the verbosity of makewhatis -t:
In the past, it always showed the title lines of the files processed.
Now, it only shows them when called with -D.
That is better because pkg_create calls makewhatis -t.
It is also more consistent with -D behaviour in non- -t modes.
Issue reported by ajacoutot@@; ok espie@@ ajacoutot@@ jasper@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.144 2014/04/23 21:06:41 schwarze Exp $ */
d2212 1
a2212 1
			say(MANDOC_DB, "%s", sqlite3_errmsg(db));
d2226 1
a2226 1
		say(MANDOC_DB "~", "%s", sqlite3_errmsg(db));
d2242 1
a2242 1
		say("", "%s: %s", tempfilename, sqlite3_errmsg(db));
d2280 1
d2285 9
a2293 1
	SQL_EXEC("PRAGMA foreign_keys = ON");
d2317 8
a2324 2
	if (real)
		SQL_EXEC("PRAGMA synchronous = OFF");
@


1.144
log
@Audit malloc(3)/calloc(3)/realloc(3) usage.
* Change eight reallocs to reallocarray to be safe from overflows.
* Change one malloc to reallocarray to be safe from overflows.
* Change one calloc to reallocarray, no zeroing needed.
* Change the order of arguments of three callocs (aesthetical).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.143 2014/04/23 19:09:16 schwarze Exp $ */
d1999 2
@


1.143
log
@Audit strlcpy(3)/strlcat(3) usage:
* Add missing truncation checks to three calls.
* In four cases where we know that the distination buffer is large enough,
cast the return vailue to (void).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.142 2014/04/23 16:34:50 schwarze Exp $ */
d474 2
a475 2
			dirs.paths = mandoc_calloc(argc,
			    sizeof(char *));
d1787 1
a1787 1
		s = mandoc_calloc(sizeof(struct str) + sz + 1, 1);
d2317 1
a2317 1
	return(mandoc_calloc(sz, 1));
@


1.142
log
@improve SQL style: avoid "SELECT *", be explicit in what columns we want;
suggested by espie@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.141 2014/04/20 16:46:04 schwarze Exp $ */
d666 7
a672 1
			strlcpy(mlink->file, path, sizeof(mlink->file));
d828 4
a831 1
		strlcpy(buf, file, sizeof(buf));
d837 5
a841 1
	strlcpy(mlink->file, start, sizeof(mlink->file));
d989 1
a989 5
		if (strlcpy(buf, mlink->file, PATH_MAX) >= PATH_MAX) {
			if (warnings)
				say(mlink->file, "Filename too long");
			goto nextlink;
		}
d995 1
a995 1
		strlcat(buf, mlink->dsec, PATH_MAX);
d2228 2
a2229 6
	if (strlcpy(tempfilename, "/tmp/mandocdb.XXXXXX",
	    sizeof(tempfilename)) >= sizeof(tempfilename)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "/tmp/mandocdb.XXXXXX: Filename too long");
		return(0);
	}
d2235 2
a2236 7
	if (strlcat(tempfilename, "/" MANDOC_DB,
	    sizeof(tempfilename)) >= sizeof(tempfilename)) {
		exitcode = (int)MANDOCLEVEL_SYSERR;
		say("", "%s/" MANDOC_DB ": Filename too long",
		    tempfilename);
		return(0);
	}
@


1.141
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.140 2014/04/19 02:56:54 schwarze Exp $ */
d1290 2
a1291 1
	    "SELECT * FROM mlinks GROUP BY pageid"
@


1.140
log
@Two minor tweaks regarding the fallback from -u/-d to default mode:
(1) Use all files found on the command line, but do *not* use all stray
files found during fallback tree recursion.
(2) If the fallback works, call that success, i.e. exit(0).
As pointed out by naddy@@, the latter is required for ports' happiness.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.139 2014/04/19 02:30:19 schwarze Exp $ */
d183 3
a185 3
static	int	 	 use_all; /* use all found files */
static	int	  	 debug; /* print what we're doing */
static	int	  	 warnings; /* warn about crap */
d188 1
a188 1
static	enum op	  	 op; /* operational mode */
d323 1
d352 1
a352 1
	 * We accept a few different invocations.  
d367 1
a367 1
		case ('a'):
d370 1
a370 1
		case ('C'):
d375 1
a375 1
		case ('D'):
d378 1
a378 1
		case ('d'):
d383 1
a383 1
		case ('n'):
d386 1
a386 1
		case ('p'):
d389 1
a389 1
		case ('Q'):
d392 1
a392 1
		case ('T'):
d400 1
a400 1
		case ('t'):
d406 1
a406 1
		case ('u'):
d411 1
a411 1
		case ('v'):
d474 2
a475 2
			dirs.paths = mandoc_calloc
				(argc, sizeof(char *));
d542 1
a542 1
		       progname, progname, progname, 
d556 1
a556 1
 *   [./]man*[/<arch>]/<name>.<section> 
d596 1
a596 1
		case (FTS_SL):
d619 1
a619 1
		case (FTS_F):
d676 1
a676 1
		case (FTS_D):
d678 1
a678 1
		case (FTS_DP):
d688 1
a688 1
		case (0):
d691 1
a691 1
		case (1):
d712 1
a712 1
			if (NULL != dsec || use_all) 
d719 1
a719 1
		case (2):
d751 1
a751 1
 *   [./]man*[/<arch>]/<name>.<section> 
d988 1
a988 1
				ohash_qlookup(&mlinks, buf)))
d1117 1
a1117 1
			case (-1):
d1124 1
a1124 1
			case (0):
d1339 1
a1339 1
	
d1409 1
a1409 1
		} 
d1473 5
a1477 5
				1 == head->nchild &&
				NULL != (head = (head->child)) &&
				MAN_TEXT == head->type &&
				0 == strcmp(head->string, "NAME") &&
				NULL != body->child) {
d1491 1
a1491 1
			/* 
d1573 1
a1573 1
		case (MDOC_ELEM):
d1575 1
a1575 1
		case (MDOC_BLOCK):
d1577 1
a1577 1
		case (MDOC_HEAD):
d1579 1
a1579 1
		case (MDOC_BODY):
d1581 1
a1581 1
		case (MDOC_TAIL):
d1605 2
a1606 2
			NULL == (n = n->child) || 
			MDOC_TEXT != n->type)
d1649 1
a1649 1
	/* 
d1651 1
a1651 1
	 * First strip away pointer symbol. 
d1653 1
a1653 1
	 * Finally, store the arguments. 
d1870 1
a1870 1
	} 
d1890 1
a1890 1
		case (ASCII_HYPH):
d1894 1
a1894 1
		case ('\t'):
d1896 1
a1896 1
		case (ASCII_NBRSP):
d1900 1
a1900 1
		case (ASCII_BREAK):
d1917 2
a1918 2
		esc = mandoc_escape
			((const char **)&val, &seq, &len);
d2129 1
a2129 1
	case (-1):
d2133 1
a2133 1
	case (0):
d2155 1
a2155 1
	case (-1):
d2159 1
a2159 1
	case (0):
d2190 1
a2190 1
	if (nodb) 
d2210 1
a2210 1
	if (SQLITE_OK == rc) 
d2403 1
a2403 1
		case ('&'):
d2406 1
a2406 1
		case ('\0'):
@


1.139
log
@Properly handle symlinks (hardlinks and .so only files were already ok):
Use the file name of the symlink but the inode number of the file pointed to,
such that we get multiple mlinks records but not multiple mpages records.
Also make sure they do not point outside the tree we are processing.

Issue found by kili@@ in desktop-file-edit(1), thanks!
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.138 2014/04/18 21:55:38 schwarze Exp $ */
a432 4
		/* 
		 * Force processing all files.
		 */
		use_all = 1;
d436 1
a436 2
		 * Jump into that directory then collect files specified
		 * on the command-line.
d440 1
d442 5
d456 1
@


1.138
log
@In update mode, when opening the database fails, probably because it is
missing or corrupt, just rebuild it from scratch.  This also helps when
installing the very first port on a freshly installed machine
and is similar to what espie@@'s classical makewhatis(8) did.

Issue reported by naddy@@ via kili@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.137 2014/04/16 21:36:18 schwarze Exp $ */
d562 1
d574 2
a575 5
	/*
	 * Walk through all components under the directory, using the
	 * logical descent of files.
	 */
	f = fts_open((char * const *)argv, FTS_LOGICAL, NULL);
d587 25
d616 1
a616 1
		if (FTS_F == ff->fts_info) {
d672 7
a678 2
		} else if (FTS_D != ff->fts_info &&
				FTS_DP != ff->fts_info) {
d767 21
d804 18
a821 8
	if (-1 == stat(buf, &st)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "&stat");
		return;
	} else if ( ! (S_IFREG & st.st_mode)) {
		exitcode = (int)MANDOCLEVEL_BADARG;
		say(file, "Not a regular file");
		return;
@


1.137
log
@Rename the mpages.id column to mpages.pageid.  There is no good reason
to call this kid by a different name here than in all other tables.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.136 2014/04/16 18:59:43 schwarze Exp $ */
d445 16
a460 6
		for (i = 0; i < argc; i++)
			filescan(argv[i]);
		if (0 == dbopen(1))
			goto out;
		if (OP_TEST != op)
			dbprune();
d463 1
a463 1
		dbclose(1);
@


1.136
log
@Give the mlinks and keys tables a pageid index,
as suggested by jeremy@@ and espie@@.

The mlinks index speeds up basic apropos(1) searches by around 30%
because it speeds up the final SELECT FROM mlinks query by about 95%.
For large result sets, the overall speedup gets even larger, in the
extreme case of "apropos Nd~." bymore than 90%.
The keys index finally makes the apropos(1) -O option usable: It no longer
incurs relevant extra cost, while in the past it was embarrassingly slow.

This comes at a cost:  Total database build times grow by about 5%,
and each index adds about 10% database size with -Q.  I consider that
acceptable in view of the huge apropos(1) performance gains.
The -Q database for /usr/share/man still remains below 1 MB.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.135 2014/04/13 22:03:04 schwarze Exp $ */
d103 1
a103 1
	int64_t		 recno;   /* id in mpages SQL table */
d1102 1
a1102 1
					if (mpage_dest->recno)
d1895 1
a1895 1
	SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, mlink->mpage->recno);
d1947 1
a1947 1
	mpage->recno = sqlite3_last_insert_rowid(db);
d1964 1
a1964 1
		SQL_BIND_INT64(stmts[STMT_INSERT_NAME], i, mpage->recno);
d1979 1
a1979 1
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, mpage->recno);
d2175 1
a2175 1
	      " \"id\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
d2182 1
a2182 1
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(id) "
d2190 1
a2190 1
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(id) "
d2197 1
a2197 1
	      " \"pageid\" INTEGER NOT NULL REFERENCES mpages(id) "
d2210 1
a2210 1
	sql = "DELETE FROM mpages WHERE id IN "
@


1.135
log
@Unify description handling across all document types (mdoc, man, cat).
Assert that the description is unset right before calling the parse_*
handler, and assign a default if it's still unset right afterwards.
Remove all stray asserts and default assignments found elsewhere.

This fixes SQL_STEP failures for man(7) pages lacking descriptions.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.134 2014/04/13 20:55:45 schwarze Exp $ */
d2185 1
d2199 2
a2200 1
	      ");\n";
@


1.134
log
@better error reporting in case of SQL errors: mention dir and file
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.133 2014/04/10 02:46:21 schwarze Exp $ */
d1157 1
a1160 1
			assert(NULL == mpage->desc);
a1161 3
			if (NULL == mpage->desc)
				mpage->desc = mandoc_strdup(
				    mpage->mlinks->name);
d1166 2
a1303 2
		assert(NULL == mpage->desc);
		mpage->desc = mandoc_strdup(mpage->mlinks->name);
a1341 1
	assert(NULL == mpage->desc);
a1480 1
			assert(NULL == mpage->desc);
@


1.133
log
@Next speed optimization step for the new apropos(1).
Split manual names out of the common "keys" table into their
own "names" table.  This reduces standard apropos(1) search
times (i.e. searching for names and descriptions only) by
typically about 70% for the full /usr/share/man database.
(Yes, that multiplies with the previous optimization step,
so both together have reduced search times by a factor of
more than six.  I'm not done yet, expect more to come.)

Even with the minimal databases built with makewhatis(8) -Q,
this step still reduces search times by 15-20%.  For both cases,
database sizes and build times hardly change (+/-2%).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.132 2014/04/09 21:50:08 schwarze Exp $ */
d58 1
a58 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d62 1
a62 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d66 1
a66 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d70 1
a70 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
d73 1
a73 1
		fprintf(stderr, "%s\n", sqlite3_errmsg(db))
a1207 1
	size_t		 i;
d1223 2
a1224 2
	i = 1;
	SQL_BIND_INT64(stmt, i, NAME_TITLE);
d1959 1
@


1.132
log
@After careful gprof(1)ing of the new apropos(1), move the descriptions
back from the keys table to the mpages table:  I found a good way
to still use them in searches, without complication of the code.

On my notebook, this reduces typical apropos(1) search times by about 40%,
it reduces /usr/share/man database size by 6% in makewhatis(8) -Q mode
and by 2% in standard mode (less overhead storing pointers to mpages),
and it doesn't measurably change database build times (may even be
going down by a percent or so because less data is being copied
around in ohashes).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.131 2014/04/04 18:23:30 schwarze Exp $ */
d129 1
d192 1
d196 1
d969 1
a969 1
	 * parse_cat() doesn't set TYPE_Nm and TYPE_NAME yet.
d980 2
a981 2
	slot = ohash_qlookup(&strings, mlink->name);
	str = ohash_find(&strings, slot);
d983 1
a983 1
	if ( ! (TYPE_NAME & str->mask))
d1027 2
d1154 1
a1154 1
			putkey(mpage, mlink->name, TYPE_Nm);
d1159 1
a1159 1
				putkey(mpage, cp, TYPE_Nm);
d1195 1
d1213 1
a1213 1
	    "SELECT key, pageid FROM keys "
d1216 2
a1217 2
	      "WHERE mlinks.pageid == keys.pageid "
	      "AND mlinks.name == keys.key"
d1225 1
a1225 1
	SQL_BIND_INT64(stmt, i, TYPE_NAME);
d1450 1
a1450 1
				putkey(mpage, start, TYPE_NAME | TYPE_Nm);
d1464 1
a1464 1
				putkey(mpage, start, TYPE_NAME | TYPE_Nm);
d1641 1
a1641 1
		putmdockey(mpage, n->child, TYPE_NAME | TYPE_Nm);
d1643 1
a1643 1
		putmdockey(mpage, n->child, TYPE_Nm);
d1677 1
a1679 1
	uint64_t	 mask;
d1686 15
a1700 8
	if (debug > 1) {
		for (i = 0, mask = 1;
		     i < mansearch_keymax;
		     i++, mask <<= 1)
			if (mask & v)
				break;
		say(mpage->mlinks->file, "Adding key %s=%*s",
		    mansearch_keynames[i], sz, cp);
d1704 2
a1705 2
	slot = ohash_qlookupi(&strings, cp, &end);
	s = ohash_find(&strings, slot);
d1713 1
a1713 1
		ohash_insert(&strings, slot, s);
d1961 15
d2191 7
d2223 3
@


1.131
log
@In -p (picky) mode, warn unless each filename (aka mlink)
appears as a name in the NAME section.
While here, garbage collect two unused variables, both called "match".
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.130 2014/04/04 16:43:16 schwarze Exp $ */
d227 1
a227 1
	{ parse_mdoc_Nd, TYPE_Nd },  /* Nd */
d1157 3
a1159 2
			putkey(mpage, NULL != mpage->desc ?
			    mpage->desc : mpage->mlinks->name, TYPE_Nd);
a1301 1
		putkey(mpage, mpage->mlinks->name, TYPE_Nd);
a1341 1
	putkey(mpage, mpage->desc, TYPE_Nd);
a1481 1
			putkey(mpage, mpage->desc, TYPE_Nd);
d1929 1
a1929 10
		for (key = ohash_first(&strings, &slot); NULL != key;
		     key = ohash_next(&strings, &slot)) {
			if (TYPE_Nd & key->mask) {
				if (NULL == key->rendered)
					render_key(mc, key);
				printf(" - %s", key->rendered);
				break;
			}
		}
		putchar('\n');
d1937 1
d2150 1
d2183 1
a2183 1
		"(form) VALUES (?)";
@


1.130
log
@Warn about missing mlinks.
This is really expensive, more than tripling database build times,
so only do it when the -p (picky) option was given, but none of the
following options were given: -Q (quick), -d, -u, or -t.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.129 2014/04/04 15:55:19 schwarze Exp $ */
d150 1
a150 1
static	int	 mlink_check(struct mpage *, struct mlink *);
d927 1
a927 1
static int
d930 2
a931 3
	int	 match;

	match = 1;
d943 1
a943 2
	    strcasecmp(mpage->sec, mlink->dsec)) {
		match = 0;
a945 1
	}
d960 1
a960 2
	if (strcasecmp(mpage->arch, mlink->arch)) {
		match = 0;
a962 1
	}
d964 12
a975 2
	if (strcasecmp(mpage->title, mlink->name))
		match = 0;
d977 5
a981 1
	return(match);
d1004 1
a1004 1
	int			 match, status;
a1151 9
		if (warnings && !use_all) {
			match = 0;
			for (mlink = mpage->mlinks; mlink;
			     mlink = mlink->next)
				if (mlink_check(mpage, mlink))
					match = 1;
		} else
			match = 1;

d1164 5
@


1.129
log
@Remember which names are in the NAME section.
This helps to find missing MLINKS.
Database build times do not change and database growth is minimal
(1.2% with -Q, 0.7% without -Q in /usr/share/man),
so making this optional would be pointless.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.128 2014/04/04 02:31:07 schwarze Exp $ */
d155 1
d499 3
d1192 36
@


1.128
log
@When the -n or -t flag is given to makewhatis(8),
write names and decriptions to stdout,
in a format similar to apropos(1) output.
Inspired by espie@@'s makewhatis.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.127 2014/04/03 21:45:31 schwarze Exp $ */
d227 1
a227 1
	{ parse_mdoc_Nm, TYPE_Nm },  /* Nm */
d1400 1
a1400 1
				putkey(mpage, start, TYPE_Nm);
d1414 1
a1414 1
				putkey(mpage, start, TYPE_Nm);
d1591 5
a1595 2
	return(SEC_NAME == n->sec ||
	    (SEC_SYNOPSIS == n->sec && MDOC_HEAD == n->type));
@


1.127
log
@Instead of silently doing nothing at all,
warn and return non-zero when the manpath is empty, that is,
when /etc/man.conf is non-existent or unreadable
AND the environment variable MANPATH is unset or empty
AND no directories were given on the command line.

Inspired by the error handling in espie@@'s makewhatis(8),
except that one doesn't know about MANPATH.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.126 2014/04/03 16:27:28 schwarze Exp $ */
d1861 1
a1861 2
	if (debug)
		say(mpage->mlinks->file, "Adding to database");
d1863 30
a1892 1
	if (nodb)
d1894 4
d1905 1
a1905 1
	for (mlink = mpage->mlinks; mlink; mlink = mlink->next)
d1907 2
@


1.126
log
@Rename the -W option to -p (mnemonics: picky, print to stderr):
That letter was already chosen by espie@@ for OpenBSD 2.7,
so avoid being gratuitiously different more than a decade later.
Accept -v for backward compatibility with espie@@'s makewhatis,
even though it does nothing right now.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.125 2014/04/03 15:37:19 schwarze Exp $ */
d465 5
@


1.125
log
@The -v option of mandocdb(8) clashes with the -v option of espie@@'s
makewhatis(8), which traditionally does something different,
so rename it to -D (mnemonics: Debug, Dump, Display).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.124 2014/03/26 21:39:38 schwarze Exp $ */
d360 1
a360 1
	while (-1 != (ch = getopt(argc, argv, "aC:Dd:nQT:tu:W")))
d381 3
d406 2
a407 2
		case ('W'):
			warnings = 1;
d512 4
a515 4
	fprintf(stderr, "usage: %s [-aDnQW] [-C file] [-Tutf8]\n"
			"       %s [-aDnQW] [-Tutf8] dir ...\n"
			"       %s [-DnQW] [-Tutf8] -d dir [file ...]\n"
			"       %s [-DnW] -u dir [file ...]\n"
@


1.124
log
@Without bloating mandoc(1) itself, let mandocdb(8) support files
called manN/X.N.gz and catN/X.0.gz, reading them through a pipe(2)
from gunzip(1) -c.  Asked for by various people in the past.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.123 2014/03/26 20:53:36 schwarze Exp $ */
d182 1
a182 1
static	int	  	 verb; /* print what we're doing */
d360 1
a360 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:nQT:tu:vW")))
d370 3
a402 3
		case ('v'):
			verb++;
			break;
d509 4
a512 4
	fprintf(stderr, "usage: %s [-anQvW] [-C file] [-Tutf8]\n"
			"       %s [-anQvW] [-Tutf8] dir ...\n"
			"       %s [-nQvW] [-Tutf8] -d dir [file ...]\n"
			"       %s [-nvW] -u dir [file ...]\n"
d1626 1
a1626 1
	if (verb > 1) {
d1853 1
a1853 1
	if (verb)
d1899 1
a1899 1
		if (verb)
@


1.123
log
@Improve error reporting.
Simplify combining a custom format string with perror(),
avoiding many manual calls to strerror(errno).
For low-level failures, report attempted function calls.
Do not abuse the say() filename argument for files outside the basedir,
and even less for other text.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.122 2014/03/23 12:44:56 schwarze Exp $ */
d122 1
d155 1
a155 1
static	void	 parse_cat(struct mpage *);
d540 1
a540 1
	int		 dform;
d575 12
a586 2
			} else if (NULL == (fsec =
					strrchr(ff->fts_name, '.'))) {
a596 4
			} else if (0 == strcmp(fsec, "gz")) {
				if (warnings)
					say(path, "Skip gz");
				continue;
d621 1
d975 1
d982 2
a983 1
	int			 match;
d1007 35
d1050 1
a1050 1
			lvl = mparse_readfd(mp, -1, mpage->mlinks->file);
d1090 1
a1090 3
			ohash_delete(&strings);
			mpage = ohash_next(&mpages, &pslot);
			continue;
d1150 1
a1150 1
			parse_cat(mpage);
d1153 18
d1180 1
a1180 1
parse_cat(struct mpage *mpage)
d1186 4
a1189 1
	if (NULL == (stream = fopen(mpage->mlinks->file, "r"))) {
@


1.122
log
@If an .Nd block contains macros, avoid fragmented entries in mandocdb(8),
instead use the .Nd content recursively.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.121 2014/03/23 12:26:58 schwarze Exp $ */
d554 1
a554 1
		say("", NULL);
d708 1
a708 1
		say(file, NULL);
d724 1
a724 1
		say(file, NULL);
d1127 1
a1127 1
			say(mpage->mlinks->file, NULL);
d1884 1
a1884 1
			say(MANDOC_DB, "%s", strerror(errno));
d1892 1
a1892 1
		say("fork cmp", "%s", strerror(errno));
d1897 1
a1897 1
		say("exec cmp", "%s", strerror(errno));
d1904 1
a1904 1
		say("wait cmp", "%s", strerror(errno));
d1907 1
a1907 1
		say("cmp", "Died from a signal");
d1918 1
a1918 1
		say("fork rm", "%s", strerror(errno));
d1922 1
a1922 1
		say("exec rm", "%s", strerror(errno));
d1929 1
a1929 1
		say("wait rm", "%s", strerror(errno));
d1932 2
a1933 2
		say(tempfilename,
		    "Cannot remove temporary directory");
d1982 1
a1982 1
		say("/tmp/mandocdb.XXXXXX", "Filename too long");
d1987 1
a1987 1
		say(tempfilename, "%s", strerror(errno));
d1993 2
a1994 1
		say(tempfilename, "Filename too long");
d2000 1
a2000 1
		say(tempfilename, "%s", sqlite3_errmsg(db));
d2097 1
a2097 1
				say(".", NULL);
d2102 1
a2102 1
			say(startdir, NULL);
d2114 1
a2114 1
			say(startdir, NULL);
d2125 1
a2125 1
		say(targetdir, NULL);
d2129 1
a2129 1
		say("", NULL);
d2139 1
a2146 1
	fputs(": ", stderr);
d2148 24
a2171 1
	if (NULL == format) {
d2173 2
a2174 8
		return;
	}

	va_start(ap, format);
	vfprintf(stderr, format, ap);
	va_end(ap);

	fputc('\n', stderr);
@


1.121
log
@If a man(7) NAME section contains macros, avoid truncated or empty
entries for .Nd in mandocdb(8), instead use the macro content
recursively.  This improves indexing of more than 200 manuals
in Xenocara, i.e. more than 15%, in particular GL and some Xkb.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.120 2014/03/23 12:11:18 schwarze Exp $ */
a1508 1
	size_t		 sz;
d1510 3
a1512 24
	if (MDOC_BODY != n->type)
		return(0);

	/*
	 * Special-case the `Nd' because we need to put the description
	 * into the document table.
	 */

	for (n = n->child; NULL != n; n = n->next) {
		if (MDOC_TEXT == n->type) {
			if (NULL != mpage->desc) {
				sz = strlen(mpage->desc) +
				     strlen(n->string) + 2;
				mpage->desc = mandoc_realloc(
				    mpage->desc, sz);
				strlcat(mpage->desc, " ", sz);
				strlcat(mpage->desc, n->string, sz);
			} else
				mpage->desc = mandoc_strdup(n->string);
		}
		if (NULL != n->child)
			parse_mdoc_Nd(mpage, n);
	}
	return(1);
@


1.120
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.119 2014/03/23 11:25:26 schwarze Exp $ */
d1266 1
a1266 1
	char		*start, *sv, *title;
d1268 1
a1268 1
	size_t		 sz, titlesz;
d1288 1
a1288 5
				NULL != (body = body->child) &&
				MAN_TEXT == body->type) {

			title = NULL;
			titlesz = 0;
d1297 2
a1298 11
			for ( ; NULL != body; body = body->next) {
				if (MAN_TEXT != body->type)
					break;
				if (0 == (sz = strlen(body->string)))
					continue;
				title = mandoc_realloc
					(title, titlesz + sz + 1);
				memcpy(title + titlesz, body->string, sz);
				titlesz += sz + 1;
				title[titlesz - 1] = ' ';
			}
a1301 27
			title = mandoc_realloc(title, titlesz + 1);
			title[titlesz] = '\0';

			/* Skip leading space.  */

			sv = title;
			while (isspace((unsigned char)*sv))
				sv++;

			if (0 == (sz = strlen(sv))) {
				free(title);
				return;
			}

			/* Erase trailing space. */

			start = &sv[sz - 1];
			while (start > sv && isspace((unsigned char)*start))
				*start-- = '\0';

			if (start == sv) {
				free(title);
				return;
			}

			start = sv;

d1310 1
d1341 1
a1341 1
			if (sv == start) {
@


1.119
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.118 2014/03/19 22:33:09 schwarze Exp $ */
d1539 1
a1539 4
	if (-1 == asprintf(&cp, "%s(%s)", n->string, n->next->string)) {
		perror(NULL);
		exit((int)MANDOCLEVEL_SYSERR);
	}
@


1.118
log
@Register pure .so pages as mlinks, not as mpages.
This doesn't affect /usr/share/man, but improves /usr/X11R6/man:
* Eliminates multiple apropos(1) output for such pages.
* Reduces X11R6 database size from 450 kB to 240 kB (-47%).
* Reduces X11R6 database build time from 1.68s to 1.00s (-40%).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.117 2014/03/19 22:20:43 schwarze Exp $ */
d49 1
@


1.117
log
@Without the MPARSE_SO option, if the file contains nothing but a
single .so request, do not read the file pointed to, but instead
let mparse_result() provide the file name pointed to as a return
value.  To be used by makewhatis(8) in the future.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.116 2014/03/19 21:51:20 schwarze Exp $ */
d102 1
d120 1
d139 2
a140 1
static	void	 dbadd(const struct mpage *, struct mchars *);
a356 1
	mparse_options = MPARSE_SO;
d823 1
d966 2
a967 2
	struct mpage		*mpage;
	struct mlink		*mlink;
d970 1
d1006 1
a1006 1
				mparse_result(mp, &mdoc, &man, NULL);
d1009 39
a1047 1
		if (NULL != mdoc) {
d1824 14
d1845 1
a1845 1
dbadd(const struct mpage *mpage, struct mchars *mc)
a1848 1
	int64_t		 recno;
d1861 1
a1861 1
	recno = sqlite3_last_insert_rowid(db);
d1864 2
a1865 9
	for (mlink = mpage->mlinks; mlink; mlink = mlink->next) {
		i = 1;
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->dsec);
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->arch);
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->name);
		SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, recno);
		SQL_STEP(stmts[STMT_INSERT_LINK]);
		sqlite3_reset(stmts[STMT_INSERT_LINK]);
	}
d1875 1
a1875 1
		SQL_BIND_INT64(stmts[STMT_INSERT_KEY], i, recno);
@


1.116
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.115 2014/03/18 16:56:10 schwarze Exp $ */
d1002 1
a1002 1
				mparse_result(mp, &mdoc, &man);
@


1.115
log
@Allow checking that databases are up to date even when you have no write
permission on the databases, as requested by espie@@ quite some time ago.
But make sure to not slow database generation down when you do have write
permission, and to not delay error reporting in -Q mode.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.114 2014/01/22 20:58:39 schwarze Exp $ */
d175 1
a175 1
static	int		 quick; /* abort the parse early */
d354 1
d375 1
a375 1
			quick = 1;
d415 1
a415 2
	mp = mparse_alloc(MPARSE_AUTO, 
		MANDOCLEVEL_FATAL, NULL, NULL, quick);
d1988 1
a1988 1
	if (quick) {
@


1.114
log
@Implement the \: (optional line break) escape sequence,
documented in the Ossanna-Kernighan-Ritter troff manual
and also supported by groff.

Missing feature reported by Steffen Nurpmeso <sdaoden at gmail dot com>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.113 2014/01/19 22:48:16 schwarze Exp $ */
d23 1
d172 1
d1879 2
d1896 28
a1923 1
	if (-1 == rename(MANDOC_DB "~", MANDOC_DB)) {
d1925 24
a1948 1
		say(MANDOC_DB, NULL);
d1963 1
a1963 1
	const char	*file, *sql;
d1969 1
d1971 4
a1974 3
	if (0 == real) {
		file = MANDOC_DB "~";
		if (-1 == remove(file) && ENOENT != errno) {
d1976 1
a1976 1
			say(file, NULL);
d1979 4
a1982 3
		ofl |= SQLITE_OPEN_EXCLUSIVE;
	} else
		file = MANDOC_DB;
d1984 2
a1985 1
	rc = sqlite3_open_v2(file, &db, ofl, NULL);
d1987 2
a1988 2
		goto prepare_statements;
	if (SQLITE_CANTOPEN != rc) {
d1990 1
a1990 1
		say(file, NULL);
d1994 19
a2012 4
	sqlite3_close(db);
	db = NULL;

	if (SQLITE_OK != (rc = sqlite3_open(file, &db))) {
d2014 1
a2014 1
		say(file, NULL);
d2018 1
d2041 1
a2041 1
		say(file, "%s", sqlite3_errmsg(db));
@


1.113
log
@Avoid the risk of trying to modify a literal string.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.112 2014/01/19 22:41:25 schwarze Exp $ */
d1667 1
a1667 1
	char		 utfbuf[7], res[5];
d1679 2
a1680 1
	res[4] = '\0';
d1711 2
a1712 1
		if (ASCII_HYPH == *val) {
d1716 3
a1718 1
		} else if ('\t' == *val || ASCII_NBRSP == *val) {
d1721 2
d1724 4
a1727 1
		} else if ('\\' != *val)
@


1.112
log
@Always store the arch in lower-case only.
Reduces database size by ~0.5%, and by ~1.5% with -Q.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.111 2014/01/19 00:09:38 schwarze Exp $ */
d959 1
d1031 1
a1031 1
		    "any" : mpage->arch, TYPE_arch);
d1039 1
a1039 1
			    "any" : mlink->arch, TYPE_arch);
@


1.111
log
@Support a second -v on mandocdb(8) to show keys while they are being added;
i need that for debugging, in particular to be used with -t.
To be able to do so, provide a global table of key names, for reuse.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.110 2014/01/18 08:55:17 schwarze Exp $ */
d160 1
a160 2
static	void	 putkey(const struct mpage *,
			const char *, uint64_t);
d964 1
a964 1
	const char		*cp;
d1188 1
a1188 1
putkey(const struct mpage *mpage, const char *value, uint64_t type)
d1190 1
d1193 4
d1450 1
a1450 1
	const char	*cp;
@


1.110
log
@Cope with slightly broken NAME sections in man(7) pages
having a trailing comma after the last name, like this:

ASN1_OBJECT_new, ASN1_OBJECT_free, - object allocation functions
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.109 2014/01/18 08:21:03 schwarze Exp $ */
d51 3
d1568 2
d1571 1
a1571 1
	const char	*end;
d1576 10
@


1.109
log
@Drop the AUTOINCREMENT PRIMARY KEYs from the mlinks and keys tables.
They are completely unused, and i cannot imagine what they *could*
ever be used for; but apparently, they are expensive to generate.

Standard DB build time goes down by 10%, now at 1.9x of makewhatis.
Standard DB size goes down by 4%, now at 11x of makewhatis.
DB build time with -Q goes down by 15%, now at 0.28x of makewhatis.
DB size with -Q goes down by 3%, now at 3.35x of makewhatis.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.108 2014/01/18 08:19:18 schwarze Exp $ */
d1305 9
@


1.108
log
@Despite some experimenting, i'm unable to find any relevant effect of
creating an index for the keys table on apropos(1) search times;
apparently, adding that index was premature optimization in the first
place; so, stop adding that index.

Its root gone, the following evil is reduced (/usr/share/man on my notebook)
 - DB build time with -Q goes down by 15%, now at 1/3 of makewhatis
 - DB size with -Q goes down by 35%, now at 3.5x of makewhatis
 - full DB build time goes down by 12%, now at 2.1x of makewhatis
 - full DB size goes down by 42%, now at 11.5x of makewhatis
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.107 2014/01/06 20:53:40 schwarze Exp $ */
d1917 1
a1917 2
		"ON DELETE CASCADE,\n"
	      " \"id\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
d1924 1
a1924 2
		"ON DELETE CASCADE,\n"
	      " \"id\" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL\n"
@


1.107
log
@Do not sync to disk after each individual manual page (duh!),
only sync to disk one single time when all data is ready.

Rebuild times for /usr/share/man/mandoc.db shrink on my notebook:
In standard mode from 45 seconds to 11 seconds   (75% reduction)
In -Q mode       from 25 seconds to 3.1 seconds  (87% reduction)
For comparison: makewhatis(8):      4.2 seconds

That is, in -Q mode, we are now *faster* than the existing makewhatis(8),
and careful profiling shows there is still a lot of room for improval.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.106 2014/01/06 15:32:47 schwarze Exp $ */
d1927 1
a1927 3
	      ");\n"
	      "\n"
	      "CREATE INDEX \"key_index\" ON keys (key);\n";
@


1.106
log
@Fix mandocdb(8) -d and -u.
It was broken by recent optimizations.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.105 2014/01/06 13:54:17 schwarze Exp $ */
d972 3
d1065 3
a1762 2
	SQL_EXEC("BEGIN TRANSACTION");

a1793 2

	SQL_EXEC("END TRANSACTION");
@


1.105
log
@Rename dbindex() to dbadd() to be less confusing.
The concept of an index file is gone since the switch to SQLite.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.104 2014/01/06 03:52:13 schwarze Exp $ */
d703 7
a709 1
	} else if (OP_TEST != op && strstr(buf, basedir) != buf) {
d713 3
a715 1
	} else if (-1 == stat(buf, &st)) {
d724 1
a724 1
	start = buf + strlen(basedir);
d1802 2
a1803 2
	if (nodb)
		return;
d1805 2
a1806 2
	mpage = ohash_first(&mpages, &slot);
	while (NULL != mpage) {
a1807 4
		i = 1;
		SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE], i, mlink->file);
		SQL_STEP(stmts[STMT_DELETE_PAGE]);
		sqlite3_reset(stmts[STMT_DELETE_PAGE]);
d1809 14
a1822 2
			say(mlink->file, "Deleted from database");
		mpage = ohash_next(&mpages, &slot);
d1824 3
d1937 3
a1939 1
	sql = "DELETE FROM mpages where file=?";
@


1.104
log
@Remove the redundant "file" column from the "mlinks" table.
The contents can easily be reconstructed from sec, arch, name, form.
Shrinks the database by another 3% in standard mode and 9% in -Q mode.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.103 2014/01/06 03:02:46 schwarze Exp $ */
d133 1
a133 1
static	void	 dbindex(const struct mpage *, struct mchars *);
d1050 1
a1050 1
		dbindex(mpage, mc);
d1735 1
a1735 1
dbindex(const struct mpage *mpage, struct mchars *mc)
d1744 1
a1744 1
		say(mpage->mlinks->file, "Adding to index");
d1805 1
a1805 1
			say(mlink->file, "Deleted from index");
@


1.103
log
@Drop Nd from the mpages table, it is still in the keys table.
This shrinks the database in standard mode by 3%, in -Q mode by 9%,
without loss of functionality.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.102 2014/01/05 20:26:36 schwarze Exp $ */
a1758 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->file);
a1891 1
	      " \"file\" TEXT NOT NULL,\n"
d1924 1
a1924 1
		"(file,sec,arch,name,pageid) VALUES (?,?,?,?,?)";
@


1.102
log
@Add an option -Q (quick) to mandocdb(8)
for accelerated generation of reduced-size databases.

Implement this by allowing the parsers to optionally
abort the parse sequence after the NAME section.

While here, garbage collect the unused void *arg attribute of
struct mparse and mparse_alloc() and fix some errors in mandoc(3).

This reduces the processing time of mandocdb(8) on /usr/share/man
by a factor of 2 and the database size by a factor of 4.
However, it still takes 5 times the time and 6 times the space
of makewhatis(8), so more work is clearly needed.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.101 2014/01/05 04:48:40 schwarze Exp $ */
a1738 1
	const char	*desc;
a1748 10
	desc = "";
	if (NULL != mpage->desc && '\0' != *mpage->desc) {
		key = ohash_find(&strings,
			ohash_qlookup(&strings, mpage->desc));
		assert(NULL != key);
		if (NULL == key->rendered)
			render_key(mc, key);
		desc = key->rendered;
	}

a1751 1
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, desc);
a1887 1
	      " \"desc\" TEXT NOT NULL,\n"
d1923 1
a1923 1
		"(desc,form) VALUES (?,?)";
@


1.101
log
@Rip out the complete "reachable" checks, without replacement.
It's a pity i spent time during t2k13 writing this; however,
when an entire concept is busted, let us not look back,

There is no such thing as an unreachable page.  Even if you are crazy
enough to put a page starting with ".Dt NAMEI 9" into a file man1/cat.1,
we now make sure that it can be found by all of the following:
Nm=namei Nm=cat sec=1 sec=9
It will always be displayed as:
cat(1) - pathname lookup
So you know that you have to type `man cat` to get at it.
That obsoletes the concept of "unreachable manuals" for good.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.100 2014/01/05 04:13:52 schwarze Exp $ */
d170 2
a172 1
static	int		 nodb; /* no database changes */
d351 1
a351 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:nT:tu:vW")))
d369 3
d411 1
a411 1
		MANDOCLEVEL_FATAL, NULL, NULL, NULL);
d501 3
a503 3
	fprintf(stderr, "usage: %s [-anvW] [-C file] [-Tutf8]\n"
			"       %s [-anvW] [-Tutf8] dir ...\n"
			"       %s [-nvW] [-Tutf8] -d dir [file ...]\n"
d505 1
a505 1
			"       %s -t file ...\n",
@


1.100
log
@Remove the obsolete file name column from the mpages table.
This column wasn't helpful because one manpage can have multiple MLINKS.
Use the file name column in the mlinks table, instead.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.99 2014/01/05 03:25:51 schwarze Exp $ */
a116 5
struct	title {
	char		*title; /* name(sec/arch) given inside the file */
	char		*file; /* file name in case of mismatch */
};

d145 1
a145 1
static	void	 mpages_merge(struct mchars *, struct mparse *, int);
d433 1
a433 1
			mpages_merge(mc, mp, 0);
d477 1
a477 1
			mpages_merge(mc, mp, warnings && !use_all);
d943 1
a943 1
mpages_merge(struct mchars *mc, struct mparse *mp, int check_reachable)
d945 1
a945 2
	struct ohash		 title_table;
	struct ohash_info	 title_info, str_info;
a949 2
	struct title		*title_entry;
	char			*title_str;
d952 1
a952 1
	unsigned int		 pslot, tslot;
a959 8
	if (check_reachable) {
		title_info.alloc = hash_alloc;
		title_info.halloc = hash_halloc;
		title_info.hfree = hash_free;
		title_info.key_offset = offsetof(struct title, title);
		ohash_init(&title_table, 6, &title_info);
	}

a1045 31
		/*
		 * Build a title string for the file.  If it matches
		 * the location of the file, remember the title as
		 * found; else, remember it as missing.
		 */

		if (check_reachable) {
			if (-1 == asprintf(&title_str, "%s(%s%s%s)",
			    mpage->title, mpage->sec,
			    '\0' == *mpage->arch ? "" : "/",
			    mpage->arch)) {
				perror(NULL);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			tslot = ohash_qlookup(&title_table, title_str);
			title_entry = ohash_find(&title_table, tslot);
			if (NULL == title_entry) {
				title_entry = mandoc_malloc(
						sizeof(struct title));
				title_entry->title = title_str;
				title_entry->file = mandoc_strdup(
				    match ? "" : mpage->mlinks->file);
				ohash_insert(&title_table, tslot,
						title_entry);
			} else {
				if (match)
					*title_entry->file = '\0';
				free(title_str);
			}
		}

a1049 15

	if (check_reachable) {
		title_entry = ohash_first(&title_table, &tslot);
		while (NULL != title_entry) {
			if ('\0' != *title_entry->file)
				say(title_entry->file,
			    	    "Probably unreachable, title is %s",
				    title_entry->title);
			free(title_entry->title);
			free(title_entry->file);
			free(title_entry);
			title_entry = ohash_next(&title_table, &tslot);
		}
		ohash_delete(&title_table);
	}
@


1.99
log
@Remove the obsolete sec and arch columns from the mpages table.
They were confusing because a manpage can have MLINKS in different
sections and architectures.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.98 2014/01/05 03:06:43 schwarze Exp $ */
a1820 6
	/*
	 * XXX The following line is obsolete
	 * and only kept for backward compatibility
	 * until apropos(1) and friends have caught up.
	 */
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->mlinks->file);
a1956 5
	/*
	 * XXX The first column in table mpages is obsolete
	 * and only kept for backward compatibility
	 * until apropos(1) and friends have caught up.
	 */
a1957 1
	      " \"file\" TEXT NOT NULL,\n"
d1994 1
a1994 1
		"(file,desc,form) VALUES (?,?,?)";
@


1.98
log
@Reimplement apropos -s NUM -S ARCH EXPR by internally converting it to
apropos \( EXPR \) -a 'sec~^NUM$' -a 'arch~^(ARCH|any)$'
in preparation for removal of sec and arch from the mpage table.

Almost no functional change except for the following bonus:
This also makes sure that for cross-section and cross-arch MLINKs,
all of the following work:
apropos -s 1 encrypt
apropos -s 8 encrypt
apropos -s 1 makekey
apropos -s 8 makekey

While here, print error messages about invalid regexps to stderr.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.97 2014/01/05 00:29:54 schwarze Exp $ */
d1822 1
a1822 1
	 * XXX The following three lines are obsolete
a1826 2
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->mlinks->dsec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->mlinks->arch);
d1964 1
a1964 1
	 * XXX The first three columns in table mpages are obsolete
a1969 2
	      " \"sec\" TEXT NOT NULL,\n"
	      " \"arch\" TEXT NOT NULL,\n"
d2006 1
a2006 1
		"(file,sec,arch,desc,form) VALUES (?,?,?,?,?)";
@


1.97
log
@Put section and architecture info into the keys table,
in preparation for removing them from the mpages table,
aiming for cleaner and more uniform interfaces.
Database growth is below 4%, part of which will be reclaimed.

As a bonus, this allows searches like:
./obj/apropos An=kettenis -a arch=ppc
./obj/apropos An=kettenis -a sec~[^4]
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.96 2014/01/02 22:44:10 schwarze Exp $ */
d1028 2
a1029 1
		putkey(mpage, mpage->arch, TYPE_arch);
d1036 2
a1037 1
			putkey(mpage, mlink->arch, TYPE_arch);
@


1.96
log
@Avoid "utf8" in the names of a function and a struct member
that don't necessarily have anything to do with UTF-8.
Just renaming, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.95 2014/01/02 22:19:41 schwarze Exp $ */
d1027 2
d1030 6
a1035 1
		for (mlink = mpage->mlinks; mlink; mlink = mlink->next)
d1037 1
@


1.95
log
@Do not put UTF-8-encoded strings into the database by default, use ASCII.
Just like for mandoc(1), provide a -Tutf8 option for people who want that.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.94 2014/01/02 20:24:39 schwarze Exp $ */
d85 1
a85 1
	char		*utf8; /* key in UTF-8 form */
d88 1
a88 1
	char		 key[]; /* the string itself */
d168 1
a172 1
static	void	 utf8key(struct mchars *, struct str *);
d1665 2
a1666 2
 * Store the UTF-8 version of a key, or alias the pointer if the key has
 * no UTF-8 transcription marks in it.
d1669 1
a1669 1
utf8key(struct mchars *mc, struct str *key)
d1678 1
a1678 1
	assert(NULL == key->utf8);
d1694 1
a1694 1
		key->utf8 = key->key;
d1773 1
a1773 1
	key->utf8 = buf;
d1780 1
a1780 1
 * Also, UTF-8-encode the description at the last possible moment.
d1803 3
a1805 3
		if (NULL == key->utf8)
			utf8key(mc, key);
		desc = key->utf8;
d1839 2
a1840 2
		if (NULL == key->utf8)
			utf8key(mc, key);
d1843 1
a1843 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_KEY], i, key->utf8);
d1847 2
a1848 2
		if (key->utf8 != key->key)
			free(key->utf8);
@


1.94
log
@Polish the mlink_add() interface:
Allocate memory inside, not in the callers.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.93 2014/01/02 18:52:15 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d179 1
d355 1
a355 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:ntu:vW")))
d373 8
d502 3
a504 3
	fprintf(stderr, "usage: %s [-anvW] [-C file]\n"
			"       %s [-anvW] dir ...\n"
			"       %s [-nvW] -d dir [file ...]\n"
d1734 1
a1738 1

a1740 2
		if (0 == (u = mchars_spec2cp(mc, seq, len)))
			continue;
d1743 2
a1744 2
		 * If we have a Unicode codepoint, try to convert that
		 * to a UTF-8 byte string.
d1746 17
a1762 3
		cpp = utfbuf;
		if (0 == (sz = utf8(u, utfbuf)))
			continue;
a1765 1
		sz = strlen(cpp);
a1766 1

a1767 1

@


1.93
log
@Check all MLINKS for consistency with the content of the manual page,
not just the first one.  This doesn't change how the check is done,
but just which MLINKS are checked.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.92 2013/12/31 19:40:20 schwarze Exp $ */
d525 2
a526 2
	char		*fsec;
	const char	*dsec, *arch, *cp, *path;
d591 1
d595 4
a598 7
			if (NULL != dsec)
				mlink->dsec = mandoc_strdup(dsec);
			if (NULL != arch)
				mlink->arch = mandoc_strdup(arch);
			mlink->name = mandoc_strdup(ff->fts_name);
			if (NULL != fsec)
				mlink->fsec = mandoc_strdup(fsec);
a617 2
			dsec = NULL;
			dform = FORM_NONE;
d628 3
a644 1
			arch = NULL;
d647 2
d722 1
a722 1
			mlink->dsec = mandoc_strdup(start + 3);
d725 1
a725 1
			mlink->dsec = mandoc_strdup(start + 3);
d731 1
a731 1
			mlink->arch = mandoc_strdup(start);
d746 1
a746 1
		mlink->fsec = mandoc_strdup(p);
a757 2
	mlink->name = mandoc_strdup(mlink->name);

d770 4
a773 8
	if (NULL == mlink->dsec)
		mlink->dsec = mandoc_strdup("");
	if (NULL == mlink->arch)
		mlink->arch = mandoc_strdup("");
	if (NULL == mlink->name)
		mlink->name = mandoc_strdup("");
	if (NULL == mlink->fsec)
		mlink->fsec = mandoc_strdup("");
@


1.92
log
@Yet another regression introduced by Kristaps when he switched from
Berkeley DB to SQLite3: In the .In parser, the logic got inverted.
The resulting NULL pointer access was found by clang;
scan log provided by Ulrich Spoerlein <uqs at FreeBSD>.

The best fix is to simply remove the whole, pointless custom
handler function for .In and let the framework do its work.
Now searching for included header files actually works.

While here, remove the similarly pointless custom .St handler,
fix the return value of the .Fd handler and disentangle the
spaghetti in the .Nm handler.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.91 2013/12/31 18:07:42 schwarze Exp $ */
d146 1
d889 48
d950 1
a984 1
		match = 1;
d1025 2
a1026 16
		/*
		 * Check whether the manual section given in a file
		 * agrees with the directory where the file is located.
		 * Some manuals have suffixes like (3p) on their
		 * section number either inside the file or in the
		 * directory name, some are linked into more than one
		 * section, like encrypt(1) = makekey(8).  Do not skip
		 * manuals for such reasons.
		 */
		if (warnings && !use_all && FORM_SRC == mpage->form &&
		    strcasecmp(mpage->sec, mpage->mlinks->dsec)) {
			match = 0;
			say(mpage->mlinks->file, "Section \"%s\" "
				"manual in %s directory",
				mpage->sec, mpage->mlinks->dsec);
		}
d1028 1
a1028 16
		/*
		 * Manual page directories exist for each kernel
		 * architecture as returned by machine(1).
		 * However, many manuals only depend on the
		 * application architecture as returned by arch(1).
		 * For example, some (2/ARM) manuals are shared
		 * across the "armish" and "zaurus" kernel
		 * architectures.
		 * A few manuals are even shared across completely
		 * different architectures, for example fdformat(1)
		 * on amd64, i386, sparc, and sparc64.
		 * Thus, warn about architecture mismatches,
		 * but don't skip manuals for this reason.
		 */
		if (warnings && !use_all &&
		    strcasecmp(mpage->arch, mpage->mlinks->arch)) {
d1030 6
a1035 9
			say(mpage->mlinks->file, "Architecture \"%s\" "
				"manual in \"%s\" directory",
				mpage->arch, mpage->mlinks->arch);
		}
		if (warnings && !use_all &&
		    strcasecmp(mpage->title, mpage->mlinks->name))
			match = 0;

		putkey(mpage, mpage->mlinks->name, TYPE_Nm);
@


1.91
log
@remove assignments that will be overwritten right afterwards,
and remove pointless local variables;
found in a clang output from Ulrich Spoerlein <uqs at FreeBSD>
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.90 2013/12/27 23:41:55 schwarze Exp $ */
a156 1
static	int	 parse_mdoc_In(struct mpage *, const struct mdoc_node *);
a159 1
static	int	 parse_mdoc_St(struct mpage *, const struct mdoc_node *);
d217 1
a217 1
	{ parse_mdoc_In, TYPE_In },  /* In */
d225 1
a225 1
	{ parse_mdoc_St, 0 },  /* St */
d1442 1
a1442 12
	return(1);
}

static int
parse_mdoc_In(struct mpage *mpage, const struct mdoc_node *n)
{

	if (NULL != n->child && MDOC_TEXT == n->child->type)
		return(0);

	putkey(mpage, n->child->string, TYPE_In);
	return(1);
a1478 11
parse_mdoc_St(struct mpage *mpage, const struct mdoc_node *n)
{

	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return(0);

	putkey(mpage, n->child->string, TYPE_St);
	return(1);
}

static int
d1535 2
a1536 6
	if (SEC_NAME == n->sec)
		return(1);
	else if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return(0);

	return(1);
@


1.90
log
@Oops, that segfaulted after deleting an mlink from the list.
Fix the loop logic in mlinks_undupe().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.89 2013/12/27 20:35:51 schwarze Exp $ */
a1736 1
		u = 0;
@


1.89
log
@Split mlinks_undupe() out of mpages_merge()
such that the check for source manuals of the same name
can be done for multiple mlinks pointing to the same preformatted mpage.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.88 2013/12/27 18:42:25 schwarze Exp $ */
d858 2
a859 2
	for(prev = &mpage->mlinks; *prev; prev = &(*prev)->next) {
		mlink = *prev;
d862 1
a862 1
			continue;
d867 1
a867 1
			continue;
d877 1
a877 1
			continue;
d881 1
a881 1
			continue;
d884 3
a886 1
		mlink = *prev;
@


1.88
log
@Save the MLINK name into the database, too;
apropos(1) will need it to display its results.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.87 2013/12/27 16:40:35 schwarze Exp $ */
d147 1
a551 1
		 * Disallow duplicate (hard-linked) files.
d666 1
a666 1
 * Add a file to the file vector.
a676 1
 * Stuff this information directly into the mlink vector.
d844 45
a899 1
	char			 buf[PATH_MAX];
d904 1
a904 1
	char			*bufp, *title_str;
a905 1
	size_t			 sz;
d925 4
a928 30
		/*
		 * If we're a catpage (as defined by our path), then see
		 * if a manpage exists by the same name (ignoring the
		 * suffix).
		 * If it does, then we want to use it instead of our
		 * own.
		 */
		if ( ! use_all && FORM_CAT == mpage->mlinks->dform) {
			sz = strlcpy(buf, mpage->mlinks->file, PATH_MAX);
			if (sz >= PATH_MAX) {
				if (warnings)
					say(mpage->mlinks->file,
					    "Filename too long");
				mpage = ohash_next(&mpages, &pslot);
				continue;
			}
			bufp = strstr(buf, "cat");
			assert(NULL != bufp);
			memcpy(bufp, "man", 3);
			if (NULL != (bufp = strrchr(buf, '.')))
				*++bufp = '\0';
			strlcat(buf, mpage->mlinks->dsec, PATH_MAX);
			if (NULL != ohash_find(&mlinks,
					ohash_qlookup(&mlinks, buf))) {
				if (warnings)
					say(mpage->mlinks->file, "Man "
					    "source exists: %s", buf);
				mpage = ohash_next(&mpages, &pslot);
				continue;
			}
@


1.87
log
@Write more than one mlink per mpage to the database.
Not yet used by apropos(1).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.86 2013/12/27 16:17:32 schwarze Exp $ */
d1809 1
d1812 1
a1812 1
		SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mlink->file);
d1952 1
d1985 1
a1985 1
		"(sec,arch,name,pageid) VALUES (?,?,?,?)";
@


1.86
log
@Allow saving more than one mlink per mpage in the mlinks ohash.
We are still only using one of them for now.
Actually, we are now using a different one,
but the order the mlinks are found is random anyway.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.85 2013/12/27 15:48:09 schwarze Exp $ */
d1767 1
d1807 9
a1815 7
	i = 1;
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mpage->mlinks->dsec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mpage->mlinks->arch);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mpage->mlinks->file);
	SQL_BIND_INT64(stmts[STMT_INSERT_LINK], i, recno);
	SQL_STEP(stmts[STMT_INSERT_LINK]);
	sqlite3_reset(stmts[STMT_INSERT_LINK]);
@


1.85
log
@Enable the framework code to allow more than one mlink per mpage.
Not used yet.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.84 2013/12/27 15:39:03 schwarze Exp $ */
a144 1
static	int	 inocheck(const struct stat *);
a559 4
			} else if (inocheck(ff->fts_statp)) {
				if (warnings)
					say(path, "Duplicate file");
				continue;
a708 4
	} else if (inocheck(&st)) {
		if (warnings)
			say(file, "Duplicate file");
		return;
a764 14
static int
inocheck(const struct stat *st)
{
	struct inodev	 inodev;
	uint32_t	 hash;

	memset(&inodev, 0, sizeof(inodev));
	inodev.st_ino = hash = st->st_ino;
	inodev.st_dev = st->st_dev;

	return(NULL != ohash_find(&mpages, ohash_lookup_memory(
			&mpages, (char *)&inodev, sizeof(inodev), hash)));
}

@


1.84
log
@Clean up the interface of mlink_add().
Consistently use "fsec" and "fform" for info derived from the file name.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.83 2013/12/27 14:29:28 schwarze Exp $ */
d114 1
d830 1
a830 1
		abort();
d855 1
a855 1
			mpage->mlinks = NULL;
@


1.83
log
@Another step on the way to clear naming, this time regarding mlinks:
* rename global ohash filenames to mlinks
* rename ofadd() to mlink_add()
* fold fileadd() and inoadd() into mlink_add()
* fold filecheck() into mpages_merge()
Still no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.82 2013/12/27 03:06:17 schwarze Exp $ */
d79 3
a81 3
	FORM_SRC, /* format is -man or -mdoc */
	FORM_CAT, /* format is cat */
	FORM_NONE /* format is unknown */
d109 1
a109 1
	enum form	 sform;   /* format from file name suffix */
d145 1
a145 2
static	void	 mlink_add(int, const char *, const char *, const char *,
			const char *, const char *, const struct stat *);
d523 1
d525 1
a525 1
	char		*sec;
d564 1
a564 1
			} else if (NULL == (sec =
d572 1
a572 1
			} else if (0 == strcmp(++sec, "html")) {
d576 1
a576 1
			} else if (0 == strcmp(sec, "gz")) {
d580 1
a580 1
			} else if (0 == strcmp(sec, "ps")) {
d584 1
a584 1
			} else if (0 == strcmp(sec, "pdf")) {
d589 2
a590 2
			    ((FORM_SRC == dform && strcmp(sec, dsec)) ||
			     (FORM_CAT == dform && strcmp(sec, "0")))) {
d595 12
a606 3
				sec[-1] = '\0';
			mlink_add(dform, path, ff->fts_name, dsec, sec,
					arch, ff->fts_statp);
d608 1
a608 1
		} else if (FTS_D != ff->fts_info && 
d688 2
a689 1
	const char	*sec, *arch, *name, *dsec;
a690 2
	int		 dform;
	struct stat	 st;
d719 2
a720 2
	sec = arch = name = dsec = NULL;
	dform = FORM_NONE;
d731 2
a732 2
			dform = FORM_SRC;
			dsec = start + 3;
d734 2
a735 2
			dform = FORM_CAT;
			dsec = start + 3;
d739 1
a739 1
		if (NULL != dsec && NULL != (p = strchr(start, '/'))) {
d741 1
a741 1
			arch = start;
d743 1
a743 1
		} 
d756 1
a756 1
		sec = p;
d763 1
a763 1
	name = start;
d765 1
a765 1
		name = p + 1;
d767 2
a768 1
	} 
d770 1
a770 1
	mlink_add(dform, file, name, dsec, sec, arch, &st);
d788 1
a788 2
mlink_add(int dform, const char *file, const char *name, const char *dsec,
	const char *sec, const char *arch, const struct stat *st)
a791 2
	struct mlink	*mlink;
	int		 sform;
d794 1
a794 1
	assert(NULL != file);
d796 15
a810 14
	if (NULL == name)
		name = "";
	if (NULL == sec)
		sec = "";
	if (NULL == dsec)
		dsec = "";
	if (NULL == arch)
		arch = "";

	if ('0' == *sec) {
		sec = dsec;
		sform = FORM_CAT;
	} else if ('1' <= *sec && '9' >= *sec)
		sform = FORM_SRC;
d812 1
a812 10
		sform = FORM_NONE;

	mlink = mandoc_calloc(1, sizeof(struct mlink));
	strlcpy(mlink->file, file, PATH_MAX);
	mlink->dform = dform;
	mlink->sform = sform;
	mlink->dsec = mandoc_strdup(dsec);
	mlink->arch = mandoc_strdup(arch);
	mlink->name = mandoc_strdup(name);
	mlink->fsec = mandoc_strdup(sec);
d949 1
a949 1
		    FORM_CAT != mpage->mlinks->sform) {
d960 2
a961 3
			if (NULL == mpage->arch)
				mpage->arch = "";
			mpage->arch = mandoc_strdup(mpage->arch);
@


1.82
log
@Split struct mlink out of struct mpage.
Still a 1:1 relation, no functional change yet.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.81 2013/12/27 01:16:54 schwarze Exp $ */
a139 2
static	void	 fileadd(struct mlink *);
static	int	 filecheck(const char *);
a143 1
static	void	 inoadd(const struct stat *, struct mpage *);
d145 1
a145 1
static	void	 ofadd(int, const char *, const char *, const char *,
d184 1
a184 1
static	struct ohash	 filenames; /* table of filenames */
d323 1
a323 1
	struct ohash_info mpages_info, filename_info;
d328 3
a330 3
	mpages_info.alloc  = filename_info.alloc  = hash_alloc;
	mpages_info.halloc = filename_info.halloc = hash_halloc;
	mpages_info.hfree  = filename_info.hfree  = hash_free;
d333 1
a333 1
	filename_info.key_offset = offsetof(struct mlink, file);
d408 1
a408 1
	ohash_init(&filenames, 6, &filename_info);
d462 1
a462 1
				ohash_init(&filenames, 6, &filename_info);
d480 1
a480 1
				ohash_delete(&filenames);
d491 1
a491 1
	ohash_delete(&filenames);
d549 1
a549 1
		 * If we're a regular file, add an mpage by using the
d596 1
a596 1
			ofadd(dform, path, ff->fts_name, dsec, sec,
d672 1
a672 1
 * Stuff this information directly into the mpage vector.
d761 1
a761 1
	ofadd(dform, file, name, dsec, sec, arch, &st);
a763 28
/*
 * See fileadd(). 
 */
static int
filecheck(const char *name)
{

	return(NULL != ohash_find(&filenames,
			ohash_qlookup(&filenames, name)));
}

/*
 * Use the standard hashing mechanism (K&R) to see if the given filename
 * already exists.
 */
static void
fileadd(struct mlink *mlink)
{
	unsigned int	 slot;

	slot = ohash_qlookup(&filenames, mlink->file);
	assert(NULL == ohash_find(&filenames, slot));
	ohash_insert(&filenames, slot, mlink);
}

/*
 * See inoadd().
 */
a777 19
/*
 * The hashing function used here is quite simple: simply take the inode
 * and use uint32_t of its bits.
 * Then when we do the lookup, use both the inode and device identifier.
 */
static void
inoadd(const struct stat *st, struct mpage *mpage)
{
	unsigned int	 slot;

	mpage->inodev.st_ino = st->st_ino;
	mpage->inodev.st_dev = st->st_dev;
	slot = ohash_lookup_memory(&mpages, (char *)&mpage->inodev,
	    sizeof(struct inodev), st->st_ino);

	assert(NULL == ohash_find(&mpages, slot));
	ohash_insert(&mpages, slot, mpage);
}

d779 1
a779 1
ofadd(int dform, const char *file, const char *name, const char *dsec,
d782 1
d786 1
d816 16
a831 1
	mpage = mandoc_calloc(1, sizeof(struct mpage));
a832 8

	/*
	 * Add to unique identifier hash.
	 * Then if it's a source manual and we're going to use source in
	 * favour of catpages, add it to that hash.
	 */
	inoadd(st, mpage);
	fileadd(mpage->mlinks);
d929 2
a930 1
			if (filecheck(buf)) {
@


1.81
log
@Add an additional mlinks table to the database, redundant for now,
both because it contains nothing but a subset of the data of the
existing mpages table and because the relationship of mpage and mlink
entries is still 1:1.  But all that will eventually change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.80 2013/12/26 23:35:59 schwarze Exp $ */
d98 9
a106 2
	enum form	 dform; /* path-cued form */
	enum form	 sform; /* suffix-cued form */
d108 6
a113 5
	char		*desc; /* parsed description */
	char		*name; /* name (from filename) (not empty) */
	char		*sec; /* suffix-cued section (or empty) */
	char		*dsec; /* path-cued section (or empty) */
	char		*arch; /* path-cued arch. (or empty) */
d137 1
a137 1
static	void	 dbindex(struct mchars *, int, const struct mpage *);
d140 1
a140 1
static	void	 fileadd(struct mpage *);
d150 1
d336 1
a336 1
	filename_info.key_offset = offsetof(struct mpage, file);
d783 1
a783 1
fileadd(struct mpage *mpage)
d787 1
a787 1
	slot = ohash_qlookup(&filenames, mpage->file);
d789 1
a789 1
	ohash_insert(&filenames, slot, mpage);
d833 1
d855 9
d865 1
a865 7
	strlcpy(mpage->file, file, PATH_MAX);
	mpage->name = mandoc_strdup(name);
	mpage->sec = mandoc_strdup(sec);
	mpage->dsec = mandoc_strdup(dsec);
	mpage->arch = mandoc_strdup(arch);
	mpage->sform = sform;
	mpage->dform = dform;
d873 12
a884 1
	fileadd(mpage);
d891 1
d896 4
a899 1
		free(mpage->name);
a900 1
		free(mpage->dsec);
d902 2
d927 1
a927 1
	const char		*msec, *march, *mtitle, *cp;
a928 1
	int			 form;
d955 2
a956 2
		if ( ! use_all && FORM_CAT == mpage->dform) {
			sz = strlcpy(buf, mpage->file, PATH_MAX);
d959 1
a959 1
					say(mpage->file,
d969 1
a969 1
			strlcat(buf, mpage->dsec, PATH_MAX);
d972 1
a972 1
					say(mpage->file, "Man "
d990 3
a992 2
		if (FORM_CAT != mpage->dform || FORM_CAT != mpage->sform) {
			lvl = mparse_readfd(mp, -1, mpage->file);
d998 9
a1006 4
			form = 1;
			msec = mdoc_meta(mdoc)->msec;
			march = mdoc_meta(mdoc)->arch;
			mtitle = mdoc_meta(mdoc)->title;
d1008 7
a1014 4
			form = 1;
			msec = man_meta(man)->msec;
			march = mpage->arch;
			mtitle = man_meta(man)->title;
d1016 7
a1022 4
			form = 0;
			msec = mpage->dsec;
			march = mpage->arch;
			mtitle = mpage->name;
a1024 7
		if (NULL == msec)
			msec = "";
		if (NULL == march)
			march = "";
		if (NULL == mtitle)
			mtitle = "";

d1034 2
a1035 2
		if (warnings && !use_all && form &&
				strcasecmp(msec, mpage->dsec)) {
d1037 1
a1037 1
			say(mpage->file, "Section \"%s\" "
d1039 1
a1039 1
				msec, mpage->dsec);
d1056 2
a1057 1
		if (warnings && !use_all && strcasecmp(march, mpage->arch)) {
d1059 1
a1059 1
			say(mpage->file, "Architecture \"%s\" "
d1061 1
a1061 1
				march, mpage->arch);
d1063 2
a1064 1
		if (warnings && !use_all && strcasecmp(mtitle, mpage->name))
d1067 1
a1067 1
		putkey(mpage, mpage->name, TYPE_Nm);
d1075 1
a1075 1
				mpage->desc : mpage->name, TYPE_Nd);
d1088 4
a1091 2
			if (-1 == asprintf(&title_str, "%s(%s%s%s)", mtitle,
			    msec, '\0' == *march ? "" : "/", march)) {
d1102 1
a1102 1
				    match ? "" : mpage->file);
d1112 1
a1112 1
		dbindex(mc, form, mpage);
d1140 1
a1140 1
	if (NULL == (stream = fopen(mpage->file, "r"))) {
d1142 1
a1142 1
			say(mpage->file, NULL);
d1195 2
a1196 1
			say(mpage->file, "Cannot find NAME section");
d1198 2
a1199 2
		mpage->desc = mandoc_strdup(mpage->name);
		putkey(mpage, mpage->name, TYPE_Nd);
d1219 2
a1220 1
			say(mpage->file, "No dash in title line");
d1830 1
a1830 1
dbindex(struct mchars *mc, int form, const struct mpage *mpage)
d1839 1
a1839 1
		say(mpage->file, "Adding to index");
d1862 3
a1864 3
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->file);
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->sec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_PAGE], i, mpage->arch);
d1866 1
a1866 1
	SQL_BIND_INT(stmts[STMT_INSERT_PAGE], i, form);
d1872 3
a1874 3
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mpage->sec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mpage->arch);
	SQL_BIND_TEXT(stmts[STMT_INSERT_LINK], i, mpage->file);
d1902 1
d1911 1
d1913 1
a1913 1
		SQL_BIND_TEXT(stmts[STMT_DELETE_PAGE], i, mpage->file);
d1917 1
a1917 1
			say(mpage->file, "Deleted from index");
@


1.80
log
@Drop the mpages_list, use the existing mpages ohash for iteration.
No functional change except that the order of database entries changes,
which doesn't matter anyway.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.79 2013/12/26 22:30:41 schwarze Exp $ */
d114 4
a117 3
	STMT_DELETE = 0, /* delete manpage */
	STMT_INSERT_DOC, /* insert manpage */
	STMT_INSERT_KEY, /* insert parsed key */
d1818 11
a1828 6
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, mpage->file);
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, mpage->sec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, mpage->arch);
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, desc);
	SQL_BIND_INT(stmts[STMT_INSERT_DOC], i, form);
	SQL_STEP(stmts[STMT_INSERT_DOC]);
d1830 9
a1838 1
	sqlite3_reset(stmts[STMT_INSERT_DOC]);
d1872 3
a1874 3
		SQL_BIND_TEXT(stmts[STMT_DELETE], i, mpage->file);
		SQL_STEP(stmts[STMT_DELETE]);
		sqlite3_reset(stmts[STMT_DELETE]);
d1957 6
a1962 1
	sql = "CREATE TABLE \"docs\" (\n"
d1971 9
d1983 2
a1984 2
	      " \"docid\" INTEGER NOT NULL REFERENCES docs(id) "
	      	"ON DELETE CASCADE,\n"
d1998 3
a2000 3
	sql = "DELETE FROM docs where file=?";
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_DELETE], NULL);
	sql = "INSERT INTO docs "
d2002 4
a2005 1
	sqlite3_prepare_v2(db, sql, -1, &stmts[STMT_INSERT_DOC], NULL);
d2007 1
a2007 1
		"(bits,key,docid) VALUES (?,?,?)";
@


1.79
log
@The name "id" is terrible for a struct.
Make this more searchable by calling it "inodev".
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.78 2013/12/26 22:12:46 schwarze Exp $ */
a97 1
	struct mpage	*next; /* next in mpages_list */
a155 1
static	int	 set_basedir(const char *);
d163 1
a178 1
static	struct mpage	*mpages_list = NULL; /* vector of files to parse */
d471 1
a473 1
				mpages_free();
d482 1
a484 1
	mpages_free();
a806 1
	uint32_t	 hash;
d809 1
a809 1
	mpage->inodev.st_ino = hash = st->st_ino;
d811 2
a812 2
	slot = ohash_lookup_memory(&mpages,
	    (char *)&mpage->inodev, sizeof(mpage->inodev), hash);
a851 2
	mpage->next = mpages_list;
	mpages_list = mpage;
d866 1
d868 2
a869 2
	while (NULL != (mpage = mpages_list)) {
		mpages_list = mpage->next;
d875 1
d880 2
a881 2
 * Run through the files in the global vector "mpages_list" and add them to the
 * database specified in "basedir".
d901 1
a901 1
	unsigned int		 slot;
d917 2
a918 1
	for (mpage = mpages_list; NULL != mpage; mpage = mpage->next) {
d932 1
d945 1
d1057 2
a1058 2
			slot = ohash_qlookup(&title_table, title_str);
			title_entry = ohash_find(&title_table, slot);
d1065 1
a1065 1
				ohash_insert(&title_table, slot,
d1076 1
d1080 1
a1080 1
		title_entry = ohash_first(&title_table, &slot);
d1089 1
a1089 1
			title_entry = ohash_next(&title_table, &slot);
d1850 1
d1855 2
a1856 1
	for (mpage = mpages_list; NULL != mpage; mpage = mpage->next) {
d1863 1
@


1.78
log
@To better support MLINKS, we will have to split the "docs" database
table into two tables, on for actual files on disk, one for (often
multiple) directory entries pointing to them.  That implies splitting
struct of into two structs, to be called "mpage" and "mlink",
respectively.  As a preparation, globally rename "of" and "inos"
to "mpage".  No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.77 2013/12/26 19:02:04 schwarze Exp $ */
d91 3
a93 3
struct	id {
	ino_t		 ino;
	dev_t		 dev;
d97 1
a97 1
	struct id	 id; /* used for hashing routine */
d327 1
a327 1
	mpages_info.key_offset = offsetof(struct mpage, id);
d790 1
a790 1
	struct id	 id;
d793 3
a795 3
	memset(&id, 0, sizeof(id));
	id.ino = hash = st->st_ino;
	id.dev = st->st_dev;
d798 1
a798 1
			&mpages, (char *)&id, sizeof(id), hash)));
d812 4
a815 4
	mpage->id.ino = hash = st->st_ino;
	mpage->id.dev = st->st_dev;
	slot = ohash_lookup_memory
		(&mpages, (char *)&mpage->id, sizeof(mpage->id), hash);
@


1.77
log
@Stop parsing man(7) input when we found all we were searching for,
such that we don't trigger an assertion on a duplicate NAME section.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.76 2013/10/27 17:01:18 schwarze Exp $ */
d86 1
a86 1
	const struct of *of; /* if set, the owning parse */
d96 1
a96 1
struct	of {
d98 1
a98 1
	struct of	*next; /* next in ofs */
d121 1
a121 1
typedef	int (*mdoc_fp)(struct of *, const struct mdoc_node *);
d129 1
a129 1
static	void	 dbindex(struct mchars *, int, const struct of *);
d132 1
a132 1
static	void	 fileadd(struct of *);
d138 1
a138 1
static	void	 inoadd(const struct stat *, struct of *);
d142 15
a156 15
static	void	 offree(void);
static	void	 ofmerge(struct mchars *, struct mparse *, int);
static	void	 parse_catpage(struct of *);
static	void	 parse_man(struct of *, const struct man_node *);
static	void	 parse_mdoc(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_body(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_head(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_Fd(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_Fn(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_In(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_Nd(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_Nm(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_Sh(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_St(struct of *, const struct mdoc_node *);
static	int	 parse_mdoc_Xr(struct of *, const struct mdoc_node *);
d158 1
a158 1
static	void	 putkey(const struct of *, 
d160 1
a160 1
static	void	 putkeys(const struct of *, 
d162 1
a162 1
static	void	 putmdockey(const struct of *,
d177 1
a177 1
static	struct ohash	 inos; /* table of inodes/devices */
d180 1
a180 1
static	struct of	*ofs = NULL; /* vector of files to parse */
d318 1
a318 1
	struct ohash_info ino_info, filename_info;
d323 3
a325 3
	ino_info.alloc  = filename_info.alloc  = hash_alloc;
	ino_info.halloc = filename_info.halloc = hash_halloc;
	ino_info.hfree  = filename_info.hfree  = hash_free;
d327 2
a328 2
	ino_info.key_offset = offsetof(struct of, id);
	filename_info.key_offset = offsetof(struct of, file);
d402 1
a402 1
	ohash_init(&inos, 6, &ino_info);
d425 1
a425 1
			ofmerge(mc, mp, 0);
d456 1
a456 1
				ohash_init(&inos, 6, &ino_info);
d469 1
a469 1
			ofmerge(mc, mp, warnings && !use_all);
d473 1
a473 1
				ohash_delete(&inos);
d475 1
a475 1
				offree();
d484 1
a484 1
	ohash_delete(&inos);
d486 1
a486 1
	offree();
d544 1
a544 1
		 * If we're a regular file, add an "of" by using the
d667 1
a667 1
 * Stuff this information directly into the "of" vector.
d775 1
a775 1
fileadd(struct of *of)
d779 1
a779 1
	slot = ohash_qlookup(&filenames, of->file);
d781 1
a781 1
	ohash_insert(&filenames, slot, of);
d797 2
a798 2
	return(NULL != ohash_find(&inos, ohash_lookup_memory(
			&inos, (char *)&id, sizeof(id), hash)));
d807 1
a807 1
inoadd(const struct stat *st, struct of *of)
d812 2
a813 2
	of->id.ino = hash = st->st_ino;
	of->id.dev = st->st_dev;
d815 1
a815 1
		(&inos, (char *)&of->id, sizeof(of->id), hash);
d817 2
a818 2
	assert(NULL == ohash_find(&inos, slot));
	ohash_insert(&inos, slot, of);
d825 1
a825 1
	struct of	*of;
d847 10
a856 10
	of = mandoc_calloc(1, sizeof(struct of));
	strlcpy(of->file, file, PATH_MAX);
	of->name = mandoc_strdup(name);
	of->sec = mandoc_strdup(sec);
	of->dsec = mandoc_strdup(dsec);
	of->arch = mandoc_strdup(arch);
	of->sform = sform;
	of->dform = dform;
	of->next = ofs;
	ofs = of;
d863 2
a864 2
	inoadd(st, of);
	fileadd(of);
d868 1
a868 1
offree(void)
d870 1
a870 1
	struct of	*of;
d872 7
a878 7
	while (NULL != (of = ofs)) {
		ofs = of->next;
		free(of->name);
		free(of->sec);
		free(of->dsec);
		free(of->arch);
		free(of);
d883 1
a883 1
 * Run through the files in the global vector "ofs" and add them to the
d890 1
a890 1
ofmerge(struct mchars *mc, struct mparse *mp, int check_reachable)
d895 1
a895 1
	struct of		*of;
d920 1
a920 1
	for (of = ofs; NULL != of; of = of->next) {
d928 2
a929 2
		if ( ! use_all && FORM_CAT == of->dform) {
			sz = strlcpy(buf, of->file, PATH_MAX);
d932 2
a933 1
					say(of->file, "Filename too long");
d941 1
a941 1
			strlcat(buf, of->dsec, PATH_MAX);
d944 1
a944 1
					say(of->file, "Man "
d961 2
a962 2
		if (FORM_CAT != of->dform || FORM_CAT != of->sform) {
			lvl = mparse_readfd(mp, -1, of->file);
d975 1
a975 1
			march = of->arch;
d979 3
a981 3
			msec = of->dsec;
			march = of->arch;
			mtitle = of->name;
d1001 1
a1001 1
				strcasecmp(msec, of->dsec)) {
d1003 3
a1005 3
			say(of->file, "Section \"%s\" "
				"manual in %s directory", 
				msec, of->dsec);
d1022 1
a1022 1
		if (warnings && !use_all && strcasecmp(march, of->arch)) {
d1024 1
a1024 1
			say(of->file, "Architecture \"%s\" "
d1026 1
a1026 1
				march, of->arch);
d1028 1
a1028 1
		if (warnings && !use_all && strcasecmp(mtitle, of->name))
d1031 1
a1031 1
		putkey(of, of->name, TYPE_Nm);
d1035 5
a1039 5
				putkey(of, cp, TYPE_Nm);
			assert(NULL == of->desc);
			parse_mdoc(of, mdoc_node(mdoc));
			putkey(of, NULL != of->desc ?
				of->desc : of->name, TYPE_Nd);
d1041 1
a1041 1
			parse_man(of, man_node(man));
d1043 1
a1043 1
			parse_catpage(of);
d1064 1
a1064 1
				    match ? "" : of->file);
d1074 1
a1074 1
		dbindex(mc, form, of);
d1095 1
a1095 1
parse_catpage(struct of *of)
d1101 1
a1101 1
	if (NULL == (stream = fopen(of->file, "r"))) {
d1103 1
a1103 1
			say(of->file, NULL);
d1156 4
a1159 4
			say(of->file, "Cannot find NAME section");
		assert(NULL == of->desc);
		of->desc = mandoc_strdup(of->name);
		putkey(of, of->name, TYPE_Nd);
d1179 1
a1179 1
			say(of->file, "No dash in title line");
d1197 3
a1199 3
	assert(NULL == of->desc);
	of->desc = mandoc_strdup(p);
	putkey(of, of->desc, TYPE_Nd);
d1208 1
a1208 1
putkey(const struct of *of, const char *value, uint64_t type)
d1212 1
a1212 1
	putkeys(of, value, strlen(value), type);
d1219 2
a1220 1
putmdockey(const struct of *of, const struct mdoc_node *n, uint64_t m)
d1225 1
a1225 1
			putmdockey(of, n->child, m);
d1227 1
a1227 1
			putkey(of, n->string, m);
d1232 1
a1232 1
parse_man(struct of *of, const struct man_node *n)
d1327 1
a1327 1
				putkey(of, start, TYPE_Nm);
d1341 1
a1341 1
				putkey(of, start, TYPE_Nm);
d1363 3
a1365 3
			assert(NULL == of->desc);
			of->desc = mandoc_strdup(start);
			putkey(of, of->desc, TYPE_Nd);
d1372 1
a1372 1
		if (NULL != of->desc)
d1374 1
a1374 1
		parse_man(of, n);
d1379 1
a1379 1
parse_mdoc(struct of *of, const struct mdoc_node *n)
d1395 1
a1395 1
			       if (0 == (*mdocs[n->tok].fp)(of, n))
d1398 2
a1399 1
				putmdockey(of, n->child, mdocs[n->tok].mask);
d1406 1
a1406 1
			parse_mdoc(of, n);
d1411 1
a1411 1
parse_mdoc_Fd(struct of *of, const struct mdoc_node *n)
d1449 1
a1449 1
		putkeys(of, start, end - start + 1, TYPE_In);
d1454 1
a1454 1
parse_mdoc_In(struct of *of, const struct mdoc_node *n)
d1460 1
a1460 1
	putkey(of, n->child->string, TYPE_In);
d1465 1
a1465 1
parse_mdoc_Fn(struct of *of, const struct mdoc_node *n)
d1485 1
a1485 1
	putkey(of, cp, TYPE_Fn);
d1488 1
a1488 1
		putkeys(of, n->string, cp - n->string, TYPE_Ft);
d1492 1
a1492 1
			putkey(of, n->string, TYPE_Fa);
d1498 1
a1498 1
parse_mdoc_St(struct of *of, const struct mdoc_node *n)
d1504 1
a1504 1
	putkey(of, n->child->string, TYPE_St);
d1509 1
a1509 1
parse_mdoc_Xr(struct of *of, const struct mdoc_node *n)
d1517 1
a1517 1
		putkey(of, n->string, TYPE_Xr);
d1525 1
a1525 1
	putkey(of, cp, TYPE_Xr);
d1531 1
a1531 1
parse_mdoc_Nd(struct of *of, const struct mdoc_node *n)
d1545 2
a1546 2
			if (NULL != of->desc) {
				sz = strlen(of->desc) +
d1548 4
a1551 3
				of->desc = mandoc_realloc(of->desc, sz);
				strlcat(of->desc, " ", sz);
				strlcat(of->desc, n->string, sz);
d1553 1
a1553 1
				of->desc = mandoc_strdup(n->string);
d1556 1
a1556 1
			parse_mdoc_Nd(of, n);
d1562 1
a1562 1
parse_mdoc_Nm(struct of *of, const struct mdoc_node *n)
d1574 1
a1574 1
parse_mdoc_Sh(struct of *of, const struct mdoc_node *n)
d1581 1
a1581 1
parse_mdoc_head(struct of *of, const struct mdoc_node *n)
d1588 1
a1588 1
parse_mdoc_body(struct of *of, const struct mdoc_node *n)
d1600 2
a1601 1
putkeys(const struct of *of, const char *cp, size_t sz, uint64_t v)
d1614 1
a1614 1
	if (NULL != s && of == s->of) {
d1622 1
a1622 1
	s->of = of;
d1789 1
a1789 1
dbindex(struct mchars *mc, int form, const struct of *of)
d1798 1
a1798 1
		say(of->file, "Adding to index");
d1804 1
a1804 1
	if (NULL != of->desc && '\0' != *of->desc) {
d1806 1
a1806 1
			ohash_qlookup(&strings, of->desc));
d1816 3
a1818 3
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, of->file);
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, of->sec);
	SQL_BIND_TEXT(stmts[STMT_INSERT_DOC], i, of->arch);
d1827 1
a1827 1
		assert(key->of == of);
d1847 1
a1847 1
	struct of	*of;
d1853 1
a1853 1
	for (of = ofs; NULL != of; of = of->next) {
d1855 1
a1855 1
		SQL_BIND_TEXT(stmts[STMT_DELETE], i, of->file);
d1859 1
a1859 1
			say(of->file, "Deleted from index");
@


1.76
log
@The man(7) language has no syntax to specify architectures, but it
can still be used to write architecture-specific manuals, of course.

So just derive the architecture a man(7) manual belongs to from the
directory where it is located and refrain from warning about each and
every architecture-specific man(7) manual found.

While here, delete some trailing whitespace in the neighbourhood.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.75 2013/10/27 16:41:31 schwarze Exp $ */
d1369 3
a1371 1
	for (n = n->child; n; n = n->next)
d1373 1
@


1.75
log
@The code in ofmerge() only tried the source parsers if at least one
of the path (/man1/ .. /man9/) or the file name suffix (*.1 .. *.9)
indicated a source manual.  That missed source manuals with unusual
names in unusual locations.

Instead, as the existing comment right above already suggests, try
the source parsers unless both the path and the file name suffix
unambiguously indicate a preformatted manual (/cat*/*.0).

This change is not expensive in practice because no real-world
system will have large numbers of preformatted pages outside
/cat*/*.0.  The only way to make information loss even less probable
would be to try the source parsers on all files, even /cat*/*.0,
which wouldn't buy us much because no real-world system will call
source manuals /cat*/*.0, but it will be expensive in practice,
because many real-world systems have large numbers of preformatted
pages called /cat*/*.0.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.74 2013/10/27 16:09:44 schwarze Exp $ */
a952 4
		form = 0;
		msec = of->dsec;
		march = of->arch;
		mtitle = of->name;
d964 1
a964 1
		} 
d974 1
a974 1
			march = "";
d976 6
a981 1
		} 
d983 1
a983 1
		if (NULL == msec) 
d985 1
a985 1
		if (NULL == march) 
d987 1
a987 1
		if (NULL == mtitle) 
@


1.74
log
@delete duplicate NULL check and polish style;
no functional change
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.73 2013/10/18 23:07:23 schwarze Exp $ */
d964 1
a964 1
		if (FORM_SRC == of->dform || FORM_SRC == of->sform) {
@


1.73
log
@Fix an assertion in dbindex():  Null strings are never entered into the
string table.  Fortunately, they never need UTF-8 translation either.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.72 2013/10/18 21:10:07 schwarze Exp $ */
d839 1
a839 4
	sform = FORM_NONE;
	if (NULL != sec && *sec <= '9' && *sec >= '1')
		sform = FORM_SRC;
	else if (NULL != sec && *sec == '0') {
d842 4
a845 1
	}
@


1.72
log
@Manuals to be checked with "mandocdb -t" need not be in the current
directory or one of its subdirectories.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.71 2013/07/02 13:26:52 schwarze Exp $ */
d1795 1
a1795 1
	if (NULL != of->desc) {
@


1.71
log
@For the strings table, ohash_init is only called in ofmerge(),
so move the str_info structure into that function.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.70 2013/07/02 12:58:54 schwarze Exp $ */
d688 1
a688 1
	} else if (strstr(buf, basedir) != buf) {
@


1.70
log
@Turning off synchronous mode logically belongs to opening the database,
so move the statement into the function dbopen().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.69 2013/07/02 11:40:40 schwarze Exp $ */
d143 1
a143 2
static	void	 ofmerge(struct mchars *, struct mparse *,
			struct ohash_info*, int);
d318 1
a318 1
	struct ohash_info ino_info, filename_info, str_info;
d323 3
a325 6
	ino_info.halloc = filename_info.halloc = 
		str_info.halloc = hash_halloc;
	ino_info.hfree = filename_info.hfree = 
		str_info.hfree = hash_free;
	ino_info.alloc = filename_info.alloc = 
		str_info.alloc = hash_alloc;
a328 1
	str_info.key_offset = offsetof(struct str, key);
d425 1
a425 1
			ofmerge(mc, mp, &str_info, 0);
d469 1
a469 1
			ofmerge(mc, mp, &str_info, warnings && !use_all);
d890 1
a890 2
ofmerge(struct mchars *mc, struct mparse *mp,
		struct ohash_info *infop, int check_reachable)
d893 1
a893 1
	struct ohash_info	 title_info;
d907 5
d949 1
a949 1
		ohash_init(&strings, 6, infop);
@


1.69
log
@Restore the check whether each page added to the database
is actually reachable by man(1).  This check got lost when
the database backend was changed from Berkeley to sqlite.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.68 2013/06/07 05:27:50 schwarze Exp $ */
a473 9
			/*
			 * Since we're opening up a new database, we can
			 * turn off synchronous mode for much better
			 * performance.
			 */
#ifndef __APPLE__
			SQL_EXEC("PRAGMA synchronous = OFF");
#endif

d1966 11
@


1.68
log
@The mdoc_handler flags are unused and will never be used.
Having a mask is sufficient to trigger putmdockey.
Simplify by dropping the flags; no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.67 2013/06/07 04:51:26 schwarze Exp $ */
d109 5
d144 1
a144 1
			struct ohash_info*);
d430 1
a430 1
			ofmerge(mc, mp, &str_info);
d448 2
a449 3
		 * First scan the tree rooted at a base directory.
		 * Then whak its database (if one exists), parse, and
		 * build up the database.
d483 1
a483 1
			ofmerge(mc, mp, &str_info);
d905 1
a905 1
		struct ohash_info *infop)
d907 22
a928 9
	int		 form;
	size_t		 sz;
	struct mdoc	*mdoc;
	struct man	*man;
	char		 buf[PATH_MAX];
	char		*bufp;
	const char	*msec, *march, *mtitle, *cp;
	struct of	*of;
	enum mandoclevel lvl;
d967 1
d1009 2
a1010 1
				strcasecmp(msec, of->dsec))
d1014 1
d1030 2
a1031 1
		if (warnings && !use_all && strcasecmp(march, of->arch))
d1035 3
d1053 29
d1085 15
@


1.67
log
@In .Xr database entries, mention the manual section again;
the section was dropped when switching from db to sqlite.
Use the customary format foo(N).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.66 2013/06/07 01:01:34 schwarze Exp $ */
a120 2
	int		 flags;  /* for use by pmdoc_node */
#define	MDOCF_CHILD	 0x01  /* automatically index child nodes */
d181 122
a302 122
	{ NULL, 0, 0 },  /* Ap */
	{ NULL, 0, 0 },  /* Dd */
	{ NULL, 0, 0 },  /* Dt */
	{ NULL, 0, 0 },  /* Os */
	{ parse_mdoc_Sh, TYPE_Sh, MDOCF_CHILD }, /* Sh */
	{ parse_mdoc_head, TYPE_Ss, MDOCF_CHILD }, /* Ss */
	{ NULL, 0, 0 },  /* Pp */
	{ NULL, 0, 0 },  /* D1 */
	{ NULL, 0, 0 },  /* Dl */
	{ NULL, 0, 0 },  /* Bd */
	{ NULL, 0, 0 },  /* Ed */
	{ NULL, 0, 0 },  /* Bl */
	{ NULL, 0, 0 },  /* El */
	{ NULL, 0, 0 },  /* It */
	{ NULL, 0, 0 },  /* Ad */
	{ NULL, TYPE_An, MDOCF_CHILD },  /* An */
	{ NULL, TYPE_Ar, MDOCF_CHILD },  /* Ar */
	{ NULL, TYPE_Cd, MDOCF_CHILD },  /* Cd */
	{ NULL, TYPE_Cm, MDOCF_CHILD },  /* Cm */
	{ NULL, TYPE_Dv, MDOCF_CHILD },  /* Dv */
	{ NULL, TYPE_Er, MDOCF_CHILD },  /* Er */
	{ NULL, TYPE_Ev, MDOCF_CHILD },  /* Ev */
	{ NULL, 0, 0 },  /* Ex */
	{ NULL, TYPE_Fa, MDOCF_CHILD },  /* Fa */
	{ parse_mdoc_Fd, TYPE_In, 0 },  /* Fd */
	{ NULL, TYPE_Fl, MDOCF_CHILD },  /* Fl */
	{ parse_mdoc_Fn, 0, 0 },  /* Fn */
	{ NULL, TYPE_Ft, MDOCF_CHILD },  /* Ft */
	{ NULL, TYPE_Ic, MDOCF_CHILD },  /* Ic */
	{ parse_mdoc_In, TYPE_In, MDOCF_CHILD },  /* In */
	{ NULL, TYPE_Li, MDOCF_CHILD },  /* Li */
	{ parse_mdoc_Nd, TYPE_Nd, MDOCF_CHILD },  /* Nd */
	{ parse_mdoc_Nm, TYPE_Nm, MDOCF_CHILD },  /* Nm */
	{ NULL, 0, 0 },  /* Op */
	{ NULL, 0, 0 },  /* Ot */
	{ NULL, TYPE_Pa, MDOCF_CHILD },  /* Pa */
	{ NULL, 0, 0 },  /* Rv */
	{ parse_mdoc_St, TYPE_St, 0 },  /* St */
	{ NULL, TYPE_Va, MDOCF_CHILD },  /* Va */
	{ parse_mdoc_body, TYPE_Va, MDOCF_CHILD },  /* Vt */
	{ parse_mdoc_Xr, TYPE_Xr, 0 },  /* Xr */
	{ NULL, 0, 0 },  /* %A */
	{ NULL, 0, 0 },  /* %B */
	{ NULL, 0, 0 },  /* %D */
	{ NULL, 0, 0 },  /* %I */
	{ NULL, 0, 0 },  /* %J */
	{ NULL, 0, 0 },  /* %N */
	{ NULL, 0, 0 },  /* %O */
	{ NULL, 0, 0 },  /* %P */
	{ NULL, 0, 0 },  /* %R */
	{ NULL, 0, 0 },  /* %T */
	{ NULL, 0, 0 },  /* %V */
	{ NULL, 0, 0 },  /* Ac */
	{ NULL, 0, 0 },  /* Ao */
	{ NULL, 0, 0 },  /* Aq */
	{ NULL, TYPE_At, MDOCF_CHILD },  /* At */
	{ NULL, 0, 0 },  /* Bc */
	{ NULL, 0, 0 },  /* Bf */
	{ NULL, 0, 0 },  /* Bo */
	{ NULL, 0, 0 },  /* Bq */
	{ NULL, TYPE_Bsx, MDOCF_CHILD },  /* Bsx */
	{ NULL, TYPE_Bx, MDOCF_CHILD },  /* Bx */
	{ NULL, 0, 0 },  /* Db */
	{ NULL, 0, 0 },  /* Dc */
	{ NULL, 0, 0 },  /* Do */
	{ NULL, 0, 0 },  /* Dq */
	{ NULL, 0, 0 },  /* Ec */
	{ NULL, 0, 0 },  /* Ef */
	{ NULL, TYPE_Em, MDOCF_CHILD },  /* Em */
	{ NULL, 0, 0 },  /* Eo */
	{ NULL, TYPE_Fx, MDOCF_CHILD },  /* Fx */
	{ NULL, TYPE_Ms, MDOCF_CHILD },  /* Ms */
	{ NULL, 0, 0 },  /* No */
	{ NULL, 0, 0 },  /* Ns */
	{ NULL, TYPE_Nx, MDOCF_CHILD },  /* Nx */
	{ NULL, TYPE_Ox, MDOCF_CHILD },  /* Ox */
	{ NULL, 0, 0 },  /* Pc */
	{ NULL, 0, 0 },  /* Pf */
	{ NULL, 0, 0 },  /* Po */
	{ NULL, 0, 0 },  /* Pq */
	{ NULL, 0, 0 },  /* Qc */
	{ NULL, 0, 0 },  /* Ql */
	{ NULL, 0, 0 },  /* Qo */
	{ NULL, 0, 0 },  /* Qq */
	{ NULL, 0, 0 },  /* Re */
	{ NULL, 0, 0 },  /* Rs */
	{ NULL, 0, 0 },  /* Sc */
	{ NULL, 0, 0 },  /* So */
	{ NULL, 0, 0 },  /* Sq */
	{ NULL, 0, 0 },  /* Sm */
	{ NULL, 0, 0 },  /* Sx */
	{ NULL, TYPE_Sy, MDOCF_CHILD },  /* Sy */
	{ NULL, TYPE_Tn, MDOCF_CHILD },  /* Tn */
	{ NULL, 0, 0 },  /* Ux */
	{ NULL, 0, 0 },  /* Xc */
	{ NULL, 0, 0 },  /* Xo */
	{ parse_mdoc_head, TYPE_Fn, 0 },  /* Fo */
	{ NULL, 0, 0 },  /* Fc */
	{ NULL, 0, 0 },  /* Oo */
	{ NULL, 0, 0 },  /* Oc */
	{ NULL, 0, 0 },  /* Bk */
	{ NULL, 0, 0 },  /* Ek */
	{ NULL, 0, 0 },  /* Bt */
	{ NULL, 0, 0 },  /* Hf */
	{ NULL, 0, 0 },  /* Fr */
	{ NULL, 0, 0 },  /* Ud */
	{ NULL, TYPE_Lb, MDOCF_CHILD },  /* Lb */
	{ NULL, 0, 0 },  /* Lp */
	{ NULL, TYPE_Lk, MDOCF_CHILD },  /* Lk */
	{ NULL, TYPE_Mt, MDOCF_CHILD },  /* Mt */
	{ NULL, 0, 0 },  /* Brq */
	{ NULL, 0, 0 },  /* Bro */
	{ NULL, 0, 0 },  /* Brc */
	{ NULL, 0, 0 },  /* %C */
	{ NULL, 0, 0 },  /* Es */
	{ NULL, 0, 0 },  /* En */
	{ NULL, TYPE_Dx, MDOCF_CHILD },  /* Dx */
	{ NULL, 0, 0 },  /* %Q */
	{ NULL, 0, 0 },  /* br */
	{ NULL, 0, 0 },  /* sp */
	{ NULL, 0, 0 },  /* %U */
	{ NULL, 0, 0 },  /* Ta */
d1333 1
a1333 2

			if (MDOCF_CHILD & mdocs[n->tok].flags)
@


1.66
log
@The string hash table is only needed to combine multiple occurences
of the same string within the same manual, so initialize and purge
it for each manual in ofmerge() instead of one single time in main().

There is no point in saving manual names and descriptions in that
table because each of them occurs only once, or very few times.
The is no point in saving section numbers there because they are
so much shorter than the descriptions.

Testing with the complete tree /usr/share/man/ on my notebook shows
that this change slightly reduces memory consumption by about 20%
while there is no measurable difference in execution time.

As a bonus, this allows to delete the functions stradd() and stradds(),
the "next" member from struct str, and the global struct str *words.

While adapting the places in the code using stradd(), i noticed that
parsing of the mdoc(7) .Nd macro was completely broken and that for
formatted manual pages with unusable NAME section, the description
was never set in the struct of.  This commit fixes both bugs as well.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.65 2013/06/06 19:00:28 schwarze Exp $ */
d1449 1
d1454 12
a1465 2
	putkey(of, n->string, TYPE_Xr);
	return(1);
@


1.65
log
@Optimize stradds() and putkeys() to not call ohash_qlookupi()
and ohash_find() twice.  As a bonus, this allows to drop hashget().
While here, rename index to slot to match the terminology in the ohash
manual; it also prevents potential clashes with index(3).
Drop the slot variable altogether where it is used only once.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.64 2013/06/06 17:51:31 schwarze Exp $ */
a86 1
	struct str	*next; /* next in owning parse sequence */
d102 5
a106 5
	const char	*desc; /* parsed description */
	const char	*sec; /* suffix-cued section (or empty) */
	const char	*dsec; /* path-cued section (or empty) */
	const char	*arch; /* path-cued arch. (or empty) */
	const char	*name; /* name (from filename) (not empty) */
d140 2
a141 1
static	void	 ofmerge(struct mchars *, struct mparse *);
a162 2
static	char 	*stradd(const char *);
static	char 	*stradds(const char *, size_t);
a178 1
static	struct str	*words = NULL; /* word list in current parse */
a310 1
	unsigned int	  slot;
a312 1
	struct str	 *s;
a403 1
	ohash_init(&strings, 6, &str_info);
d427 1
a427 1
			ofmerge(mc, mp);
d457 6
d481 1
a481 1
			ofmerge(mc, mp);
d483 6
a488 5
			offree();
			ohash_delete(&inos);
			ohash_init(&inos, 6, &ino_info);
			ohash_delete(&filenames);
			ohash_init(&filenames, 6, &filename_info);
a495 7
	for (s = ohash_first(&strings, &slot); NULL != s;
	     s = ohash_next(&strings, &slot)) {
		if (s->utf8 != s->key)
			free(s->utf8);
		free(s);
	}
	ohash_delete(&strings);
d533 1
a533 1
	const char	*dsec, *arch, *cp, *name, *path;
d601 1
a601 1
			} else {
d603 2
a604 5
				sec = stradd(sec);
			}
			name = stradd(ff->fts_name);
			ofadd(dform, path, 
				name, dsec, sec, arch, ff->fts_statp);
d631 1
a631 1
				dsec = stradd(cp + 3);
d634 1
a634 1
				dsec = stradd(cp + 3);
d651 1
a651 1
				arch = stradd(ff->fts_name);
d861 4
a864 4
	of->name = name;
	of->sec = sec;
	of->dsec = dsec;
	of->arch = arch;
d886 4
d902 2
a903 1
ofmerge(struct mchars *mc, struct mparse *mp)
d944 1
a944 1
		words = NULL;
d1022 1
d1024 2
d1032 1
d1099 2
d1139 3
a1141 2
	of->desc = stradd(p);
	putkey(of, p, TYPE_Nd);
d1305 2
a1306 2
			of->desc = stradd(start);
			putkey(of, start, TYPE_Nd);
a1460 1
	char		*sv, *desc;
a1469 1
	desc = NULL;
d1472 8
a1479 9
			sz = strlen(n->string) + 1;
			if (NULL != (sv = desc))
				sz += strlen(desc) + 1;
			desc = mandoc_realloc(desc, sz);
			if (NULL != sv)
				strlcat(desc, " ", sz);
			else
				*desc = '\0';
			strlcat(desc, n->string, sz);
a1483 3

	of->desc = NULL != desc ? stradd(desc) : NULL;
	free(desc);
d1521 3
a1523 44
 * See stradds().
 */
static char *
stradd(const char *cp)
{

	return(stradds(cp, strlen(cp)));
}

/*
 * This looks up or adds a string to the string table.
 * The string table is a table of all strings encountered during parse
 * or file scan.
 * In using it, we avoid having thousands of (e.g.) "cat1" string
 * allocations for the "of" table.
 * We also have a layer atop the string table for keeping track of words
 * in a parse sequence (see putkeys()).
 */
static char *
stradds(const char *cp, size_t sz)
{
	struct str	*s;
	unsigned int	 slot;
	const char	*end;

	end = cp + sz;
	slot = ohash_qlookupi(&strings, cp, &end);
	if (NULL != (s = ohash_find(&strings, slot)))
		return(s->key);

	s = mandoc_calloc(sizeof(struct str) + sz + 1, 1);
	memcpy(s->key, cp, sz);
	ohash_insert(&strings, slot, s);
	return(s->key);
}

/*
 * Add a word to the current parse sequence.
 * Within the hashtable of strings, we maintain a list of strings that
 * are currently indexed.
 * Each of these ("words") has a bitmask modified within the parse.
 * When we finish a parse, we'll dump the list, then remove the head
 * entry -- since the next parse will have a new "of", it can keep track
 * of its entries without conflict.
a1546 2

	s->next = words;
a1548 1
	words = s;
d1720 1
d1750 2
a1751 1
	for (key = words; NULL != key; key = key->next) {
d1761 3
@


1.64
log
@Drop wordaddbuf() which is identical to putkeys().
Also rename straddbuf() to stradds() to be more similar to putkeys().
Just cleanup, no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.63 2013/06/06 15:15:07 schwarze Exp $ */
a132 1
static	struct str *hashget(const char *, size_t);
d314 1
a314 1
	unsigned int	  index;
d495 2
a496 2
	for (s = ohash_first(&strings, &index);
			NULL != s; s = ohash_next(&strings, &index)) {
a785 1
	unsigned int	 index;
d787 2
a788 2
	index = ohash_qlookup(&filenames, name);
	return(NULL != ohash_find(&filenames, index));
d798 1
a798 1
	unsigned int	 index;
d800 3
a802 3
	index = ohash_qlookup(&filenames, of->file);
	assert(NULL == ohash_find(&filenames, index));
	ohash_insert(&filenames, index, of);
a812 1
	unsigned int	 index;
a816 2
	index = ohash_lookup_memory
		(&inos, (char *)&id, sizeof(id), hash);
d818 2
a819 1
	return(NULL != ohash_find(&inos, index));
d831 1
a831 1
	unsigned int	 index;
d835 1
a835 1
	index = ohash_lookup_memory
d838 2
a839 2
	assert(NULL == ohash_find(&inos, index));
	ohash_insert(&inos, index, of);
d1546 1
a1546 1
	unsigned int	 index;
d1549 3
a1551 1
	if (NULL != (s = hashget(cp, sz)))
d1556 1
a1556 5

	end = cp + sz;
	index = ohash_qlookupi(&strings, cp, &end);
	assert(NULL == ohash_find(&strings, index));
	ohash_insert(&strings, index, s);
a1559 11
static struct str *
hashget(const char *cp, size_t sz)
{
	unsigned int	 index;
	const char	*end;

	end = cp + sz;
	index = ohash_qlookupi(&strings, cp, &end);
	return(ohash_find(&strings, index));
}

d1573 1
a1573 1
	unsigned int	 index;
d1579 3
a1581 1
	s = hashget(cp, sz);
d1589 1
a1589 4
		end = cp + sz;
		index = ohash_qlookupi(&strings, cp, &end);
		assert(NULL == ohash_find(&strings, index));
		ohash_insert(&strings, index, s);
d1776 2
a1777 1
		key = hashget(of->desc, strlen(of->desc));
@


1.63
log
@In dbopen(), check success of remove("mandoc.db~").
While here, simplify dbopen() and dbclose(): No need for strlcpy()
and strlcat() when dealing with constant strings only.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.62 2013/06/06 02:40:37 schwarze Exp $ */
d160 1
a160 1
			const char *, int, uint64_t);
d165 1
a165 1
static	char 	*straddbuf(const char *, size_t);
a168 2
static	void 	 wordaddbuf(const struct of *, 
			const char *, size_t, uint64_t);
d1155 1
a1155 11
	wordaddbuf(of, value, strlen(value), type);
}

/*
 * Like putkey() but for unterminated strings.
 */
static void
putkeys(const struct of *of, const char *value, int sz, uint64_t type)
{

	wordaddbuf(of, value, sz, type);
d1528 1
a1528 1
 * See straddbuf().
d1534 1
a1534 1
	return(straddbuf(cp, strlen(cp)));
d1544 1
a1544 1
 * in a parse sequence (see wordaddbuf()).
d1547 1
a1547 1
straddbuf(const char *cp, size_t sz)
d1587 1
a1587 2
wordaddbuf(const struct of *of, 
		const char *cp, size_t sz, uint64_t v)
@


1.62
log
@In parse_catpage(), the comment saying that the filename would be
used as a default page description if no usable NAME section was found
was preserved when moving from db to sqlite, but the code line actually
doing that was removed without replacement.  So, put it back.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.61 2013/06/05 21:21:08 schwarze Exp $ */
d26 1
a1867 1
	char		 file[PATH_MAX];
d1883 1
a1883 3
	strlcpy(file, MANDOC_DB, PATH_MAX);
	strlcat(file, "~", PATH_MAX);
	if (-1 == rename(file, MANDOC_DB)) {
d1900 1
a1900 2
	char		 file[PATH_MAX];
	const char	*sql;
a1901 1
	size_t		 sz;
d1906 11
a1916 14
	sz = strlcpy(file, MANDOC_DB, PATH_MAX);
	if ( ! real)
		sz = strlcat(file, "~", PATH_MAX);

	if (sz >= PATH_MAX) {
		fprintf(stderr, "%s: Path too long\n", file);
		return(0);
	}

	if ( ! real)
		remove(file);

	ofl = SQLITE_OPEN_READWRITE | 
		(0 == real ? SQLITE_OPEN_EXCLUSIVE : 0);
@


1.61
log
@The return value from parse_man() is completely unused,
so make the function void; no functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.60 2013/06/05 20:27:11 schwarze Exp $ */
d1104 1
@


1.60
log
@Two sanity checks got lost in treescan()
during the switch from db to sqlite; restore these:

* Warn and skip when directory and file name mismatch.
* Warn and skip when finding special files.
* Warning about "mandocdb.db" is useless, it is always present.
* While here, do not hardcode "mandocdb.db", use MANDOC_DB.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.59 2013/06/05 17:48:14 schwarze Exp $ */
d143 1
a143 2
static	int	 parse_man(struct of *, 
			const struct man_node *);
d1183 1
a1183 1
static int
d1192 1
a1192 1
		return(0);
d1234 1
a1234 1
				return(1);
d1247 1
a1247 1
				return(1);
d1258 1
a1258 1
				return(1);
d1295 1
a1295 1
				return(1);
d1319 1
a1319 1
			return(1);
d1324 1
a1324 4
		if (parse_man(of, n))
			return(1);

	return(0);
@


1.59
log
@Add back the realpath() checks that got lost during the change from
db to sqlite; they are needed to prevent corruption of the database
when paths containing dot, dotdot, or symlinks are given on the
command line.  Also make sure the exit-code is really non-zero on
system errors and use mandoc(1) exit codes.

To make all this simpler,
 * Drop the "basedir" argument from almost every function and make it
   global because it is really state info used all over the place.
 * Move "startdir" and "fd" as local vars into set_basedir() because they
   are only used for this one purpose, i.e. to move out of basedir again.

While here,
 * Clarify the name of path_arg in the main program; in the -C case,
   it is not a dir, and anyway there are lots of different dirs around.
 * Include missing <stdio.h> needed for perror().
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.58 2013/06/05 02:00:26 schwarze Exp $ */
d570 2
d580 3
a582 10
			} 

			cp = ff->fts_name;

			if (0 == strcmp(cp, "mandocdb.db")) {
				if (warnings)
					say(path, "Skip database");
				continue;
			} else if (NULL != (cp = strrchr(cp, '.'))) {
				if (0 == strcmp(cp + 1, "html")) {
d584 2
a585 13
						say(path, "Skip html");
					continue;
				} else if (0 == strcmp(cp + 1, "gz")) {
					if (warnings)
						say(path, "Skip gz");
					continue;
				} else if (0 == strcmp(cp + 1, "ps")) {
					if (warnings)
						say(path, "Skip ps");
					continue;
				} else if (0 == strcmp(cp + 1, "pdf")) {
					if (warnings)
						say(path, "Skip pdf");
d588 25
a612 5
			}

			if (NULL != (sec = strrchr(ff->fts_name, '.'))) {
				*sec = '\0';
				sec = stradd(sec + 1);
d619 3
a621 1
				FTS_DP != ff->fts_info)
d623 1
@


1.58
log
@Some places used PATH_MAX from <limits.h>, some MAXPATHLEN from <sys/param.h>.
Consistently use the PATH_MAX since it is specified by POSIX,
while MAXPATHLEN is not.
In preparation for using this at a few more places.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.57 2013/06/03 22:51:14 schwarze Exp $ */
a25 1
#include <errno.h>
d31 1
d125 4
a128 5
static	void	 dbclose(const char *, int);
static	void	 dbindex(struct mchars *, int,
			const struct of *, const char *);
static	int	 dbopen(const char *, int);
static	void	 dbprune(const char *);
d131 1
a131 1
static	void	 filescan(const char *, const char *);
d138 2
a139 3
static	void	 ofadd(const char *, int, const char *, 
			const char *, const char *, const char *, 
			const char *, const struct stat *);
d141 2
a142 2
static	int	 ofmerge(struct mchars *, struct mparse *, const char *);
static	void	 parse_catpage(struct of *, const char *);
d156 1
a156 1
static	int	 path_reset(const char *, int, const char *);
d163 1
a163 1
static	void	 say(const char *, const char *, const char *, ...);
d166 1
a166 1
static	int	 treescan(const char *);
d177 1
d179 1
d316 1
a316 2
	char		  cwd[PATH_MAX];
	int		  ch, rc, fd, i;
d319 1
a319 1
	const char	 *dir;
a346 14
	 * Remember where we started by keeping a fd open to the origin
	 * path component: throughout this utility, we chdir() a lot to
	 * handle relative paths, and by doing this, we can return to
	 * the starting point.
	 */
	if (NULL == getcwd(cwd, PATH_MAX)) {
		perror(NULL);
		return(EXIT_FAILURE);
	} else if (-1 == (fd = open(cwd, O_RDONLY, 0))) {
		perror(cwd);
		return(EXIT_FAILURE);
	}

	/*
d357 1
a357 1
	dir = NULL;
d367 1
a367 1
			dir = optarg;
d372 1
a372 1
			dir = optarg;
d386 1
a386 1
			dir = optarg;
d407 1
a407 1
	rc = 1;
d421 1
a421 2
		if (NULL == dir)
			dir = cwd;
d427 1
a427 1
		if (0 == path_reset(cwd, fd, dir))
d430 2
a431 2
			filescan(argv[i], dir);
		if (0 == dbopen(dir, 1))
d434 1
a434 1
			dbprune(dir);
d436 2
a437 2
			rc = ofmerge(mc, mp, dir);
		dbclose(dir, 1);
d451 1
a451 1
			manpath_parse(&dirs, dir, NULL, NULL);
d466 1
a466 1
			if (0 == path_reset(cwd, fd, dirs.paths[j]))
d468 1
a468 1
			if (0 == treescan(dirs.paths[j]))
d470 1
a470 1
			if (0 == path_reset(cwd, fd, dirs.paths[j]))
d472 1
a472 1
			if (0 == dbopen(dirs.paths[j], 0))
d484 2
a485 3
			if (0 == ofmerge(mc, mp, dirs.paths[j]))
				goto out;
			dbclose(dirs.paths[j], 0);
d494 1
a494 1
	close(fd);
d508 1
a508 1
	return(rc ? EXIT_SUCCESS : EXIT_FAILURE);
d518 1
a518 1
	return(EXIT_FAILURE);
d522 1
a522 1
 * Scan a directory tree rooted at "base" for manpages.
d536 1
a536 1
treescan(const char *base)
d554 2
a555 1
		perror(base);
d572 1
a572 1
					say(base, path, "Extraneous file");
d576 1
a576 1
					say(base, path, "Duplicate file");
d584 1
a584 1
					say(base, path, "Skip database");
d589 1
a589 1
						say(base, path, "Skip html");
d593 1
a593 1
						say(base, path, "Skip gz");
d597 1
a597 1
						say(base, path, "Skip ps");
d601 1
a601 1
						say(base, path, "Skip pdf");
d611 1
a611 1
			ofadd(base, dform, path, 
d646 1
a646 1
				say(base, path, "Unknown directory part");
d662 1
a662 1
				say(base, path, "Extraneous directory part");
d688 1
a688 1
filescan(const char *file, const char *base)
d690 1
d692 1
a692 1
	char		*p, *start, *buf;
d701 11
a711 3
	if (-1 == stat(file, &st)) {
		if (warnings)
			say(base, file, "%s", strerror(errno));
d714 2
a715 2
		if (warnings)
			say(base, file, "Not a regular file");
d719 1
a719 1
			say(base, file, "Duplicate file");
d722 1
a722 3

	buf = mandoc_strdup(file);
	start = buf;
d773 1
a773 2
	ofadd(base, dform, file, name, dsec, sec, arch, &st);
	free(buf);
d842 2
a843 3
ofadd(const char *base, int dform, const char *file, 
		const char *name, const char *dsec, const char *sec, 
		const char *arch, const struct stat *st)
d900 1
a900 1
 * database specified in "base".
d905 2
a906 2
static int
ofmerge(struct mchars *mc, struct mparse *mp, const char *base)
d930 1
a930 2
					say(base, of->file,
					    "Filename too long");
d941 1
a941 1
					say(base, of->file, "Man "
d997 1
a997 1
			say(base, of->file, "Section \"%s\" "
d1016 1
a1016 1
			say(base, of->file, "Architecture \"%s\" "
d1029 1
a1029 1
			parse_catpage(of, base);
d1031 1
a1031 1
		dbindex(mc, form, of, base);
a1032 2

	return(1);
d1036 1
a1036 1
parse_catpage(struct of *of, const char *base)
d1044 1
a1044 1
			say(base, of->file, "%s", strerror(errno));
d1097 1
a1097 1
			say(base, of->file, "Cannot find NAME section");
d1117 1
a1117 1
			say(base, of->file, "No dash in title line");
d1787 1
a1787 2
dbindex(struct mchars *mc, int form, 
		const struct of *of, const char *base)
d1795 1
a1795 1
		say(base, of->file, "Adding to index");
d1837 1
a1837 1
dbprune(const char *base)
d1851 1
a1851 1
			say(base, of->file, "Deleted from index");
d1860 1
a1860 1
dbclose(const char *base, int real)
d1881 4
a1884 2
	if (-1 == rename(file, MANDOC_DB))
		perror(MANDOC_DB);
d1896 1
a1896 1
dbopen(const char *base, int real)
d1925 2
a1926 1
		perror(file);
d1934 2
a1935 1
		perror(file);
d1959 2
a1960 1
		perror(sqlite3_errmsg(db));
d1999 1
a1999 1
path_reset(const char *cwd, int fd, const char *base)
d2001 2
d2004 39
a2042 2
	if (-1 == fchdir(fd)) {
		perror(cwd);
d2044 3
a2046 2
	} else if (-1 == chdir(base)) {
		perror(base);
d2053 1
a2053 1
say(const char *dir, const char *file, const char *format, ...)
d2057 4
a2060 1
	fprintf(stderr, "%s", dir);
d2062 1
a2062 1
		fprintf(stderr, "//%s", file);
d2065 5
@


1.57
log
@Changing existing SQLite databases was utterly broken:
1) SQL statements were only prepared when creating a new database.
2) We rely heavily on foreign_keys, but never enabled them.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.56 2013/06/03 19:01:31 schwarze Exp $ */
a21 1
#include <sys/param.h>
d30 1
d101 1
a101 1
	char		 file[MAXPATHLEN]; /* filename rel. to manpath */
d316 1
a316 1
	char		  cwd[MAXPATHLEN];
d353 1
a353 1
	if (NULL == getcwd(cwd, MAXPATHLEN)) {
d879 1
a879 1
	strlcpy(of->file, file, MAXPATHLEN);
d923 1
a923 1
	char		 buf[MAXPATHLEN];
d938 2
a939 2
			sz = strlcpy(buf, of->file, MAXPATHLEN);
			if (sz >= MAXPATHLEN) {
d950 1
a950 1
			strlcat(buf, of->dsec, MAXPATHLEN);
d1878 1
a1878 1
	char		 file[MAXPATHLEN];
d1894 2
a1895 2
	strlcpy(file, MANDOC_DB, MAXPATHLEN);
	strlcat(file, "~", MAXPATHLEN);
d1911 1
a1911 1
	char		 file[MAXPATHLEN];
d1919 1
a1919 1
	sz = strlcpy(file, MANDOC_DB, MAXPATHLEN);
d1921 1
a1921 1
		sz = strlcat(file, "~", MAXPATHLEN);
d1923 1
a1923 1
	if (sz >= MAXPATHLEN) {
@


1.56
log
@Starting the preparations to integrate this into OpenBSD.
As variadic macros are not supported on all architectures,
replace them by a real function.  While here,
* choose a more logical order for "dir" and "file" arguments
* choose a more logical order when printing; as a bonus,
  a simple sed 's/:.*//' will get you valid file names
* in ofmerge(), skip diagnostic string comparisons
  when we don't want warnings anyway
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.55 2012/06/09 14:11:16 kristaps Exp $ */
d1936 1
a1936 1
		return(1);
d1974 2
@


1.55
log
@Merge whatis.1 into apropos.1 (and remove), add whatis bits to apropos
(via mansearch), and merge mandocdb.h into mansearch.h (and remove).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.54 2012/06/09 11:21:12 kristaps Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
a49 17
/* Post a warning to stderr. */
#define WARNING(_f, _b, _fmt, _args...) \
	do if (warnings) { \
		fprintf(stderr, "%s: ", (_b)); \
		fprintf(stderr, (_fmt), ##_args); \
		if ('\0' != *(_f)) \
			fprintf(stderr, ": %s", (_f)); \
		fprintf(stderr, "\n"); \
	} while (/* CONSTCOND */ 0)
/* Post a "verbose" message to stderr. */
#define	DEBUG(_f, _b, _fmt, _args...) \
	do if (verb) { \
		fprintf(stderr, "%s: ", (_b)); \
		fprintf(stderr, (_fmt), ##_args); \
		fprintf(stderr, ": %s\n", (_f)); \
	} while (/* CONSTCOND */ 0)

d165 1
d587 2
a588 1
				WARNING(path, base, "Extraneous file");
d591 2
a592 1
				WARNING(path, base, "Duplicate file");
d599 2
a600 1
				WARNING(path, base, "Skip database");
d604 2
a605 1
					WARNING(path, base, "Skip html");
d608 2
a609 1
					WARNING(path, base, "Skip gz");
d612 2
a613 1
					WARNING(path, base, "Skip ps");
d616 2
a617 1
					WARNING(path, base, "Skip pdf");
d661 2
a662 1
			WARNING(path, base, "Unknown directory part");
d677 2
a678 1
			WARNING(path, base, "Extraneous directory part");
d717 2
a718 1
		WARNING(file, base, "%s", strerror(errno));
d721 2
a722 1
		WARNING(file, base, "Not a regular file");
d725 2
a726 1
		WARNING(file, base, "Duplicate file");
d940 3
a942 2
				WARNING(of->file, base, 
					"Filename too long");
d952 3
a954 2
				WARNING(of->file, base, "Man "
					"source exists: %s", buf);
d1007 3
a1009 2
		if ( ! use_all && form && strcasecmp(msec, of->dsec))
			WARNING(of->file, base, "Section \"%s\" "
d1027 2
a1028 2
		if ( ! use_all && strcasecmp(march, of->arch))
			WARNING(of->file, base, "Architecture \"%s\" "
d1057 2
a1058 1
		WARNING(of->file, base, "%s", strerror(errno));
d1110 2
a1111 1
		WARNING(of->file, base, "Cannot find NAME section");
d1130 2
a1131 1
		WARNING(of->file, base, "No dash in title line");
d1809 2
a1810 1
	DEBUG(of->file, base, "Adding to index");
d1865 2
a1866 1
		DEBUG(of->file, base, "Deleted from index");
d2019 17
@


1.54
log
@Ths SYNCHRONOUS = off optimisation fails on my Mac OSX.  Take it out until
I can test properly for this feature.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.53 2012/06/09 11:00:13 kristaps Exp $ */
a46 1
#include "mandocdb.h"
d48 1
@


1.53
log
@Add a compatibility interface for ohash.
This include's espie@@'s wholesale src/lib/libc/ohash directory from OpenBSD
into compat_ohash.c (with a single copyright/license notice at the top)
and src/include/ohash.h as compat_ohash.h.
The ohash_int.h part of compat_ohash.c has been changed only in that ohash.h
points to compat_ohash.h.
Added HAVE_OHASH test (test-ohash.c) to Makefile.
In mandocdb.c and mansearch.c, check HAVE_OHASH test for inclusion.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.52 2012/06/08 15:06:28 kristaps Exp $ */
d512 1
d514 1
@


1.52
log
@Turn off sqlite3 synchronous mode when creating a new database.
This makes it run about 5x faster.
While here, wrap some sqlite3 statements in #defines to extract errors.
(Really, the warning/error/etc. macros should be functionified.)
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.51 2012/06/08 12:05:27 kristaps Exp $ */
d37 1
d39 3
d334 1
d529 2
a530 2
	for (s = ohash_first(&strings, &ch);
			NULL != s; s = ohash_next(&strings, &ch)) {
@


1.51
log
@Use C99 syntax for declaring the string-hash key array.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.50 2012/06/08 10:43:01 kristaps Exp $ */
d63 19
d501 8
d1798 1
d1814 1
a1814 1
	sqlite3_exec(db, "BEGIN TRANSACTION", NULL, NULL, NULL);
d1816 7
a1822 15
	sqlite3_bind_text
		(stmts[STMT_INSERT_DOC], 1, 
		 of->file, -1, SQLITE_STATIC);
	sqlite3_bind_text
		(stmts[STMT_INSERT_DOC], 2, 
		 of->sec, -1, SQLITE_STATIC);
	sqlite3_bind_text
		(stmts[STMT_INSERT_DOC], 3, 
		 of->arch, -1, SQLITE_STATIC);
	sqlite3_bind_text
		(stmts[STMT_INSERT_DOC], 4, 
		 desc, -1, SQLITE_STATIC);
	sqlite3_bind_int
		(stmts[STMT_INSERT_DOC], 5, form);
	sqlite3_step(stmts[STMT_INSERT_DOC]);
d1830 5
a1834 8
		sqlite3_bind_int64
			(stmts[STMT_INSERT_KEY], 1, key->mask);
		sqlite3_bind_text
			(stmts[STMT_INSERT_KEY], 2, 
			 key->utf8, -1, SQLITE_STATIC);
		sqlite3_bind_int64
			(stmts[STMT_INSERT_KEY], 3, recno);
		sqlite3_step(stmts[STMT_INSERT_KEY]);
d1838 1
a1838 2
	sqlite3_exec(db, "COMMIT TRANSACTION", NULL, NULL, NULL);

d1845 1
d1851 3
a1853 4
		sqlite3_bind_text
			(stmts[STMT_DELETE], 1, 
			 of->file, -1, SQLITE_STATIC);
		sqlite3_step(stmts[STMT_DELETE]);
d1920 1
a1920 1
	ofl = SQLITE_OPEN_PRIVATECACHE | SQLITE_OPEN_READWRITE |
@


1.50
log
@Re-tooled mandocdb using sqlite3 and ohash.
See the tech@@ mailing list entries in June 2012 for details, as well as the
discuss@@ mailing list entries from March 2012.
Among other changes, this utility now:
 1.  uses a single sqlite3 database instead of several berkeley dbs
 2.  stores utf-8 encoded strings
 3.  using ohash to aggressively hash its contents
 4.  using fts() instead of manually walking directories
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49 2012/05/27 17:48:57 schwarze Exp $ */
d82 1
a82 1
	char		 key[1]; /* the string itself */
d1541 1
a1541 1
	s = mandoc_calloc(sizeof(struct str) + sz, 1);
d1588 1
a1588 1
		s = mandoc_calloc(sizeof(struct str) + sz, 1);
@


1.49
log
@Support -Ios='OpenBSD 5.1' to override uname(3) as the source of the
default value for the mdoc(7) .Os macro.
Needed for man.cgi on the OpenBSD website.

Problem with man.cgi first noticed by deraadt@@;
beck@@ and deraadt@@ agree with the way to solve the issue.

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.48 2012/05/27 17:39:28 schwarze Exp $ */
d23 1
a23 1
#include <sys/types.h>
a26 1
#include <dirent.h>
d29 1
d31 1
a31 1
#include <stdio.h>
d37 2
a38 9
#if defined(__linux__)
# include <endian.h>
# include <db_185.h>
#elif defined(__APPLE__)
# include <libkern/OSByteOrder.h>
# include <db.h>
#else
# include <db.h>
#endif
d40 1
a41 1
#include "mdoc.h"
d46 1
a46 6
#define	MANDOC_BUFSZ	  BUFSIZ
#define	MANDOC_SLOP	  1024

#define	MANDOC_SRC	  0x1
#define	MANDOC_FORM	  0x2

d55 7
a61 2
		
/* Access to the mandoc database on disk. */
d63 6
a68 5
struct	mdb {
	char		  idxn[MAXPATHLEN]; /* index db filename */
	char		  dbn[MAXPATHLEN]; /* keyword db filename */
	DB		 *idx; /* index recno database */
	DB		 *db; /* keyword btree database */
d71 5
a75 1
/* Stack of temporarily unused index records. */
d77 6
a82 5
struct	recs {
	recno_t		 *stack; /* pointer to a malloc'ed array */
	size_t		  size; /* number of allocated slots */
	size_t		  cur; /* current number of empty records */
	recno_t		  last; /* last record number in the index */
d85 4
a88 1
/* Tiny list for files.  No need to bring in QUEUE. */
d91 10
a100 7
	char		 *fname; /* heap-allocated */
	char		 *sec;
	char		 *arch;
	char		 *title;
	int		  src_form;
	struct of	 *next; /* NULL for last one */
	struct of	 *first; /* first in list */
d103 5
a107 6
/* Buffer for storing growable data. */

struct	buf {
	char		 *cp;
	size_t		  len; /* current length */
	size_t		  size; /* total buffer size */
d110 1
a110 1
/* Operation we're going to perform. */
d112 5
a116 6
enum	op {
	OP_DEFAULT = 0, /* new dbs from dir list or default config */
	OP_CONFFILE, /* new databases from custom config file */
	OP_UPDATE, /* delete/add entries in existing database */
	OP_DELETE, /* delete entries from existing database */
	OP_TEST /* change no databases, report potential problems */
d119 61
a179 51
#define	MAN_ARGS	  DB *hash, \
			  struct buf *buf, \
			  struct buf *dbuf, \
			  const struct man_node *n
#define	MDOC_ARGS	  DB *hash, \
			  struct buf *buf, \
			  struct buf *dbuf, \
			  const struct mdoc_node *n, \
			  const struct mdoc_meta *m

static	void		  buf_appendmdoc(struct buf *, 
				const struct mdoc_node *, int);
static	void		  buf_append(struct buf *, const char *);
static	void		  buf_appendb(struct buf *, 
				const void *, size_t);
static	void		  dbt_put(DB *, const char *, DBT *, DBT *);
static	void		  hash_put(DB *, const struct buf *, uint64_t);
static	void		  hash_reset(DB **);
static	void		  index_merge(const struct of *, struct mparse *,
				struct buf *, struct buf *, DB *,
				struct mdb *, struct recs *,
				const char *);
static	void		  index_prune(const struct of *, struct mdb *,
				struct recs *, const char *);
static	void		  ofile_argbuild(int, char *[],
				struct of **, const char *);
static	void		  ofile_dirbuild(const char *, const char *,
				const char *, int, struct of **, char *);
static	void		  ofile_free(struct of *);
static	void		  pformatted(DB *, struct buf *, struct buf *,
				const struct of *, const char *);
static	int		  pman_node(MAN_ARGS);
static	void		  pmdoc_node(MDOC_ARGS);
static	int		  pmdoc_head(MDOC_ARGS);
static	int		  pmdoc_body(MDOC_ARGS);
static	int		  pmdoc_Fd(MDOC_ARGS);
static	int		  pmdoc_In(MDOC_ARGS);
static	int		  pmdoc_Fn(MDOC_ARGS);
static	int		  pmdoc_Nd(MDOC_ARGS);
static	int		  pmdoc_Nm(MDOC_ARGS);
static	int		  pmdoc_Sh(MDOC_ARGS);
static	int		  pmdoc_St(MDOC_ARGS);
static	int		  pmdoc_Xr(MDOC_ARGS);

#define	MDOCF_CHILD	  0x01  /* Automatically index child nodes. */

struct	mdoc_handler {
	int		(*fp)(MDOC_ARGS);  /* Optional handler. */
	uint64_t	  mask;  /* Set unless handler returns 0. */
	int		  flags;  /* For use by pmdoc_node. */
};
d186 2
a187 2
	{ pmdoc_Sh, TYPE_Sh, MDOCF_CHILD }, /* Sh */
	{ pmdoc_head, TYPE_Ss, MDOCF_CHILD }, /* Ss */
d206 1
a206 1
	{ pmdoc_Fd, TYPE_In, 0 },  /* Fd */
d208 1
a208 1
	{ pmdoc_Fn, 0, 0 },  /* Fn */
d211 1
a211 1
	{ pmdoc_In, TYPE_In, 0 },  /* In */
d213 2
a214 2
	{ pmdoc_Nd, TYPE_Nd, MDOCF_CHILD },  /* Nd */
	{ pmdoc_Nm, TYPE_Nm, MDOCF_CHILD },  /* Nm */
d219 1
a219 1
	{ pmdoc_St, TYPE_St, 0 },  /* St */
d221 2
a222 2
	{ pmdoc_body, TYPE_Va, MDOCF_CHILD },  /* Vt */
	{ pmdoc_Xr, TYPE_Xr, 0 },  /* Xr */
d278 1
a278 1
	{ pmdoc_head, TYPE_Fn, 0 },  /* Fo */
a305 5
static	const char	 *progname;
static	int		  use_all;  /* Use all directories and files. */
static	int		  verb;  /* Output verbosity level. */
static	int		  warnings;  /* Potential problems in manuals. */

d309 23
a331 16
	struct mparse	*mp; /* parse sequence */
	struct manpaths	 dirs;
	struct mdb	 mdb;
	struct recs	 recs;
	enum op		 op; /* current operation */
	const char	*dir;
	int		 ch, i, flags;
	char		 dirbuf[MAXPATHLEN];
	DB		*hash; /* temporary keyword hashtable */
	BTREEINFO	 info; /* btree configuration */
	size_t		 sz1, sz2;
	struct buf	 buf, /* keyword buffer */
			 dbuf; /* description buffer */
	struct of	*of; /* list of files for processing */
	extern int	 optind;
	extern char	*optarg;
d339 24
a362 3
	memset(&dirs, 0, sizeof(struct manpaths));
	memset(&mdb, 0, sizeof(struct mdb));
	memset(&recs, 0, sizeof(struct recs));
d364 1
a364 3
	of = NULL;
	mp = NULL;
	hash = NULL;
a365 1
	dir = NULL;
d367 1
a367 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:tu:vW")))
d373 1
a373 5
			if (op) {
				fprintf(stderr,
				    "-C: conflicting options\n");
				goto usage;
			}
d378 1
a378 5
			if (op) {
				fprintf(stderr,
				    "-d: conflicting options\n");
				goto usage;
			}
d382 3
d386 1
a387 5
			if (op) {
				fprintf(stderr,
				    "-t: conflicting options\n");
				goto usage;
			}
d389 1
a389 2
			use_all = 1;
			warnings = 1;
d392 1
a392 5
			if (op) {
				fprintf(stderr,
				    "-u: conflicting options\n");
				goto usage;
			}
d410 1
a410 1
		fprintf(stderr, "-C: too many arguments\n");
d414 182
a595 3
	memset(&info, 0, sizeof(BTREEINFO));
	info.lorder = 4321;
	info.flags = R_DUP;
d597 11
a607 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL, NULL);
d609 15
a623 2
	memset(&buf, 0, sizeof(struct buf));
	memset(&dbuf, 0, sizeof(struct buf));
d625 7
a631 1
	buf.size = dbuf.size = MANDOC_BUFSZ;
d633 2
a634 2
	buf.cp = mandoc_malloc(buf.size);
	dbuf.cp = mandoc_malloc(dbuf.size);
d636 18
a653 21
	if (OP_TEST == op) {
		ofile_argbuild(argc, argv, &of, ".");
		if (NULL == of)
			goto out;
		index_merge(of, mp, &dbuf, &buf,
				hash, &mdb, &recs, ".");
		goto out;
	}

	if (OP_UPDATE == op || OP_DELETE == op) {
		strlcat(mdb.dbn, dir, MAXPATHLEN);
		strlcat(mdb.dbn, "/", MAXPATHLEN);
		sz1 = strlcat(mdb.dbn, MANDOC_DB, MAXPATHLEN);

		strlcat(mdb.idxn, dir, MAXPATHLEN);
		strlcat(mdb.idxn, "/", MAXPATHLEN);
		sz2 = strlcat(mdb.idxn, MANDOC_IDX, MAXPATHLEN);

		if (sz1 >= MAXPATHLEN || sz2 >= MAXPATHLEN) {
			fprintf(stderr, "%s: path too long\n", dir);
			exit((int)MANDOCLEVEL_BADARG);
d655 5
d661 22
a682 11
		flags = O_CREAT | O_RDWR;
		mdb.db = dbopen(mdb.dbn, flags, 0644, DB_BTREE, &info);
		mdb.idx = dbopen(mdb.idxn, flags, 0644, DB_RECNO, NULL);

		if (NULL == mdb.db) {
			perror(mdb.dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		} else if (NULL == mdb.idx) {
			perror(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d684 1
a684 1
		ofile_argbuild(argc, argv, &of, dir);
d686 2
a687 2
		if (NULL == of)
			goto out;
d689 10
a698 1
		index_prune(of, &mdb, &recs, dir);
d700 4
a703 5
		/*
		 * Go to the root of the respective manual tree.
		 * This must work or no manuals may be found (they're
		 * indexed relative to the root).
		 */
d705 14
a718 7
		if (OP_UPDATE == op) {
			if (-1 == chdir(dir)) {
				perror(dir);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			index_merge(of, mp, &dbuf, &buf, hash,
					&mdb, &recs, dir);
d721 19
a739 1
		goto out;
d743 2
a744 3
	 * Configure the directories we're going to scan.
	 * If we have command-line arguments, use them.
	 * If not, we use man(1)'s method (see mandocdb.8).
d746 17
d764 3
a766 7
	if (argc > 0) {
		dirs.paths = mandoc_calloc(argc, sizeof(char *));
		dirs.sz = argc;
		for (i = 0; i < argc; i++) 
			dirs.paths[i] = mandoc_strdup(argv[i]);
	} else
		manpath_parse(&dirs, dir, NULL, NULL);
d768 8
a775 6
	for (i = 0; i < dirs.sz; i++) {
		/*
		 * Go to the root of the respective manual tree.
		 * This must work or no manuals may be found:
		 * They are indexed relative to the root.
		 */
d777 4
a780 4
		if (-1 == chdir(dirs.paths[i])) {
			perror(dirs.paths[i]);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d782 15
a796 2
		strlcpy(mdb.dbn, MANDOC_DB, MAXPATHLEN);
		strlcpy(mdb.idxn, MANDOC_IDX, MAXPATHLEN);
d798 2
a799 11
		flags = O_CREAT | O_TRUNC | O_RDWR;
		mdb.db = dbopen(mdb.dbn, flags, 0644, DB_BTREE, &info);
		mdb.idx = dbopen(mdb.idxn, flags, 0644, DB_RECNO, NULL);

		if (NULL == mdb.db) {
			perror(mdb.dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		} else if (NULL == mdb.idx) {
			perror(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d801 10
a810 3
		/*
		 * Search for manuals and fill the new database.
		 */
d812 4
a815 2
		strlcpy(dirbuf, dirs.paths[i], MAXPATHLEN);
	       	ofile_dirbuild(".", "", "", 0, &of, dirbuf);
d817 3
a819 6
		if (NULL != of) {
			index_merge(of, mp, &dbuf, &buf, hash,
			     &mdb, &recs, dirs.paths[i]);
			ofile_free(of);
			of = NULL;
		}
d821 37
a857 5
		(*mdb.db->close)(mdb.db);
		(*mdb.idx->close)(mdb.idx);
		mdb.db = NULL;
		mdb.idx = NULL;
	}
d859 8
a866 9
out:
	if (mdb.db)
		(*mdb.db->close)(mdb.db);
	if (mdb.idx)
		(*mdb.idx->close)(mdb.idx);
	if (hash)
		(*hash->close)(hash);
	if (mp)
		mparse_free(mp);
d868 4
a871 5
	manpath_free(&dirs);
	ofile_free(of);
	free(buf.cp);
	free(dbuf.cp);
	free(recs.stack);
d873 5
a877 1
	return(MANDOCLEVEL_OK);
d879 12
a890 21
usage:
	fprintf(stderr,
		"usage: %s [-av] [-C file] | dir ... | -t file ...\n"
		"                        -d dir [file ...] | "
		"-u dir [file ...]\n",
		progname);

	return((int)MANDOCLEVEL_BADARG);
}

void
index_merge(const struct of *of, struct mparse *mp,
		struct buf *dbuf, struct buf *buf, DB *hash,
		struct mdb *mdb, struct recs *recs,
		const char *basedir)
{
	recno_t		 rec;
	int		 ch, skip;
	DBT		 key, val;
	DB		*files;  /* temporary file name table */
	char	 	 emptystring[1] = {'\0'};
d893 42
a934 16
	char		*p;
	const char	*fn, *msec, *march, *mtitle;
	uint64_t	 mask;
	size_t		 sv;
	unsigned	 seq;
	uint64_t	 vbuf[2];
	char		 type;

	if (warnings) {
		files = NULL;
		hash_reset(&files);
	}

	rec = 0;
	for (of = of->first; of; of = of->next) {
		fn = of->fname;
d941 5
a945 9

		mparse_reset(mp);
		mdoc = NULL;
		man = NULL;

		if ((MANDOC_SRC & of->src_form ||
		    ! (MANDOC_FORM & of->src_form)) &&
		    MANDOCLEVEL_FATAL > mparse_readfd(mp, -1, fn))
			mparse_result(mp, &mdoc, &man);
d948 1
a950 2
			if (NULL == march)
				march = "";
d953 1
d957 8
a964 5
		} else {
			msec = of->sec;
			march = of->arch;
			mtitle = of->title;
		}
d975 4
a979 6
		skip = 0;
		assert(of->sec);
		assert(msec);
		if (strcasecmp(msec, of->sec))
			WARNING(fn, basedir, "Section \"%s\" manual "
				"in \"%s\" directory", msec, of->sec);
d994 2
a995 5

		assert(of->arch);
		assert(march);
		if (strcasecmp(march, of->arch))
			WARNING(fn, basedir, "Architecture \"%s\" "
d999 1
a999 5
		/*
		 * By default, skip a file if the title given
		 * in the file disagrees with the file name.
		 * Do not warn, this happens for all MLINKs.
		 */
d1001 8
a1008 4
		assert(of->title);
		assert(mtitle);
		if (strcasecmp(mtitle, of->title))
			skip = 1;
d1010 2
a1011 5
		/*
		 * Build a title string for the file.  If it matches
		 * the location of the file, remember the title as
		 * found; else, remember it as missing.
		 */
d1013 2
a1014 35
		if (warnings) {
			buf->len = 0;
			buf_appendb(buf, mtitle, strlen(mtitle));
			buf_appendb(buf, "(", 1);
			buf_appendb(buf, msec, strlen(msec));
			if ('\0' != *march) {
				buf_appendb(buf, "/", 1);
				buf_appendb(buf, march, strlen(march));
			}
			buf_appendb(buf, ")", 2);
			for (p = buf->cp; '\0' != *p; p++)
				*p = tolower(*p);
			key.data = buf->cp;
			key.size = buf->len;
			val.data = NULL;
			val.size = 0;
			if (0 == skip)
				val.data = emptystring;
			else {
				ch = (*files->get)(files, &key, &val, 0);
				if (ch < 0) {
					perror("hash");
					exit((int)MANDOCLEVEL_SYSERR);
				} else if (ch > 0) {
					val.data = (void *)fn;
					val.size = strlen(fn) + 1;
				} else
					val.data = NULL;
			}
			if (NULL != val.data &&
			    (*files->put)(files, &key, &val, 0) < 0) {
				perror("hash");
				exit((int)MANDOCLEVEL_SYSERR);
			}
		}
d1016 6
a1021 2
		if (skip && !use_all)
			continue;
d1023 4
a1026 9
		/*
		 * The index record value consists of a nil-terminated
		 * filename, a nil-terminated manual section, and a
		 * nil-terminated description.  Use the actual
		 * location of the file, such that the user can find
		 * it with man(1).  Since the description may not be
		 * set, we set a sentinel to see if we're going to
		 * write a nil byte in its place.
		 */
d1028 1
a1028 7
		dbuf->len = 0;
		type = mdoc ? 'd' : (man ? 'a' : 'c');
		buf_appendb(dbuf, &type, 1);
		buf_appendb(dbuf, fn, strlen(fn) + 1);
		buf_appendb(dbuf, of->sec, strlen(of->sec) + 1);
		buf_appendb(dbuf, of->title, strlen(of->title) + 1);
		buf_appendb(dbuf, of->arch, strlen(of->arch) + 1);
d1030 3
a1032 1
		sv = dbuf->len;
d1034 4
a1037 4
		/*
		 * Collect keyword/mask pairs.
		 * Each pair will become a new btree node.
		 */
d1039 10
a1048 8
		hash_reset(&hash);
		if (mdoc)
			pmdoc_node(hash, buf, dbuf,
				mdoc_node(mdoc), mdoc_meta(mdoc));
		else if (man)
			pman_node(hash, buf, dbuf, man_node(man));
		else
			pformatted(hash, buf, dbuf, of, basedir);
d1050 2
a1051 1
		/* Test mode, do not access any database. */
d1053 8
a1060 1
		if (NULL == mdb->db || NULL == mdb->idx)
d1062 5
d1068 6
a1073 7
		/*
		 * Make sure the file name is always registered
		 * as an .Nm search key.
		 */
		buf->len = 0;
		buf_append(buf, of->title);
		hash_put(hash, buf, TYPE_Nm);
d1075 6
a1080 4
		/*
		 * Reclaim an empty index record, if available.
		 * Use its record number for all new btree nodes.
		 */
d1082 2
a1083 9
		if (recs->cur > 0) {
			recs->cur--;
			rec = recs->stack[(int)recs->cur];
		} else if (recs->last > 0) {
			rec = recs->last;
			recs->last = 0;
		} else
			rec++;
		vbuf[1] = htobe64(rec);
d1085 5
a1089 4
		/*
		 * Copy from the in-memory hashtable of pending
		 * keyword/mask pairs into the database.
		 */
d1091 7
a1097 14
		seq = R_FIRST;
		while (0 == (ch = (*hash->seq)(hash, &key, &val, seq))) {
			seq = R_NEXT;
			assert(sizeof(uint64_t) == val.size);
			memcpy(&mask, val.data, val.size);
			vbuf[0] = htobe64(mask);
			val.size = sizeof(vbuf);
			val.data = &vbuf;
			dbt_put(mdb->db, mdb->dbn, &key, &val);
		}
		if (ch < 0) {
			perror("hash");
			exit((int)MANDOCLEVEL_SYSERR);
		}
d1099 1
a1099 4
		/*
		 * Apply to the index.  If we haven't had a description
		 * set, put an empty one in now.
		 */
d1101 1
a1101 2
		if (dbuf->len == sv)
			buf_appendb(dbuf, "", 1);
d1103 9
a1111 2
		key.data = &rec;
		key.size = sizeof(recno_t);
d1113 5
a1117 2
		val.data = dbuf->cp;
		val.size = dbuf->len;
d1119 6
a1124 2
		if (verb)
			printf("%s: Adding to index: %s\n", basedir, fn);
d1126 3
a1128 2
		dbt_put(mdb->idx, mdb->idxn, &key, &val);
	}
d1130 6
a1135 4
	/*
	 * Iterate the remembered file titles and check that
	 * all files can be found by their main title.
	 */
d1137 1
a1137 11
	if (warnings) {
		seq = R_FIRST;
		while (0 == (*files->seq)(files, &key, &val, seq)) {
			seq = R_NEXT;
			if (val.size)
				WARNING((char *)val.data, basedir,
					"Probably unreachable, title "
					"is %s", (char *)key.data);
		}
		(*files->close)(files);
	}
d1141 1
a1141 4
 * Scan through all entries in the index file `idx' and prune those
 * entries in `ofile'.
 * Pruning consists of removing from `db', then invalidating the entry
 * in `idx' (zeroing its value size).
d1144 1
a1144 2
index_prune(const struct of *ofile, struct mdb *mdb,
		struct recs *recs, const char *basedir)
a1145 13
	const struct of	*of;
	const char	*fn;
	uint64_t	 vbuf[2];
	unsigned	 seq, sseq;
	DBT		 key, val;
	int		 ch;

	recs->cur = 0;
	seq = R_FIRST;
	while (0 == (ch = (*mdb->idx->seq)(mdb->idx, &key, &val, seq))) {
		seq = R_NEXT;
		assert(sizeof(recno_t) == key.size);
		memcpy(&recs->last, key.data, key.size);
d1147 7
a1153 1
		/* Deleted records are zero-sized.  Skip them. */
d1155 7
a1161 2
		if (0 == val.size)
			goto cont;
d1163 2
a1164 6
		/*
		 * Make sure we're sane.
		 * Read past our mdoc/man/cat type to the next string,
		 * then make sure it's bounded by a NUL.
		 * Failing any of these, we go into our error handler.
		 */
d1166 6
a1171 3
		fn = (char *)val.data + 1;
		if (NULL == memchr(fn, '\0', val.size - 1))
			break;
d1173 10
a1182 4
		/*
		 * Search for the file in those we care about.
		 * XXX: build this into a tree.  Too slow.
		 */
d1184 2
a1185 3
		for (of = ofile->first; of; of = of->next)
			if (0 == strcmp(fn, of->fname))
				break;
d1187 6
a1192 2
		if (NULL == of)
			continue;
d1194 13
a1206 4
		/*
		 * Search through the keyword database, throwing out all
		 * references to our file.
		 */
d1208 2
a1209 6
		sseq = R_FIRST;
		while (0 == (ch = (*mdb->db->seq)(mdb->db,
					&key, &val, sseq))) {
			sseq = R_NEXT;
			if (sizeof(vbuf) != val.size)
				break;
d1211 1
a1211 3
			memcpy(vbuf, val.data, val.size);
			if (recs->last != betoh64(vbuf[1]))
				continue;
d1213 3
a1215 4
			if ((ch = (*mdb->db->del)(mdb->db,
					&key, R_CURSOR)) < 0)
				break;
		}
d1217 4
a1220 8
		if (ch < 0) {
			perror(mdb->dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		} else if (1 != ch) {
			fprintf(stderr, "%s: corrupt database\n",
					mdb->dbn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d1222 1
a1222 3
		if (verb)
			printf("%s: Deleting from index: %s\n",
					basedir, fn);
d1224 3
a1226 2
		val.size = 0;
		ch = (*mdb->idx->put)(mdb->idx, &key, &val, R_CURSOR);
d1228 4
a1231 8
		if (ch < 0)
			break;
cont:
		if (recs->cur >= recs->size) {
			recs->size += MANDOC_SLOP;
			recs->stack = mandoc_realloc(recs->stack,
					recs->size * sizeof(recno_t));
		}
d1233 1
a1233 3
		recs->stack[(int)recs->cur] = recs->last;
		recs->cur++;
	}
d1235 7
a1241 7
	if (ch < 0) {
		perror(mdb->idxn);
		exit((int)MANDOCLEVEL_SYSERR);
	} else if (1 != ch) {
		fprintf(stderr, "%s: corrupt index\n", mdb->idxn);
		exit((int)MANDOCLEVEL_SYSERR);
	}
d1243 4
a1246 2
	recs->last++;
}
d1248 2
a1249 6
/*
 * Grow the buffer (if necessary) and copy in a binary string.
 */
static void
buf_appendb(struct buf *buf, const void *cp, size_t sz)
{
d1251 1
a1251 1
	/* Overshoot by MANDOC_BUFSZ. */
d1253 4
a1256 4
	while (buf->len + sz >= buf->size) {
		buf->size = buf->len + sz + MANDOC_BUFSZ;
		buf->cp = mandoc_realloc(buf->cp, buf->size);
	}
d1258 5
a1262 3
	memcpy(buf->cp + (int)buf->len, cp, sz);
	buf->len += sz;
}
d1264 5
a1268 10
/*
 * Append a nil-terminated string to the buffer.  
 * This can be invoked multiple times.  
 * The buffer string will be nil-terminated.
 * If invoked multiple times, a space is put between strings.
 */
static void
buf_append(struct buf *buf, const char *cp)
{
	size_t		 sz;
d1270 2
a1271 2
	if (0 == (sz = strlen(cp)))
		return;
d1273 10
a1282 2
	if (buf->len)
		buf->cp[(int)buf->len - 1] = ' ';
d1284 2
a1285 2
	buf_appendb(buf, cp, sz + 1);
}
d1287 7
a1293 12
/*
 * Recursively add all text from a given node.  
 * This is optimised for general mdoc nodes in this context, which do
 * not consist of subexpressions and having a recursive call for n->next
 * would be wasteful.
 * The "f" variable should be 0 unless called from pmdoc_Nd for the
 * description buffer, which does not start at the beginning of the
 * buffer.
 */
static void
buf_appendmdoc(struct buf *buf, const struct mdoc_node *n, int f)
{
d1295 3
a1297 10
	for ( ; n; n = n->next) {
		if (n->child)
			buf_appendmdoc(buf, n->child, f);

		if (MDOC_TEXT == n->type && f) {
			f = 0;
			buf_appendb(buf, n->string, 
					strlen(n->string) + 1);
		} else if (MDOC_TEXT == n->type)
			buf_append(buf, n->string);
d1299 1
a1299 1
	}
d1303 1
a1303 1
hash_reset(DB **db)
a1304 1
	DB		*hash;
d1306 15
a1320 2
	if (NULL != (hash = *db))
		(*hash->close)(hash);
d1322 9
a1330 4
	*db = dbopen(NULL, O_CREAT|O_RDWR, 0644, DB_HASH, NULL);
	if (NULL == *db) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
a1333 17
/* ARGSUSED */
static int
pmdoc_head(MDOC_ARGS)
{

	return(MDOC_HEAD == n->type);
}

/* ARGSUSED */
static int
pmdoc_body(MDOC_ARGS)
{

	return(MDOC_BODY == n->type);
}

/* ARGSUSED */
d1335 1
a1335 1
pmdoc_Fd(MDOC_ARGS)
d1340 3
a1342 3
	if (SEC_SYNOPSIS != n->sec)
		return(0);
	if (NULL == (n = n->child) || MDOC_TEXT != n->type)
d1349 1
d1372 2
a1373 4
	assert(end >= start);

	buf_appendb(buf, start, (size_t)(end - start + 1));
	buf_appendb(buf, "", 1);
a1376 1
/* ARGSUSED */
d1378 1
a1378 1
pmdoc_In(MDOC_ARGS)
d1381 1
a1381 1
	if (NULL == n->child || MDOC_TEXT != n->child->type)
d1384 1
a1384 1
	buf_append(buf, n->child->string);
a1387 1
/* ARGSUSED */
d1389 1
a1389 1
pmdoc_Fn(MDOC_ARGS)
a1390 1
	struct mdoc_node *nn;
d1393 1
a1393 3
	nn = n->child;

	if (NULL == nn || MDOC_TEXT != nn->type)
d1396 6
a1401 5
	/* .Fn "struct type *name" "char *arg" */

	cp = strrchr(nn->string, ' ');
	if (NULL == cp)
		cp = nn->string;
d1403 2
a1404 1
	/* Strip away pointer symbol. */
d1409 1
a1409 6
	/* Store the function name. */

	buf_append(buf, cp);
	hash_put(hash, buf, TYPE_Fn);

	/* Store the function type. */
d1411 2
a1412 8
	if (nn->string < cp) {
		buf->len = 0;
		buf_appendb(buf, nn->string, cp - nn->string);
		buf_appendb(buf, "", 1);
		hash_put(hash, buf, TYPE_Ft);
	}

	/* Store the arguments. */
d1414 3
a1416 7
	for (nn = nn->next; nn; nn = nn->next) {
		if (MDOC_TEXT != nn->type)
			continue;
		buf->len = 0;
		buf_append(buf, nn->string);
		hash_put(hash, buf, TYPE_Fa);
	}
a1420 1
/* ARGSUSED */
d1422 1
a1422 1
pmdoc_St(MDOC_ARGS)
d1428 1
a1428 1
	buf_append(buf, n->child->string);
a1431 1
/* ARGSUSED */
d1433 1
a1433 1
pmdoc_Xr(MDOC_ARGS)
d1439 1
a1439 8
	buf_appendb(buf, n->string, strlen(n->string));

	if (NULL != (n = n->next)) {
		buf_appendb(buf, ".", 1);
		buf_appendb(buf, n->string, strlen(n->string) + 1);
	} else
		buf_appendb(buf, ".", 2);

a1442 1
/* ARGSUSED */
d1444 1
a1444 1
pmdoc_Nd(MDOC_ARGS)
d1446 2
d1452 24
a1475 1
	buf_appendmdoc(dbuf, n->child, 1);
a1478 1
/* ARGSUSED */
d1480 1
a1480 1
pmdoc_Nm(MDOC_ARGS)
a1487 3
	if (NULL == n->child)
		buf_append(buf, m->name);

a1490 1
/* ARGSUSED */
d1492 1
a1492 1
pmdoc_Sh(MDOC_ARGS)
d1498 2
a1499 2
static void
hash_put(DB *db, const struct buf *buf, uint64_t mask)
a1500 3
	uint64_t	 oldmask;
	DBT		 key, val;
	int		 rc;
d1502 2
a1503 2
	if (buf->len < 2)
		return;
d1505 3
a1507 2
	key.data = buf->cp;
	key.size = buf->len;
d1509 1
a1509 16
	if ((rc = (*db->get)(db, &key, &val, 0)) < 0) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	} else if (0 == rc) {
		assert(sizeof(uint64_t) == val.size);
		memcpy(&oldmask, val.data, val.size);
		mask |= oldmask;
	}

	val.data = &mask;
	val.size = sizeof(uint64_t); 

	if ((rc = (*db->put)(db, &key, &val, 0)) < 0) {
		perror("hash");
		exit((int)MANDOCLEVEL_SYSERR);
	} 
d1512 5
a1516 2
static void
dbt_put(DB *db, const char *dbn, DBT *key, DBT *val)
d1519 1
a1519 9
	assert(key->size);
	assert(val->size);

	if (0 == (*db->put)(db, key, val, 0))
		return;
	
	perror(dbn);
	exit((int)MANDOCLEVEL_SYSERR);
	/* NOTREACHED */
d1523 7
a1529 2
 * Call out to per-macro handlers after clearing the persistent database
 * key.  If the macro sets the database key, flush it to the database.
d1531 2
a1532 2
static void
pmdoc_node(MDOC_ARGS)
d1534 6
d1541 2
a1542 2
	if (NULL == n)
		return;
d1544 6
a1549 11
	switch (n->type) {
	case (MDOC_HEAD):
		/* FALLTHROUGH */
	case (MDOC_BODY):
		/* FALLTHROUGH */
	case (MDOC_TAIL):
		/* FALLTHROUGH */
	case (MDOC_BLOCK):
		/* FALLTHROUGH */
	case (MDOC_ELEM):
		buf->len = 0;
d1551 5
a1555 5
		/*
		 * Both NULL handlers and handlers returning true
		 * request using the data.  Only skip the element
		 * when the handler returns false.
		 */
d1557 4
a1560 3
		if (NULL != mdocs[n->tok].fp &&
		    0 == (*mdocs[n->tok].fp)(hash, buf, dbuf, n, m))
			break;
d1562 16
a1577 5
		/*
		 * For many macros, use the text from all children.
		 * Set zero flags for macros not needing this.
		 * In that case, the handler must fill the buffer.
		 */
d1579 2
a1580 2
		if (MDOCF_CHILD & mdocs[n->tok].flags)
			buf_appendmdoc(buf, n->child, 0);
d1582 1
a1582 6
		/*
		 * Cover the most common case:
		 * Automatically stage one string per element.
		 * Set a zero mask for macros not needing this.
		 * Additional staging can be done in the handler.
		 */
d1584 10
a1593 5
		if (mdocs[n->tok].mask)
			hash_put(hash, buf, mdocs[n->tok].mask);
		break;
	default:
		break;
d1596 4
a1599 2
	pmdoc_node(hash, buf, dbuf, n->child, m);
	pmdoc_node(hash, buf, dbuf, n->next, m);
d1602 8
a1609 2
static int
pman_node(MAN_ARGS)
d1611 1
a1611 3
	const struct man_node *head, *body;
	char		*start, *sv, *title;
	size_t		 sz, titlesz;
d1613 35
a1647 1
	if (NULL == n)
d1650 3
a1652 6
	/*
	 * We're only searching for one thing: the first text child in
	 * the BODY of a NAME section.  Since we don't keep track of
	 * sections in -man, run some hoops to find out whether we're in
	 * the correct section or not.
	 */
d1654 21
a1674 10
	if (MAN_BODY == n->type && MAN_SH == n->tok) {
		body = n;
		assert(body->parent);
		if (NULL != (head = body->parent->head) &&
				1 == head->nchild &&
				NULL != (head = (head->child)) &&
				MAN_TEXT == head->type &&
				0 == strcmp(head->string, "NAME") &&
				NULL != (body = body->child) &&
				MAN_TEXT == body->type) {
d1676 2
a1677 21
			title = NULL;
			titlesz = 0;
			/*
			 * Suck the entire NAME section into memory.
			 * Yes, we might run away.
			 * But too many manuals have big, spread-out
			 * NAME sections over many lines.
			 */
			for ( ; NULL != body; body = body->next) {
				if (MAN_TEXT != body->type)
					break;
				if (0 == (sz = strlen(body->string)))
					continue;
				title = mandoc_realloc
					(title, titlesz + sz + 1);
				memcpy(title + titlesz, body->string, sz);
				titlesz += sz + 1;
				title[(int)titlesz - 1] = ' ';
			}
			if (NULL == title)
				return(0);
d1679 8
a1686 2
			title = mandoc_realloc(title, titlesz + 1);
			title[(int)titlesz] = '\0';
d1688 1
a1688 1
			/* Skip leading space.  */
d1690 2
a1691 3
			sv = title;
			while (isspace((unsigned char)*sv))
				sv++;
d1693 11
a1703 4
			if (0 == (sz = strlen(sv))) {
				free(title);
				return(0);
			}
d1705 10
a1714 1
			/* Erase trailing space. */
d1716 1
a1716 3
			start = &sv[sz - 1];
			while (start > sv && isspace((unsigned char)*start))
				*start-- = '\0';
d1718 2
a1719 4
			if (start == sv) {
				free(title);
				return(0);
			}
d1721 8
a1728 1
			start = sv;
d1730 4
a1733 9
			/* 
			 * Go through a special heuristic dance here.
			 * This is why -man manuals are great!
			 * (I'm being sarcastic: my eyes are bleeding.)
			 * Conventionally, one or more manual names are
			 * comma-specified prior to a whitespace, then a
			 * dash, then a description.  Try to puzzle out
			 * the name parts here.
			 */
d1735 7
a1741 4
			for ( ;; ) {
				sz = strcspn(start, " ,");
				if ('\0' == start[(int)sz])
					break;
d1743 1
a1743 3
				buf->len = 0;
				buf_appendb(buf, start, sz);
				buf_appendb(buf, "", 1);
d1745 2
a1746 1
				hash_put(hash, buf, TYPE_Nm);
d1748 1
a1748 4
				if (' ' == start[(int)sz]) {
					start += (int)sz + 1;
					break;
				}
d1750 2
a1751 38
				assert(',' == start[(int)sz]);
				start += (int)sz + 1;
				while (' ' == *start)
					start++;
			}

			buf->len = 0;

			if (sv == start) {
				buf_append(buf, start);
				free(title);
				return(1);
			}

			while (isspace((unsigned char)*start))
				start++;

			if (0 == strncmp(start, "-", 1))
				start += 1;
			else if (0 == strncmp(start, "\\-\\-", 4))
				start += 4;
			else if (0 == strncmp(start, "\\-", 2))
				start += 2;
			else if (0 == strncmp(start, "\\(en", 4))
				start += 4;
			else if (0 == strncmp(start, "\\(em", 4))
				start += 4;

			while (' ' == *start)
				start++;

			sz = strlen(start) + 1;
			buf_appendb(dbuf, start, sz);
			buf_appendb(buf, start, sz);

			hash_put(hash, buf, TYPE_Nd);
			free(title);
		}
d1754 2
a1755 5
	for (n = n->child; n; n = n->next)
		if (pman_node(hash, buf, dbuf, n))
			return(1);

	return(0);
d1759 4
a1762 2
 * Parse a formatted manual page.
 * By necessity, this involves rather crude guesswork.
d1765 2
a1766 2
pformatted(DB *hash, struct buf *buf, struct buf *dbuf, 
		const struct of *of, const char *basedir)
d1768 3
a1770 21
	FILE		*stream;
	char		*line, *p, *title;
	size_t		 len, plen, titlesz;

	if (NULL == (stream = fopen(of->fname, "r"))) {
		WARNING(of->fname, basedir, "%s", strerror(errno));
		return;
	}

	/*
	 * Always use the title derived from the filename up front,
	 * do not even try to find it in the file.  This also makes
	 * sure we don't end up with an orphan index record, even if
	 * the file content turns out to be completely unintelligible.
	 */

	buf->len = 0;
	buf_append(buf, of->title);
	hash_put(hash, buf, TYPE_Nm);

	/* Skip to first blank line. */
d1772 1
a1772 22
	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' == *line)
			break;

	/*
	 * Assume the first line that is not indented
	 * is the first section header.  Skip to it.
	 */

	while (NULL != (line = fgetln(stream, &len)))
		if ('\n' != *line && ' ' != *line)
			break;
	
	/*
	 * Read up until the next section into a buffer.
	 * Strip the leading and trailing newline from each read line,
	 * appending a trailing space.
	 * Ignore empty (whitespace-only) lines.
	 */

	titlesz = 0;
	title = NULL;
d1774 1
a1774 29
	while (NULL != (line = fgetln(stream, &len))) {
		if (' ' != *line || '\n' != line[(int)len - 1])
			break;
		while (len > 0 && isspace((unsigned char)*line)) {
			line++;
			len--;
		}
		if (1 == len)
			continue;
		title = mandoc_realloc(title, titlesz + len);
		memcpy(title + titlesz, line, len);
		titlesz += len;
		title[(int)titlesz - 1] = ' ';
	}

	/*
	 * If no page content can be found, or the input line
	 * is already the next section header, or there is no
	 * trailing newline, reuse the page title as the page
	 * description.
	 */

	if (NULL == title || '\0' == *title) {
		WARNING(of->fname, basedir, 
			"Cannot find NAME section");
		buf_appendb(dbuf, buf->cp, buf->size);
		hash_put(hash, buf, TYPE_Nd);
		fclose(stream);
		free(title);
a1775 4
	}

	title = mandoc_realloc(title, titlesz + 1);
	title[(int)titlesz] = '\0';
d1777 42
a1818 13
	/*
	 * Skip to the first dash.
	 * Use the remaining line as the description (no more than 70
	 * bytes).
	 */

	if (NULL != (p = strstr(title, "- "))) {
		for (p += 2; ' ' == *p || '\b' == *p; p++)
			/* Skip to next word. */ ;
	} else {
		WARNING(of->fname, basedir, 
			"No dash in title line");
		p = title;
d1821 1
a1821 13
	plen = strlen(p);

	/* Strip backspace-encoding from line. */

	while (NULL != (line = memchr(p, '\b', plen))) {
		len = line - p;
		if (0 == len) {
			memmove(line, line + 1, plen--);
			continue;
		} 
		memmove(line - 1, line + 1, plen - len);
		plen -= 2;
	}
a1822 6
	buf_appendb(dbuf, p, plen + 1);
	buf->len = 0;
	buf_appendb(buf, p, plen + 1);
	hash_put(hash, buf, TYPE_Nd);
	fclose(stream);
	free(title);
d1826 1
a1826 2
ofile_argbuild(int argc, char *argv[], 
		struct of **of, const char *basedir)
d1828 1
a1828 5
	char		 buf[MAXPATHLEN];
	const char	*sec, *arch, *title;
	char		*p;
	int		 i, src_form;
	struct of	*nof;
d1830 2
a1831 8
	for (i = 0; i < argc; i++) {

		/*
		 * Try to infer the manual section, architecture and
		 * page title from the path, assuming it looks like
		 *   man*[/<arch>]/<title>.<section>   or
		 *   cat<section>[/<arch>]/<title>.0
		 */
d1833 7
a1839 61
		if (strlcpy(buf, argv[i], sizeof(buf)) >= sizeof(buf)) {
			fprintf(stderr, "%s: Path too long\n", argv[i]);
			continue;
		}
		sec = arch = title = "";
		src_form = 0;
		p = strrchr(buf, '\0');
		while (p-- > buf) {
			if ('\0' == *sec && '.' == *p) {
				sec = p + 1;
				*p = '\0';
				if ('0' == *sec)
					src_form |= MANDOC_FORM;
				else if ('1' <= *sec && '9' >= *sec)
					src_form |= MANDOC_SRC;
				continue;
			}
			if ('/' != *p)
				continue;
			if ('\0' == *title) {
				title = p + 1;
				*p = '\0';
				continue;
			}
			if (0 == strncmp("man", p + 1, 3))
				src_form |= MANDOC_SRC;
			else if (0 == strncmp("cat", p + 1, 3))
				src_form |= MANDOC_FORM;
			else
				arch = p + 1;
			break;
		}
		if ('\0' == *title) {
			WARNING(argv[i], basedir, 
				"Cannot deduce title from filename");
			title = buf;
		}

		/*
		 * Build the file structure.
		 */

		nof = mandoc_calloc(1, sizeof(struct of));
		nof->fname = mandoc_strdup(argv[i]);
		nof->sec = mandoc_strdup(sec);
		nof->arch = mandoc_strdup(arch);
		nof->title = mandoc_strdup(title);
		nof->src_form = src_form;

		/*
		 * Add the structure to the list.
		 */

		if (NULL == *of) {
			*of = nof;
			(*of)->first = nof;
		} else {
			nof->first = (*of)->first;
			(*of)->next = nof;
			*of = nof;
		}
d1844 2
a1845 6
 * Recursively build up a list of files to parse.
 * We use this instead of ftw() and so on because I don't want global
 * variables hanging around.
 * This ignores the mandocdb.db and mandocdb.index files, but assumes that
 * everything else is a manual.
 * Pass in a pointer to a NULL structure for the first invocation.
d1848 1
a1848 2
ofile_dirbuild(const char *dir, const char* psec, const char *parch,
		int p_src_form, struct of **of, char *basedir)
d1850 2
a1851 8
	char		 buf[MAXPATHLEN];
	size_t		 sz;
	DIR		*d;
	const char	*fn, *sec, *arch;
	char		*p, *q, *suffix;
	struct of	*nof;
	struct dirent	*dp;
	int		 src_form;
d1853 1
a1853 2
	if (NULL == (d = opendir(dir))) {
		WARNING("", dir, "%s", strerror(errno));
d1855 4
d1861 2
a1862 2
	while (NULL != (dp = readdir(d))) {
		fn = dp->d_name;
d1864 2
a1865 2
		if ('.' == *fn)
			continue;
d1867 5
a1871 1
		src_form = p_src_form;
d1873 15
a1887 3
		if (DT_DIR == dp->d_type) {
			sec = psec;
			arch = parch;
d1889 2
a1890 5
			/*
			 * By default, only use directories called:
			 *   man<section>/[<arch>/]   or
			 *   cat<section>/[<arch>/]
			 */
d1892 3
a1894 26
			if ('\0' == *sec) {
				if(0 == strncmp("man", fn, 3)) {
					src_form |= MANDOC_SRC;
					sec = fn + 3;
				} else if (0 == strncmp("cat", fn, 3)) {
					src_form |= MANDOC_FORM;
					sec = fn + 3;
				} else {
					WARNING(fn, basedir, "Bad section");
					if (use_all)
						sec = fn;
					else
						continue;
				}
			} else if ('\0' == *arch) {
				if (NULL != strchr(fn, '.')) {
					WARNING(fn, basedir, "Bad architecture");
					if (0 == use_all)
						continue;
				}
				arch = fn;
			} else {
				WARNING(fn, basedir, "Excessive subdirectory");
				if (0 == use_all)
					continue;
			}
d1896 4
a1899 6
			buf[0] = '\0';
			strlcat(buf, dir, MAXPATHLEN);
			strlcat(buf, "/", MAXPATHLEN);
			strlcat(basedir, "/", MAXPATHLEN);
			strlcat(basedir, fn, MAXPATHLEN);
			sz = strlcat(buf, fn, MAXPATHLEN);
d1901 2
a1902 4
			if (MAXPATHLEN <= sz) {
				WARNING(fn, basedir, "Path too long");
				continue;
			}
d1904 2
a1905 2
			ofile_dirbuild(buf, sec, arch,
					src_form, of, basedir);
d1907 7
a1913 4
			p = strrchr(basedir, '/');
			*p = '\0';
			continue;
		}
d1915 2
a1916 11
		if (DT_REG != dp->d_type) {
			WARNING(fn, basedir, "Not a regular file");
			continue;
		}
		if (!strcmp(MANDOC_DB, fn) || !strcmp(MANDOC_IDX, fn))
			continue;
		if ('\0' == *psec) {
			WARNING(fn, basedir, "File outside section");
			if (0 == use_all)
				continue;
		}
d1918 4
a1921 5
		/*
		 * By default, skip files where the file name suffix
		 * does not agree with the section directory
		 * they are located in.
		 */
d1923 18
a1940 17
		suffix = strrchr(fn, '.');
		if (NULL == suffix) {
			WARNING(fn, basedir, "No filename suffix");
			if (0 == use_all)
				continue;
		} else if ((MANDOC_SRC & src_form &&
				strcmp(suffix + 1, psec)) ||
			    (MANDOC_FORM & src_form &&
				strcmp(suffix + 1, "0"))) {
			WARNING(fn, basedir, "Wrong filename suffix");
			if (0 == use_all)
				continue;
			if ('0' == suffix[1])
				src_form |= MANDOC_FORM;
			else if ('1' <= suffix[1] && '9' >= suffix[1])
				src_form |= MANDOC_SRC;
		}
d1942 4
a1945 40
		/*
		 * Skip formatted manuals if a source version is
		 * available.  Ignore the age: it is very unlikely
		 * that people install newer formatted base manuals
		 * when they used to have source manuals before,
		 * and in ports, old manuals get removed on update.
		 */
		if (0 == use_all && MANDOC_FORM & src_form &&
				'\0' != *psec) {
			buf[0] = '\0';
			strlcat(buf, dir, MAXPATHLEN);
			p = strrchr(buf, '/');
			if ('\0' != *parch && NULL != p)
				for (p--; p > buf; p--)
					if ('/' == *p)
						break;
			if (NULL == p)
				p = buf;
			else
				p++;
			if (0 == strncmp("cat", p, 3))
				memcpy(p, "man", 3);
			strlcat(buf, "/", MAXPATHLEN);
			sz = strlcat(buf, fn, MAXPATHLEN);
			if (sz >= MAXPATHLEN) {
				WARNING(fn, basedir, "Path too long");
				continue;
			}
			q = strrchr(buf, '.');
			if (NULL != q && p < q++) {
				*q = '\0';
				sz = strlcat(buf, psec, MAXPATHLEN);
				if (sz >= MAXPATHLEN) {
					WARNING(fn, basedir, "Path too long");
					continue;
				}
				if (0 == access(buf, R_OK))
					continue;
			}
		}
d1947 10
a1956 11
		buf[0] = '\0';
		assert('.' == dir[0]);
		if ('/' == dir[1]) {
			strlcat(buf, dir + 2, MAXPATHLEN);
			strlcat(buf, "/", MAXPATHLEN);
		}
		sz = strlcat(buf, fn, MAXPATHLEN);
		if (sz >= MAXPATHLEN) {
			WARNING(fn, basedir, "Path too long");
			continue;
		}
d1958 3
a1960 5
		nof = mandoc_calloc(1, sizeof(struct of));
		nof->fname = mandoc_strdup(buf);
		nof->sec = mandoc_strdup(psec);
		nof->arch = mandoc_strdup(parch);
		nof->src_form = src_form;
d1962 2
a1963 4
		/*
		 * Remember the file name without the extension,
		 * to be used as the page title in the database.
		 */
d1965 3
a1967 3
		if (NULL != suffix)
			*suffix = '\0';
		nof->title = mandoc_strdup(fn);
d1969 2
a1970 3
		/*
		 * Add the structure to the list.
		 */
d1972 3
a1974 9
		if (NULL == *of) {
			*of = nof;
			(*of)->first = nof;
		} else {
			nof->first = (*of)->first;
			(*of)->next = nof;
			*of = nof;
		}
	}
d1976 1
a1976 1
	closedir(d);
d1979 2
a1980 2
static void
ofile_free(struct of *of)
a1981 1
	struct of	*nof;
d1983 6
a1988 11
	if (NULL != of)
		of = of->first;

	while (NULL != of) {
		nof = of->next;
		free(of->fname);
		free(of->sec);
		free(of->arch);
		free(of->title);
		free(of);
		of = nof;
d1990 1
@


1.49.2.1
log
@Similar to rev. 1.58:
Consistently use the PATH_MAX since it is specified by POSIX.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49 2012/05/27 17:48:57 schwarze Exp $ */
d22 1
a30 1
#include <limits.h>
d71 2
a72 2
	char		  idxn[PATH_MAX]; /* index db filename */
	char		  dbn[PATH_MAX]; /* keyword db filename */
d308 1
a308 1
	char		 dirbuf[PATH_MAX];
d419 7
a425 7
		strlcat(mdb.dbn, dir, PATH_MAX);
		strlcat(mdb.dbn, "/", PATH_MAX);
		sz1 = strlcat(mdb.dbn, MANDOC_DB, PATH_MAX);

		strlcat(mdb.idxn, dir, PATH_MAX);
		strlcat(mdb.idxn, "/", PATH_MAX);
		sz2 = strlcat(mdb.idxn, MANDOC_IDX, PATH_MAX);
d427 1
a427 1
		if (sz1 >= PATH_MAX || sz2 >= PATH_MAX) {
d495 2
a496 2
		strlcpy(mdb.dbn, MANDOC_DB, PATH_MAX);
		strlcpy(mdb.idxn, MANDOC_IDX, PATH_MAX);
d514 1
a514 1
		strlcpy(dirbuf, dirs.paths[i], PATH_MAX);
d1601 1
a1601 1
	char		 buf[PATH_MAX];
d1692 1
a1692 1
	char		 buf[PATH_MAX];
d1752 5
a1756 5
			strlcat(buf, dir, PATH_MAX);
			strlcat(buf, "/", PATH_MAX);
			strlcat(basedir, "/", PATH_MAX);
			strlcat(basedir, fn, PATH_MAX);
			sz = strlcat(buf, fn, PATH_MAX);
d1758 1
a1758 1
			if (PATH_MAX <= sz) {
d1817 1
a1817 1
			strlcat(buf, dir, PATH_MAX);
d1829 3
a1831 3
			strlcat(buf, "/", PATH_MAX);
			sz = strlcat(buf, fn, PATH_MAX);
			if (sz >= PATH_MAX) {
d1838 2
a1839 2
				sz = strlcat(buf, psec, PATH_MAX);
				if (sz >= PATH_MAX) {
d1851 2
a1852 2
			strlcat(buf, dir + 2, PATH_MAX);
			strlcat(buf, "/", PATH_MAX);
d1854 2
a1855 2
		sz = strlcat(buf, fn, PATH_MAX);
		if (sz >= PATH_MAX) {
@


1.49.2.2
log
@merge OpenBSD rev. 1.41:
backout non-portable code
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.1 2013/09/17 21:32:07 schwarze Exp $ */
d59 9
d136 2
a137 1
				struct mdb *, struct recs *);
d139 3
a141 3
				struct recs *);
static	void		  ofile_argbuild(int, char *[], struct of **,
				const char *);
d143 1
a143 1
				const char *, int, struct of **);
d145 2
a146 2
static	void		  pformatted(DB *, struct buf *, 
				struct buf *, const struct of *);
a306 2
	char		*cp;
	char		 pbuf[PATH_MAX];
d308 1
d410 1
a410 1
		ofile_argbuild(argc, argv, &of, NULL);
d413 2
a414 1
		index_merge(of, mp, &dbuf, &buf, hash, &mdb, &recs);
d419 2
a420 10
		if (NULL == realpath(dir, pbuf)) {
			perror(dir);
			exit((int)MANDOCLEVEL_BADARG);
		}
		if (strlcat(pbuf, "/", PATH_MAX) >= PATH_MAX) {
			fprintf(stderr, "%s: path too long\n", pbuf);
			exit((int)MANDOCLEVEL_BADARG);
		}

		strlcat(mdb.dbn, pbuf, PATH_MAX);
d423 2
a424 1
		strlcat(mdb.idxn, pbuf, PATH_MAX);
d428 1
a428 1
			fprintf(stderr, "%s: path too long\n", mdb.idxn);
d444 1
a444 1
		ofile_argbuild(argc, argv, &of, pbuf);
d449 1
a449 1
		index_prune(of, &mdb, &recs);
d463 1
a463 1
					&mdb, &recs);
d478 2
a479 7
		for (i = 0; i < argc; i++) {
			if (NULL == (cp = realpath(argv[i], pbuf))) {
				perror(argv[i]);
				goto out;
			}
			dirs.paths[i] = mandoc_strdup(cp);
		}
a483 1

d514 2
a515 1
	       	ofile_dirbuild(".", "", "", 0, &of);
d519 1
a519 1
			     &mdb, &recs);
d550 1
a550 1
		"usage: %s [-avvv] [-C file] | dir ... | -t file ...\n"
d561 2
a562 1
		struct mdb *mdb, struct recs *recs)
d568 1
d571 1
a572 1
	char		*p;
d632 3
a634 7
		if (warnings)
			if (strcasecmp(msec, of->sec))
				fprintf(stderr, "%s: "
					"section \"%s\" manual "
					"in \"%s\" directory\n",
					fn, msec, of->sec);

d652 4
a655 6
		if (warnings)
			if (strcasecmp(march, of->arch))
				fprintf(stderr, "%s: "
					"architecture \"%s\" manual "
					"in \"%s\" directory\n",
					fn, march, of->arch);
d691 1
a691 1
				val.data = "";
d745 1
a745 1
			pformatted(hash, buf, dbuf, of);
a791 2
			unlink(mdb->dbn);
			unlink(mdb->idxn);
d810 1
a810 1
			printf("%s: adding to index\n", fn);
d825 3
a827 3
				fprintf(stderr, "%s: probably "
				    "unreachable, title is %s\n",
				    (char *)val.data, (char *)key.data);
d840 2
a841 1
index_prune(const struct of *ofile, struct mdb *mdb, struct recs *recs)
d916 2
a917 1
			printf("%s: deleting from index\n", fn);
d1477 2
a1478 2
pformatted(DB *hash, struct buf *buf, 
		struct buf *dbuf, const struct of *of)
d1485 1
a1485 2
		if (warnings)
			perror(of->fname);
a1539 1

d1548 2
a1549 3
		if (warnings)
			fprintf(stderr, "%s: cannot find NAME section\n",
					of->fname);
d1570 2
a1571 3
		if (warnings)
			fprintf(stderr, "%s: no dash in title line\n",
					of->fname);
d1598 2
a1599 2
ofile_argbuild(int argc, char *argv[], struct of **of,
		const char *basedir)
a1601 1
	char		 pbuf[PATH_MAX];
d1603 1
a1603 1
	char		*relpath, *p;
a1607 13
		if (NULL == (relpath = realpath(argv[i], pbuf))) {
			perror(argv[i]);
			continue;
		}
		if (NULL != basedir) {
			if (strstr(pbuf, basedir) != pbuf) {
				fprintf(stderr, "%s: file outside "
				    "base directory %s\n",
				    pbuf, basedir);
				continue;
			}
			relpath = pbuf + strlen(basedir);
		}
d1616 2
a1617 2
		if (strlcpy(buf, relpath, sizeof(buf)) >= sizeof(buf)) {
			fprintf(stderr, "%s: path too long\n", relpath);
d1649 2
a1650 5
			if (warnings)
				fprintf(stderr,
				    "%s: cannot deduce title "
				    "from filename\n",
				    relpath);
d1659 1
a1659 1
		nof->fname = mandoc_strdup(relpath);
d1690 1
a1690 1
		int p_src_form, struct of **of)
d1702 1
a1702 2
		if (warnings)
			perror(dir);
d1732 1
a1732 3
					if (warnings) fprintf(stderr,
					    "%s/%s: bad section\n",
					    dir, fn);
d1740 1
a1740 3
					if (warnings) fprintf(stderr,
					    "%s/%s: bad architecture\n",
					    dir, fn);
d1746 1
a1746 2
				if (warnings) fprintf(stderr, "%s/%s: "
				    "excessive subdirectory\n", dir, fn);
d1754 2
d1759 1
a1759 2
				if (warnings) fprintf(stderr, "%s/%s: "
				    "path too long\n", dir, fn);
d1763 5
a1767 1
			ofile_dirbuild(buf, sec, arch, src_form, of);
d1772 1
a1772 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: not a regular file\n",
				    dir, fn);
d1778 1
a1778 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: file outside section\n",
				    dir, fn);
d1791 1
a1791 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: no filename suffix\n",
				    dir, fn);
d1798 1
a1798 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: wrong filename suffix\n",
				    dir, fn);
d1832 1
a1832 3
				if (warnings) fprintf(stderr,
				    "%s/%s: path too long\n",
				    dir, fn);
d1840 1
a1840 3
					if (warnings) fprintf(stderr,
					    "%s/%s: path too long\n",
					    dir, fn);
d1856 1
a1856 2
			if (warnings) fprintf(stderr,
			    "%s/%s: path too long\n", dir, fn);
@


1.49.2.3
log
@Merge OpenBSD rev. 1.34.
Do not truncate the production database when starting to build a new one.
Suggested by deraadt@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.2 2013/09/17 22:48:53 schwarze Exp $ */
d498 2
a499 1
		/* Create a new database in two temporary files. */
d501 10
a510 30
		flags = O_CREAT | O_EXCL | O_RDWR;
		while (NULL == mdb.db) {
			strlcpy(mdb.dbn, MANDOC_DB, PATH_MAX);
			strlcat(mdb.dbn, ".XXXXXXXXXX", PATH_MAX);
			if (NULL == mktemp(mdb.dbn)) {
				perror(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			mdb.db = dbopen(mdb.dbn, flags, 0644,
					DB_BTREE, &info);
			if (NULL == mdb.db && EEXIST != errno) {
				perror(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
		}
		while (NULL == mdb.idx) {
			strlcpy(mdb.idxn, MANDOC_IDX, PATH_MAX);
			strlcat(mdb.idxn, ".XXXXXXXXXX", PATH_MAX);
			if (NULL == mktemp(mdb.idxn)) {
				perror(mdb.idxn);
				unlink(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
			mdb.idx = dbopen(mdb.idxn, flags, 0644,
					DB_RECNO, NULL);
			if (NULL == mdb.idx && EEXIST != errno) {
				perror(mdb.idxn);
				unlink(mdb.dbn);
				exit((int)MANDOCLEVEL_SYSERR);
			}
a529 20

		/*
		 * Replace the old database with the new one.
		 * This is not perfectly atomic,
		 * but i cannot think of a better way.
		 */

		if (-1 == rename(mdb.dbn, MANDOC_DB)) {
			perror(MANDOC_DB);
			unlink(mdb.dbn);
			unlink(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
		if (-1 == rename(mdb.idxn, MANDOC_IDX)) {
			perror(MANDOC_IDX);
			unlink(MANDOC_DB);
			unlink(MANDOC_IDX);
			unlink(mdb.idxn);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.49.2.4
log
@Merge OpenBSD rev. 1.43:
Kristaps changed the size member of struct manpaths from int to size_t.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.3 2013/09/17 23:07:22 schwarze Exp $ */
d302 1
a302 1
	size_t		 sz1, sz2, ipath;
d485 1
a485 1
	for (ipath = 0; ipath < dirs.sz; ipath++) {
d493 2
a494 2
		if (-1 == chdir(dirs.paths[ipath])) {
			perror(dirs.paths[ipath]);
@


1.49.2.5
log
@Fix typo in filenames: mandocdb.{db,index} -> mandoc.{db,index}
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.4 2013/09/17 23:12:21 schwarze Exp $ */
d1750 1
a1750 1
 * This ignores the mandoc.db and mandoc.index files, but assumes that
@


1.49.2.6
log
@Fix build on Solaris.
Initial version for SmartOS by ONODERA Ryo <ryoon at netbsd dot org>.
Generalized for Solaris by Jonathan Perkin <jperkin at netbsd dot org>.
Received via Thomas Klausner <wiz at netbsd dot org>.
Style cleanup by myself.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.5 2013/09/18 00:54:20 schwarze Exp $ */
d37 1
a37 1
#if defined(__linux__) || defined(__sun)
a46 4
#if defined(__sun)
#include <sys/stat.h>
#endif

a1758 3
#if defined(__sun)
	struct stat	 sb;
#endif
a1780 4
#if defined(__sun)
		stat(dp->d_name, &sb);
		if (S_IFDIR & sb.st_mode) {
#else
a1781 1
#endif
a1837 3
#if defined(__sun)
		if (0 == S_IFREG & sb.st_mode) {
#else
a1838 1
#endif
@


1.49.2.7
log
@DragonFly needs explicit #include <sys/endian.h> to use be64toh(),
while most other systems include that indirectly via <sys/types.h>.
Reported by Franco Fichtner <franco at lastsummer dot de>.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.6 2013/10/01 00:52:58 schwarze Exp $ */
a43 1
# include <sys/endian.h>
@


1.49.2.8
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- do not complain about unused variables in test-*.c
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.7 2013/10/02 21:03:26 schwarze Exp $ */
a622 2
	static char	 emptystring[] = "";

d741 1
a741 1
				val.data = emptystring;
@


1.49.2.9
log
@On __sun, use <sys/byteorder.h>, BE_64(x), and <db_185.h>.
Thanks to Thomas Klausner <wiz at NetBSD dot org> for providing
failing SmartOS build logs such that i could write this patch
without access to a __sun system and for confirming that these
patches help.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.8 2013/10/05 20:30:05 schwarze Exp $ */
d37 4
a40 1
#if defined(__APPLE__)
d42 1
a42 5
#elif defined(__linux__)
# include <endian.h>
#elif defined(__sun)
# include <sys/byteorder.h>
# include <sys/stat.h>
d45 1
d48 2
a49 4
#if defined(__linux__) || defined(__sun)
# include <db_185.h>
#else
# include <db.h>
@


1.49.2.10
log
@My audit of mandoc revealed one missing (unsigned char) cast
in a tolower() argument containing arbitrary char data.
Thanks to deraadt@@ for triggering the audit.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.9 2013/10/10 23:43:04 schwarze Exp $ */
d739 1
a739 1
				*p = tolower((unsigned char)*p);
@


1.49.2.11
log
@Cope with the mparse_alloc() interface change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.10 2013/11/21 01:53:48 schwarze Exp $ */
a290 1
static	int		  quick;  /* abort the parse early */
d332 1
a332 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:Qtu:vW")))
a354 3
		case ('Q'):
			quick = 1;
			break;
d397 1
a397 2
	mp = mparse_alloc(MPARSE_AUTO,
		MANDOCLEVEL_FATAL, NULL, NULL, quick);
d598 1
a598 1
		"usage: %s [-aQvvv] [-C file] | dir ... | -t file ...\n"
@


1.49.2.12
log
@cope with mparse_alloc() interface change
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.11 2014/01/05 21:30:57 schwarze Exp $ */
d291 1
a291 1
static	int		  mparse_options;  /* abort the parse early */
a331 1
	mparse_options = MPARSE_SO;
d357 1
a357 1
			mparse_options |= MPARSE_QUICK;
d401 2
a402 1
	mp = mparse_alloc(mparse_options, MANDOCLEVEL_FATAL, NULL, NULL);
@


1.49.2.13
log
@cope with the mparse_result() interface change
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.12 2014/03/19 22:09:29 schwarze Exp $ */
d654 1
a654 1
			mparse_result(mp, &mdoc, &man, NULL);
@


1.49.2.14
log
@introduce mandoc_aux to 1.12
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.13 2014/03/19 22:24:12 schwarze Exp $ */
a56 1
#include "mandoc_aux.h"
@


1.49.2.15
log
@backport man(7) .Nd improvement
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.14 2014/03/23 12:04:54 schwarze Exp $ */
d1386 2
a1387 2
	char		*start, *title;
	size_t		 sz;
d1407 2
a1408 1
				NULL != body->child) {
d1410 2
d1418 18
d1437 17
a1453 3
			title = NULL;
			man_deroff(&title, body);
			if (NULL == title)
d1455 3
a1468 1
			start = title;
d1493 1
a1493 1
			if (start == title) {
@


1.49.2.16
log
@Audit malloc(3)/calloc(3)/realloc(3) in VERSION_1_12.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.15 2014/03/23 12:37:58 schwarze Exp $ */
d987 2
a988 2
			recs->stack = mandoc_reallocarray(recs->stack,
			    recs->size, sizeof(recno_t));
@


1.49.2.17
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.16 2014/04/23 21:31:38 schwarze Exp $ */
d18 1
d20 1
@


1.49.2.18
log
@Cygwin support; from Yaakov Selkowitz,
https://sourceforge.net/p/cygwin-ports/mdocml/ci/master/tree/
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.49.2.17 2014/08/11 00:31:13 schwarze Exp $ */
d37 1
a37 1
#elif defined(__linux__) || defined(__CYGWIN__)
d46 1
a46 1
#if defined(__linux__) || defined(__CYGWIN__) || defined(__sun)
@


1.48
log
@update Copyright years according to the CVS logs; no code change
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.47 2012/04/15 13:30:38 schwarze Exp $ */
d399 1
a399 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
@


1.47
log
@Being reluctant to add yet more trailing whitespace, i rather back
it out here than merge it to OpenBSD.  No binary change.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.46 2012/03/23 06:52:17 kristaps Exp $ */
d3 2
a4 2
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
@


1.46
log
@Improve mandocdb's ability to handle NAME sections by sucking the entire
shebang into a buffer and parsing it that way.  This improves on many
cruddy -man manuals in the wild.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.45 2012/03/23 05:45:45 kristaps Exp $ */
d140 1
a140 1
static	void		  ofile_argbuild(int, char *[], 
d145 1
a145 1
static	void		  pformatted(DB *, struct buf *, struct buf *, 
d413 1
a413 1
		index_merge(of, mp, &dbuf, &buf, 
d654 1
a654 1
				"manual in \"%s\" directory", 
d825 1
a825 1
				WARNING((char *)val.data, basedir, 
d840 1
a840 1
index_prune(const struct of *ofile, struct mdb *mdb, 
d916 1
a916 1
			printf("%s: Deleting from index: %s\n", 
d1763 1
a1763 1
			ofile_dirbuild(buf, sec, arch, 
@


1.45
log
@Clean up code a bit by pushing warnings into WARNING macro.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.44 2012/03/23 05:07:35 kristaps Exp $ */
d550 1
a550 1
		"usage: %s [-avvv] [-C file] | dir ... | -t file ...\n"
d825 3
a827 3
				fprintf(stderr, "%s: probably "
				    "unreachable, title is %s\n",
				    (char *)val.data, (char *)key.data);
d1326 2
a1327 2
	const char	*start, *sv;
	size_t		 sz;
d1350 48
a1397 2
			assert(body->string);
			start = sv = body->string;
d1435 1
d1439 1
a1439 1
			while (' ' == *start)
d1461 1
@


1.44
log
@Merge some/most of schwarze@@'s OpenBSD changes into mandoc: many more
warnings about grokking manpages in their respective directories.
DO NOT, however, import his temporary-file routines (I don't plan on
staying with a recno/btree split) nor the realpath() routines, which
destroy relative path-ness.

Also pull in the lorder bits.

There are some changes I started to make then stopped relating to
reporting errors in the correct directories.  I'll clean this up in
subsequent commits.

This puts us more or less on parity with OpenBSD.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.43 2011/12/31 18:47:52 kristaps Exp $ */
d28 1
d59 9
d143 1
a143 1
				const char *, int, struct of **);
d308 1
d514 2
a515 1
	       	ofile_dirbuild(".", "", "", 0, &of);
d632 3
a634 6
		if (warnings && strcasecmp(msec, of->sec))
			fprintf(stderr, "%s: section \"%s\" manual "
					"in \"%s\" directory\n",
					fn, msec, of->sec);


d652 4
a655 4
		if (warnings && strcasecmp(march, of->arch))
			fprintf(stderr, "%s: architecture \"%s\" manual "
					"in \"%s\" directory\n",
					fn, march, of->arch);
d1437 1
a1437 2
		if (warnings)
			perror(of->fname);
a1491 1

d1500 2
a1501 3
		if (warnings)
			fprintf(stderr, "%s: Cannot find NAME "
				"section: %s\n", basedir, of->fname);
d1522 2
a1523 3
		if (warnings)
			fprintf(stderr, "%s/%s: No dash in "
				"title line\n", basedir, of->fname);
d1601 2
a1602 4
			if (warnings)
				fprintf(stderr, "%s/%s: Cannot deduce "
					"title from filename\n",
					basedir, argv[i]);
d1642 1
a1642 1
		int p_src_form, struct of **of)
d1654 1
a1654 2
		if (warnings)
			perror(dir);
d1684 1
a1684 3
					if (warnings) fprintf(stderr,
					    "%s/%s: bad section\n",
					    dir, fn);
d1692 1
a1692 3
					if (warnings) fprintf(stderr,
					    "%s/%s: bad architecture\n",
					    dir, fn);
d1698 1
a1698 2
				if (warnings) fprintf(stderr, "%s/%s: "
				    "excessive subdirectory\n", dir, fn);
d1706 2
d1711 1
a1711 2
				if (warnings) fprintf(stderr, "%s/%s: "
				    "path too long\n", dir, fn);
d1715 5
a1719 1
			ofile_dirbuild(buf, sec, arch, src_form, of);
d1724 1
a1724 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: not a regular file\n",
				    dir, fn);
d1730 1
a1730 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: file outside section\n",
				    dir, fn);
d1743 1
a1743 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: no filename suffix\n",
				    dir, fn);
d1750 1
a1750 4
			if (warnings)
				fprintf(stderr,
				    "%s/%s: wrong filename suffix\n",
				    dir, fn);
d1784 1
a1784 3
				if (warnings) fprintf(stderr,
				    "%s/%s: path too long\n",
				    dir, fn);
d1792 1
a1792 3
					if (warnings) fprintf(stderr,
					    "%s/%s: path too long\n",
					    dir, fn);
d1808 1
a1808 2
			if (warnings) fprintf(stderr,
			    "%s/%s: path too long\n", dir, fn);
@


1.43
log
@When parsing catpages, read from the first section (NAME, we hope) until
the next section.  Also, remove the limit of 72 characters and enforce
this, instead in the apropos frontend.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.42 2011/12/28 00:32:13 schwarze Exp $ */
d126 2
a127 1
				struct mdb *, struct recs *);
d129 3
a131 2
				struct recs *);
static	void		  ofile_argbuild(int, char *[], struct of **);
d135 2
a136 2
static	void		  pformatted(DB *, struct buf *, 
				struct buf *, const struct of *);
a296 2
	char		*cp;
	char		 pbuf[PATH_MAX];
d385 1
a397 4
	flags = O_CREAT | O_RDWR;
	if (OP_DEFAULT == op || OP_CONFFILE == op)
		flags |= O_TRUNC;

d399 1
a399 1
		ofile_argbuild(argc, argv, &of);
d402 2
a403 1
		index_merge(of, mp, &dbuf, &buf, hash, &mdb, &recs);
d421 1
d433 1
a433 1
		ofile_argbuild(argc, argv, &of);
d438 1
a438 1
		index_prune(of, &mdb, &recs);
d452 1
a452 1
					&mdb, &recs);
d467 2
a468 7
		for (i = 0; i < argc; i++) {
			if (NULL == (cp = realpath(argv[i], pbuf))) {
				perror(argv[i]);
				goto out;
			}
			dirs.paths[i] = mandoc_strdup(cp);
		}
d473 5
a477 1
		mdb.idxn[0] = mdb.dbn[0] = '\0';
d479 3
a481 12
		strlcat(mdb.dbn, dirs.paths[i], MAXPATHLEN);
		strlcat(mdb.dbn, "/", MAXPATHLEN);
		sz1 = strlcat(mdb.dbn, MANDOC_DB, MAXPATHLEN);

		strlcat(mdb.idxn, dirs.paths[i], MAXPATHLEN);
		strlcat(mdb.idxn, "/", MAXPATHLEN);
		sz2 = strlcat(mdb.idxn, MANDOC_IDX, MAXPATHLEN);

		if (sz1 >= MAXPATHLEN || sz2 >= MAXPATHLEN) {
			fprintf(stderr, "%s: path too long\n",
					dirs.paths[i]);
			exit((int)MANDOCLEVEL_BADARG);
d484 2
a485 4
		if (mdb.db)
			(*mdb.db->close)(mdb.db);
		if (mdb.idx)
			(*mdb.idx->close)(mdb.idx);
d487 1
d499 3
a501 7
		ofile_free(of);
		of = NULL;

		if (-1 == chdir(dirs.paths[i])) {
			perror(dirs.paths[i]);
			exit((int)MANDOCLEVEL_SYSERR);
		}
a503 2
		if (NULL == of)
			continue;
d505 5
a509 9
		/*
		 * Go to the root of the respective manual tree.
		 * This must work or no manuals may be found (they're
		 * indexed relative to the root).
		 */

		if (-1 == chdir(dirs.paths[i])) {
			perror(dirs.paths[i]);
			exit((int)MANDOCLEVEL_SYSERR);
d512 4
a515 1
		index_merge(of, mp, &dbuf, &buf, hash, &mdb, &recs);
d549 2
a550 1
		struct mdb *mdb, struct recs *recs)
d555 2
d559 1
d567 5
d608 7
a614 3
		 * By default, skip a file if the manual section
		 * given in the file disagrees with the directory
		 * where the file is located.
d620 2
a621 4
		if (strcasecmp(msec, of->sec)) {
			if (warnings)
				fprintf(stderr, "%s: "
					"section \"%s\" manual "
d624 1
a624 2
			skip = 1;
		}
d643 2
a644 4
		if (strcasecmp(march, of->arch)) {
			if (warnings)
				fprintf(stderr, "%s: "
					"architecture \"%s\" manual "
a646 2
			march = of->arch;
		}
d651 1
a651 2
		 * If both agree, use the file name as the title,
		 * because the one in the file usually is all caps.
d656 1
a656 6
		if (strcasecmp(mtitle, of->title)) {
			if (warnings)
				fprintf(stderr, "%s: "
					"title \"%s\" in file "
					"but \"%s\" in filename\n",
					fn, mtitle, of->title);
d658 42
a699 2
		} else
			mtitle = of->title;
d707 5
a711 3
		 * nil-terminated description.  Since the description
		 * may not be set, we set a sentinel to see if we're
		 * going to write a nil byte in its place.
d718 3
a720 3
		buf_appendb(dbuf, msec, strlen(msec) + 1);
		buf_appendb(dbuf, mtitle, strlen(mtitle) + 1);
		buf_appendb(dbuf, march, strlen(march) + 1);
d736 1
a736 1
			pformatted(hash, buf, dbuf, of);
d744 8
d801 1
a801 1
			printf("%s: adding to index\n", fn);
d805 17
d831 2
a832 1
index_prune(const struct of *ofile, struct mdb *mdb, struct recs *recs)
d907 2
a908 1
			printf("%s: deleting from index\n", fn);
d1420 2
a1421 2
pformatted(DB *hash, struct buf *buf, 
		struct buf *dbuf, const struct of *of)
d1494 2
a1495 2
			fprintf(stderr, "%s: cannot find NAME section\n",
					of->fname);
d1517 2
a1518 2
			fprintf(stderr, "%s: no dash in title line\n",
					of->fname);
d1545 2
a1546 1
ofile_argbuild(int argc, char *argv[], struct of **of)
d1564 1
a1564 1
			fprintf(stderr, "%s: path too long\n", argv[i]);
d1597 3
a1599 4
				fprintf(stderr,
				    "%s: cannot deduce title "
				    "from filename\n",
				    argv[i]);
a1617 2
		if (verb > 1)
			printf("%s: scheduling\n", argv[i]);
d1633 1
a1633 1
 * This ignores the whatis.db and whatis.index files, but assumes that
a1716 3
			if (verb > 1)
				printf("%s: scanning\n", buf);

a1845 3
		if (verb > 1)
			printf("%s: scheduling\n", buf);

@


1.42
log
@Do not skip manuals shared across architectures when building databases.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.41 2011/12/25 19:31:25 kristaps Exp $ */
d26 1
d133 2
a134 2
static	void		  pformatted(DB *, struct buf *, struct buf *,
				const struct of *);
d1338 2
d1370 2
a1371 2
pformatted(DB *hash, struct buf *buf, struct buf *dbuf,
		 const struct of *of)
d1374 2
a1375 2
	char		*line, *p;
	size_t		 len, plen;
d1408 26
d1442 1
a1442 2
	line = fgetln(stream, &len);
	if (NULL == line || ' ' != *line || '\n' != line[(int)len - 1]) {
d1449 1
d1453 2
a1454 1
	line[(int)--len] = '\0';
d1462 1
a1462 1
	if (NULL != (p = strstr(line, "- "))) {
d1469 1
a1469 1
		p = line;
d1472 1
a1472 4
	if ((plen = strlen(p)) > 70) {
		plen = 70;
		p[plen] = '\0';
	}
d1491 1
@


1.41
log
@First memory leak in mandocdb.c freeing "struct of".  Also properly
const-ify several strings.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.40 2011/12/25 16:53:51 schwarze Exp $ */
d618 2
a619 2
		 * and architecture given in the file disagree
		 * with the directory where the file is located.
d634 15
d657 1
a657 1
			skip = 1;
@


1.40
log
@Use the traditional name "whatis.db" for the mandocdb(8) databases.
Requested by deraadt@@, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.39 2011/12/25 14:58:39 schwarze Exp $ */
d1455 2
a1456 1
	char		*sec, *arch, *title, *p;
d1760 1
d1779 4
a1782 1
	while (of) {
@


1.39
log
@For binary compatability of the databases across architectures,
use pointers to arrays, not pointers to structs.  It is now possible
to create databases on sparc64 and use them on i386 and vice versa.
Kristaps@@ can't think of anything else that might be required, either.
Put this in now such that we can move on.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.38 2011/12/25 13:08:12 schwarze Exp $ */
d1541 1
a1541 1
 * This ignores the mandoc.db and mandoc.index files, but assumes that
@


1.38
log
@Implement test mode (makewhatis -t), required for pkg_create(8).
Always do all consistency checks; when any one fails, decide whether
to print a message, or skip the file, or both, or none.

While here, do some cleanup as well:
* Bail out on conflicting options.
* Do not crash with -a if there are plain files in the root dir.
* Collect some related variables into structs.

Feedback and OK kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.37 2011/12/20 21:41:11 schwarze Exp $ */
d578 1
a578 1
	struct db_val	 vbuf;
d717 1
a717 1
		vbuf.rec = htobe32(rec);
d729 2
a730 2
			vbuf.mask = htobe64(mask);
			val.size = sizeof(struct db_val);
d771 1
a771 1
	struct db_val	*vbuf;
d820 1
a820 1
			if (sizeof(struct db_val) != val.size)
d823 2
a824 2
			vbuf = val.data;
			if (recs->last != betoh32(vbuf->rec))
@


1.37
log
@Do not cast void pointers to pointers requiring alignment.
This makes mandocdb(8)/apropos(1) work on strict alignment architectures.
Basic way to fix this confirmed by deraadt@@ and kettenis@@, thanks.
ok kristaps@@

This now works on both sparc64 and i386, but note that the binary
database format is still machine-dependent.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.36 2011/12/16 12:06:35 kristaps Exp $ */
d57 18
d98 2
a99 1
	OP_NEW = 0, /* new database */
d101 2
a102 1
	OP_DELETE /* delete entries from existing database */
d125 3
a127 6
				DB *, const char *, DB *, const char *,
				recno_t, const recno_t *, size_t);
static	void		  index_prune(const struct of *, DB *, 
				const char *, DB *, const char *, 
				recno_t *, recno_t **, size_t *,
				size_t *);
a145 1
static	void		  usage(void);
d283 1
d290 2
a293 1
	char		*conf_file;
d295 1
a295 3
	char		 pbuf[PATH_MAX],
			 ibuf[MAXPATHLEN], /* index fname */
			 fbuf[MAXPATHLEN];  /* btree fname */
d297 1
a297 3
	DB		*idx, /* index database */
			*db, /* keyword database */
			*hash; /* temporary keyword hashtable */
d299 1
a299 5
	recno_t		 maxrec; /* last record number in the index */
	recno_t		*recs; /* the numbers of all empty records */
	size_t		 sz1, sz2,
			 recsz, /* number of allocated slots in recs */
			 reccur; /* current number of empty records */
d313 2
a315 2
	verb = 0;
	use_all = 0;
a316 1
	db = idx = NULL;
d319 1
a319 4
	recs = NULL;
	recsz = reccur = 0;
	maxrec = 0;
	op = OP_NEW;
a320 1
	conf_file = NULL;
d322 1
a322 1
	while (-1 != (ch = getopt(argc, argv, "aC:d:u:v")))
d328 7
a334 1
			conf_file = optarg;
d337 5
d345 11
d357 5
d368 3
d372 1
a372 2
			usage();
			return((int)MANDOCLEVEL_BADARG);
d378 5
d396 11
a406 1
	flags = OP_NEW == op ? O_CREAT|O_TRUNC|O_RDWR : O_CREAT|O_RDWR;
d409 7
a415 9
		ibuf[0] = fbuf[0] = '\0';

		strlcat(fbuf, dir, MAXPATHLEN);
		strlcat(fbuf, "/", MAXPATHLEN);
		sz1 = strlcat(fbuf, MANDOC_DB, MAXPATHLEN);

		strlcat(ibuf, dir, MAXPATHLEN);
		strlcat(ibuf, "/", MAXPATHLEN);
		sz2 = strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d418 1
a418 1
			fprintf(stderr, "%s: Path too long\n", dir);
d422 2
a423 2
		db = dbopen(fbuf, flags, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, flags, 0644, DB_RECNO, NULL);
d425 2
a426 2
		if (NULL == db) {
			perror(fbuf);
d428 2
a429 2
		} else if (NULL == idx) {
			perror(ibuf);
d438 1
a438 4
		of = of->first;

		index_prune(of, db, fbuf, idx, ibuf,
				&maxrec, &recs, &recsz, &reccur);
d452 1
a452 2
					db, fbuf, idx, ibuf,
					maxrec, recs, reccur);
d475 1
a475 1
		manpath_parse(&dirs, conf_file, NULL, NULL);
d478 1
a478 1
		ibuf[0] = fbuf[0] = '\0';
d480 7
a486 7
		strlcat(fbuf, dirs.paths[i], MAXPATHLEN);
		strlcat(fbuf, "/", MAXPATHLEN);
		sz1 = strlcat(fbuf, MANDOC_DB, MAXPATHLEN);

		strlcat(ibuf, dirs.paths[i], MAXPATHLEN);
		strlcat(ibuf, "/", MAXPATHLEN);
		sz2 = strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d489 1
a489 1
			fprintf(stderr, "%s: Path too long\n",
d494 4
a497 4
		if (db)
			(*db->close)(db);
		if (idx)
			(*idx->close)(idx);
d499 2
a500 2
		db = dbopen(fbuf, flags, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, flags, 0644, DB_RECNO, NULL);
d502 2
a503 2
		if (NULL == db) {
			perror(fbuf);
d505 2
a506 2
		} else if (NULL == idx) {
			perror(ibuf);
d516 1
a516 3
		} 

	       	ofile_dirbuild(".", NULL, NULL, 0, &of);
d518 1
a521 2
		of = of->first;

d523 1
a523 1
		 * Go to the root of the respective manual tree.  
d533 1
a533 2
		index_merge(of, mp, &dbuf, &buf, hash, db, fbuf,
				idx, ibuf, maxrec, recs, reccur);
d537 4
a540 4
	if (db)
		(*db->close)(db);
	if (idx)
		(*idx->close)(idx);
d550 1
a550 1
	free(recs);
d553 9
d567 1
a567 2
		DB *db, const char *dbf, DB *idx, const char *idxf,
		recno_t maxrec, const recno_t *recs, size_t reccur)
d570 1
a570 1
	int		 ch;
d574 1
a574 1
	const char	*fn, *msec, *mtitle, *arch;
d581 2
a582 1
	for (rec = 0; of; of = of->next) {
d602 3
a604 1
			arch = mdoc_meta(mdoc)->arch;
d608 1
a608 1
			arch = NULL;
d612 1
a612 1
			arch = of->arch;
d622 21
a642 12
		if (0 == use_all) {
			assert(of->sec);
			assert(msec);
			if (strcasecmp(msec, of->sec))
				continue;

			if (NULL == arch) {
				if (NULL != of->arch)
					continue;
			} else if (NULL == of->arch ||
					strcasecmp(arch, of->arch))
				continue;
d645 1
a645 4
		if (NULL == arch)
			arch = "";

		/* 
d654 9
d664 1
a664 3
		if (0 == strcasecmp(mtitle, of->title))
			mtitle = of->title;
		else if (0 == use_all)
d667 1
a667 1
		/* 
d681 1
a681 1
		buf_appendb(dbuf, arch, strlen(arch) + 1);
d699 5
d709 6
a714 6
		if (reccur > 0) {
			--reccur;
			rec = recs[(int)reccur];
		} else if (maxrec > 0) {
			rec = maxrec;
			maxrec = 0;
d732 1
a732 1
			dbt_put(db, dbf, &key, &val);
d738 1
a738 1
		
d754 1
a754 1
			printf("%s: Added index\n", fn);
d756 1
a756 1
		dbt_put(idx, idxf, &key, &val);
d767 1
a767 3
index_prune(const struct of *ofile, DB *db, const char *dbf, 
		DB *idx, const char *idxf, recno_t *maxrec,
		recno_t **recs, size_t *recsz, size_t *reccur)
d776 1
a776 1
	*reccur = 0;
d778 1
a778 1
	while (0 == (ch = (*idx->seq)(idx, &key, &val, seq))) {
d781 1
a781 1
		memcpy(maxrec, key.data, key.size);
d799 1
a799 1
		/* 
d804 1
a804 1
		for (of = ofile; of; of = of->next)
d817 2
a818 1
		while (0 == (ch = (*db->seq)(db, &key, &val, sseq))) {
d824 1
a824 1
			if (*maxrec != betoh32(vbuf->rec))
d827 2
a828 1
			if ((ch = (*db->del)(db, &key, R_CURSOR)) < 0)
d833 1
a833 1
			perror(dbf);
d836 2
a837 1
			fprintf(stderr, "%s: Corrupt database\n", dbf);
d842 1
a842 1
			printf("%s: Deleted index\n", fn);
d845 1
a845 1
		ch = (*idx->put)(idx, &key, &val, R_CURSOR);
d850 4
a853 4
		if (*reccur >= *recsz) {
			*recsz += MANDOC_SLOP;
			*recs = mandoc_realloc
				(*recs, *recsz * sizeof(recno_t));
d856 2
a857 2
		(*recs)[(int)*reccur] = *maxrec;
		(*reccur)++;
d861 1
a861 1
		perror(idxf);
d864 1
a864 1
		fprintf(stderr, "%s: Corrupt index\n", idxf);
d868 1
a868 1
	(*maxrec)++;
d1360 2
a1361 1
		perror(of->fname);
d1400 3
d1420 4
a1423 1
	} else
d1425 1
d1469 1
a1469 1
			fprintf(stderr, "%s: Path too long\n", argv[i]);
d1472 1
a1472 1
		sec = arch = title = NULL;
d1476 1
a1476 1
			if (NULL == sec && '.' == *p) {
d1487 1
a1487 1
			if (NULL == title) {
d1500 6
a1505 1
		if (NULL == title)
d1507 1
d1515 2
a1516 4
		if (NULL != sec)
			nof->sec = mandoc_strdup(sec);
		if (NULL != arch)
			nof->arch = mandoc_strdup(arch);
d1524 2
d1559 3
a1561 2
		perror(dir);
		exit((int)MANDOCLEVEL_SYSERR);
d1582 1
a1582 1
			if (NULL == sec) {
d1589 22
a1610 3
				} else if (use_all)
					sec = fn;
				else
d1612 1
a1612 5
			} else if (NULL == arch && (use_all ||
					NULL == strchr(fn, '.')))
				arch = fn;
			else if (0 == use_all)
				continue;
d1620 3
a1622 2
				fprintf(stderr, "%s: Path too long\n", dir);
				exit((int)MANDOCLEVEL_SYSERR);
d1624 4
a1627 1
 
d1629 1
d1632 8
a1639 4
		if (DT_REG != dp->d_type ||
				(NULL == psec && !use_all) ||
				! strcmp(MANDOC_DB, fn) ||
				! strcmp(MANDOC_IDX, fn))
d1641 8
d1657 6
a1662 2
		if (0 == use_all) {
			if (NULL == suffix)
d1664 2
a1665 2
			if ((MANDOC_SRC & src_form &&
					 strcmp(suffix + 1, psec)) ||
d1667 7
a1673 4
					 strcmp(suffix + 1, "0")))
					continue;
		}
		if (NULL != suffix) {
a1679 1

d1688 1
a1688 1
				NULL != psec) {
d1692 1
a1692 1
			if (NULL != parch && NULL != p)
d1705 3
a1707 1
				fprintf(stderr, "%s: Path too long\n", buf);
d1715 3
a1717 2
					fprintf(stderr,
					    "%s: Path too long\n", buf);
d1725 1
d1727 4
a1730 4
		assert('/' == dir[1]);
		buf[0] = '\0';
		strlcat(buf, dir + 2, MAXPATHLEN);
		strlcat(buf, "/", MAXPATHLEN);
d1733 2
a1734 1
			fprintf(stderr, "%s: Path too long\n", dir);
d1740 2
a1741 4
		if (NULL != psec)
			nof->sec = mandoc_strdup(psec);
		if (NULL != parch)
			nof->arch = mandoc_strdup(parch);
d1757 2
a1786 11

static void
usage(void)
{

	fprintf(stderr, "usage: %s [-v] "
			"[-C file] |"
			" dir ... |"
			" -d dir [file ...] |"
			" -u dir [file ...]\n", progname);
}
@


1.36
log
@Make the stored "cat"/"mdoc"/"man" strings just be c/d/a single-character
bytes.  This cuts down a little in index size and allows for cleaner
extraction of information.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.35 2011/12/16 08:04:34 kristaps Exp $ */
d528 1
d659 3
a661 1
			vbuf.mask = htobe64(*(uint64_t *)val.data);
d714 2
a715 1
		*maxrec = *(recno_t *)key.data;
d1075 1
d1088 5
a1092 2
	} else if (0 == rc)
		mask |= *(uint64_t *)val.data;
@


1.35
log
@Make paths in the mandocdb(8) index relative to the databases' path
prefix.  This means that an index in, say, /usr/share/man will point to
man1/foo.1 instead of /usr/share/man/man1/foo.1.  Not only does this
save a lot of space, it also allows manual trees to be moved around
without any side effects to the mandocdb(8) databases.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.34 2011/12/12 02:00:49 schwarze Exp $ */
d531 1
d612 2
a613 1
		buf_append(dbuf, mdoc ? "mdoc" : (man ? "man" : "cat"));
d701 1
a701 1
	const char	*fn, *cp;
a711 1
		cp = val.data;
d725 2
a726 5
		if (NULL == (fn = memchr(cp, '\0', val.size)))
			break;
		if (++fn - cp >= (int)val.size)
			break;
		if (NULL == memchr(fn, '\0', val.size - (fn - cp)))
@


1.34
log
@implement -C (alternative config file) for apropos(1) and mandocdb(8),
including various tweaks to the whatis(8) manual;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.33 2011/12/10 22:01:06 schwarze Exp $ */
a23 1
#include <sys/stat.h>
d112 1
a112 1
static	int		  ofile_dirbuild(const char *, const char *,
d386 1
a386 4
		if (verb > 2) {
			printf("%s: Opened\n", fbuf);
			printf("%s: Opened\n", ibuf);
		}
a387 1
		ofile_argbuild(argc, argv, &of);
d397 3
a399 3
		 * Go to the root of the respective manual tree
		 * such that .so links work.  In case of failure,
		 * just prod on, even though .so links won't work.
d403 4
a406 1
			chdir(dir);
a466 5
		if (verb > 2) {
			printf("%s: Truncated\n", fbuf);
			printf("%s: Truncated\n", ibuf);
		}

d470 2
a471 2
		if ( ! ofile_dirbuild(dirs.paths[i], NULL, NULL,
					0, &of)) 
d473 3
d483 3
a485 3
		 * Go to the root of the respective manual tree
		 * such that .so links work.  In case of failure,
		 * just prod on, even though .so links won't work.
d488 5
a492 1
		chdir(dirs.paths[i]);
a1436 2
		if (verb > 2) 
			printf("%s: Scheduling\n", argv[i]);
d1456 1
a1456 1
static int
a1460 1
	struct stat	 sb;
d1471 1
a1471 1
		return(0);
d1516 1
a1516 1
				return(0);
d1519 2
a1520 2
			if (verb > 2)
				printf("%s: Scanning\n", buf);
a1521 4
			if ( ! ofile_dirbuild(buf, sec, arch,
					src_form, of))
				return(0);
		}
d1523 3
a1525 3
		    (NULL == psec && !use_all) ||
		    !strcmp(MANDOC_DB, fn) ||
		    !strcmp(MANDOC_IDX, fn))
d1589 1
a1589 1
				if (0 == stat(buf, &sb))
d1594 2
d1597 1
a1597 1
		strlcat(buf, dir, MAXPATHLEN);
a1625 2
		if (verb > 2)
			printf("%s: Scheduling\n", buf);
a1636 1
	return(1);
@


1.33
log
@Avoid leaking index records:
Before allocating a record for a file,
first make sure we actually want to use the file.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.32 2011/12/10 16:53:39 schwarze Exp $ */
d276 1
d316 1
d318 1
a318 1
	while (-1 != (ch = getopt(argc, argv, "ad:u:v")))
d323 3
d434 1
a434 1
		manpath_parse(&dirs, NULL, NULL);
d1668 4
a1671 3
			"[-d dir [files...] |"
			" -u dir [files...] |"
			" dir...]\n", progname);
@


1.32
log
@Fix selection of arch-specific manuals:
(1) Correctly compare cat vs. man paths.
(2) Compare arch (and section) names case-insensitively.
Problem noticed by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.31 2011/12/09 11:16:34 schwarze Exp $ */
d531 3
a533 1
		 * Reclaim an empty index record, if available.
a535 9
		if (reccur > 0) {
			--reccur;
			rec = recs[(int)reccur];
		} else if (maxrec > 0) {
			rec = maxrec;
			maxrec = 0;
		} else
			rec++;

a536 1
		hash_reset(&hash);
a539 6
		/*
		 * Try interpreting the file as mdoc(7) or man(7)
		 * source code, unless it is already known to be
		 * formatted.  Fall back to formatted mode.
		 */

d614 4
a617 1
		/* Fix the record number in the btree value. */
d619 1
d629 2
a630 2
		 * Copy from the in-memory hashtable of pending keywords
		 * into the database.
d633 8
d642 6
@


1.31
log
@Tweak pformatted():
* If the first section is empty, use the file name as .Nd.
* No need to check (len > 0) after successful fgetln(3).
* Improve some comments and strip trailing whitespace.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.30 2011/12/09 01:21:10 kristaps Exp $ */
d582 1
a582 1
			if (strcmp(msec, of->sec))
d589 1
a589 1
					strcmp(arch, of->arch))
d1562 4
@


1.30
log
@Considerably tidy mandocdb(8) catman descriptions by skipping to the first
hyphen-space combo, not the last hyphen as done previously.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.29 2011/12/09 00:49:01 kristaps Exp $ */
d1291 1
a1291 1
	/* Skip to first blank line. */ 
d1294 1
a1294 1
		if (len && '\n' == *line)
d1297 3
a1299 3
	/* 
	 * Skip to first section header.
	 * This happens when text is flush-left.
d1303 1
a1303 1
		if (len && '\n' != *line && ' ' != *line)
d1307 4
a1310 3
	 * If no page content can be found or the input line is
	 * malformed (zer-length or has no trailing newline), reuse the
	 * page title as the page description.
d1314 1
a1314 1
	if (NULL == line || len == 0 || '\n' != line[(int)len - 1]) {
d1323 2
a1324 2
	/* 
	 * Skip to the last dash.
@


1.29
log
@Strip backspace encoding from preformatted manuals.  This cleans up a lot
of catpage entries in the mandoc databases.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.28 2011/12/08 09:19:13 kristaps Exp $ */
d1328 2
a1329 2
	if (NULL != (p = strrchr(line, '-'))) {
		for (++p; ' ' == *p || '\b' == *p; p++)
@


1.28
log
@Clean up grok of preformatted manual description.
 (1) put fclose() at the end, as line isn't valid afterward (see fgetln())
 (2) clean up loops to be more readable to my old eyes
 (3) mandate trailing newline, nul-terminate, and use strrchr
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.27 2011/12/08 02:24:31 schwarze Exp $ */
d1339 12
@


1.27
log
@bugfix: make reclaiming of index slots actually work;
index_prune always counted the free slots,
but didn't tell anybody about them, so they weren't reused
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.26 2011/12/08 01:00:58 kristaps Exp $ */
d1291 1
a1291 2
	while (NULL != (line = fgetln(stream, &len)) && '\n' != *line)
		/* Skip to first blank line. */ ;
d1293 12
a1304 3
	while (NULL != (line = fgetln(stream, &len)) &&
			('\n' == *line || ' ' == *line))
		/* Skip to first section header. */ ;
d1307 3
a1309 2
	 * If no page content can be found,
	 * reuse the page title as the page description.
d1312 2
a1313 1
	if (NULL == (line = fgetln(stream, &len))) {
a1318 1
	fclose(stream);
d1320 6
a1325 2
	/*
	 * If there is a dash, skip to the text following it.
d1328 4
a1331 7
	for (p = line, plen = len; plen; p++, plen--)
		if ('-' == *p)
			break;
	for ( ; plen; p++, plen--)
		if ('-' != *p && ' ' != *p && 8 != *p)
			break;
	if (0 == plen) {
d1333 4
a1336 1
		plen = len;
d1339 1
a1339 8
	/*
	 * Copy the rest of the line, but no more than 70 bytes.
	 */

	if (70 < plen)
		plen = 70;
	p[plen-1] = '\0';
	buf_appendb(dbuf, p, plen);
d1341 1
a1341 1
	buf_appendb(buf, p, plen);
d1343 1
@


1.26
log
@If arguments are passed to mandocdb(8) in "default" mode, then use
realpath() to convert them into absolute paths before putting the
traversed subdirectory filenames into the index.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.25 2011/12/07 01:57:20 schwarze Exp $ */
d110 2
a111 1
				recno_t *, recno_t **, size_t *);
d394 1
a394 1
				&maxrec, &recs, &recsz);
d686 2
a687 2
		DB *idx, const char *idxf,
		recno_t *maxrec, recno_t **recs, size_t *recsz)
a693 1
	size_t		 reccur;
d696 1
a696 1
	reccur = 0;
d770 1
a770 1
		if (reccur >= *recsz) {
d776 2
a777 2
		(*recs)[(int)reccur] = *maxrec;
		reccur++;
@


1.25
log
@Implement search support for 24 additional macros, extract more information
from Fn, and lift section restrictions from An Cd Er Ev Fn Fo In Pa St Va Vt
by removing 4 handler functions and 50 lines of code.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.24 2011/12/04 14:23:29 schwarze Exp $ */
d275 3
a277 1
	char		 ibuf[MAXPATHLEN], /* index fname */
d418 1
a418 1
		dirs.paths = mandoc_malloc(argc * sizeof(char *));
d420 7
a426 2
		for (i = 0; i < argc; i++)
			dirs.paths[i] = mandoc_strdup(argv[i]);
@


1.24
log
@Fix parsing of file names given on the command line; i broke it
when adding support for formatted manual pages.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.23 2011/12/03 18:47:09 kristaps Exp $ */
d119 10
a128 14
static	void		  pmdoc_An(MDOC_ARGS);
static	void		  pmdoc_Cd(MDOC_ARGS);
static	void		  pmdoc_Er(MDOC_ARGS);
static	void		  pmdoc_Ev(MDOC_ARGS);
static	void		  pmdoc_Fd(MDOC_ARGS);
static	void		  pmdoc_In(MDOC_ARGS);
static	void		  pmdoc_Fn(MDOC_ARGS);
static	void		  pmdoc_Fo(MDOC_ARGS);
static	void		  pmdoc_Nd(MDOC_ARGS);
static	void		  pmdoc_Nm(MDOC_ARGS);
static	void		  pmdoc_Pa(MDOC_ARGS);
static	void		  pmdoc_St(MDOC_ARGS);
static	void		  pmdoc_Vt(MDOC_ARGS);
static	void		  pmdoc_Xr(MDOC_ARGS);
d131 1
a131 1
typedef	void		(*pmdoc_nf)(MDOC_ARGS);
d133 129
a261 123
static	const pmdoc_nf	  mdocs[MDOC_MAX] = {
	NULL, /* Ap */
	NULL, /* Dd */
	NULL, /* Dt */
	NULL, /* Os */
	NULL, /* Sh */ 
	NULL, /* Ss */ 
	NULL, /* Pp */ 
	NULL, /* D1 */
	NULL, /* Dl */
	NULL, /* Bd */
	NULL, /* Ed */
	NULL, /* Bl */ 
	NULL, /* El */
	NULL, /* It */
	NULL, /* Ad */ 
	pmdoc_An, /* An */ 
	NULL, /* Ar */
	pmdoc_Cd, /* Cd */ 
	NULL, /* Cm */
	NULL, /* Dv */ 
	pmdoc_Er, /* Er */ 
	pmdoc_Ev, /* Ev */ 
	NULL, /* Ex */ 
	NULL, /* Fa */ 
	pmdoc_Fd, /* Fd */
	NULL, /* Fl */
	pmdoc_Fn, /* Fn */ 
	NULL, /* Ft */ 
	NULL, /* Ic */ 
	pmdoc_In, /* In */ 
	NULL, /* Li */
	pmdoc_Nd, /* Nd */
	pmdoc_Nm, /* Nm */
	NULL, /* Op */
	NULL, /* Ot */
	pmdoc_Pa, /* Pa */
	NULL, /* Rv */
	pmdoc_St, /* St */ 
	pmdoc_Vt, /* Va */
	pmdoc_Vt, /* Vt */ 
	pmdoc_Xr, /* Xr */ 
	NULL, /* %A */
	NULL, /* %B */
	NULL, /* %D */
	NULL, /* %I */
	NULL, /* %J */
	NULL, /* %N */
	NULL, /* %O */
	NULL, /* %P */
	NULL, /* %R */
	NULL, /* %T */
	NULL, /* %V */
	NULL, /* Ac */
	NULL, /* Ao */
	NULL, /* Aq */
	NULL, /* At */ 
	NULL, /* Bc */
	NULL, /* Bf */
	NULL, /* Bo */
	NULL, /* Bq */
	NULL, /* Bsx */
	NULL, /* Bx */
	NULL, /* Db */
	NULL, /* Dc */
	NULL, /* Do */
	NULL, /* Dq */
	NULL, /* Ec */
	NULL, /* Ef */ 
	NULL, /* Em */ 
	NULL, /* Eo */
	NULL, /* Fx */
	NULL, /* Ms */ 
	NULL, /* No */
	NULL, /* Ns */
	NULL, /* Nx */
	NULL, /* Ox */
	NULL, /* Pc */
	NULL, /* Pf */
	NULL, /* Po */
	NULL, /* Pq */
	NULL, /* Qc */
	NULL, /* Ql */
	NULL, /* Qo */
	NULL, /* Qq */
	NULL, /* Re */
	NULL, /* Rs */
	NULL, /* Sc */
	NULL, /* So */
	NULL, /* Sq */
	NULL, /* Sm */ 
	NULL, /* Sx */
	NULL, /* Sy */
	NULL, /* Tn */
	NULL, /* Ux */
	NULL, /* Xc */
	NULL, /* Xo */
	pmdoc_Fo, /* Fo */ 
	NULL, /* Fc */ 
	NULL, /* Oo */
	NULL, /* Oc */
	NULL, /* Bk */
	NULL, /* Ek */
	NULL, /* Bt */
	NULL, /* Hf */
	NULL, /* Fr */
	NULL, /* Ud */
	NULL, /* Lb */
	NULL, /* Lp */ 
	NULL, /* Lk */ 
	NULL, /* Mt */ 
	NULL, /* Brq */ 
	NULL, /* Bro */ 
	NULL, /* Brc */ 
	NULL, /* %C */
	NULL, /* Es */
	NULL, /* En */
	NULL, /* Dx */
	NULL, /* %Q */
	NULL, /* br */
	NULL, /* sp */
	NULL, /* %U */
	NULL, /* Ta */
a848 12
/* ARGSUSED */
static void
pmdoc_An(MDOC_ARGS)
{
	
	if (SEC_AUTHORS != n->sec)
		return;

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_An);
}

d865 17
a881 1
static void
d886 1
a886 1
	
d888 1
a888 1
		return;
d890 1
a890 1
		return;
d897 1
a897 1
		return;
d900 1
a900 1
		return;
d912 1
a912 1
		return;
d922 1
a922 2

	hash_put(hash, buf, TYPE_In);
d926 2
a927 2
static void
pmdoc_Cd(MDOC_ARGS)
a928 7
	
	if (SEC_SYNOPSIS != n->sec)
		return;

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Cd);
}
a929 7
/* ARGSUSED */
static void
pmdoc_In(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec)
		return;
d931 1
a931 1
		return;
d934 1
a934 1
	hash_put(hash, buf, TYPE_In);
d938 1
a938 1
static void
d941 1
a942 5
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;
d944 6
a949 1
	/* .Fn "struct type *arg" "foo" */
d951 1
a951 1
	cp = strrchr(n->child->string, ' ');
d953 1
a953 1
		cp = n->child->string;
d960 2
d964 21
d988 1
a988 1
static void
d991 1
a991 3
	
	if (SEC_STANDARDS != n->sec)
		return;
d993 1
a993 1
		return;
d996 1
a996 1
	hash_put(hash, buf, TYPE_St);
d1000 1
a1000 1
static void
d1005 1
a1005 1
		return;
d1015 1
a1015 1
	hash_put(hash, buf, TYPE_Xr);
d1019 1
a1019 53
static void
pmdoc_Vt(MDOC_ARGS)
{
	const char	*start;
	size_t		 sz;
	
	if (SEC_SYNOPSIS != n->sec)
		return;
	if (MDOC_Vt == n->tok && MDOC_BODY != n->type)
		return;
	if (NULL == n->last || MDOC_TEXT != n->last->type)
		return;

	/*
	 * Strip away leading pointer symbol '*' and trailing ';'.
	 */

	start = n->last->string;

	while ('*' == *start)
		start++;

	if (0 == (sz = strlen(start)))
		return;

	if (';' == start[(int)sz - 1])
		sz--;

	if (0 == sz)
		return;

	buf_appendb(buf, start, sz);
	buf_appendb(buf, "", 1);
	hash_put(hash, buf, TYPE_Va);
}

/* ARGSUSED */
static void
pmdoc_Fo(MDOC_ARGS)
{
	
	if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;
	if (NULL == n->child || MDOC_TEXT != n->child->type)
		return;

	buf_append(buf, n->child->string);
	hash_put(hash, buf, TYPE_Fn);
}


/* ARGSUSED */
static void
d1024 1
a1024 1
		return;
d1027 1
a1027 3
	buf_appendmdoc(buf, n->child, 0);

	hash_put(hash, buf, TYPE_Nd);
d1031 2
a1032 2
static void
pmdoc_Er(MDOC_ARGS)
d1035 4
a1038 6
	if (SEC_ERRORS != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Er);
}
d1040 2
a1041 4
/* ARGSUSED */
static void
pmdoc_Ev(MDOC_ARGS)
{
d1043 1
a1043 5
	if (SEC_ENVIRONMENT != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Ev);
d1047 2
a1048 2
static void
pmdoc_Pa(MDOC_ARGS)
d1051 1
a1051 24
	if (SEC_FILES != n->sec)
		return;
	
	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Pa);
}

/* ARGSUSED */
static void
pmdoc_Nm(MDOC_ARGS)
{
	
	if (SEC_NAME == n->sec) {
		buf_appendmdoc(buf, n->child, 0);
		hash_put(hash, buf, TYPE_Nm);
		return;
	} else if (SEC_SYNOPSIS != n->sec || MDOC_HEAD != n->type)
		return;

	if (NULL == n->child)
		buf_append(buf, m->name);

	buf_appendmdoc(buf, n->child, 0);
	hash_put(hash, buf, TYPE_Nm);
d1117 10
a1126 1
		if (NULL == mdocs[n->tok])
d1129 18
a1146 2
		buf->len = 0;
		(*mdocs[n->tok])(hash, buf, dbuf, n, m);
@


1.23
log
@Back out lorder, which doesn't seem necessary (?).  I think this means all
fields are endian-neutral, although the recno(3) key is unknown.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.22 2011/12/03 12:09:07 kristaps Exp $ */
d1420 1
a1420 1
			if (strncmp("man", p + 1, 3)) {
d1422 1
a1422 2
				arch = p + 1;
			} else if (strncmp("cat", p + 1, 3)) {
d1424 1
a1425 1
			}
@


1.22
log
@Make sure the btree(3) goop is also BE.  This covers both the DB metadata
and prior commits handle the contained binary fields.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.21 2011/12/02 00:21:56 kristaps Exp $ */
a335 1
	info.lorder = 4321;
@


1.21
log
@This is a little gross: Linux and Apple need lots some cajoling to work
with byte-swapping.  Tested on Mac.  Any Linux machines somebody can
test on?  Anybody?

While here, note the correct byte-size in mandocdb(8) and also note
field widths and endianness.  The btree is now endian-neutral.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.20 2011/12/01 23:55:58 kristaps Exp $ */
d336 1
@


1.20
log
@Use OpenBSD's endian functions.  Make btree type also be endian-neutral.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.19 2011/12/01 23:46:26 kristaps Exp $ */
d36 2
a37 1
#ifdef __linux__
d39 3
@


1.19
log
@In apropos_db.c, move all btree reading (and safety checks) into the
btree_read() function.  Also, add a forgotten free() for the type of
grokked record.

Then in both mandocdb.c and apropos_db.c, make the "rec" field of the
btree by in network-order.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.18 2011/12/01 21:05:49 kristaps Exp $ */
a35 2
#include <arpa/inet.h>

d629 1
a629 1
		vbuf.rec = htonl(rec);
d633 1
a633 1
			vbuf.mask = *(uint64_t *)val.data;
d733 1
a733 1
			if (*maxrec != ntohl(vbuf->rec))
@


1.18
log
@Fix mandocdb(8) to pass over the type when pruning the database.  This
fixed `-d' perpetually adding the same files.  While here, clean up the
code and document it.  Remove -vv (complain if you want it back in).
Document the error messages in a DIAGNOSTICS section of mandocdb(8).
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.17 2011/11/29 00:34:50 schwarze Exp $ */
d36 2
d631 1
a631 1
		vbuf.rec = rec;
a634 1

a637 1

d735 1
a735 1
			if (*maxrec != vbuf->rec)
@


1.17
log
@chdir(2) to the right man page tree before parsing manuals;
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.16 2011/11/27 23:27:31 schwarze Exp $ */
a637 3
			if (verb > 1)
				printf("%s: Added keyword: %s\n", 
						fn, (char *)key.data);
d661 1
d678 1
a678 1
	const char	*fn;
d690 25
a714 10
		if (0 == val.size) {
			if (reccur >= *recsz) {
				*recsz += MANDOC_SLOP;
				*recs = mandoc_realloc(*recs, 
					*recsz * sizeof(recno_t));
			}
			(*recs)[(int)reccur] = *maxrec;
			reccur++;
			continue;
		}
a715 1
		fn = (char *)val.data;
d723 5
d731 3
a733 1
			assert(sizeof(struct db_val) == val.size);
d737 2
a738 5
			if (verb)
				printf("%s: Deleted keyword: %s\n", 
						fn, (char *)key.data);
			ch = (*db->del)(db, &key, R_CURSOR);
			if (ch < 0)
d741 1
d745 3
a754 4
		if (ch < 0) {
			perror(idxf);
			exit((int)MANDOCLEVEL_SYSERR);
		}
d756 3
d768 9
@


1.16
log
@Reimplement the global command line options -a and -v
as static global variables, reducing the maze of arguments
passed around among various static functions.
Suggested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.15 2011/11/27 23:11:37 schwarze Exp $ */
d34 1
d387 8
a394 1
		if (OP_UPDATE == op)
d398 1
d467 7
@


1.15
log
@Save the manual type (mdoc, man, or cat) in the index file
of the mandoc databases, as suggested by kristaps@@.
Given the well-structured code, this is surprisingly simple.

This changes the mandoc.index database format.
Run "sudo mandocdb" to regenerate your databases.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.14 2011/11/27 22:57:53 schwarze Exp $ */
d100 2
a101 3
				struct buf *, struct buf *,
				DB *, DB *, const char *, 
				DB *, const char *, int, int,
d105 2
a106 3
				int, recno_t *, recno_t **, size_t *);
static	void		  ofile_argbuild(char *[], int, int, int,
				struct of **);
d108 1
a108 2
				const char *, int, int, int,
				struct of **);
d258 2
d270 1
a270 3
	int		 verb, /* output verbosity */
			 use_all, /* use all directories and files */
			 ch, i, flags;
d377 1
a377 1
		ofile_argbuild(argv, argc, use_all, verb, &of);
d383 1
a383 1
		index_prune(of, db, fbuf, idx, ibuf, verb,
d388 2
a389 2
					db, fbuf, idx, ibuf, use_all,
					verb, maxrec, recs, reccur);
d450 1
a450 1
				0, use_all, verb, &of)) 
d459 1
a459 2
				idx, ibuf, use_all, verb,
				maxrec, recs, reccur);
d483 2
a484 3
		struct buf *dbuf, struct buf *buf,
		DB *hash, DB *db, const char *dbf,
		DB *idx, const char *idxf, int use_all, int verb,
d660 1
a660 1
		DB *idx, const char *idxf, int verb,
d1334 1
a1334 2
ofile_argbuild(char *argv[], int argc, int use_all, int verb,
		struct of **of)
d1426 1
a1426 1
		int p_src_form, int use_all, int verb, struct of **of)
d1492 1
a1492 1
					src_form, use_all, verb, of))
@


1.14
log
@Rudimentary handling of formatted manuals ("cat pages").
Coded on the train back from p2k11 in Budapest.
Kristaps has seen the patch and agreed with the direction.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.13 2011/11/26 22:38:11 schwarze Exp $ */
d595 1
@


1.13
log
@Sync to OpenBSD, mostly gratuitous and whitespace differences,
but a few serious things as well:
* -M overrides MANPATH
* -m prepends to the path
* put back database close calls that got lost in mandocdb
* missing sys/types.h in manpath.c, needed for size_t
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.12 2011/11/26 11:23:56 schwarze Exp $ */
d23 2
d50 3
d60 1
d110 2
a111 1
				const char *, int, int, struct of **);
d113 2
d453 1
a453 1
				use_all, verb, &of))
d504 5
d520 2
d523 23
a545 3
		if (mparse_readfd(mp, -1, fn) >= MANDOCLEVEL_FATAL) {
			fprintf(stderr, "%s: Parse failure\n", fn);
			continue;
a547 4
		mparse_result(mp, &mdoc, &man);
		if (NULL == mdoc && NULL == man)
			continue;

a553 5
		msec = NULL != mdoc ? 
			mdoc_meta(mdoc)->msec : man_meta(man)->msec;
		arch = NULL != mdoc ? 
			mdoc_meta(mdoc)->arch : NULL;

a577 3
		mtitle = NULL != mdoc ? 
			mdoc_meta(mdoc)->title : man_meta(man)->title;

d607 1
a607 1
		else 
d609 2
d1261 76
d1343 1
a1343 1
	int		 i;
d1351 2
a1352 1
		 *   man*[/<arch>]/<title>.<section>
d1360 1
d1366 4
d1379 5
a1383 1
			if (strncmp("man", p + 1, 3))
d1385 1
d1402 1
d1431 1
a1431 1
		int use_all, int verb, struct of **of)
d1434 1
d1438 1
a1438 1
	char		*suffix;
d1441 1
d1454 2
d1462 2
a1463 1
			 *   man<section>/[<arch>/]
d1467 2
a1468 1
				if(0 == strncmp("man", fn, 3))
d1470 4
a1473 1
				else if (use_all)
d1497 1
a1497 1
					use_all, verb, of))
d1516 36
a1551 1
			if (strcmp(suffix + 1, psec))
d1553 13
d1574 1
a1574 1
			return(0);
d1583 1
d1594 4
a1599 1

@


1.12
log
@Store page titles in the correct case, and by default, only
put stuff into the database that man(1) will be able to retrieve.
However, support an option to use all directories and files.
feedback and ok  kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.11 2011/11/24 12:54:19 kristaps Exp $ */
d381 1
a381 1
			index_merge(of, mp, &dbuf, &buf, hash, 
d414 1
a414 1
			fprintf(stderr, "%s: Path too long\n", 
d419 5
d452 1
a452 1
		index_merge(of, mp, &dbuf, &buf, hash, db, fbuf, 
d479 1
a479 1
		DB *hash, DB *db, const char *dbf, 
@


1.11
log
@I say that mandocdb(8) uses "man(1)'s method", but it doesn't.  It just uses
the configuration file and ignores MANPATH.  Everybody else uses MANPATH
(being apropos and man), so why shouldn't we?
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.10 2011/11/23 09:52:20 kristaps Exp $ */
d4 1
d52 3
d96 1
a96 1
				DB *, const char *, int,
d101 4
a104 2
static	void		  ofile_argbuild(char *[], int, int, struct of **);
static	int		  ofile_dirbuild(const char *, int, struct of **);
d263 1
d269 2
a270 2
	recno_t		 maxrec; /* supremum of all records */
	recno_t		*recs; /* buffer of empty records */
d272 2
a273 2
			 recsz, /* buffer size of recs */
			 reccur; /* valid number of recs */
d289 1
d300 1
a300 1
	while (-1 != (ch = getopt(argc, argv, "d:u:v")))
d302 3
d361 1
a361 1
		} else if (NULL == db) {
d371 1
a371 1
		ofile_argbuild(argv, argc, verb, &of);
d382 2
a383 2
					db, fbuf, idx, ibuf, verb,
					maxrec, recs, reccur);
d425 1
a425 1
		} else if (NULL == db) {
d438 2
a439 1
		if ( ! ofile_dirbuild(dirs.paths[i], verb, &of)) 
d448 2
a449 1
				idx, ibuf, verb, maxrec, recs, reccur);
d475 1
a475 1
		DB *idx, const char *idxf, int verb,
d511 6
a518 2
		mtitle = NULL != mdoc ? 
			mdoc_meta(mdoc)->title : man_meta(man)->title;
d522 14
d540 18
d1231 2
a1232 1
ofile_argbuild(char *argv[], int argc, int verb, struct of **of)
d1234 2
d1240 37
d1278 11
a1288 1
		nof->fname = strdup(argv[i]);
d1311 2
a1312 1
ofile_dirbuild(const char *dir, int verb, struct of **of)
d1317 2
a1318 1
	const char	*fn;
d1329 4
d1334 19
a1352 3
			if (0 == strcmp(".", fn))
				continue;
			if (0 == strcmp("..", fn))
d1360 27
a1386 3
			if (sz < MAXPATHLEN) {
				if ( ! ofile_dirbuild(buf, verb, of))
					return(0);
d1388 1
a1388 1
			} else if (sz < MAXPATHLEN)
a1389 3

			fprintf(stderr, "%s: Path too long\n", dir);
			return(0);
a1390 6
		if (DT_REG != dp->d_type)
			continue;

		if (0 == strcmp(MANDOC_DB, fn) ||
				0 == strcmp(MANDOC_IDX, fn))
			continue;
d1403 13
d1442 3
@


1.10
log
@Have mandocdb(8) take advantage of manpath.h.
This brings it in line with makewhatis(8), which, like apropos(1), will use
man.conf (or manpath(1)) if no manpath entries are provided.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.9 2011/11/20 12:39:08 kristaps Exp $ */
d389 1
a389 1
		manpath_parseconf(&dirs);
@


1.9
log
@Merge schwarze@@'s work for 64-bit types.  This is based on a tweaked patch
submitted to tech@@ on 16/11/2011, 01:39.  It has been updated to account
for the logical-operator functions and to avoid keeping a live pointer into
the DBT value, which is not guaranteed to be consistent across calls into
the bdb library.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.8 2011/11/13 10:49:57 schwarze Exp $ */
d42 1
d251 1
d279 2
d377 15
a391 1
	for (i = 0; i < argc; i++) {
d394 1
a394 1
		strlcat(fbuf, argv[i], MAXPATHLEN);
d398 1
a398 1
		strlcat(ibuf, argv[i], MAXPATHLEN);
d403 2
a404 1
			fprintf(stderr, "%s: Path too long\n", argv[i]);
d427 1
a427 1
		if ( ! ofile_dirbuild(argv[i], verb, &of)) 
d449 1
@


1.8
log
@Inventing new keywords for mostly the same thing when a well-established
set of keywords already exists is a bad idea, so reuse the mdoc(7)
macro names as apropos(1) search types.  This is a gain in brevity
as well.  Some time ago, kristaps@@ agreed in principle.

The search type bit field constants are used by both mandocdb(8) and
apropos(1) and should better stay in sync, so give them their own
header file.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.7 2011/11/13 00:53:13 schwarze Exp $ */
d86 1
a86 1
static	void		  hash_put(DB *, const struct buf *, int);
d453 1
a453 1
	char		 vbuf[8];
a515 3
		
		memset(vbuf, 0, sizeof(uint32_t));
		memcpy(vbuf + 4, &rec, sizeof(uint32_t));
d517 1
d522 3
a524 3
			memcpy(vbuf, val.data, sizeof(uint32_t));
			val.size = sizeof(vbuf);
			val.data = vbuf;
d569 1
d602 3
a604 2
			assert(8 == val.size);
			if (*maxrec != *(recno_t *)(val.data + 4))
d985 1
a985 1
hash_put(DB *db, const struct buf *buf, int mask)
d1000 1
a1000 1
		mask |= *(int *)val.data;
d1003 1
a1003 1
	val.size = sizeof(int); 
@


1.7
log
@Fix two crashes that occur when walking very large (i.e. real-world) trees:
1) Avoid excessive, needless recursion, lest you overflow the stack;
2) Close all dir file descriptors, lest you run out of descriptors.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.6 2011/09/17 13:54:27 schwarze Exp $ */
d41 1
a42 2
#define	MANDOC_DB	 "mandoc.db"
#define	MANDOC_IDX	 "mandoc.index"
a45 16
/* Bit-fields.  See mandocdb.8. */

#define TYPE_NAME	  0x01
#define TYPE_FUNCTION	  0x02
#define TYPE_UTILITY	  0x04
#define TYPE_INCLUDES	  0x08
#define TYPE_VARIABLE	  0x10
#define TYPE_STANDARD	  0x20
#define TYPE_AUTHOR	  0x40
#define TYPE_CONFIG	  0x80
#define TYPE_DESC	  0x100
#define TYPE_XREF	  0x200
#define TYPE_PATH	  0x400
#define TYPE_ENV	  0x800
#define TYPE_ERR	  0x1000

d714 1
a714 1
	hash_put(hash, buf, TYPE_AUTHOR);
d775 1
a775 1
	hash_put(hash, buf, TYPE_INCLUDES);
d787 1
a787 1
	hash_put(hash, buf, TYPE_CONFIG);
d801 1
a801 1
	hash_put(hash, buf, TYPE_INCLUDES);
d827 1
a827 1
	hash_put(hash, buf, TYPE_FUNCTION);
d841 1
a841 1
	hash_put(hash, buf, TYPE_STANDARD);
d860 1
a860 1
	hash_put(hash, buf, TYPE_XREF);
d897 1
a897 1
	hash_put(hash, buf, TYPE_VARIABLE);
d911 1
a911 1
	hash_put(hash, buf, TYPE_FUNCTION);
d926 1
a926 1
	hash_put(hash, buf, TYPE_DESC);
d938 1
a938 1
	hash_put(hash, buf, TYPE_ERR);
d950 1
a950 1
	hash_put(hash, buf, TYPE_ENV);
d962 1
a962 1
	hash_put(hash, buf, TYPE_PATH);
d972 1
a972 1
		hash_put(hash, buf, TYPE_NAME);
d981 1
a981 1
	hash_put(hash, buf, TYPE_UTILITY);
d1111 1
a1111 1
				hash_put(hash, buf, TYPE_NAME);
d1150 1
a1150 1
			hash_put(hash, buf, TYPE_DESC);
@


1.6
log
@fix an obvious typo: sz was used uninitialized
found while merging to OpenBSD
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.5 2011/07/15 17:59:29 kristaps Exp $ */
d1171 3
a1173 4
	if (pman_node(hash, buf, dbuf, n->child))
		return(1);
	if (pman_node(hash, buf, dbuf, n->next))
		return(1);
d1278 1
@


1.5
log
@Big step forward in bringing mandocdb in line with most makewhatis-type
systems.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.4 2011/07/15 10:15:24 kristaps Exp $ */
d1257 1
a1257 1
		strlcat(buf, fn, MAXPATHLEN);
@


1.4
log
@First step of making mandocdb a true makewhatis/mandb replacement:
accept a set of directories on the command line ("manpaths") that are
recursed for files.  The databases are created in each manpath root.
This temporarily removes OP_UPDATE and OP_DELETE functionality, which
will be added back in.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.3 2011/07/15 09:06:23 kristaps Exp $ */
a44 1
#define	MANDOC_FLAGS	  O_CREAT|O_TRUNC|O_RDWR
d63 2
d66 3
a68 3
	char		 *fname;
	struct of	 *next;
	struct of	 *first;
d75 2
a76 2
	size_t		  len;
	size_t		  size;
d83 1
a83 1
	OP_UPDATE, /* update entries in existing database */
d108 1
a108 1
				DB *, const char *, 
d112 3
a114 2
				recno_t *, recno_t **, size_t *);
static	int		  ofile_build(const char *, struct of **);
d268 1
d271 2
a272 1
	int		 ch, i, flags;
d279 2
a280 1
	size_t		 recsz, /* buffer size of recs */
d284 1
a284 1
	struct of	*of;
d294 1
d303 1
d305 1
a305 4
	memset(&buf, 0, sizeof(struct buf));
	memset(&dbuf, 0, sizeof(struct buf));

	while (-1 != (ch = getopt(argc, argv, "")))
d307 11
d331 2
a332 1
	flags = OP_NEW == op ? O_CREAT|O_TRUNC|O_RDWR : O_CREAT|O_RDWR;
d339 51
d391 1
a391 2
		ibuf[0] = ibuf[MAXPATHLEN - 2] =
			fbuf[0] = fbuf[MAXPATHLEN - 2] = '\0';
d394 2
a395 1
		strlcat(fbuf, MANDOC_DB, MAXPATHLEN);
d398 2
a399 1
		strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d401 1
a401 2
		if ('\0' != fbuf[MAXPATHLEN - 2] ||
				'\0' != ibuf[MAXPATHLEN - 2]) {
d403 1
a403 1
			break;
d411 1
a411 1
			break;
d414 6
a419 1
			break;
d425 2
a426 3
		if ( ! ofile_build(argv[i], &of))
			break;
		of = of->first;
d428 2
a429 3
		if (OP_DELETE == op || OP_UPDATE == op)
			index_prune(of, db, fbuf, idx, ibuf, 
					&maxrec, &recs, &recsz);
d431 1
a431 2
		if (OP_DELETE == op)
			continue;
d433 2
a434 2
		index_merge(of, mp, &dbuf, &buf, hash, db, 
				fbuf, idx, ibuf, maxrec, recs, reccur);
d437 1
d452 1
a452 1
	return(i < argc ? MANDOCLEVEL_SYSERR : MANDOCLEVEL_OK);
d459 1
a459 1
		DB *idx, const char *idxf, 
d545 3
a547 2
			printf("%s: Added keyword: %s\n", 
					fn, (char *)key.data);
d569 2
a570 1
		printf("%s: Added index\n", fn);
d583 1
a583 1
		DB *idx, const char *idxf, 
d623 3
a625 2
			printf("%s: Deleted keyword: %s\n", 
				fn, (char *)key.data);
d635 2
a636 1
		printf("%s: Deleted index\n", fn);
d742 1
a742 1
	*db = dbopen(NULL, MANDOC_FLAGS, 0644, DB_HASH, NULL);
d1179 22
d1210 1
a1210 1
ofile_build(const char *dir, struct of **of)
d1212 2
d1227 12
a1238 2
			if (strcmp(".", fn) && strcmp("..", fn))
				if ( ! ofile_build(dp->d_name, of))
d1240 8
a1247 2
			continue;
		} else if (DT_REG != dp->d_type)
d1254 9
d1264 4
a1267 1
		nof->fname = mandoc_strdup(fn);
d1273 1
d1299 4
a1302 1
	fprintf(stderr, "usage: %s [dir...]\n", progname);
@


1.3
log
@Move parts of mandocdb that "do stuff" to the databases into their own
functions.  This will make it easier to call repeatedly (for different
directoreis) as must be done with the new interfaces being developed.
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.2 2011/07/14 14:36:37 schwarze Exp $ */
d24 1
d67 1
d112 2
a265 1
	const char	*dir; /* result dir (default: cwd) */
d268 1
a268 1
	int		 ch, verb, i;
a271 1
	enum mandoclevel ec; /* exit status */
d279 1
a279 1
	struct of	*ofile;
d289 1
a289 3
	ofile = NULL;
	dir = "";
	verb = 0;
a296 1
	ec = MANDOCLEVEL_SYSERR;
d301 1
a301 1
	while (-1 != (ch = getopt(argc, argv, "d:ruv")))
a302 12
		case ('d'):
			dir = optarg;
			break;
		case ('r'):
			op = OP_DELETE;
			break;
		case ('u'):
			op = OP_UPDATE;
			break;
		case ('v'):
			verb++;
			break;
d311 2
a312 2
	ibuf[0] = ibuf[MAXPATHLEN - 2] =
		fbuf[0] = fbuf[MAXPATHLEN - 2] = '\0';
d314 1
a314 2
	strlcat(fbuf, dir, MAXPATHLEN);
	strlcat(fbuf, MANDOC_DB, MAXPATHLEN);
d316 1
a316 2
	strlcat(ibuf, dir, MAXPATHLEN);
	strlcat(ibuf, MANDOC_IDX, MAXPATHLEN);
d318 1
a318 5
	if ('\0' != fbuf[MAXPATHLEN - 2] ||
			'\0' != ibuf[MAXPATHLEN - 2]) {
		fprintf(stderr, "%s: Path too long\n", dir);
		goto out;
	}
d320 2
a321 6
	/*
	 * For the keyword database, open a BTREE database that allows
	 * duplicates.  
	 * For the index database, use a standard RECNO database type.
	 * Truncate the database if we're creating a new one.
	 */
d323 3
a325 2
	memset(&info, 0, sizeof(BTREEINFO));
	info.flags = R_DUP;
d327 2
a328 7
	if (OP_NEW == op) {
		db = dbopen(fbuf, MANDOC_FLAGS, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, MANDOC_FLAGS, 0644, DB_RECNO, NULL);
	} else {
		db = dbopen(fbuf, O_CREAT|O_RDWR, 0644, DB_BTREE, &info);
		idx = dbopen(ibuf, O_CREAT|O_RDWR, 0644, DB_RECNO, NULL);
	}
d330 2
a331 7
	if (NULL == db) {
		perror(fbuf);
		goto out;
	} else if (NULL == db) {
		perror(ibuf);
		goto out;
	}
d333 5
a337 5
	ofile = mandoc_calloc(argc, sizeof(struct of));
	for (i = 0; i < argc; i++) {
		ofile[i].next = &ofile[i + 1];
		ofile[i].fname = argv[i];
	}
d339 2
a340 1
	ofile[argc - 1].next = NULL;
d342 7
a348 8
	/*
	 * If we're going to delete or update a database, remove the
	 * entries now (both the index and all keywords pointing to it).
	 * This doesn't actually remove them: it only sets their record
	 * value lengths to zero.
	 * While doing so, add the empty records to a list we'll access
	 * later in re-adding entries to the database.
	 */
d350 2
a351 8
	if (OP_DELETE == op || OP_UPDATE == op)
		index_prune(ofile, db, fbuf, idx, ibuf, 
				&maxrec, &recs, &recsz);

	if (OP_DELETE == op) {
		ec = MANDOCLEVEL_OK;
		goto out;
	}
d353 3
a355 7
	/*
	 * Add records to the database.
	 * Try parsing each manual given on the command line.  
	 * If we fail, then emit an error and keep on going.  
	 * Take resulting trees and push them down into the database code.
	 * Use the auto-parser and don't report any errors.
	 */
d357 3
a359 1
	mp = mparse_alloc(MPARSE_AUTO, MANDOCLEVEL_FATAL, NULL, NULL);
d361 2
a362 3
	buf.size = dbuf.size = MANDOC_BUFSZ;
	buf.cp = mandoc_malloc(buf.size);
	dbuf.cp = mandoc_malloc(dbuf.size);
d364 3
a366 2
	index_merge(ofile, mp, &dbuf, &buf, hash, db, 
			fbuf, idx, ibuf, maxrec, recs, reccur);
a367 2
	ec = MANDOCLEVEL_OK;
out:
d377 1
a377 1
	free(ofile);
d382 1
a382 1
	return((int)ec);
d1105 63
d1172 1
a1172 2
	fprintf(stderr, "usage: %s [-ruv] [-d path] [file...]\n", 
			progname);
@


1.2
log
@move mandocdb(1) to mandocdb(8)
"please make this change" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: mandocdb.c,v 1.1 2011/07/14 10:57:02 kristaps Exp $ */
d63 5
d102 8
a260 2
	struct mdoc	*mdoc; /* resulting mdoc */
	struct man	*man; /* resulting man */
d262 1
a262 5
	char		*fn; /* current file being parsed */
	const char	*msec, /* manual section */
	      	 	*mtitle, /* manual title */
			*arch, /* manual architecture */
	      		*dir; /* result dir (default: cwd) */
d264 2
a265 3
			 fbuf[MAXPATHLEN],  /* btree fname */
			 vbuf[8]; /* stringified record number */
	int		 ch, seq, sseq, verb, i;
a268 1
	DBT		 key, val;
a269 1
	size_t		 sv;
d271 1
a271 2
	recno_t		 rec,
			 maxrec; /* supremum of all records */
d277 1
d287 1
d365 8
d382 3
a384 64
	if (OP_DELETE == op || OP_UPDATE == op) {
		seq = R_FIRST;
		while (0 == (ch = (*idx->seq)(idx, &key, &val, seq))) {
			seq = R_NEXT;
			maxrec = *(recno_t *)key.data;
			if (0 == val.size && OP_UPDATE == op) {
				if (reccur >= recsz) {
					recsz += MANDOC_SLOP;
					recs = mandoc_realloc
						(recs, recsz * sizeof(recno_t));
				}
				recs[(int)reccur] = maxrec;
				reccur++;
				continue;
			}

			fn = (char *)val.data;
			for (i = 0; i < argc; i++)
				if (0 == strcmp(fn, argv[i]))
					break;

			if (i == argc)
				continue;

			sseq = R_FIRST;
			while (0 == (ch = (*db->seq)(db, &key, &val, sseq))) {
				sseq = R_NEXT;
				assert(8 == val.size);
				if (maxrec != *(recno_t *)(val.data + 4))
					continue;
				if (verb > 1)
					printf("%s: Deleted keyword: %s\n", 
						fn, (char *)key.data);
				ch = (*db->del)(db, &key, R_CURSOR);
				if (ch < 0)
					break;
			}
			if (ch < 0) {
				perror(fbuf);
				exit((int)MANDOCLEVEL_SYSERR);
			}

			if (verb)
				printf("%s: Deleted index\n", fn);

			val.size = 0;
			ch = (*idx->put)(idx, &key, &val, R_CURSOR);
			if (ch < 0) {
				perror(ibuf);
				exit((int)MANDOCLEVEL_SYSERR);
			}

			if (OP_UPDATE == op) {
				if (reccur >= recsz) {
					recsz += MANDOC_SLOP;
					recs = mandoc_realloc
						(recs, recsz * sizeof(recno_t));
				}
				recs[(int)reccur] = maxrec;
				reccur++;
			}
		}
		maxrec++;
	}
d405 47
a451 11
	for (rec = 0, i = 0; i < argc; i++) {
		fn = argv[i];
		if (OP_UPDATE == op) {
			if (reccur > 0) {
				--reccur;
				rec = recs[(int)reccur];
			} else if (maxrec > 0) {
				rec = maxrec;
				maxrec = 0;
			} else
				rec++;
d471 2
a472 1
		arch = NULL != mdoc ? mdoc_meta(mdoc)->arch : NULL;
d485 5
a489 5
		dbuf.len = 0;
		buf_appendb(&dbuf, fn, strlen(fn) + 1);
		buf_appendb(&dbuf, msec, strlen(msec) + 1);
		buf_appendb(&dbuf, mtitle, strlen(mtitle) + 1);
		buf_appendb(&dbuf, arch, strlen(arch) + 1);
d491 1
a491 1
		sv = dbuf.len;
d496 1
a496 1
			pmdoc_node(hash, &buf, &dbuf,
d499 1
a499 1
			pman_node(hash, &buf, &dbuf, man_node(man));
d517 3
a519 5
			if (verb > 1)
				printf("%s: Added keyword: %s, 0x%x\n", 
					fn, (char *)key.data, 
					*(int *)val.data);
			dbt_put(db, fbuf, &key, &val);
d531 2
a532 2
		if (dbuf.len == sv)
			buf_appendb(&dbuf, "", 1);
d537 7
a543 2
		val.data = dbuf.cp;
		val.size = dbuf.len;
d545 17
a561 2
		if (verb > 0)
			printf("%s: Added index\n", fn);
d563 42
a604 2
		dbt_put(idx, ibuf, &key, &val);
	}
d606 6
a611 10
	ec = MANDOCLEVEL_OK;
out:
	if (db)
		(*db->close)(db);
	if (idx)
		(*idx->close)(idx);
	if (hash)
		(*hash->close)(hash);
	if (mp)
		mparse_free(mp);
d613 5
a617 3
	free(buf.cp);
	free(dbuf.cp);
	free(recs);
d619 4
a622 1
	return((int)ec);
@


1.1
log
@Rename makewhatis [back] into mandocdb.  This is to maintain consistency
with OpenBSD, which is sandboxing the code for merge.  It makes sense
because it doesn't really make a `makewhatis' file in the traditional
sense, so it may be confusing.
@
text
@d1 1
a1 1
/*	$Id: makewhatis.c,v 1.21 2011/07/12 15:26:35 kristaps Exp $ */
d47 1
a47 1
/* Bit-fields.  See makewhatis.1. */
@
