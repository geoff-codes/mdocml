head	1.283;
access;
symbols
	VERSION_1_13_3:1.263
	VERSION_1_13_2:1.239
	VERSION_1_12_4:1.226
	VERSION_1_13_1:1.224
	VERSION_1_12_3:1.189
	VERSION_1_12_2:1.178
	VERSION_1_12:1.226.0.2
	VERSION_1_12_1:1.172
	VERSION_1_12_0:1.171
	VERSION_1_11_7:1.168
	VERSION_1_11_6:1.168
	VERSION_1_11_5:1.150
	VERSION_1_11_4:1.144
	VERSION_1_11_3:1.142
	VERSION_1_11_2:1.137
	VERSION_1_11_1:1.130
	VERSION_1_10_10:1.127
	VERSION_1_10_9:1.120
	VERSION_1_10_8:1.108
	VERSION_1_10_7:1.107
	VERSION_1_10_6:1.102
	VERSION_1_10_5:1.97
	VERSION_1_10_5_PREPDF:1.95
	VERSION_1_10_4:1.94
	VERSION_1_10_3:1.91
	VERSION_1_10_2:1.88
	VERSION_1_10_1:1.86
	VERSION_1_9_5:1.65
	VERSION_1_8_5:1.65
	VERSION_1_8_1:1.65
	VERSION_1_7_16:1.65
	VERSION_1_7_15:1.65
	OPENBSD_CHECKIN:1.65
	VERSION_1_6_5:1.65
	VERSION_1_5_1:1.65
	VERSION_1_3_15:1.65
	VERSION_1_3_6:1.65
	VERSION_1_2_0:1.65
	VERSION_1_0_2:1.60
	VERSION_1_0_1:1.51;
locks; strict;
comment	@ * @;


1.283
date	2015.10.22.21.54.23;	author schwarze;	state Exp;
branches;
next	1.282;

1.282
date	2015.10.21.23.51.11;	author schwarze;	state Exp;
branches;
next	1.281;

1.281
date	2015.10.20.02.01.32;	author schwarze;	state Exp;
branches;
next	1.280;

1.280
date	2015.10.15.23.35.55;	author schwarze;	state Exp;
branches;
next	1.279;

1.279
date	2015.10.13.22.59.54;	author schwarze;	state Exp;
branches;
next	1.278;

1.278
date	2015.10.12.00.08.16;	author schwarze;	state Exp;
branches;
next	1.277;

1.277
date	2015.10.06.18.32.20;	author schwarze;	state Exp;
branches;
next	1.276;

1.276
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.275;

1.275
date	2015.08.29.23.56.01;	author schwarze;	state Exp;
branches;
next	1.274;

1.274
date	2015.08.29.21.37.20;	author schwarze;	state Exp;
branches;
next	1.273;

1.273
date	2015.08.29.20.26.04;	author schwarze;	state Exp;
branches;
next	1.272;

1.272
date	2015.06.27.13.29.14;	author schwarze;	state Exp;
branches;
next	1.271;

1.271
date	2015.05.31.23.13.22;	author schwarze;	state Exp;
branches;
next	1.270;

1.270
date	2015.05.01.16.02.47;	author schwarze;	state Exp;
branches;
next	1.269;

1.269
date	2015.04.23.16.17.44;	author schwarze;	state Exp;
branches;
next	1.268;

1.268
date	2015.04.19.14.57.38;	author schwarze;	state Exp;
branches;
next	1.267;

1.267
date	2015.04.19.14.25.41;	author schwarze;	state Exp;
branches;
next	1.266;

1.266
date	2015.04.19.13.50.26;	author schwarze;	state Exp;
branches;
next	1.265;

1.265
date	2015.04.18.17.28.36;	author schwarze;	state Exp;
branches;
next	1.264;

1.264
date	2015.04.04.13.53.42;	author schwarze;	state Exp;
branches;
next	1.263;

1.263
date	2015.02.21.14.46.58;	author schwarze;	state Exp;
branches;
next	1.262;

1.262
date	2015.02.17.18.09.14;	author schwarze;	state Exp;
branches;
next	1.261;

1.261
date	2015.02.17.17.16.52;	author schwarze;	state Exp;
branches;
next	1.260;

1.260
date	2015.02.06.16.06.25;	author schwarze;	state Exp;
branches;
next	1.259;

1.259
date	2015.01.30.00.19.46;	author schwarze;	state Exp;
branches;
next	1.258;

1.258
date	2015.01.28.17.32.07;	author schwarze;	state Exp;
branches;
next	1.257;

1.257
date	2015.01.28.15.03.45;	author schwarze;	state Exp;
branches;
next	1.256;

1.256
date	2015.01.24.02.41.49;	author schwarze;	state Exp;
branches;
next	1.255;

1.255
date	2015.01.23.20.18.40;	author schwarze;	state Exp;
branches;
next	1.254;

1.254
date	2015.01.23.00.42.00;	author schwarze;	state Exp;
branches;
next	1.253;

1.253
date	2015.01.22.22.51.43;	author schwarze;	state Exp;
branches;
next	1.252;

1.252
date	2015.01.21.02.16.52;	author schwarze;	state Exp;
branches;
next	1.251;

1.251
date	2015.01.20.21.16.51;	author schwarze;	state Exp;
branches;
next	1.250;

1.250
date	2015.01.16.16.53.49;	author schwarze;	state Exp;
branches;
next	1.249;

1.249
date	2015.01.14.22.58.16;	author schwarze;	state Exp;
branches;
next	1.248;

1.248
date	2015.01.07.12.19.46;	author schwarze;	state Exp;
branches;
next	1.247;

1.247
date	2015.01.01.19.28.49;	author schwarze;	state Exp;
branches;
next	1.246;

1.246
date	2014.12.28.14.16.26;	author schwarze;	state Exp;
branches;
next	1.245;

1.245
date	2014.12.25.17.23.32;	author schwarze;	state Exp;
branches;
next	1.244;

1.244
date	2014.12.18.17.43.41;	author schwarze;	state Exp;
branches;
next	1.243;

1.243
date	2014.12.16.23.44.41;	author schwarze;	state Exp;
branches;
next	1.242;

1.242
date	2014.12.16.03.53.43;	author schwarze;	state Exp;
branches;
next	1.241;

1.241
date	2014.12.16.01.22.59;	author schwarze;	state Exp;
branches;
next	1.240;

1.240
date	2014.12.15.23.43.26;	author schwarze;	state Exp;
branches;
next	1.239;

1.239
date	2014.11.19.01.20.25;	author schwarze;	state Exp;
branches;
next	1.238;

1.238
date	2014.11.01.06.03.13;	author schwarze;	state Exp;
branches;
next	1.237;

1.237
date	2014.10.28.17.36.19;	author schwarze;	state Exp;
branches;
next	1.236;

1.236
date	2014.10.25.15.23.56;	author schwarze;	state Exp;
branches;
next	1.235;

1.235
date	2014.10.25.14.35.37;	author schwarze;	state Exp;
branches;
next	1.234;

1.234
date	2014.10.20.19.04.45;	author kristaps;	state Exp;
branches;
next	1.233;

1.233
date	2014.10.20.15.04.56;	author schwarze;	state Exp;
branches;
next	1.232;

1.232
date	2014.10.20.02.33.06;	author schwarze;	state Exp;
branches;
next	1.231;

1.231
date	2014.10.16.01.28.38;	author schwarze;	state Exp;
branches;
next	1.230;

1.230
date	2014.10.16.01.11.20;	author schwarze;	state Exp;
branches;
next	1.229;

1.229
date	2014.09.07.00.21.53;	author schwarze;	state Exp;
branches;
next	1.228;

1.228
date	2014.09.06.23.24.32;	author schwarze;	state Exp;
branches;
next	1.227;

1.227
date	2014.09.06.22.39.36;	author schwarze;	state Exp;
branches;
next	1.226;

1.226
date	2014.08.19.16.52.32;	author schwarze;	state Exp;
branches;
next	1.225;

1.225
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.224;

1.224
date	2014.08.01.17.27.44;	author schwarze;	state Exp;
branches;
next	1.223;

1.223
date	2014.08.01.15.08.46;	author schwarze;	state Exp;
branches;
next	1.222;

1.222
date	2014.07.30.12.58.21;	author schwarze;	state Exp;
branches;
next	1.221;

1.221
date	2014.07.07.21.36.20;	author schwarze;	state Exp;
branches;
next	1.220;

1.220
date	2014.07.07.11.35.06;	author schwarze;	state Exp;
branches;
next	1.219;

1.219
date	2014.07.06.19.09.00;	author schwarze;	state Exp;
branches;
next	1.218;

1.218
date	2014.07.06.18.46.55;	author schwarze;	state Exp;
branches;
next	1.217;

1.217
date	2014.07.04.16.12.08;	author schwarze;	state Exp;
branches;
next	1.216;

1.216
date	2014.07.03.21.23.54;	author schwarze;	state Exp;
branches;
next	1.215;

1.215
date	2014.07.01.00.32.29;	author schwarze;	state Exp;
branches;
next	1.214;

1.214
date	2014.06.29.23.26.00;	author schwarze;	state Exp;
branches;
next	1.213;

1.213
date	2014.06.29.22.38.47;	author schwarze;	state Exp;
branches;
next	1.212;

1.212
date	2014.06.29.22.14.10;	author schwarze;	state Exp;
branches;
next	1.211;

1.211
date	2014.06.29.21.20.31;	author schwarze;	state Exp;
branches;
next	1.210;

1.210
date	2014.06.25.00.20.19;	author schwarze;	state Exp;
branches;
next	1.209;

1.209
date	2014.04.23.16.08.33;	author schwarze;	state Exp;
branches;
next	1.208;

1.208
date	2014.04.20.19.40.13;	author schwarze;	state Exp;
branches;
next	1.207;

1.207
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.206;

1.206
date	2014.04.08.01.37.27;	author schwarze;	state Exp;
branches;
next	1.205;

1.205
date	2014.04.07.21.00.08;	author schwarze;	state Exp;
branches;
next	1.204;

1.204
date	2014.04.07.15.07.13;	author schwarze;	state Exp;
branches;
next	1.203;

1.203
date	2014.04.05.20.34.57;	author schwarze;	state Exp;
branches;
next	1.202;

1.202
date	2014.03.23.12.11.18;	author schwarze;	state Exp;
branches;
next	1.201;

1.201
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.200;

1.200
date	2014.03.20.02.57.28;	author schwarze;	state Exp;
branches;
next	1.199;

1.199
date	2014.03.19.21.51.20;	author schwarze;	state Exp;
branches;
next	1.198;

1.198
date	2014.03.08.04.43.54;	author schwarze;	state Exp;
branches;
next	1.197;

1.197
date	2014.03.07.18.37.37;	author schwarze;	state Exp;
branches;
next	1.196;

1.196
date	2014.03.07.18.30.11;	author schwarze;	state Exp;
branches;
next	1.195;

1.195
date	2014.03.07.02.22.05;	author schwarze;	state Exp;
branches;
next	1.194;

1.194
date	2014.02.14.23.24.26;	author schwarze;	state Exp;
branches;
next	1.193;

1.193
date	2014.02.14.23.05.20;	author schwarze;	state Exp;
branches;
next	1.192;

1.192
date	2014.02.14.22.27.41;	author schwarze;	state Exp;
branches;
next	1.191;

1.191
date	2014.01.06.23.46.07;	author schwarze;	state Exp;
branches;
next	1.190;

1.190
date	2014.01.06.21.34.31;	author schwarze;	state Exp;
branches;
next	1.189;

1.189
date	2013.12.30.18.44.06;	author schwarze;	state Exp;
branches;
next	1.188;

1.188
date	2013.12.25.00.50.05;	author schwarze;	state Exp;
branches;
next	1.187;

1.187
date	2013.12.15.21.23.52;	author schwarze;	state Exp;
branches;
next	1.186;

1.186
date	2013.10.22.20.38.00;	author schwarze;	state Exp;
branches;
next	1.185;

1.185
date	2013.10.14.01.43.14;	author schwarze;	state Exp;
branches;
next	1.184;

1.184
date	2013.10.05.22.25.12;	author schwarze;	state Exp;
branches;
next	1.183;

1.183
date	2013.10.05.22.21.20;	author schwarze;	state Exp;
branches;
next	1.182;

1.182
date	2013.10.05.22.19.10;	author schwarze;	state Exp;
branches;
next	1.181;

1.181
date	2013.10.05.22.15.03;	author schwarze;	state Exp;
branches;
next	1.180;

1.180
date	2013.10.05.22.08.12;	author schwarze;	state Exp;
branches;
next	1.179;

1.179
date	2013.10.05.20.30.05;	author schwarze;	state Exp;
branches;
next	1.178;

1.178
date	2013.07.13.12.52.07;	author schwarze;	state Exp;
branches;
next	1.177;

1.177
date	2013.06.27.09.49.47;	author schwarze;	state Exp;
branches;
next	1.176;

1.176
date	2013.05.31.22.08.09;	author schwarze;	state Exp;
branches;
next	1.175;

1.175
date	2012.11.19.17.57.23;	author schwarze;	state Exp;
branches;
next	1.174;

1.174
date	2012.06.12.20.21.04;	author kristaps;	state Exp;
branches;
next	1.173;

1.173
date	2012.05.31.22.41.19;	author schwarze;	state Exp;
branches;
next	1.172;

1.172
date	2011.10.24.21.41.45;	author schwarze;	state Exp;
branches;
next	1.171;

1.171
date	2011.09.19.08.34.45;	author schwarze;	state Exp;
branches;
next	1.170;

1.170
date	2011.09.18.23.51.31;	author schwarze;	state Exp;
branches;
next	1.169;

1.169
date	2011.09.18.14.14.15;	author schwarze;	state Exp;
branches;
next	1.168;

1.168
date	2011.08.16.12.30.12;	author kristaps;	state Exp;
branches;
next	1.167;

1.167
date	2011.07.29.10.16.59;	author kristaps;	state Exp;
branches;
next	1.166;

1.166
date	2011.07.29.09.19.48;	author kristaps;	state Exp;
branches;
next	1.165;

1.165
date	2011.07.28.14.53.22;	author kristaps;	state Exp;
branches;
next	1.164;

1.164
date	2011.07.28.14.17.11;	author kristaps;	state Exp;
branches;
next	1.163;

1.163
date	2011.07.27.20.55.28;	author kristaps;	state Exp;
branches;
next	1.162;

1.162
date	2011.07.27.17.25.30;	author kristaps;	state Exp;
branches;
next	1.161;

1.161
date	2011.07.27.14.58.28;	author kristaps;	state Exp;
branches;
next	1.160;

1.160
date	2011.07.27.14.23.27;	author kristaps;	state Exp;
branches;
next	1.159;

1.159
date	2011.07.27.14.19.26;	author kristaps;	state Exp;
branches;
next	1.158;

1.158
date	2011.07.27.13.47.26;	author kristaps;	state Exp;
branches;
next	1.157;

1.157
date	2011.07.27.13.42.27;	author kristaps;	state Exp;
branches;
next	1.156;

1.156
date	2011.07.27.12.41.02;	author kristaps;	state Exp;
branches;
next	1.155;

1.155
date	2011.07.27.07.32.26;	author kristaps;	state Exp;
branches;
next	1.154;

1.154
date	2011.07.27.07.09.41;	author kristaps;	state Exp;
branches;
next	1.153;

1.153
date	2011.07.26.14.24.06;	author kristaps;	state Exp;
branches;
next	1.152;

1.152
date	2011.07.26.14.09.01;	author kristaps;	state Exp;
branches;
next	1.151;

1.151
date	2011.07.25.15.37.00;	author kristaps;	state Exp;
branches;
next	1.150;

1.150
date	2011.07.23.18.41.18;	author kristaps;	state Exp;
branches;
next	1.149;

1.149
date	2011.07.21.15.21.13;	author kristaps;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.21.10.24.35;	author kristaps;	state Exp;
branches;
next	1.147;

1.147
date	2011.07.18.07.46.41;	author kristaps;	state Exp;
branches;
next	1.146;

1.146
date	2011.07.17.12.13.37;	author kristaps;	state Exp;
branches;
next	1.145;

1.145
date	2011.07.12.21.32.43;	author kristaps;	state Exp;
branches;
next	1.144;

1.144
date	2011.07.08.09.28.33;	author kristaps;	state Exp;
branches;
next	1.143;

1.143
date	2011.06.30.08.05.13;	author kristaps;	state Exp;
branches;
next	1.142;

1.142
date	2011.05.26.11.58.25;	author kristaps;	state Exp;
branches;
next	1.141;

1.141
date	2011.05.24.21.18.06;	author kristaps;	state Exp;
branches;
next	1.140;

1.140
date	2011.05.24.15.22.14;	author kristaps;	state Exp;
branches;
next	1.139;

1.139
date	2011.05.24.14.00.39;	author kristaps;	state Exp;
branches;
next	1.138;

1.138
date	2011.05.14.16.06.08;	author kristaps;	state Exp;
branches;
next	1.137;

1.137
date	2011.04.24.23.51.17;	author schwarze;	state Exp;
branches;
next	1.136;

1.136
date	2011.04.19.16.38.48;	author kristaps;	state Exp;
branches;
next	1.135;

1.135
date	2011.04.17.09.08.19;	author kristaps;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.13.16.26.11;	author kristaps;	state Exp;
branches;
next	1.133;

1.133
date	2011.04.13.10.01.27;	author kristaps;	state Exp;
branches;
next	1.132;

1.132
date	2011.04.13.09.57.41;	author kristaps;	state Exp;
branches;
next	1.131;

1.131
date	2011.04.05.22.22.33;	author schwarze;	state Exp;
branches;
next	1.130;

1.130
date	2011.03.29.09.00.48;	author kristaps;	state Exp;
branches;
next	1.129;

1.129
date	2011.03.22.09.50.11;	author kristaps;	state Exp;
branches;
next	1.128;

1.128
date	2011.03.20.16.02.05;	author kristaps;	state Exp;
branches;
next	1.127;

1.127
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.126;

1.126
date	2011.02.09.09.05.52;	author kristaps;	state Exp;
branches;
next	1.125;

1.125
date	2011.02.06.20.36.36;	author kristaps;	state Exp;
branches;
next	1.124;

1.124
date	2011.01.25.01.12.02;	author schwarze;	state Exp;
branches;
next	1.123;

1.123
date	2011.01.22.13.16.02;	author schwarze;	state Exp;
branches;
next	1.122;

1.122
date	2011.01.16.04.00.34;	author schwarze;	state Exp;
branches;
next	1.121;

1.121
date	2011.01.11.00.11.45;	author schwarze;	state Exp;
branches;
next	1.120;

1.120
date	2011.01.03.23.24.16;	author schwarze;	state Exp;
branches;
next	1.119;

1.119
date	2011.01.03.22.42.37;	author schwarze;	state Exp;
branches;
next	1.118;

1.118
date	2011.01.02.10.10.57;	author kristaps;	state Exp;
branches;
next	1.117;

1.117
date	2011.01.01.16.18.39;	author kristaps;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.01.16.10.40;	author kristaps;	state Exp;
branches;
next	1.115;

1.115
date	2011.01.01.15.45.18;	author kristaps;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.31.18.19.43;	author kristaps;	state Exp;
branches;
next	1.113;

1.113
date	2010.12.31.14.52.41;	author kristaps;	state Exp;
branches;
next	1.112;

1.112
date	2010.12.29.14.53.31;	author kristaps;	state Exp;
branches;
next	1.111;

1.111
date	2010.12.29.01.16.57;	author kristaps;	state Exp;
branches;
next	1.110;

1.110
date	2010.12.28.10.59.07;	author kristaps;	state Exp;
branches;
next	1.109;

1.109
date	2010.12.28.10.51.03;	author kristaps;	state Exp;
branches;
next	1.108;

1.108
date	2010.12.21.01.46.44;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2010.12.06.13.25.25;	author kristaps;	state Exp;
branches;
next	1.106;

1.106
date	2010.12.02.10.53.03;	author kristaps;	state Exp;
branches;
next	1.105;

1.105
date	2010.12.01.16.54.25;	author kristaps;	state Exp;
branches;
next	1.104;

1.104
date	2010.12.01.10.31.35;	author kristaps;	state Exp;
branches;
next	1.103;

1.103
date	2010.12.01.10.21.25;	author kristaps;	state Exp;
branches;
next	1.102;

1.102
date	2010.09.04.20.18.53;	author kristaps;	state Exp;
branches;
next	1.101;

1.101
date	2010.09.04.18.31.44;	author kristaps;	state Exp;
branches;
next	1.100;

1.100
date	2010.08.29.11.29.51;	author kristaps;	state Exp;
branches;
next	1.99;

1.99
date	2010.08.24.12.48.43;	author kristaps;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.20.01.02.07;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.27.19.56.50;	author kristaps;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.27.13.16.00;	author kristaps;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.21.09.15.48;	author kristaps;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.07.15.04.54;	author kristaps;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.04.22.04.04;	author schwarze;	state Exp;
branches;
next	1.92;

1.92
date	2010.07.03.16.02.12;	author schwarze;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.27.16.36.22;	author kristaps;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.27.15.52.41;	author kristaps;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.26.15.22.19;	author kristaps;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.10.21.42.02;	author kristaps;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.09.20.00.38;	author kristaps;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.01.11.47.28;	author kristaps;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.29.19.41.47;	author kristaps;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.24.23.54.18;	author schwarze;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.24.22.25.58;	author schwarze;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.17.02.01.05;	author kristaps;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.17.00.46.35;	author kristaps;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.17.00.37.26;	author kristaps;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.17.00.06.36;	author kristaps;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.16.22.28.33;	author kristaps;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.16.19.08.11;	author kristaps;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.16.14.47.19;	author kristaps;	state Exp;
branches;
next	1.75;

1.75
date	2010.05.16.13.49.23;	author kristaps;	state Exp;
branches;
next	1.74;

1.74
date	2010.05.16.10.59.36;	author kristaps;	state Exp;
branches;
next	1.73;

1.73
date	2010.05.15.22.28.22;	author kristaps;	state Exp;
branches;
next	1.72;

1.72
date	2010.05.15.22.22.51;	author kristaps;	state Exp;
branches;
next	1.71;

1.71
date	2010.05.15.21.53.11;	author kristaps;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.15.20.51.40;	author kristaps;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.15.18.48.32;	author kristaps;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.15.18.43.59;	author kristaps;	state Exp;
branches;
next	1.67;

1.67
date	2010.05.15.18.35.14;	author kristaps;	state Exp;
branches;
next	1.66;

1.66
date	2010.05.15.07.52.11;	author kristaps;	state Exp;
branches;
next	1.65;

1.65
date	2008.12.15.02.29.44;	author kristaps;	state dead;
branches;
next	1.64;

1.64
date	2008.12.12.10.11.10;	author kristaps;	state Exp;
branches;
next	1.63;

1.63
date	2008.12.10.16.03.12;	author kristaps;	state Exp;
branches;
next	1.62;

1.62
date	2008.12.10.13.41.59;	author kristaps;	state Exp;
branches;
next	1.61;

1.61
date	2008.12.10.13.15.55;	author kristaps;	state Exp;
branches;
next	1.60;

1.60
date	2008.12.10.12.09.47;	author kristaps;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.10.12.05.33;	author kristaps;	state Exp;
branches;
next	1.58;

1.58
date	2008.12.10.10.43.57;	author kristaps;	state Exp;
branches;
next	1.57;

1.57
date	2008.12.10.00.52.46;	author kristaps;	state Exp;
branches;
next	1.56;

1.56
date	2008.12.09.19.57.26;	author kristaps;	state Exp;
branches;
next	1.55;

1.55
date	2008.12.09.17.09.12;	author kristaps;	state Exp;
branches;
next	1.54;

1.54
date	2008.12.09.00.27.17;	author kristaps;	state Exp;
branches;
next	1.53;

1.53
date	2008.12.08.20.32.49;	author kristaps;	state Exp;
branches;
next	1.52;

1.52
date	2008.12.08.16.29.57;	author kristaps;	state Exp;
branches;
next	1.51;

1.51
date	2008.12.08.12.46.28;	author kristaps;	state Exp;
branches;
next	1.50;

1.50
date	2008.12.07.22.40.18;	author kristaps;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.07.16.41.04;	author kristaps;	state Exp;
branches;
next	1.48;

1.48
date	2008.12.07.14.38.57;	author kristaps;	state Exp;
branches;
next	1.47;

1.47
date	2008.12.06.21.10.31;	author kristaps;	state Exp;
branches;
next	1.46;

1.46
date	2008.12.06.19.41.41;	author kristaps;	state Exp;
branches;
next	1.45;

1.45
date	2008.12.06.16.50.18;	author kristaps;	state Exp;
branches;
next	1.44;

1.44
date	2008.12.06.13.18.44;	author kristaps;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.05.22.54.44;	author kristaps;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.05.22.34.30;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.05.11.28.17;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.04.23.10.51;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.04.19.31.57;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2008.12.04.16.34.59;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.04.16.19.52;	author kristaps;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.04.11.25.29;	author kristaps;	state Exp;
branches;
next	1.35;

1.35
date	2008.12.03.19.21.58;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.02.18.26.57;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.02.13.20.24;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.02.00.15.41;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.02.00.10.37;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2008.12.01.21.25.48;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.01.16.14.34;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.01.16.01.28;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.01.15.32.36;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.01.09.25.18;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2008.11.30.23.05.57;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.30.21.41.35;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.30.20.53.34;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.30.18.53.11;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.30.18.50.44;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2008.11.30.12.41.45;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.29.16.23.22;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.29.16.11.42;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.29.14.14.21;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.28.18.15.29;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.28.15.25.49;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.28.11.21.12;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2008.11.27.17.27.50;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.27.16.54.58;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.27.14.02.41;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.27.13.29.44;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.27.11.23.51;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.26.22.27.08;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.26.21.42.59;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.26.16.50.34;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.25.16.49.57;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.25.12.14.02;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.24.18.34.50;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.24.18.32.39;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2008.11.24.14.24.55;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.283
log
@move man(7) validation into the dedicated validation phase, too
@
text
@/*	$Id: roff.c,v 1.282 2015/10/21 23:51:11 schwarze Exp $ */
/*
 * Copyright (c) 2008-2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "mandoc_aux.h"
#include "roff.h"
#include "libmandoc.h"
#include "roff_int.h"
#include "libroff.h"

/* Maximum number of string expansions per line, to break infinite loops. */
#define	EXPAND_LIMIT	1000

/* --- data types --------------------------------------------------------- */

enum	rofft {
	ROFF_ab,
	ROFF_ad,
	ROFF_af,
	ROFF_aln,
	ROFF_als,
	ROFF_am,
	ROFF_am1,
	ROFF_ami,
	ROFF_ami1,
	ROFF_as,
	ROFF_as1,
	ROFF_asciify,
	ROFF_backtrace,
	ROFF_bd,
	ROFF_bleedat,
	ROFF_blm,
	ROFF_box,
	ROFF_boxa,
	ROFF_bp,
	ROFF_BP,
	/* MAN_br, MDOC_br */
	ROFF_break,
	ROFF_breakchar,
	ROFF_brnl,
	ROFF_brp,
	ROFF_brpnl,
	ROFF_c2,
	ROFF_cc,
	ROFF_ce,
	ROFF_cf,
	ROFF_cflags,
	ROFF_ch,
	ROFF_char,
	ROFF_chop,
	ROFF_class,
	ROFF_close,
	ROFF_CL,
	ROFF_color,
	ROFF_composite,
	ROFF_continue,
	ROFF_cp,
	ROFF_cropat,
	ROFF_cs,
	ROFF_cu,
	ROFF_da,
	ROFF_dch,
	ROFF_Dd,
	ROFF_de,
	ROFF_de1,
	ROFF_defcolor,
	ROFF_dei,
	ROFF_dei1,
	ROFF_device,
	ROFF_devicem,
	ROFF_di,
	ROFF_do,
	ROFF_ds,
	ROFF_ds1,
	ROFF_dwh,
	ROFF_dt,
	ROFF_ec,
	ROFF_ecr,
	ROFF_ecs,
	ROFF_el,
	ROFF_em,
	ROFF_EN,
	ROFF_eo,
	ROFF_EP,
	ROFF_EQ,
	ROFF_errprint,
	ROFF_ev,
	ROFF_evc,
	ROFF_ex,
	ROFF_fallback,
	ROFF_fam,
	ROFF_fc,
	ROFF_fchar,
	ROFF_fcolor,
	ROFF_fdeferlig,
	ROFF_feature,
	/* MAN_fi; ignored in mdoc(7) */
	ROFF_fkern,
	ROFF_fl,
	ROFF_flig,
	ROFF_fp,
	ROFF_fps,
	ROFF_fschar,
	ROFF_fspacewidth,
	ROFF_fspecial,
	/* MAN_ft; ignored in mdoc(7) */
	ROFF_ftr,
	ROFF_fzoom,
	ROFF_gcolor,
	ROFF_hc,
	ROFF_hcode,
	ROFF_hidechar,
	ROFF_hla,
	ROFF_hlm,
	ROFF_hpf,
	ROFF_hpfa,
	ROFF_hpfcode,
	ROFF_hw,
	ROFF_hy,
	ROFF_hylang,
	ROFF_hylen,
	ROFF_hym,
	ROFF_hypp,
	ROFF_hys,
	ROFF_ie,
	ROFF_if,
	ROFF_ig,
	/* MAN_in; ignored in mdoc(7) */
	ROFF_index,
	ROFF_it,
	ROFF_itc,
	ROFF_IX,
	ROFF_kern,
	ROFF_kernafter,
	ROFF_kernbefore,
	ROFF_kernpair,
	ROFF_lc,
	ROFF_lc_ctype,
	ROFF_lds,
	ROFF_length,
	ROFF_letadj,
	ROFF_lf,
	ROFF_lg,
	ROFF_lhang,
	ROFF_linetabs,
	/* MAN_ll, MDOC_ll */
	ROFF_lnr,
	ROFF_lnrf,
	ROFF_lpfx,
	ROFF_ls,
	ROFF_lsm,
	ROFF_lt,
	ROFF_mc,
	ROFF_mediasize,
	ROFF_minss,
	ROFF_mk,
	ROFF_mso,
	ROFF_na,
	ROFF_ne,
	/* MAN_nf; ignored in mdoc(7) */
	ROFF_nh,
	ROFF_nhychar,
	ROFF_nm,
	ROFF_nn,
	ROFF_nop,
	ROFF_nr,
	ROFF_nrf,
	ROFF_nroff,
	ROFF_ns,
	ROFF_nx,
	ROFF_open,
	ROFF_opena,
	ROFF_os,
	ROFF_output,
	ROFF_padj,
	ROFF_papersize,
	ROFF_pc,
	ROFF_pev,
	ROFF_pi,
	ROFF_PI,
	ROFF_pl,
	ROFF_pm,
	ROFF_pn,
	ROFF_pnr,
	ROFF_po,
	ROFF_ps,
	ROFF_psbb,
	ROFF_pshape,
	ROFF_pso,
	ROFF_ptr,
	ROFF_pvs,
	ROFF_rchar,
	ROFF_rd,
	ROFF_recursionlimit,
	ROFF_return,
	ROFF_rfschar,
	ROFF_rhang,
	ROFF_rj,
	ROFF_rm,
	ROFF_rn,
	ROFF_rnn,
	ROFF_rr,
	ROFF_rs,
	ROFF_rt,
	ROFF_schar,
	ROFF_sentchar,
	ROFF_shc,
	ROFF_shift,
	ROFF_sizes,
	ROFF_so,
	/* MAN_sp, MDOC_sp */
	ROFF_spacewidth,
	ROFF_special,
	ROFF_spreadwarn,
	ROFF_ss,
	ROFF_sty,
	ROFF_substring,
	ROFF_sv,
	ROFF_sy,
	ROFF_T_,
	ROFF_ta,
	ROFF_tc,
	ROFF_TE,
	ROFF_TH,
	ROFF_ti,
	ROFF_tkf,
	ROFF_tl,
	ROFF_tm,
	ROFF_tm1,
	ROFF_tmc,
	ROFF_tr,
	ROFF_track,
	ROFF_transchar,
	ROFF_trf,
	ROFF_trimat,
	ROFF_trin,
	ROFF_trnt,
	ROFF_troff,
	ROFF_TS,
	ROFF_uf,
	ROFF_ul,
	ROFF_unformat,
	ROFF_unwatch,
	ROFF_unwatchn,
	ROFF_vpt,
	ROFF_vs,
	ROFF_warn,
	ROFF_warnscale,
	ROFF_watch,
	ROFF_watchlength,
	ROFF_watchn,
	ROFF_wh,
	ROFF_while,
	ROFF_write,
	ROFF_writec,
	ROFF_writem,
	ROFF_xflag,
	ROFF_cblock,
	ROFF_USERDEF,
	ROFF_MAX
};

/*
 * An incredibly-simple string buffer.
 */
struct	roffstr {
	char		*p; /* nil-terminated buffer */
	size_t		 sz; /* saved strlen(p) */
};

/*
 * A key-value roffstr pair as part of a singly-linked list.
 */
struct	roffkv {
	struct roffstr	 key;
	struct roffstr	 val;
	struct roffkv	*next; /* next in list */
};

/*
 * A single number register as part of a singly-linked list.
 */
struct	roffreg {
	struct roffstr	 key;
	int		 val;
	struct roffreg	*next;
};

struct	roff {
	struct mparse	*parse; /* parse point */
	struct roffnode	*last; /* leaf of stack */
	int		*rstack; /* stack of inverted `ie' values */
	struct roffreg	*regtab; /* number registers */
	struct roffkv	*strtab; /* user-defined strings & macros */
	struct roffkv	*xmbtab; /* multi-byte trans table (`tr') */
	struct roffstr	*xtab; /* single-byte trans table (`tr') */
	const char	*current_string; /* value of last called user macro */
	struct tbl_node	*first_tbl; /* first table parsed */
	struct tbl_node	*last_tbl; /* last table parsed */
	struct tbl_node	*tbl; /* current table being parsed */
	struct eqn_node	*last_eqn; /* last equation parsed */
	struct eqn_node	*first_eqn; /* first equation parsed */
	struct eqn_node	*eqn; /* current equation being parsed */
	int		 eqn_inline; /* current equation is inline */
	int		 options; /* parse options */
	int		 rstacksz; /* current size limit of rstack */
	int		 rstackpos; /* position in rstack */
	int		 format; /* current file in mdoc or man format */
	int		 argc; /* number of args of the last macro */
	char		 control; /* control character */
};

struct	roffnode {
	enum rofft	 tok; /* type of node */
	struct roffnode	*parent; /* up one in stack */
	int		 line; /* parse line */
	int		 col; /* parse col */
	char		*name; /* node name, e.g. macro name */
	char		*end; /* end-rules: custom token */
	int		 endspan; /* end-rules: next-line or infty */
	int		 rule; /* current evaluation rule */
};

#define	ROFF_ARGS	 struct roff *r, /* parse ctx */ \
			 enum rofft tok, /* tok of macro */ \
			 struct buf *buf, /* input buffer */ \
			 int ln, /* parse line */ \
			 int ppos, /* original pos in buffer */ \
			 int pos, /* current pos in buffer */ \
			 int *offs /* reset offset of buffer data */

typedef	enum rofferr (*roffproc)(ROFF_ARGS);

struct	roffmac {
	const char	*name; /* macro name */
	roffproc	 proc; /* process new macro */
	roffproc	 text; /* process as child text of macro */
	roffproc	 sub; /* process as child of macro */
	int		 flags;
#define	ROFFMAC_STRUCT	(1 << 0) /* always interpret */
	struct roffmac	*next;
};

struct	predef {
	const char	*name; /* predefined input name */
	const char	*str; /* replacement symbol */
};

#define	PREDEF(__name, __str) \
	{ (__name), (__str) },

/* --- function prototypes ------------------------------------------------ */

static	enum rofft	 roffhash_find(const char *, size_t);
static	void		 roffhash_init(void);
static	void		 roffnode_cleanscope(struct roff *);
static	void		 roffnode_pop(struct roff *);
static	void		 roffnode_push(struct roff *, enum rofft,
				const char *, int, int);
static	enum rofferr	 roff_block(ROFF_ARGS);
static	enum rofferr	 roff_block_text(ROFF_ARGS);
static	enum rofferr	 roff_block_sub(ROFF_ARGS);
static	enum rofferr	 roff_brp(ROFF_ARGS);
static	enum rofferr	 roff_cblock(ROFF_ARGS);
static	enum rofferr	 roff_cc(ROFF_ARGS);
static	void		 roff_ccond(struct roff *, int, int);
static	enum rofferr	 roff_cond(ROFF_ARGS);
static	enum rofferr	 roff_cond_text(ROFF_ARGS);
static	enum rofferr	 roff_cond_sub(ROFF_ARGS);
static	enum rofferr	 roff_ds(ROFF_ARGS);
static	enum rofferr	 roff_eqndelim(struct roff *, struct buf *, int);
static	int		 roff_evalcond(struct roff *r, int, char *, int *);
static	int		 roff_evalnum(struct roff *, int,
				const char *, int *, int *, int);
static	int		 roff_evalpar(struct roff *, int,
				const char *, int *, int *, int);
static	int		 roff_evalstrcond(const char *, int *);
static	void		 roff_free1(struct roff *);
static	void		 roff_freereg(struct roffreg *);
static	void		 roff_freestr(struct roffkv *);
static	size_t		 roff_getname(struct roff *, char **, int, int);
static	int		 roff_getnum(const char *, int *, int *, int);
static	int		 roff_getop(const char *, int *, char *);
static	int		 roff_getregn(const struct roff *,
				const char *, size_t);
static	int		 roff_getregro(const struct roff *,
				const char *name);
static	const char	*roff_getstrn(const struct roff *,
				const char *, size_t);
static	int		 roff_hasregn(const struct roff *,
				const char *, size_t);
static	enum rofferr	 roff_insec(ROFF_ARGS);
static	enum rofferr	 roff_it(ROFF_ARGS);
static	enum rofferr	 roff_line_ignore(ROFF_ARGS);
static	void		 roff_man_alloc1(struct roff_man *);
static	void		 roff_man_free1(struct roff_man *);
static	enum rofferr	 roff_nr(ROFF_ARGS);
static	enum rofft	 roff_parse(struct roff *, char *, int *,
				int, int);
static	enum rofferr	 roff_parsetext(struct buf *, int, int *);
static	enum rofferr	 roff_res(struct roff *, struct buf *, int, int);
static	enum rofferr	 roff_rm(ROFF_ARGS);
static	enum rofferr	 roff_rr(ROFF_ARGS);
static	void		 roff_setstr(struct roff *,
				const char *, const char *, int);
static	void		 roff_setstrn(struct roffkv **, const char *,
				size_t, const char *, size_t, int);
static	enum rofferr	 roff_so(ROFF_ARGS);
static	enum rofferr	 roff_tr(ROFF_ARGS);
static	enum rofferr	 roff_Dd(ROFF_ARGS);
static	enum rofferr	 roff_TH(ROFF_ARGS);
static	enum rofferr	 roff_TE(ROFF_ARGS);
static	enum rofferr	 roff_TS(ROFF_ARGS);
static	enum rofferr	 roff_EQ(ROFF_ARGS);
static	enum rofferr	 roff_EN(ROFF_ARGS);
static	enum rofferr	 roff_T_(ROFF_ARGS);
static	enum rofferr	 roff_unsupp(ROFF_ARGS);
static	enum rofferr	 roff_userdef(ROFF_ARGS);

/* --- constant data ------------------------------------------------------ */

/* See roffhash_find() */

#define	ASCII_HI	 126
#define	ASCII_LO	 33
#define	HASHWIDTH	(ASCII_HI - ASCII_LO + 1)

#define	ROFFNUM_SCALE	(1 << 0)  /* Honour scaling in roff_getnum(). */
#define	ROFFNUM_WHITE	(1 << 1)  /* Skip whitespace in roff_evalnum(). */

static	struct roffmac	*hash[HASHWIDTH];

static	struct roffmac	 roffs[ROFF_MAX] = {
	{ "ab", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ad", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "af", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "aln", roff_unsupp, NULL, NULL, 0, NULL },
	{ "als", roff_unsupp, NULL, NULL, 0, NULL },
	{ "am", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "am1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "ami", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "ami1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "as", roff_ds, NULL, NULL, 0, NULL },
	{ "as1", roff_ds, NULL, NULL, 0, NULL },
	{ "asciify", roff_unsupp, NULL, NULL, 0, NULL },
	{ "backtrace", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "bd", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "bleedat", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "blm", roff_unsupp, NULL, NULL, 0, NULL },
	{ "box", roff_unsupp, NULL, NULL, 0, NULL },
	{ "boxa", roff_unsupp, NULL, NULL, 0, NULL },
	{ "bp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "BP", roff_unsupp, NULL, NULL, 0, NULL },
	{ "break", roff_unsupp, NULL, NULL, 0, NULL },
	{ "breakchar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "brnl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "brp", roff_brp, NULL, NULL, 0, NULL },
	{ "brpnl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "c2", roff_unsupp, NULL, NULL, 0, NULL },
	{ "cc", roff_cc, NULL, NULL, 0, NULL },
	{ "ce", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cf", roff_insec, NULL, NULL, 0, NULL },
	{ "cflags", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ch", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "char", roff_unsupp, NULL, NULL, 0, NULL },
	{ "chop", roff_unsupp, NULL, NULL, 0, NULL },
	{ "class", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "close", roff_insec, NULL, NULL, 0, NULL },
	{ "CL", roff_unsupp, NULL, NULL, 0, NULL },
	{ "color", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "composite", roff_unsupp, NULL, NULL, 0, NULL },
	{ "continue", roff_unsupp, NULL, NULL, 0, NULL },
	{ "cp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cropat", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "cu", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "da", roff_unsupp, NULL, NULL, 0, NULL },
	{ "dch", roff_unsupp, NULL, NULL, 0, NULL },
	{ "Dd", roff_Dd, NULL, NULL, 0, NULL },
	{ "de", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "de1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "defcolor", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "dei", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "dei1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "device", roff_unsupp, NULL, NULL, 0, NULL },
	{ "devicem", roff_unsupp, NULL, NULL, 0, NULL },
	{ "di", roff_unsupp, NULL, NULL, 0, NULL },
	{ "do", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ds", roff_ds, NULL, NULL, 0, NULL },
	{ "ds1", roff_ds, NULL, NULL, 0, NULL },
	{ "dwh", roff_unsupp, NULL, NULL, 0, NULL },
	{ "dt", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ec", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ecr", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ecs", roff_unsupp, NULL, NULL, 0, NULL },
	{ "el", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT, NULL },
	{ "em", roff_unsupp, NULL, NULL, 0, NULL },
	{ "EN", roff_EN, NULL, NULL, 0, NULL },
	{ "eo", roff_unsupp, NULL, NULL, 0, NULL },
	{ "EP", roff_unsupp, NULL, NULL, 0, NULL },
	{ "EQ", roff_EQ, NULL, NULL, 0, NULL },
	{ "errprint", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ev", roff_unsupp, NULL, NULL, 0, NULL },
	{ "evc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ex", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fallback", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fam", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fchar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fcolor", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fdeferlig", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "feature", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fkern", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "flig", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fps", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fschar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "fspacewidth", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fspecial", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ftr", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "fzoom", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "gcolor", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hcode", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hidechar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hla", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hlm", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hpf", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hpfa", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hpfcode", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hw", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hy", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hylang", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hylen", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hym", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hypp", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "hys", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ie", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT, NULL },
	{ "if", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT, NULL },
	{ "ig", roff_block, roff_block_text, roff_block_sub, 0, NULL },
	{ "index", roff_unsupp, NULL, NULL, 0, NULL },
	{ "it", roff_it, NULL, NULL, 0, NULL },
	{ "itc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "IX", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kern", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kernafter", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kernbefore", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "kernpair", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lc_ctype", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lds", roff_unsupp, NULL, NULL, 0, NULL },
	{ "length", roff_unsupp, NULL, NULL, 0, NULL },
	{ "letadj", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lf", roff_insec, NULL, NULL, 0, NULL },
	{ "lg", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lhang", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "linetabs", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lnr", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lnrf", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lpfx", roff_unsupp, NULL, NULL, 0, NULL },
	{ "ls", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "lsm", roff_unsupp, NULL, NULL, 0, NULL },
	{ "lt", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mediasize", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "minss", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mk", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "mso", roff_insec, NULL, NULL, 0, NULL },
	{ "na", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ne", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nh", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nhychar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nm", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nn", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nop", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nr", roff_nr, NULL, NULL, 0, NULL },
	{ "nrf", roff_unsupp, NULL, NULL, 0, NULL },
	{ "nroff", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ns", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "nx", roff_insec, NULL, NULL, 0, NULL },
	{ "open", roff_insec, NULL, NULL, 0, NULL },
	{ "opena", roff_insec, NULL, NULL, 0, NULL },
	{ "os", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "output", roff_unsupp, NULL, NULL, 0, NULL },
	{ "padj", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "papersize", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pev", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pi", roff_insec, NULL, NULL, 0, NULL },
	{ "PI", roff_unsupp, NULL, NULL, 0, NULL },
	{ "pl", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pm", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pnr", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "po", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ps", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "psbb", roff_unsupp, NULL, NULL, 0, NULL },
	{ "pshape", roff_unsupp, NULL, NULL, 0, NULL },
	{ "pso", roff_insec, NULL, NULL, 0, NULL },
	{ "ptr", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "pvs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rchar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rd", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "recursionlimit", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "return", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rfschar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rhang", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rj", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rm", roff_rm, NULL, NULL, 0, NULL },
	{ "rn", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rnn", roff_unsupp, NULL, NULL, 0, NULL },
	{ "rr", roff_rr, NULL, NULL, 0, NULL },
	{ "rs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "rt", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "schar", roff_unsupp, NULL, NULL, 0, NULL },
	{ "sentchar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "shc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "shift", roff_unsupp, NULL, NULL, 0, NULL },
	{ "sizes", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "so", roff_so, NULL, NULL, 0, NULL },
	{ "spacewidth", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "special", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "spreadwarn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ss", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "sty", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "substring", roff_unsupp, NULL, NULL, 0, NULL },
	{ "sv", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "sy", roff_insec, NULL, NULL, 0, NULL },
	{ "T&", roff_T_, NULL, NULL, 0, NULL },
	{ "ta", roff_unsupp, NULL, NULL, 0, NULL },
	{ "tc", roff_unsupp, NULL, NULL, 0, NULL },
	{ "TE", roff_TE, NULL, NULL, 0, NULL },
	{ "TH", roff_TH, NULL, NULL, 0, NULL },
	{ "ti", roff_unsupp, NULL, NULL, 0, NULL },
	{ "tkf", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tl", roff_unsupp, NULL, NULL, 0, NULL },
	{ "tm", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tm1", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tmc", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "tr", roff_tr, NULL, NULL, 0, NULL },
	{ "track", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "transchar", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "trf", roff_insec, NULL, NULL, 0, NULL },
	{ "trimat", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "trin", roff_unsupp, NULL, NULL, 0, NULL },
	{ "trnt", roff_unsupp, NULL, NULL, 0, NULL },
	{ "troff", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "TS", roff_TS, NULL, NULL, 0, NULL },
	{ "uf", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "ul", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "unformat", roff_unsupp, NULL, NULL, 0, NULL },
	{ "unwatch", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "unwatchn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "vpt", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "vs", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "warn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "warnscale", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "watch", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "watchlength", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "watchn", roff_line_ignore, NULL, NULL, 0, NULL },
	{ "wh", roff_unsupp, NULL, NULL, 0, NULL },
	{ "while", roff_unsupp, NULL, NULL, 0, NULL },
	{ "write", roff_insec, NULL, NULL, 0, NULL },
	{ "writec", roff_insec, NULL, NULL, 0, NULL },
	{ "writem", roff_insec, NULL, NULL, 0, NULL },
	{ "xflag", roff_line_ignore, NULL, NULL, 0, NULL },
	{ ".", roff_cblock, NULL, NULL, 0, NULL },
	{ NULL, roff_userdef, NULL, NULL, 0, NULL },
};

/* not currently implemented: Ds em Eq LP Me PP pp Or Rd Sf SH */
const	char *const __mdoc_reserved[] = {
	"Ac", "Ad", "An", "Ao", "Ap", "Aq", "Ar", "At",
	"Bc", "Bd", "Bf", "Bk", "Bl", "Bo", "Bq",
	"Brc", "Bro", "Brq", "Bsx", "Bt", "Bx",
	"Cd", "Cm", "Db", "Dc", "Dd", "Dl", "Do", "Dq",
	"Dt", "Dv", "Dx", "D1",
	"Ec", "Ed", "Ef", "Ek", "El", "Em",
	"En", "Eo", "Er", "Es", "Ev", "Ex",
	"Fa", "Fc", "Fd", "Fl", "Fn", "Fo", "Fr", "Ft", "Fx",
	"Hf", "Ic", "In", "It", "Lb", "Li", "Lk", "Lp",
	"Ms", "Mt", "Nd", "Nm", "No", "Ns", "Nx",
	"Oc", "Oo", "Op", "Os", "Ot", "Ox",
	"Pa", "Pc", "Pf", "Po", "Pp", "Pq",
	"Qc", "Ql", "Qo", "Qq", "Re", "Rs", "Rv",
	"Sc", "Sh", "Sm", "So", "Sq",
	"Ss", "St", "Sx", "Sy",
	"Ta", "Tn", "Ud", "Ux", "Va", "Vt", "Xc", "Xo", "Xr",
	"%A", "%B", "%C", "%D", "%I", "%J", "%N", "%O",
	"%P", "%Q", "%R", "%T", "%U", "%V",
	NULL
};

/* not currently implemented: BT DE DS ME MT PT SY TQ YS */
const	char *const __man_reserved[] = {
	"AT", "B", "BI", "BR", "DT",
	"EE", "EN", "EQ", "EX", "HP", "I", "IB", "IP", "IR",
	"LP", "OP", "P", "PD", "PP",
	"R", "RB", "RE", "RI", "RS", "SB", "SH", "SM", "SS",
	"TE", "TH", "TP", "TS", "T&", "UC", "UE", "UR",
	NULL
};

/* Array of injected predefined strings. */
#define	PREDEFS_MAX	 38
static	const struct predef predefs[PREDEFS_MAX] = {
#include "predefs.in"
};

/* See roffhash_find() */
#define	ROFF_HASH(p)	(p[0] - ASCII_LO)

static	int	 roffit_lines;  /* number of lines to delay */
static	char	*roffit_macro;  /* nil-terminated macro line */


/* --- request table ------------------------------------------------------ */

static void
roffhash_init(void)
{
	struct roffmac	 *n;
	int		  buc, i;

	for (i = 0; i < (int)ROFF_USERDEF; i++) {
		assert(roffs[i].name[0] >= ASCII_LO);
		assert(roffs[i].name[0] <= ASCII_HI);

		buc = ROFF_HASH(roffs[i].name);

		if (NULL != (n = hash[buc])) {
			for ( ; n->next; n = n->next)
				/* Do nothing. */ ;
			n->next = &roffs[i];
		} else
			hash[buc] = &roffs[i];
	}
}

/*
 * Look up a roff token by its name.  Returns ROFF_MAX if no macro by
 * the nil-terminated string name could be found.
 */
static enum rofft
roffhash_find(const char *p, size_t s)
{
	int		 buc;
	struct roffmac	*n;

	/*
	 * libroff has an extremely simple hashtable, for the time
	 * being, which simply keys on the first character, which must
	 * be printable, then walks a chain.  It works well enough until
	 * optimised.
	 */

	if (p[0] < ASCII_LO || p[0] > ASCII_HI)
		return ROFF_MAX;

	buc = ROFF_HASH(p);

	if (NULL == (n = hash[buc]))
		return ROFF_MAX;
	for ( ; n; n = n->next)
		if (0 == strncmp(n->name, p, s) && '\0' == n->name[(int)s])
			return (enum rofft)(n - roffs);

	return ROFF_MAX;
}

/* --- stack of request blocks -------------------------------------------- */

/*
 * Pop the current node off of the stack of roff instructions currently
 * pending.
 */
static void
roffnode_pop(struct roff *r)
{
	struct roffnode	*p;

	assert(r->last);
	p = r->last;

	r->last = r->last->parent;
	free(p->name);
	free(p->end);
	free(p);
}

/*
 * Push a roff node onto the instruction stack.  This must later be
 * removed with roffnode_pop().
 */
static void
roffnode_push(struct roff *r, enum rofft tok, const char *name,
		int line, int col)
{
	struct roffnode	*p;

	p = mandoc_calloc(1, sizeof(struct roffnode));
	p->tok = tok;
	if (name)
		p->name = mandoc_strdup(name);
	p->parent = r->last;
	p->line = line;
	p->col = col;
	p->rule = p->parent ? p->parent->rule : 0;

	r->last = p;
}

/* --- roff parser state data management ---------------------------------- */

static void
roff_free1(struct roff *r)
{
	struct tbl_node	*tbl;
	struct eqn_node	*e;
	int		 i;

	while (NULL != (tbl = r->first_tbl)) {
		r->first_tbl = tbl->next;
		tbl_free(tbl);
	}
	r->first_tbl = r->last_tbl = r->tbl = NULL;

	while (NULL != (e = r->first_eqn)) {
		r->first_eqn = e->next;
		eqn_free(e);
	}
	r->first_eqn = r->last_eqn = r->eqn = NULL;

	while (r->last)
		roffnode_pop(r);

	free (r->rstack);
	r->rstack = NULL;
	r->rstacksz = 0;
	r->rstackpos = -1;

	roff_freereg(r->regtab);
	r->regtab = NULL;

	roff_freestr(r->strtab);
	roff_freestr(r->xmbtab);
	r->strtab = r->xmbtab = NULL;

	if (r->xtab)
		for (i = 0; i < 128; i++)
			free(r->xtab[i].p);
	free(r->xtab);
	r->xtab = NULL;
}

void
roff_reset(struct roff *r)
{

	roff_free1(r);
	r->format = r->options & (MPARSE_MDOC | MPARSE_MAN);
	r->control = 0;
}

void
roff_free(struct roff *r)
{

	roff_free1(r);
	free(r);
}

struct roff *
roff_alloc(struct mparse *parse, int options)
{
	struct roff	*r;

	r = mandoc_calloc(1, sizeof(struct roff));
	r->parse = parse;
	r->options = options;
	r->format = options & (MPARSE_MDOC | MPARSE_MAN);
	r->rstackpos = -1;

	roffhash_init();

	return r;
}

/* --- syntax tree state data management ---------------------------------- */

static void
roff_man_free1(struct roff_man *man)
{

	if (man->first != NULL)
		roff_node_delete(man, man->first);
	free(man->meta.msec);
	free(man->meta.vol);
	free(man->meta.os);
	free(man->meta.arch);
	free(man->meta.title);
	free(man->meta.name);
	free(man->meta.date);
}

static void
roff_man_alloc1(struct roff_man *man)
{

	memset(&man->meta, 0, sizeof(man->meta));
	man->first = mandoc_calloc(1, sizeof(*man->first));
	man->first->type = ROFFT_ROOT;
	man->last = man->first;
	man->last_es = NULL;
	man->flags = 0;
	man->macroset = MACROSET_NONE;
	man->lastsec = man->lastnamed = SEC_NONE;
	man->next = ROFF_NEXT_CHILD;
}

void
roff_man_reset(struct roff_man *man)
{

	roff_man_free1(man);
	roff_man_alloc1(man);
}

void
roff_man_free(struct roff_man *man)
{

	roff_man_free1(man);
	free(man);
}

struct roff_man *
roff_man_alloc(struct roff *roff, struct mparse *parse,
	const char *defos, int quick)
{
	struct roff_man *man;

	man = mandoc_calloc(1, sizeof(*man));
	man->parse = parse;
	man->roff = roff;
	man->defos = defos;
	man->quick = quick;
	roff_man_alloc1(man);
	return man;
}

/* --- syntax tree handling ----------------------------------------------- */

struct roff_node *
roff_node_alloc(struct roff_man *man, int line, int pos,
	enum roff_type type, int tok)
{
	struct roff_node	*n;

	n = mandoc_calloc(1, sizeof(*n));
	n->line = line;
	n->pos = pos;
	n->tok = tok;
	n->type = type;
	n->sec = man->lastsec;

	if (man->flags & MDOC_SYNOPSIS)
		n->flags |= MDOC_SYNPRETTY;
	else
		n->flags &= ~MDOC_SYNPRETTY;
	if (man->flags & MDOC_NEWLINE)
		n->flags |= MDOC_LINE;
	man->flags &= ~MDOC_NEWLINE;

	return n;
}

void
roff_node_append(struct roff_man *man, struct roff_node *n)
{

	switch (man->next) {
	case ROFF_NEXT_SIBLING:
		if (man->last->next != NULL) {
			n->next = man->last->next;
			man->last->next->prev = n;
		} else
			man->last->parent->last = n;
		man->last->next = n;
		n->prev = man->last;
		n->parent = man->last->parent;
		break;
	case ROFF_NEXT_CHILD:
		man->last->child = n;
		n->parent = man->last;
		n->parent->last = n;
		break;
	default:
		abort();
	}
	n->parent->nchild++;
	man->last = n;

	switch (n->type) {
	case ROFFT_HEAD:
		n->parent->head = n;
		break;
	case ROFFT_BODY:
		if (n->end != ENDBODY_NOT)
			return;
		n->parent->body = n;
		break;
	case ROFFT_TAIL:
		n->parent->tail = n;
		break;
	default:
		return;
	}

	/*
	 * Copy over the normalised-data pointer of our parent.  Not
	 * everybody has one, but copying a null pointer is fine.
	 */

	n->norm = n->parent->norm;
	assert(n->parent->type == ROFFT_BLOCK);
}

void
roff_word_alloc(struct roff_man *man, int line, int pos, const char *word)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_TEXT, TOKEN_NONE);
	n->string = roff_strdup(man->roff, word);
	roff_node_append(man, n);
	if (man->macroset == MACROSET_MDOC)
		n->flags |= MDOC_VALID | MDOC_ENDED;
	else
		n->flags |= MAN_VALID;
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_word_append(struct roff_man *man, const char *word)
{
	struct roff_node	*n;
	char			*addstr, *newstr;

	n = man->last;
	addstr = roff_strdup(man->roff, word);
	mandoc_asprintf(&newstr, "%s %s", n->string, addstr);
	free(addstr);
	free(n->string);
	n->string = newstr;
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_elem_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_ELEM, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
}

struct roff_node *
roff_block_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_BLOCK, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
	return n;
}

struct roff_node *
roff_head_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_HEAD, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
	return n;
}

struct roff_node *
roff_body_alloc(struct roff_man *man, int line, int pos, int tok)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, line, pos, ROFFT_BODY, tok);
	roff_node_append(man, n);
	man->next = ROFF_NEXT_CHILD;
	return n;
}

void
roff_addeqn(struct roff_man *man, const struct eqn *eqn)
{
	struct roff_node	*n;

	n = roff_node_alloc(man, eqn->ln, eqn->pos, ROFFT_EQN, TOKEN_NONE);
	n->eqn = eqn;
	if (eqn->ln > man->last->line)
		n->flags |= MDOC_LINE;
	roff_node_append(man, n);
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_addtbl(struct roff_man *man, const struct tbl_span *tbl)
{
	struct roff_node	*n;

	if (man->macroset == MACROSET_MAN)
		man_breakscope(man, TOKEN_NONE);
	n = roff_node_alloc(man, tbl->line, 0, ROFFT_TBL, TOKEN_NONE);
	n->span = tbl;
	roff_node_append(man, n);
	if (man->macroset == MACROSET_MDOC)
		n->flags |= MDOC_VALID | MDOC_ENDED;
	else
		n->flags |= MAN_VALID;
	man->next = ROFF_NEXT_SIBLING;
}

void
roff_node_unlink(struct roff_man *man, struct roff_node *n)
{

	/* Adjust siblings. */

	if (n->prev)
		n->prev->next = n->next;
	if (n->next)
		n->next->prev = n->prev;

	/* Adjust parent. */

	if (n->parent != NULL) {
		n->parent->nchild--;
		if (n->parent->child == n)
			n->parent->child = n->next;
		if (n->parent->last == n)
			n->parent->last = n->prev;
	}

	/* Adjust parse point. */

	if (man == NULL)
		return;
	if (man->last == n) {
		if (n->prev == NULL) {
			man->last = n->parent;
			man->next = ROFF_NEXT_CHILD;
		} else {
			man->last = n->prev;
			man->next = ROFF_NEXT_SIBLING;
		}
	}
	if (man->first == n)
		man->first = NULL;
}

void
roff_node_free(struct roff_node *n)
{

	if (n->args != NULL)
		mdoc_argv_free(n->args);
	if (n->type == ROFFT_BLOCK || n->type == ROFFT_ELEM)
		free(n->norm);
	free(n->string);
	free(n);
}

void
roff_node_delete(struct roff_man *man, struct roff_node *n)
{

	while (n->child != NULL)
		roff_node_delete(man, n->child);
	assert(n->nchild == 0);
	roff_node_unlink(man, n);
	roff_node_free(n);
}

void
deroff(char **dest, const struct roff_node *n)
{
	char	*cp;
	size_t	 sz;

	if (n->type != ROFFT_TEXT) {
		for (n = n->child; n != NULL; n = n->next)
			deroff(dest, n);
		return;
	}

	/* Skip leading whitespace and escape sequences. */

	cp = n->string;
	while (*cp != '\0') {
		if ('\\' == *cp) {
			cp++;
			mandoc_escape((const char **)&cp, NULL, NULL);
		} else if (isspace((unsigned char)*cp))
			cp++;
		else
			break;
	}

	/* Skip trailing whitespace. */

	for (sz = strlen(cp); sz; sz--)
		if ( ! isspace((unsigned char)cp[sz-1]))
			break;

	/* Skip empty strings. */

	if (sz == 0)
		return;

	if (*dest == NULL) {
		*dest = mandoc_strndup(cp, sz);
		return;
	}

	mandoc_asprintf(&cp, "%s %*s", *dest, (int)sz, cp);
	free(*dest);
	*dest = cp;
}

/* --- main functions of the roff parser ---------------------------------- */

/*
 * In the current line, expand escape sequences that tend to get
 * used in numerical expressions and conditional requests.
 * Also check the syntax of the remaining escape sequences.
 */
static enum rofferr
roff_res(struct roff *r, struct buf *buf, int ln, int pos)
{
	char		 ubuf[24]; /* buffer to print the number */
	const char	*start;	/* start of the string to process */
	char		*stesc;	/* start of an escape sequence ('\\') */
	const char	*stnam;	/* start of the name, after "[(*" */
	const char	*cp;	/* end of the name, e.g. before ']' */
	const char	*res;	/* the string to be substituted */
	char		*nbuf;	/* new buffer to copy buf->buf to */
	size_t		 maxl;  /* expected length of the escape name */
	size_t		 naml;	/* actual length of the escape name */
	enum mandoc_esc	 esc;	/* type of the escape sequence */
	int		 inaml;	/* length returned from mandoc_escape() */
	int		 expand_count;	/* to avoid infinite loops */
	int		 npos;	/* position in numeric expression */
	int		 arg_complete; /* argument not interrupted by eol */
	char		 term;	/* character terminating the escape */

	expand_count = 0;
	start = buf->buf + pos;
	stesc = strchr(start, '\0') - 1;
	while (stesc-- > start) {

		/* Search backwards for the next backslash. */

		if (*stesc != '\\')
			continue;

		/* If it is escaped, skip it. */

		for (cp = stesc - 1; cp >= start; cp--)
			if (*cp != '\\')
				break;

		if ((stesc - cp) % 2 == 0) {
			stesc = (char *)cp;
			continue;
		}

		/* Decide whether to expand or to check only. */

		term = '\0';
		cp = stesc + 1;
		switch (*cp) {
		case '*':
			res = NULL;
			break;
		case 'B':
		case 'w':
			term = cp[1];
			/* FALLTHROUGH */
		case 'n':
			res = ubuf;
			break;
		default:
			esc = mandoc_escape(&cp, &stnam, &inaml);
			if (esc == ESCAPE_ERROR ||
			    (esc == ESCAPE_SPECIAL &&
			     mchars_spec2cp(stnam, inaml) < 0))
				mandoc_vmsg(MANDOCERR_ESC_BAD,
				    r->parse, ln, (int)(stesc - buf->buf),
				    "%.*s", (int)(cp - stesc), stesc);
			continue;
		}

		if (EXPAND_LIMIT < ++expand_count) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(stesc - buf->buf), NULL);
			return ROFF_IGN;
		}

		/*
		 * The third character decides the length
		 * of the name of the string or register.
		 * Save a pointer to the name.
		 */

		if (term == '\0') {
			switch (*++cp) {
			case '\0':
				maxl = 0;
				break;
			case '(':
				cp++;
				maxl = 2;
				break;
			case '[':
				cp++;
				term = ']';
				maxl = 0;
				break;
			default:
				maxl = 1;
				break;
			}
		} else {
			cp += 2;
			maxl = 0;
		}
		stnam = cp;

		/* Advance to the end of the name. */

		naml = 0;
		arg_complete = 1;
		while (maxl == 0 || naml < maxl) {
			if (*cp == '\0') {
				mandoc_msg(MANDOCERR_ESC_BAD, r->parse,
				    ln, (int)(stesc - buf->buf), stesc);
				arg_complete = 0;
				break;
			}
			if (maxl == 0 && *cp == term) {
				cp++;
				break;
			}
			if (*cp++ != '\\' || stesc[1] != 'w') {
				naml++;
				continue;
			}
			switch (mandoc_escape(&cp, NULL, NULL)) {
			case ESCAPE_SPECIAL:
			case ESCAPE_UNICODE:
			case ESCAPE_NUMBERED:
			case ESCAPE_OVERSTRIKE:
				naml++;
				break;
			default:
				break;
			}
		}

		/*
		 * Retrieve the replacement string; if it is
		 * undefined, resume searching for escapes.
		 */

		switch (stesc[1]) {
		case '*':
			if (arg_complete)
				res = roff_getstrn(r, stnam, naml);
			break;
		case 'B':
			npos = 0;
			ubuf[0] = arg_complete &&
			    roff_evalnum(r, ln, stnam, &npos,
			      NULL, ROFFNUM_SCALE) &&
			    stnam + npos + 1 == cp ? '1' : '0';
			ubuf[1] = '\0';
			break;
		case 'n':
			if (arg_complete)
				(void)snprintf(ubuf, sizeof(ubuf), "%d",
				    roff_getregn(r, stnam, naml));
			else
				ubuf[0] = '\0';
			break;
		case 'w':
			/* use even incomplete args */
			(void)snprintf(ubuf, sizeof(ubuf), "%d",
			    24 * (int)naml);
			break;
		}

		if (res == NULL) {
			mandoc_vmsg(MANDOCERR_STR_UNDEF,
			    r->parse, ln, (int)(stesc - buf->buf),
			    "%.*s", (int)naml, stnam);
			res = "";
		} else if (buf->sz + strlen(res) > SHRT_MAX) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(stesc - buf->buf), NULL);
			return ROFF_IGN;
		}

		/* Replace the escape sequence by the string. */

		*stesc = '\0';
		buf->sz = mandoc_asprintf(&nbuf, "%s%s%s",
		    buf->buf, res, cp) + 1;

		/* Prepare for the next replacement. */

		start = nbuf + pos;
		stesc = nbuf + (stesc - buf->buf) + strlen(res);
		free(buf->buf);
		buf->buf = nbuf;
	}
	return ROFF_CONT;
}

/*
 * Process text streams.
 */
static enum rofferr
roff_parsetext(struct buf *buf, int pos, int *offs)
{
	size_t		 sz;
	const char	*start;
	char		*p;
	int		 isz;
	enum mandoc_esc	 esc;

	/* Spring the input line trap. */

	if (roffit_lines == 1) {
		isz = mandoc_asprintf(&p, "%s\n.%s", buf->buf, roffit_macro);
		free(buf->buf);
		buf->buf = p;
		buf->sz = isz + 1;
		*offs = 0;
		free(roffit_macro);
		roffit_lines = 0;
		return ROFF_REPARSE;
	} else if (roffit_lines > 1)
		--roffit_lines;

	/* Convert all breakable hyphens into ASCII_HYPH. */

	start = p = buf->buf + pos;

	while (*p != '\0') {
		sz = strcspn(p, "-\\");
		p += sz;

		if (*p == '\0')
			break;

		if (*p == '\\') {
			/* Skip over escapes. */
			p++;
			esc = mandoc_escape((const char **)&p, NULL, NULL);
			if (esc == ESCAPE_ERROR)
				break;
			while (*p == '-')
				p++;
			continue;
		} else if (p == start) {
			p++;
			continue;
		}

		if (isalpha((unsigned char)p[-1]) &&
		    isalpha((unsigned char)p[1]))
			*p = ASCII_HYPH;
		p++;
	}
	return ROFF_CONT;
}

enum rofferr
roff_parseln(struct roff *r, int ln, struct buf *buf, int *offs)
{
	enum rofft	 t;
	enum rofferr	 e;
	int		 pos;	/* parse point */
	int		 spos;	/* saved parse point for messages */
	int		 ppos;	/* original offset in buf->buf */
	int		 ctl;	/* macro line (boolean) */

	ppos = pos = *offs;

	/* Handle in-line equation delimiters. */

	if (r->tbl == NULL &&
	    r->last_eqn != NULL && r->last_eqn->delim &&
	    (r->eqn == NULL || r->eqn_inline)) {
		e = roff_eqndelim(r, buf, pos);
		if (e == ROFF_REPARSE)
			return e;
		assert(e == ROFF_CONT);
	}

	/* Expand some escape sequences. */

	e = roff_res(r, buf, ln, pos);
	if (e == ROFF_IGN)
		return e;
	assert(e == ROFF_CONT);

	ctl = roff_getcontrol(r, buf->buf, &pos);

	/*
	 * First, if a scope is open and we're not a macro, pass the
	 * text through the macro's filter.
	 * Equations process all content themselves.
	 * Tables process almost all content themselves, but we want
	 * to warn about macros before passing it there.
	 */

	if (r->last != NULL && ! ctl) {
		t = r->last->tok;
		assert(roffs[t].text);
		e = (*roffs[t].text)(r, t, buf, ln, pos, pos, offs);
		assert(e == ROFF_IGN || e == ROFF_CONT);
		if (e != ROFF_CONT)
			return e;
	}
	if (r->eqn != NULL)
		return eqn_read(&r->eqn, ln, buf->buf, ppos, offs);
	if (r->tbl != NULL && ( ! ctl || buf->buf[pos] == '\0'))
		return tbl_read(r->tbl, ln, buf->buf, ppos);
	if ( ! ctl)
		return roff_parsetext(buf, pos, offs);

	/* Skip empty request lines. */

	if (buf->buf[pos] == '"') {
		mandoc_msg(MANDOCERR_COMMENT_BAD, r->parse,
		    ln, pos, NULL);
		return ROFF_IGN;
	} else if (buf->buf[pos] == '\0')
		return ROFF_IGN;

	/*
	 * If a scope is open, go to the child handler for that macro,
	 * as it may want to preprocess before doing anything with it.
	 * Don't do so if an equation is open.
	 */

	if (r->last) {
		t = r->last->tok;
		assert(roffs[t].sub);
		return (*roffs[t].sub)(r, t, buf, ln, ppos, pos, offs);
	}

	/* No scope is open.  This is a new request or macro. */

	spos = pos;
	t = roff_parse(r, buf->buf, &pos, ln, ppos);

	/* Tables ignore most macros. */

	if (r->tbl != NULL && (t == ROFF_MAX || t == ROFF_TS)) {
		mandoc_msg(MANDOCERR_TBLMACRO, r->parse,
		    ln, pos, buf->buf + spos);
		if (t == ROFF_TS)
			return ROFF_IGN;
		while (buf->buf[pos] != '\0' && buf->buf[pos] != ' ')
			pos++;
		while (buf->buf[pos] != '\0' && buf->buf[pos] == ' ')
			pos++;
		return tbl_read(r->tbl, ln, buf->buf, pos);
	}

	/*
	 * This is neither a roff request nor a user-defined macro.
	 * Let the standard macro set parsers handle it.
	 */

	if (t == ROFF_MAX)
		return ROFF_CONT;

	/* Execute a roff request or a user defined macro. */

	assert(roffs[t].proc);
	return (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs);
}

void
roff_endparse(struct roff *r)
{

	if (r->last)
		mandoc_msg(MANDOCERR_BLK_NOEND, r->parse,
		    r->last->line, r->last->col,
		    roffs[r->last->tok].name);

	if (r->eqn) {
		mandoc_msg(MANDOCERR_BLK_NOEND, r->parse,
		    r->eqn->eqn.ln, r->eqn->eqn.pos, "EQ");
		eqn_end(&r->eqn);
	}

	if (r->tbl) {
		mandoc_msg(MANDOCERR_BLK_NOEND, r->parse,
		    r->tbl->line, r->tbl->pos, "TS");
		tbl_end(&r->tbl);
	}
}

/*
 * Parse a roff node's type from the input buffer.  This must be in the
 * form of ".foo xxx" in the usual way.
 */
static enum rofft
roff_parse(struct roff *r, char *buf, int *pos, int ln, int ppos)
{
	char		*cp;
	const char	*mac;
	size_t		 maclen;
	enum rofft	 t;

	cp = buf + *pos;

	if ('\0' == *cp || '"' == *cp || '\t' == *cp || ' ' == *cp)
		return ROFF_MAX;

	mac = cp;
	maclen = roff_getname(r, &cp, ln, ppos);

	t = (r->current_string = roff_getstrn(r, mac, maclen))
	    ? ROFF_USERDEF : roffhash_find(mac, maclen);

	if (ROFF_MAX != t)
		*pos = cp - buf;

	return t;
}

/* --- handling of request blocks ----------------------------------------- */

static enum rofferr
roff_cblock(ROFF_ARGS)
{

	/*
	 * A block-close `..' should only be invoked as a child of an
	 * ignore macro, otherwise raise a warning and just ignore it.
	 */

	if (r->last == NULL) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "..");
		return ROFF_IGN;
	}

	switch (r->last->tok) {
	case ROFF_am:
		/* ROFF_am1 is remapped to ROFF_am in roff_block(). */
	case ROFF_ami:
	case ROFF_de:
		/* ROFF_de1 is remapped to ROFF_de in roff_block(). */
	case ROFF_dei:
	case ROFF_ig:
		break;
	default:
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "..");
		return ROFF_IGN;
	}

	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse, ln, pos,
		    ".. %s", buf->buf + pos);

	roffnode_pop(r);
	roffnode_cleanscope(r);
	return ROFF_IGN;

}

static void
roffnode_cleanscope(struct roff *r)
{

	while (r->last) {
		if (--r->last->endspan != 0)
			break;
		roffnode_pop(r);
	}
}

static void
roff_ccond(struct roff *r, int ln, int ppos)
{

	if (NULL == r->last) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "\\}");
		return;
	}

	switch (r->last->tok) {
	case ROFF_el:
	case ROFF_ie:
	case ROFF_if:
		break;
	default:
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "\\}");
		return;
	}

	if (r->last->endspan > -1) {
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "\\}");
		return;
	}

	roffnode_pop(r);
	roffnode_cleanscope(r);
	return;
}

static enum rofferr
roff_block(ROFF_ARGS)
{
	const char	*name;
	char		*iname, *cp;
	size_t		 namesz;

	/* Ignore groff compatibility mode for now. */

	if (tok == ROFF_de1)
		tok = ROFF_de;
	else if (tok == ROFF_dei1)
		tok = ROFF_dei;
	else if (tok == ROFF_am1)
		tok = ROFF_am;
	else if (tok == ROFF_ami1)
		tok = ROFF_ami;

	/* Parse the macro name argument. */

	cp = buf->buf + pos;
	if (tok == ROFF_ig) {
		iname = NULL;
		namesz = 0;
	} else {
		iname = cp;
		namesz = roff_getname(r, &cp, ln, ppos);
		iname[namesz] = '\0';
	}

	/* Resolve the macro name argument if it is indirect. */

	if (namesz && (tok == ROFF_dei || tok == ROFF_ami)) {
		if ((name = roff_getstrn(r, iname, namesz)) == NULL) {
			mandoc_vmsg(MANDOCERR_STR_UNDEF,
			    r->parse, ln, (int)(iname - buf->buf),
			    "%.*s", (int)namesz, iname);
			namesz = 0;
		} else
			namesz = strlen(name);
	} else
		name = iname;

	if (namesz == 0 && tok != ROFF_ig) {
		mandoc_msg(MANDOCERR_REQ_EMPTY, r->parse,
		    ln, ppos, roffs[tok].name);
		return ROFF_IGN;
	}

	roffnode_push(r, tok, name, ln, ppos);

	/*
	 * At the beginning of a `de' macro, clear the existing string
	 * with the same name, if there is one.  New content will be
	 * appended from roff_block_text() in multiline mode.
	 */

	if (tok == ROFF_de || tok == ROFF_dei)
		roff_setstrn(&r->strtab, name, namesz, "", 0, 0);

	if (*cp == '\0')
		return ROFF_IGN;

	/* Get the custom end marker. */

	iname = cp;
	namesz = roff_getname(r, &cp, ln, ppos);

	/* Resolve the end marker if it is indirect. */

	if (namesz && (tok == ROFF_dei || tok == ROFF_ami)) {
		if ((name = roff_getstrn(r, iname, namesz)) == NULL) {
			mandoc_vmsg(MANDOCERR_STR_UNDEF,
			    r->parse, ln, (int)(iname - buf->buf),
			    "%.*s", (int)namesz, iname);
			namesz = 0;
		} else
			namesz = strlen(name);
	} else
		name = iname;

	if (namesz)
		r->last->end = mandoc_strndup(name, namesz);

	if (*cp != '\0')
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, r->parse,
		    ln, pos, ".%s ... %s", roffs[tok].name, cp);

	return ROFF_IGN;
}

static enum rofferr
roff_block_sub(ROFF_ARGS)
{
	enum rofft	t;
	int		i, j;

	/*
	 * First check whether a custom macro exists at this level.  If
	 * it does, then check against it.  This is some of groff's
	 * stranger behaviours.  If we encountered a custom end-scope
	 * tag and that tag also happens to be a "real" macro, then we
	 * need to try interpreting it again as a real macro.  If it's
	 * not, then return ignore.  Else continue.
	 */

	if (r->last->end) {
		for (i = pos, j = 0; r->last->end[j]; j++, i++)
			if (buf->buf[i] != r->last->end[j])
				break;

		if (r->last->end[j] == '\0' &&
		    (buf->buf[i] == '\0' ||
		     buf->buf[i] == ' ' ||
		     buf->buf[i] == '\t')) {
			roffnode_pop(r);
			roffnode_cleanscope(r);

			while (buf->buf[i] == ' ' || buf->buf[i] == '\t')
				i++;

			pos = i;
			if (roff_parse(r, buf->buf, &pos, ln, ppos) !=
			    ROFF_MAX)
				return ROFF_RERUN;
			return ROFF_IGN;
		}
	}

	/*
	 * If we have no custom end-query or lookup failed, then try
	 * pulling it out of the hashtable.
	 */

	t = roff_parse(r, buf->buf, &pos, ln, ppos);

	if (t != ROFF_cblock) {
		if (tok != ROFF_ig)
			roff_setstr(r, r->last->name, buf->buf + ppos, 2);
		return ROFF_IGN;
	}

	assert(roffs[t].proc);
	return (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs);
}

static enum rofferr
roff_block_text(ROFF_ARGS)
{

	if (tok != ROFF_ig)
		roff_setstr(r, r->last->name, buf->buf + pos, 2);

	return ROFF_IGN;
}

static enum rofferr
roff_cond_sub(ROFF_ARGS)
{
	enum rofft	 t;
	char		*ep;
	int		 rr;

	rr = r->last->rule;
	roffnode_cleanscope(r);
	t = roff_parse(r, buf->buf, &pos, ln, ppos);

	/*
	 * Fully handle known macros when they are structurally
	 * required or when the conditional evaluated to true.
	 */

	if ((t != ROFF_MAX) &&
	    (rr || roffs[t].flags & ROFFMAC_STRUCT)) {
		assert(roffs[t].proc);
		return (*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs);
	}

	/*
	 * If `\}' occurs on a macro line without a preceding macro,
	 * drop the line completely.
	 */

	ep = buf->buf + pos;
	if (ep[0] == '\\' && ep[1] == '}')
		rr = 0;

	/* Always check for the closing delimiter `\}'. */

	while ((ep = strchr(ep, '\\')) != NULL) {
		if (*(++ep) == '}') {
			*ep = '&';
			roff_ccond(r, ln, ep - buf->buf - 1);
		}
		if (*ep != '\0')
			++ep;
	}
	return rr ? ROFF_CONT : ROFF_IGN;
}

static enum rofferr
roff_cond_text(ROFF_ARGS)
{
	char		*ep;
	int		 rr;

	rr = r->last->rule;
	roffnode_cleanscope(r);

	ep = buf->buf + pos;
	while ((ep = strchr(ep, '\\')) != NULL) {
		if (*(++ep) == '}') {
			*ep = '&';
			roff_ccond(r, ln, ep - buf->buf - 1);
		}
		if (*ep != '\0')
			++ep;
	}
	return rr ? ROFF_CONT : ROFF_IGN;
}

/* --- handling of numeric and conditional expressions -------------------- */

/*
 * Parse a single signed integer number.  Stop at the first non-digit.
 * If there is at least one digit, return success and advance the
 * parse point, else return failure and let the parse point unchanged.
 * Ignore overflows, treat them just like the C language.
 */
static int
roff_getnum(const char *v, int *pos, int *res, int flags)
{
	int	 myres, scaled, n, p;

	if (NULL == res)
		res = &myres;

	p = *pos;
	n = v[p] == '-';
	if (n || v[p] == '+')
		p++;

	if (flags & ROFFNUM_WHITE)
		while (isspace((unsigned char)v[p]))
			p++;

	for (*res = 0; isdigit((unsigned char)v[p]); p++)
		*res = 10 * *res + v[p] - '0';
	if (p == *pos + n)
		return 0;

	if (n)
		*res = -*res;

	/* Each number may be followed by one optional scaling unit. */

	switch (v[p]) {
	case 'f':
		scaled = *res * 65536;
		break;
	case 'i':
		scaled = *res * 240;
		break;
	case 'c':
		scaled = *res * 240 / 2.54;
		break;
	case 'v':
	case 'P':
		scaled = *res * 40;
		break;
	case 'm':
	case 'n':
		scaled = *res * 24;
		break;
	case 'p':
		scaled = *res * 10 / 3;
		break;
	case 'u':
		scaled = *res;
		break;
	case 'M':
		scaled = *res * 6 / 25;
		break;
	default:
		scaled = *res;
		p--;
		break;
	}
	if (flags & ROFFNUM_SCALE)
		*res = scaled;

	*pos = p + 1;
	return 1;
}

/*
 * Evaluate a string comparison condition.
 * The first character is the delimiter.
 * Succeed if the string up to its second occurrence
 * matches the string up to its third occurence.
 * Advance the cursor after the third occurrence
 * or lacking that, to the end of the line.
 */
static int
roff_evalstrcond(const char *v, int *pos)
{
	const char	*s1, *s2, *s3;
	int		 match;

	match = 0;
	s1 = v + *pos;		/* initial delimiter */
	s2 = s1 + 1;		/* for scanning the first string */
	s3 = strchr(s2, *s1);	/* for scanning the second string */

	if (NULL == s3)		/* found no middle delimiter */
		goto out;

	while ('\0' != *++s3) {
		if (*s2 != *s3) {  /* mismatch */
			s3 = strchr(s3, *s1);
			break;
		}
		if (*s3 == *s1) {  /* found the final delimiter */
			match = 1;
			break;
		}
		s2++;
	}

out:
	if (NULL == s3)
		s3 = strchr(s2, '\0');
	else if (*s3 != '\0')
		s3++;
	*pos = s3 - v;
	return match;
}

/*
 * Evaluate an optionally negated single character, numerical,
 * or string condition.
 */
static int
roff_evalcond(struct roff *r, int ln, char *v, int *pos)
{
	char	*cp, *name;
	size_t	 sz;
	int	 number, savepos, wanttrue;

	if ('!' == v[*pos]) {
		wanttrue = 0;
		(*pos)++;
	} else
		wanttrue = 1;

	switch (v[*pos]) {
	case '\0':
		return 0;
	case 'n':
	case 'o':
		(*pos)++;
		return wanttrue;
	case 'c':
	case 'd':
	case 'e':
	case 't':
	case 'v':
		(*pos)++;
		return !wanttrue;
	case 'r':
		cp = name = v + ++*pos;
		sz = roff_getname(r, &cp, ln, *pos);
		*pos = cp - v;
		return (sz && roff_hasregn(r, name, sz)) == wanttrue;
	default:
		break;
	}

	savepos = *pos;
	if (roff_evalnum(r, ln, v, pos, &number, ROFFNUM_SCALE))
		return (number > 0) == wanttrue;
	else if (*pos == savepos)
		return roff_evalstrcond(v, pos) == wanttrue;
	else
		return 0;
}

static enum rofferr
roff_line_ignore(ROFF_ARGS)
{

	return ROFF_IGN;
}

static enum rofferr
roff_insec(ROFF_ARGS)
{

	mandoc_msg(MANDOCERR_REQ_INSEC, r->parse,
	    ln, ppos, roffs[tok].name);
	return ROFF_IGN;
}

static enum rofferr
roff_unsupp(ROFF_ARGS)
{

	mandoc_msg(MANDOCERR_REQ_UNSUPP, r->parse,
	    ln, ppos, roffs[tok].name);
	return ROFF_IGN;
}

static enum rofferr
roff_cond(ROFF_ARGS)
{

	roffnode_push(r, tok, NULL, ln, ppos);

	/*
	 * An `.el' has no conditional body: it will consume the value
	 * of the current rstack entry set in prior `ie' calls or
	 * defaults to DENY.
	 *
	 * If we're not an `el', however, then evaluate the conditional.
	 */

	r->last->rule = tok == ROFF_el ?
	    (r->rstackpos < 0 ? 0 : r->rstack[r->rstackpos--]) :
	    roff_evalcond(r, ln, buf->buf, &pos);

	/*
	 * An if-else will put the NEGATION of the current evaluated
	 * conditional into the stack of rules.
	 */

	if (tok == ROFF_ie) {
		if (r->rstackpos + 1 == r->rstacksz) {
			r->rstacksz += 16;
			r->rstack = mandoc_reallocarray(r->rstack,
			    r->rstacksz, sizeof(int));
		}
		r->rstack[++r->rstackpos] = !r->last->rule;
	}

	/* If the parent has false as its rule, then so do we. */

	if (r->last->parent && !r->last->parent->rule)
		r->last->rule = 0;

	/*
	 * Determine scope.
	 * If there is nothing on the line after the conditional,
	 * not even whitespace, use next-line scope.
	 */

	if (buf->buf[pos] == '\0') {
		r->last->endspan = 2;
		goto out;
	}

	while (buf->buf[pos] == ' ')
		pos++;

	/* An opening brace requests multiline scope. */

	if (buf->buf[pos] == '\\' && buf->buf[pos + 1] == '{') {
		r->last->endspan = -1;
		pos += 2;
		while (buf->buf[pos] == ' ')
			pos++;
		goto out;
	}

	/*
	 * Anything else following the conditional causes
	 * single-line scope.  Warn if the scope contains
	 * nothing but trailing whitespace.
	 */

	if (buf->buf[pos] == '\0')
		mandoc_msg(MANDOCERR_COND_EMPTY, r->parse,
		    ln, ppos, roffs[tok].name);

	r->last->endspan = 1;

out:
	*offs = pos;
	return ROFF_RERUN;
}

static enum rofferr
roff_ds(ROFF_ARGS)
{
	char		*string;
	const char	*name;
	size_t		 namesz;

	/* Ignore groff compatibility mode for now. */

	if (tok == ROFF_ds1)
		tok = ROFF_ds;
	else if (tok == ROFF_as1)
		tok = ROFF_as;

	/*
	 * The first word is the name of the string.
	 * If it is empty or terminated by an escape sequence,
	 * abort the `ds' request without defining anything.
	 */

	name = string = buf->buf + pos;
	if (*name == '\0')
		return ROFF_IGN;

	namesz = roff_getname(r, &string, ln, pos);
	if (name[namesz] == '\\')
		return ROFF_IGN;

	/* Read past the initial double-quote, if any. */
	if (*string == '"')
		string++;

	/* The rest is the value. */
	roff_setstrn(&r->strtab, name, namesz, string, strlen(string),
	    ROFF_as == tok);
	return ROFF_IGN;
}

/*
 * Parse a single operator, one or two characters long.
 * If the operator is recognized, return success and advance the
 * parse point, else return failure and let the parse point unchanged.
 */
static int
roff_getop(const char *v, int *pos, char *res)
{

	*res = v[*pos];

	switch (*res) {
	case '+':
	case '-':
	case '*':
	case '/':
	case '%':
	case '&':
	case ':':
		break;
	case '<':
		switch (v[*pos + 1]) {
		case '=':
			*res = 'l';
			(*pos)++;
			break;
		case '>':
			*res = '!';
			(*pos)++;
			break;
		case '?':
			*res = 'i';
			(*pos)++;
			break;
		default:
			break;
		}
		break;
	case '>':
		switch (v[*pos + 1]) {
		case '=':
			*res = 'g';
			(*pos)++;
			break;
		case '?':
			*res = 'a';
			(*pos)++;
			break;
		default:
			break;
		}
		break;
	case '=':
		if ('=' == v[*pos + 1])
			(*pos)++;
		break;
	default:
		return 0;
	}
	(*pos)++;

	return *res;
}

/*
 * Evaluate either a parenthesized numeric expression
 * or a single signed integer number.
 */
static int
roff_evalpar(struct roff *r, int ln,
	const char *v, int *pos, int *res, int flags)
{

	if ('(' != v[*pos])
		return roff_getnum(v, pos, res, flags);

	(*pos)++;
	if ( ! roff_evalnum(r, ln, v, pos, res, flags | ROFFNUM_WHITE))
		return 0;

	/*
	 * Omission of the closing parenthesis
	 * is an error in validation mode,
	 * but ignored in evaluation mode.
	 */

	if (')' == v[*pos])
		(*pos)++;
	else if (NULL == res)
		return 0;

	return 1;
}

/*
 * Evaluate a complete numeric expression.
 * Proceed left to right, there is no concept of precedence.
 */
static int
roff_evalnum(struct roff *r, int ln, const char *v,
	int *pos, int *res, int flags)
{
	int		 mypos, operand2;
	char		 operator;

	if (NULL == pos) {
		mypos = 0;
		pos = &mypos;
	}

	if (flags & ROFFNUM_WHITE)
		while (isspace((unsigned char)v[*pos]))
			(*pos)++;

	if ( ! roff_evalpar(r, ln, v, pos, res, flags))
		return 0;

	while (1) {
		if (flags & ROFFNUM_WHITE)
			while (isspace((unsigned char)v[*pos]))
				(*pos)++;

		if ( ! roff_getop(v, pos, &operator))
			break;

		if (flags & ROFFNUM_WHITE)
			while (isspace((unsigned char)v[*pos]))
				(*pos)++;

		if ( ! roff_evalpar(r, ln, v, pos, &operand2, flags))
			return 0;

		if (flags & ROFFNUM_WHITE)
			while (isspace((unsigned char)v[*pos]))
				(*pos)++;

		if (NULL == res)
			continue;

		switch (operator) {
		case '+':
			*res += operand2;
			break;
		case '-':
			*res -= operand2;
			break;
		case '*':
			*res *= operand2;
			break;
		case '/':
			if (operand2 == 0) {
				mandoc_msg(MANDOCERR_DIVZERO,
					r->parse, ln, *pos, v);
				*res = 0;
				break;
			}
			*res /= operand2;
			break;
		case '%':
			if (operand2 == 0) {
				mandoc_msg(MANDOCERR_DIVZERO,
					r->parse, ln, *pos, v);
				*res = 0;
				break;
			}
			*res %= operand2;
			break;
		case '<':
			*res = *res < operand2;
			break;
		case '>':
			*res = *res > operand2;
			break;
		case 'l':
			*res = *res <= operand2;
			break;
		case 'g':
			*res = *res >= operand2;
			break;
		case '=':
			*res = *res == operand2;
			break;
		case '!':
			*res = *res != operand2;
			break;
		case '&':
			*res = *res && operand2;
			break;
		case ':':
			*res = *res || operand2;
			break;
		case 'i':
			if (operand2 < *res)
				*res = operand2;
			break;
		case 'a':
			if (operand2 > *res)
				*res = operand2;
			break;
		default:
			abort();
		}
	}
	return 1;
}

/* --- register management ------------------------------------------------ */

void
roff_setreg(struct roff *r, const char *name, int val, char sign)
{
	struct roffreg	*reg;

	/* Search for an existing register with the same name. */
	reg = r->regtab;

	while (reg && strcmp(name, reg->key.p))
		reg = reg->next;

	if (NULL == reg) {
		/* Create a new register. */
		reg = mandoc_malloc(sizeof(struct roffreg));
		reg->key.p = mandoc_strdup(name);
		reg->key.sz = strlen(name);
		reg->val = 0;
		reg->next = r->regtab;
		r->regtab = reg;
	}

	if ('+' == sign)
		reg->val += val;
	else if ('-' == sign)
		reg->val -= val;
	else
		reg->val = val;
}

/*
 * Handle some predefined read-only number registers.
 * For now, return -1 if the requested register is not predefined;
 * in case a predefined read-only register having the value -1
 * were to turn up, another special value would have to be chosen.
 */
static int
roff_getregro(const struct roff *r, const char *name)
{

	switch (*name) {
	case '$':  /* Number of arguments of the last macro evaluated. */
		return r->argc;
	case 'A':  /* ASCII approximation mode is always off. */
		return 0;
	case 'g':  /* Groff compatibility mode is always on. */
		return 1;
	case 'H':  /* Fixed horizontal resolution. */
		return 24;
	case 'j':  /* Always adjust left margin only. */
		return 0;
	case 'T':  /* Some output device is always defined. */
		return 1;
	case 'V':  /* Fixed vertical resolution. */
		return 40;
	default:
		return -1;
	}
}

int
roff_getreg(const struct roff *r, const char *name)
{
	struct roffreg	*reg;
	int		 val;

	if ('.' == name[0] && '\0' != name[1] && '\0' == name[2]) {
		val = roff_getregro(r, name + 1);
		if (-1 != val)
			return val;
	}

	for (reg = r->regtab; reg; reg = reg->next)
		if (0 == strcmp(name, reg->key.p))
			return reg->val;

	return 0;
}

static int
roff_getregn(const struct roff *r, const char *name, size_t len)
{
	struct roffreg	*reg;
	int		 val;

	if ('.' == name[0] && 2 == len) {
		val = roff_getregro(r, name + 1);
		if (-1 != val)
			return val;
	}

	for (reg = r->regtab; reg; reg = reg->next)
		if (len == reg->key.sz &&
		    0 == strncmp(name, reg->key.p, len))
			return reg->val;

	return 0;
}

static int
roff_hasregn(const struct roff *r, const char *name, size_t len)
{
	struct roffreg	*reg;
	int		 val;

	if ('.' == name[0] && 2 == len) {
		val = roff_getregro(r, name + 1);
		if (-1 != val)
			return 1;
	}

	for (reg = r->regtab; reg; reg = reg->next)
		if (len == reg->key.sz &&
		    0 == strncmp(name, reg->key.p, len))
			return 1;

	return 0;
}

static void
roff_freereg(struct roffreg *reg)
{
	struct roffreg	*old_reg;

	while (NULL != reg) {
		free(reg->key.p);
		old_reg = reg;
		reg = reg->next;
		free(old_reg);
	}
}

static enum rofferr
roff_nr(ROFF_ARGS)
{
	char		*key, *val;
	size_t		 keysz;
	int		 iv;
	char		 sign;

	key = val = buf->buf + pos;
	if (*key == '\0')
		return ROFF_IGN;

	keysz = roff_getname(r, &val, ln, pos);
	if (key[keysz] == '\\')
		return ROFF_IGN;
	key[keysz] = '\0';

	sign = *val;
	if (sign == '+' || sign == '-')
		val++;

	if (roff_evalnum(r, ln, val, NULL, &iv, ROFFNUM_SCALE))
		roff_setreg(r, key, iv, sign);

	return ROFF_IGN;
}

static enum rofferr
roff_rr(ROFF_ARGS)
{
	struct roffreg	*reg, **prev;
	char		*name, *cp;
	size_t		 namesz;

	name = cp = buf->buf + pos;
	if (*name == '\0')
		return ROFF_IGN;
	namesz = roff_getname(r, &cp, ln, pos);
	name[namesz] = '\0';

	prev = &r->regtab;
	while (1) {
		reg = *prev;
		if (reg == NULL || !strcmp(name, reg->key.p))
			break;
		prev = &reg->next;
	}
	if (reg != NULL) {
		*prev = reg->next;
		free(reg->key.p);
		free(reg);
	}
	return ROFF_IGN;
}

/* --- handler functions for roff requests -------------------------------- */

static enum rofferr
roff_rm(ROFF_ARGS)
{
	const char	 *name;
	char		 *cp;
	size_t		  namesz;

	cp = buf->buf + pos;
	while (*cp != '\0') {
		name = cp;
		namesz = roff_getname(r, &cp, ln, (int)(cp - buf->buf));
		roff_setstrn(&r->strtab, name, namesz, NULL, 0, 0);
		if (name[namesz] == '\\')
			break;
	}
	return ROFF_IGN;
}

static enum rofferr
roff_it(ROFF_ARGS)
{
	int		 iv;

	/* Parse the number of lines. */

	if ( ! roff_evalnum(r, ln, buf->buf, &pos, &iv, 0)) {
		mandoc_msg(MANDOCERR_IT_NONUM, r->parse,
		    ln, ppos, buf->buf + 1);
		return ROFF_IGN;
	}

	while (isspace((unsigned char)buf->buf[pos]))
		pos++;

	/*
	 * Arm the input line trap.
	 * Special-casing "an-trap" is an ugly workaround to cope
	 * with DocBook stupidly fiddling with man(7) internals.
	 */

	roffit_lines = iv;
	roffit_macro = mandoc_strdup(iv != 1 ||
	    strcmp(buf->buf + pos, "an-trap") ?
	    buf->buf + pos : "br");
	return ROFF_IGN;
}

static enum rofferr
roff_Dd(ROFF_ARGS)
{
	const char *const	*cp;

	if ((r->options & (MPARSE_MDOC | MPARSE_QUICK)) == 0)
		for (cp = __mdoc_reserved; *cp; cp++)
			roff_setstr(r, *cp, NULL, 0);

	if (r->format == 0)
		r->format = MPARSE_MDOC;

	return ROFF_CONT;
}

static enum rofferr
roff_TH(ROFF_ARGS)
{
	const char *const	*cp;

	if ((r->options & MPARSE_QUICK) == 0)
		for (cp = __man_reserved; *cp; cp++)
			roff_setstr(r, *cp, NULL, 0);

	if (r->format == 0)
		r->format = MPARSE_MAN;

	return ROFF_CONT;
}

static enum rofferr
roff_TE(ROFF_ARGS)
{

	if (NULL == r->tbl)
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "TE");
	else if ( ! tbl_end(&r->tbl)) {
		free(buf->buf);
		buf->buf = mandoc_strdup(".sp");
		buf->sz = 4;
		return ROFF_REPARSE;
	}
	return ROFF_IGN;
}

static enum rofferr
roff_T_(ROFF_ARGS)
{

	if (NULL == r->tbl)
		mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse,
		    ln, ppos, "T&");
	else
		tbl_restart(ppos, ln, r->tbl);

	return ROFF_IGN;
}

/*
 * Handle in-line equation delimiters.
 */
static enum rofferr
roff_eqndelim(struct roff *r, struct buf *buf, int pos)
{
	char		*cp1, *cp2;
	const char	*bef_pr, *bef_nl, *mac, *aft_nl, *aft_pr;

	/*
	 * Outside equations, look for an opening delimiter.
	 * If we are inside an equation, we already know it is
	 * in-line, or this function wouldn't have been called;
	 * so look for a closing delimiter.
	 */

	cp1 = buf->buf + pos;
	cp2 = strchr(cp1, r->eqn == NULL ?
	    r->last_eqn->odelim : r->last_eqn->cdelim);
	if (cp2 == NULL)
		return ROFF_CONT;

	*cp2++ = '\0';
	bef_pr = bef_nl = aft_nl = aft_pr = "";

	/* Handle preceding text, protecting whitespace. */

	if (*buf->buf != '\0') {
		if (r->eqn == NULL)
			bef_pr = "\\&";
		bef_nl = "\n";
	}

	/*
	 * Prepare replacing the delimiter with an equation macro
	 * and drop leading white space from the equation.
	 */

	if (r->eqn == NULL) {
		while (*cp2 == ' ')
			cp2++;
		mac = ".EQ";
	} else
		mac = ".EN";

	/* Handle following text, protecting whitespace. */

	if (*cp2 != '\0') {
		aft_nl = "\n";
		if (r->eqn != NULL)
			aft_pr = "\\&";
	}

	/* Do the actual replacement. */

	buf->sz = mandoc_asprintf(&cp1, "%s%s%s%s%s%s%s", buf->buf,
	    bef_pr, bef_nl, mac, aft_nl, aft_pr, cp2) + 1;
	free(buf->buf);
	buf->buf = cp1;

	/* Toggle the in-line state of the eqn subsystem. */

	r->eqn_inline = r->eqn == NULL;
	return ROFF_REPARSE;
}

static enum rofferr
roff_EQ(ROFF_ARGS)
{
	struct eqn_node *e;

	assert(r->eqn == NULL);
	e = eqn_alloc(ppos, ln, r->parse);

	if (r->last_eqn) {
		r->last_eqn->next = e;
		e->delim = r->last_eqn->delim;
		e->odelim = r->last_eqn->odelim;
		e->cdelim = r->last_eqn->cdelim;
	} else
		r->first_eqn = r->last_eqn = e;

	r->eqn = r->last_eqn = e;

	if (buf->buf[pos] != '\0')
		mandoc_vmsg(MANDOCERR_ARG_SKIP, r->parse, ln, pos,
		    ".EQ %s", buf->buf + pos);

	return ROFF_IGN;
}

static enum rofferr
roff_EN(ROFF_ARGS)
{

	mandoc_msg(MANDOCERR_BLK_NOTOPEN, r->parse, ln, ppos, "EN");
	return ROFF_IGN;
}

static enum rofferr
roff_TS(ROFF_ARGS)
{
	struct tbl_node	*tbl;

	if (r->tbl) {
		mandoc_msg(MANDOCERR_BLK_BROKEN, r->parse,
		    ln, ppos, "TS breaks TS");
		tbl_end(&r->tbl);
	}

	tbl = tbl_alloc(ppos, ln, r->parse);

	if (r->last_tbl)
		r->last_tbl->next = tbl;
	else
		r->first_tbl = r->last_tbl = tbl;

	r->tbl = r->last_tbl = tbl;
	return ROFF_IGN;
}

static enum rofferr
roff_brp(ROFF_ARGS)
{

	buf->buf[pos - 1] = '\0';
	return ROFF_CONT;
}

static enum rofferr
roff_cc(ROFF_ARGS)
{
	const char	*p;

	p = buf->buf + pos;

	if (*p == '\0' || (r->control = *p++) == '.')
		r->control = 0;

	if (*p != '\0')
		mandoc_vmsg(MANDOCERR_ARG_EXCESS, r->parse,
		    ln, p - buf->buf, "cc ... %s", p);

	return ROFF_IGN;
}

static enum rofferr
roff_tr(ROFF_ARGS)
{
	const char	*p, *first, *second;
	size_t		 fsz, ssz;
	enum mandoc_esc	 esc;

	p = buf->buf + pos;

	if (*p == '\0') {
		mandoc_msg(MANDOCERR_REQ_EMPTY, r->parse, ln, ppos, "tr");
		return ROFF_IGN;
	}

	while (*p != '\0') {
		fsz = ssz = 1;

		first = p++;
		if (*first == '\\') {
			esc = mandoc_escape(&p, NULL, NULL);
			if (esc == ESCAPE_ERROR) {
				mandoc_msg(MANDOCERR_ESC_BAD, r->parse,
				    ln, (int)(p - buf->buf), first);
				return ROFF_IGN;
			}
			fsz = (size_t)(p - first);
		}

		second = p++;
		if (*second == '\\') {
			esc = mandoc_escape(&p, NULL, NULL);
			if (esc == ESCAPE_ERROR) {
				mandoc_msg(MANDOCERR_ESC_BAD, r->parse,
				    ln, (int)(p - buf->buf), second);
				return ROFF_IGN;
			}
			ssz = (size_t)(p - second);
		} else if (*second == '\0') {
			mandoc_vmsg(MANDOCERR_TR_ODD, r->parse,
			    ln, first - buf->buf, "tr %s", first);
			second = " ";
			p--;
		}

		if (fsz > 1) {
			roff_setstrn(&r->xmbtab, first, fsz,
			    second, ssz, 0);
			continue;
		}

		if (r->xtab == NULL)
			r->xtab = mandoc_calloc(128,
			    sizeof(struct roffstr));

		free(r->xtab[(int)*first].p);
		r->xtab[(int)*first].p = mandoc_strndup(second, ssz);
		r->xtab[(int)*first].sz = ssz;
	}

	return ROFF_IGN;
}

static enum rofferr
roff_so(ROFF_ARGS)
{
	char *name, *cp;

	name = buf->buf + pos;
	mandoc_vmsg(MANDOCERR_SO, r->parse, ln, ppos, "so %s", name);

	/*
	 * Handle `so'.  Be EXTREMELY careful, as we shouldn't be
	 * opening anything that's not in our cwd or anything beneath
	 * it.  Thus, explicitly disallow traversing up the file-system
	 * or using absolute paths.
	 */

	if (*name == '/' || strstr(name, "../") || strstr(name, "/..")) {
		mandoc_vmsg(MANDOCERR_SO_PATH, r->parse, ln, ppos,
		    ".so %s", name);
		buf->sz = mandoc_asprintf(&cp,
		    ".sp\nSee the file %s.\n.sp", name) + 1;
		free(buf->buf);
		buf->buf = cp;
		*offs = 0;
		return ROFF_REPARSE;
	}

	*offs = pos;
	return ROFF_SO;
}

/* --- user defined strings and macros ------------------------------------ */

static enum rofferr
roff_userdef(ROFF_ARGS)
{
	const char	 *arg[9], *ap;
	char		 *cp, *n1, *n2;
	int		  i, ib, ie;
	size_t		  asz, rsz;

	/*
	 * Collect pointers to macro argument strings
	 * and NUL-terminate them.
	 */

	r->argc = 0;
	cp = buf->buf + pos;
	for (i = 0; i < 9; i++) {
		if (*cp == '\0')
			arg[i] = "";
		else {
			arg[i] = mandoc_getarg(r->parse, &cp, ln, &pos);
			r->argc = i + 1;
		}
	}

	/*
	 * Expand macro arguments.
	 */

	buf->sz = strlen(r->current_string) + 1;
	n1 = cp = mandoc_malloc(buf->sz);
	memcpy(n1, r->current_string, buf->sz);
	while (*cp != '\0') {

		/* Scan ahead for the next argument invocation. */

		if (*cp++ != '\\')
			continue;
		if (*cp++ != '$')
			continue;
		if (*cp == '*') {  /* \\$* inserts all arguments */
			ib = 0;
			ie = r->argc - 1;
		} else {  /* \\$1 .. \\$9 insert one argument */
			ib = ie = *cp - '1';
			if (ib < 0 || ib > 8)
				continue;
		}
		cp -= 2;

		/*
		 * Determine the size of the expanded argument,
		 * taking escaping of quotes into account.
		 */

		asz = ie > ib ? ie - ib : 0;  /* for blanks */
		for (i = ib; i <= ie; i++) {
			for (ap = arg[i]; *ap != '\0'; ap++) {
				asz++;
				if (*ap == '"')
					asz += 3;
			}
		}
		if (asz != 3) {

			/*
			 * Determine the size of the rest of the
			 * unexpanded macro, including the NUL.
			 */

			rsz = buf->sz - (cp - n1) - 3;

			/*
			 * When shrinking, move before
			 * releasing the storage.
			 */

			if (asz < 3)
				memmove(cp + asz, cp + 3, rsz);

			/*
			 * Resize the storage for the macro
			 * and readjust the parse pointer.
			 */

			buf->sz += asz - 3;
			n2 = mandoc_realloc(n1, buf->sz);
			cp = n2 + (cp - n1);
			n1 = n2;

			/*
			 * When growing, make room
			 * for the expanded argument.
			 */

			if (asz > 3)
				memmove(cp + asz, cp + 3, rsz);
		}

		/* Copy the expanded argument, escaping quotes. */

		n2 = cp;
		for (i = ib; i <= ie; i++) {
			for (ap = arg[i]; *ap != '\0'; ap++) {
				if (*ap == '"') {
					memcpy(n2, "\\(dq", 4);
					n2 += 4;
				} else
					*n2++ = *ap;
			}
			if (i < ie)
				*n2++ = ' ';
		}
	}

	/*
	 * Replace the macro invocation
	 * by the expanded macro.
	 */

	free(buf->buf);
	buf->buf = n1;
	*offs = 0;

	return buf->sz > 1 && buf->buf[buf->sz - 2] == '\n' ?
	   ROFF_REPARSE : ROFF_APPEND;
}

static size_t
roff_getname(struct roff *r, char **cpp, int ln, int pos)
{
	char	 *name, *cp;
	size_t	  namesz;

	name = *cpp;
	if ('\0' == *name)
		return 0;

	/* Read until end of name and terminate it with NUL. */
	for (cp = name; 1; cp++) {
		if ('\0' == *cp || ' ' == *cp) {
			namesz = cp - name;
			break;
		}
		if ('\\' != *cp)
			continue;
		namesz = cp - name;
		if ('{' == cp[1] || '}' == cp[1])
			break;
		cp++;
		if ('\\' == *cp)
			continue;
		mandoc_vmsg(MANDOCERR_NAMESC, r->parse, ln, pos,
		    "%.*s", (int)(cp - name + 1), name);
		mandoc_escape((const char **)&cp, NULL, NULL);
		break;
	}

	/* Read past spaces. */
	while (' ' == *cp)
		cp++;

	*cpp = cp;
	return namesz;
}

/*
 * Store *string into the user-defined string called *name.
 * To clear an existing entry, call with (*r, *name, NULL, 0).
 * append == 0: replace mode
 * append == 1: single-line append mode
 * append == 2: multiline append mode, append '\n' after each call
 */
static void
roff_setstr(struct roff *r, const char *name, const char *string,
	int append)
{

	roff_setstrn(&r->strtab, name, strlen(name), string,
	    string ? strlen(string) : 0, append);
}

static void
roff_setstrn(struct roffkv **r, const char *name, size_t namesz,
		const char *string, size_t stringsz, int append)
{
	struct roffkv	*n;
	char		*c;
	int		 i;
	size_t		 oldch, newch;

	/* Search for an existing string with the same name. */
	n = *r;

	while (n && (namesz != n->key.sz ||
			strncmp(n->key.p, name, namesz)))
		n = n->next;

	if (NULL == n) {
		/* Create a new string table entry. */
		n = mandoc_malloc(sizeof(struct roffkv));
		n->key.p = mandoc_strndup(name, namesz);
		n->key.sz = namesz;
		n->val.p = NULL;
		n->val.sz = 0;
		n->next = *r;
		*r = n;
	} else if (0 == append) {
		free(n->val.p);
		n->val.p = NULL;
		n->val.sz = 0;
	}

	if (NULL == string)
		return;

	/*
	 * One additional byte for the '\n' in multiline mode,
	 * and one for the terminating '\0'.
	 */
	newch = stringsz + (1 < append ? 2u : 1u);

	if (NULL == n->val.p) {
		n->val.p = mandoc_malloc(newch);
		*n->val.p = '\0';
		oldch = 0;
	} else {
		oldch = n->val.sz;
		n->val.p = mandoc_realloc(n->val.p, oldch + newch);
	}

	/* Skip existing content in the destination buffer. */
	c = n->val.p + (int)oldch;

	/* Append new content to the destination buffer. */
	i = 0;
	while (i < (int)stringsz) {
		/*
		 * Rudimentary roff copy mode:
		 * Handle escaped backslashes.
		 */
		if ('\\' == string[i] && '\\' == string[i + 1])
			i++;
		*c++ = string[i++];
	}

	/* Append terminating bytes. */
	if (1 < append)
		*c++ = '\n';

	*c = '\0';
	n->val.sz = (int)(c - n->val.p);
}

static const char *
roff_getstrn(const struct roff *r, const char *name, size_t len)
{
	const struct roffkv *n;
	int i;

	for (n = r->strtab; n; n = n->next)
		if (0 == strncmp(name, n->key.p, len) &&
		    '\0' == n->key.p[(int)len])
			return n->val.p;

	for (i = 0; i < PREDEFS_MAX; i++)
		if (0 == strncmp(name, predefs[i].name, len) &&
				'\0' == predefs[i].name[(int)len])
			return predefs[i].str;

	return NULL;
}

static void
roff_freestr(struct roffkv *r)
{
	struct roffkv	 *n, *nn;

	for (n = r; n; n = nn) {
		free(n->key.p);
		free(n->val.p);
		nn = n->next;
		free(n);
	}
}

/* --- accessors and utility functions ------------------------------------ */

const struct tbl_span *
roff_span(const struct roff *r)
{

	return r->tbl ? tbl_span(r->tbl) : NULL;
}

const struct eqn *
roff_eqn(const struct roff *r)
{

	return r->last_eqn ? &r->last_eqn->eqn : NULL;
}

/*
 * Duplicate an input string, making the appropriate character
 * conversations (as stipulated by `tr') along the way.
 * Returns a heap-allocated string with all the replacements made.
 */
char *
roff_strdup(const struct roff *r, const char *p)
{
	const struct roffkv *cp;
	char		*res;
	const char	*pp;
	size_t		 ssz, sz;
	enum mandoc_esc	 esc;

	if (NULL == r->xmbtab && NULL == r->xtab)
		return mandoc_strdup(p);
	else if ('\0' == *p)
		return mandoc_strdup("");

	/*
	 * Step through each character looking for term matches
	 * (remember that a `tr' can be invoked with an escape, which is
	 * a glyph but the escape is multi-character).
	 * We only do this if the character hash has been initialised
	 * and the string is >0 length.
	 */

	res = NULL;
	ssz = 0;

	while ('\0' != *p) {
		if ('\\' != *p && r->xtab && r->xtab[(int)*p].p) {
			sz = r->xtab[(int)*p].sz;
			res = mandoc_realloc(res, ssz + sz + 1);
			memcpy(res + ssz, r->xtab[(int)*p].p, sz);
			ssz += sz;
			p++;
			continue;
		} else if ('\\' != *p) {
			res = mandoc_realloc(res, ssz + 2);
			res[ssz++] = *p++;
			continue;
		}

		/* Search for term matches. */
		for (cp = r->xmbtab; cp; cp = cp->next)
			if (0 == strncmp(p, cp->key.p, cp->key.sz))
				break;

		if (NULL != cp) {
			/*
			 * A match has been found.
			 * Append the match to the array and move
			 * forward by its keysize.
			 */
			res = mandoc_realloc(res,
			    ssz + cp->val.sz + 1);
			memcpy(res + ssz, cp->val.p, cp->val.sz);
			ssz += cp->val.sz;
			p += (int)cp->key.sz;
			continue;
		}

		/*
		 * Handle escapes carefully: we need to copy
		 * over just the escape itself, or else we might
		 * do replacements within the escape itself.
		 * Make sure to pass along the bogus string.
		 */
		pp = p++;
		esc = mandoc_escape(&p, NULL, NULL);
		if (ESCAPE_ERROR == esc) {
			sz = strlen(pp);
			res = mandoc_realloc(res, ssz + sz + 1);
			memcpy(res + ssz, pp, sz);
			break;
		}
		/*
		 * We bail out on bad escapes.
		 * No need to warn: we already did so when
		 * roff_res() was called.
		 */
		sz = (int)(p - pp);
		res = mandoc_realloc(res, ssz + sz + 1);
		memcpy(res + ssz, pp, sz);
		ssz += sz;
	}

	res[(int)ssz] = '\0';
	return res;
}

int
roff_getformat(const struct roff *r)
{

	return r->format;
}

/*
 * Find out whether a line is a macro line or not.
 * If it is, adjust the current position and return one; if it isn't,
 * return zero and don't change the current position.
 * If the control character has been set with `.cc', then let that grain
 * precedence.
 * This is slighly contrary to groff, where using the non-breaking
 * control character when `cc' has been invoked will cause the
 * non-breaking macro contents to be printed verbatim.
 */
int
roff_getcontrol(const struct roff *r, const char *cp, int *ppos)
{
	int		pos;

	pos = *ppos;

	if (0 != r->control && cp[pos] == r->control)
		pos++;
	else if (0 != r->control)
		return 0;
	else if ('\\' == cp[pos] && '.' == cp[pos + 1])
		pos += 2;
	else if ('.' == cp[pos] || '\'' == cp[pos])
		pos++;
	else
		return 0;

	while (' ' == cp[pos] || '\t' == cp[pos])
		pos++;

	*ppos = pos;
	return 1;
}
@


1.282
log
@Move all mdoc(7) node validation done before child parsing
to the new separate validation pass, except for a tiny bit
needed by the parser which goes to the new mdoc_state() module;
cleaner, simpler, and surprisingly also shorter by 15 lines.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.281 2015/10/20 02:01:32 schwarze Exp $ */
d1066 1
a1066 1
		man_valid_post(man);
d1154 1
a1154 1
		man_valid_post(man);
@


1.281
log
@In order to become able to generate syntax tree nodes on the roff(7)
level, validation must be separated from parsing and rewinding.
This first big step moves calling of the mdoc(7) post_*() functions
out of the parser loop into their own mdoc_validate() pass, while
using a new mdoc_state() module to make syntax tree state handling
available to both the parser loop and the validation pass.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.280 2015/10/15 23:35:55 schwarze Exp $ */
d1028 1
a1028 21

	/*
	 * Copy over the normalised-data pointer of our parent.  Not
	 * everybody has one, but copying a null pointer is fine.
	 */

	switch (n->type) {
	case ROFFT_BODY:
		if (n->end != ENDBODY_NOT)
			break;
		/* FALLTHROUGH */
	case ROFFT_TAIL:
	case ROFFT_HEAD:
		n->norm = n->parent->norm;
		break;
	default:
		break;
	}

	if (man->macroset == MACROSET_MDOC)
		mdoc_valid_pre(man, n);
a1031 1
		assert(n->parent->type == ROFFT_BLOCK);
d1035 2
a1036 3
		if (n->end)
			break;
		assert(n->parent->type == ROFFT_BLOCK);
a1039 1
		assert(n->parent->type == ROFFT_BLOCK);
d1043 1
a1043 1
		break;
d1045 8
a1052 1
	man->last = n;
@


1.280
log
@Delete two preprocessor constants that are no longer used.
Patch from Michael Reed <m dot reed at mykolab dot com>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.279 2015/10/13 22:59:54 schwarze Exp $ */
d1010 5
d1022 1
a1027 1
	n->parent->last = n;
d1080 1
a1080 1
		mdoc_valid_post(man);
d1168 1
a1168 1
		mdoc_valid_post(man);
@


1.279
log
@Major character table cleanup:
* Use ohash(3) rather than a hand-rolled hash table.
* Make the character table static in the chars.c module:
There is no need to pass a pointer around, we most certainly
never want to use two different character tables concurrently.
* No need to keep the characters in a separate file chars.in;
that merely encourages downstream porters to mess with them.
* Sort the characters to agree with the mandoc_chars(7) manual page.
* Specify Unicode codepoints in hex, not decimal (that's the detail
that originally triggered this patch).
No functional change, minus 100 LOC, and i don't see a performance change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.278 2015/10/12 00:08:16 schwarze Exp $ */
a35 3
/* Maximum number of nested if-else conditionals. */
#define	RSTACK_MAX	128

@


1.278
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.277 2015/10/06 18:32:20 schwarze Exp $ */
a318 1
	const struct mchars *mchars; /* character table */
d903 1
a903 1
roff_alloc(struct mparse *parse, const struct mchars *mchars, int options)
a908 1
	r->mchars = mchars;
d1345 1
a1345 1
			     mchars_spec2cp(r->mchars, stnam, inaml) < 0))
@


1.277
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.276 2015/09/26 00:54:04 schwarze Exp $ */
a1039 1
		/* FALLTHROUGH */
a1336 1
			/* FALLTHROUGH */
a1410 1
				/* FALLTHROUGH */
a1411 1
				/* FALLTHROUGH */
a1412 1
				/* FALLTHROUGH */
a1718 1
		/* FALLTHROUGH */
a1719 1
		/* FALLTHROUGH */
a1721 1
		/* FALLTHROUGH */
a1722 1
		/* FALLTHROUGH */
a1763 1
		/* FALLTHROUGH */
a1764 1
		/* FALLTHROUGH */
a2050 1
		/* FALLTHROUGH */
a2054 1
		/* FALLTHROUGH */
a2142 1
		/* FALLTHROUGH */
a2146 1
		/* FALLTHROUGH */
a2147 1
		/* FALLTHROUGH */
a2148 1
		/* FALLTHROUGH */
a2149 1
		/* FALLTHROUGH */
a2324 1
		/* FALLTHROUGH */
a2325 1
		/* FALLTHROUGH */
a2326 1
		/* FALLTHROUGH */
a2327 1
		/* FALLTHROUGH */
a2328 1
		/* FALLTHROUGH */
a2329 1
		/* FALLTHROUGH */
@


1.276
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.275 2015/08/29 23:56:01 schwarze Exp $ */
d788 1
a788 1
		return(ROFF_MAX);
d793 1
a793 1
		return(ROFF_MAX);
d796 1
a796 1
			return((enum rofft)(n - roffs));
d798 1
a798 1
	return(ROFF_MAX);
d917 1
a917 1
	return(r);
d980 1
a980 1
	return(man);
d1006 1
a1006 1
	return(n);
d1120 1
a1120 1
	return(n);
d1131 1
a1131 1
	return(n);
d1142 1
a1142 1
	return(n);
d1359 1
a1359 1
			return(ROFF_IGN);
d1466 1
a1466 1
			return(ROFF_IGN);
d1482 1
a1482 1
	return(ROFF_CONT);
d1507 1
a1507 1
		return(ROFF_REPARSE);
d1541 1
a1541 1
	return(ROFF_CONT);
d1563 1
a1563 1
			return(e);
d1571 1
a1571 1
		return(e);
d1590 1
a1590 1
			return(e);
d1593 1
a1593 1
		return(eqn_read(&r->eqn, ln, buf->buf, ppos, offs));
d1595 1
a1595 1
		return(tbl_read(r->tbl, ln, buf->buf, ppos));
d1597 1
a1597 1
		return(roff_parsetext(buf, pos, offs));
d1604 1
a1604 1
		return(ROFF_IGN);
d1606 1
a1606 1
		return(ROFF_IGN);
d1617 1
a1617 1
		return((*roffs[t].sub)(r, t, buf, ln, ppos, pos, offs));
d1631 1
a1631 1
			return(ROFF_IGN);
d1636 1
a1636 1
		return(tbl_read(r->tbl, ln, buf->buf, pos));
d1645 1
a1645 1
		return(ROFF_CONT);
d1650 1
a1650 1
	return((*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs));
d1690 1
a1690 1
		return(ROFF_MAX);
d1701 1
a1701 1
	return(t);
d1718 1
a1718 1
		return(ROFF_IGN);
d1737 1
a1737 1
		return(ROFF_IGN);
d1746 1
a1746 1
	return(ROFF_IGN);
d1841 1
a1841 1
		return(ROFF_IGN);
d1856 1
a1856 1
		return(ROFF_IGN);
d1883 1
a1883 1
	return(ROFF_IGN);
d1919 2
a1920 2
				return(ROFF_RERUN);
			return(ROFF_IGN);
d1934 1
a1934 1
		return(ROFF_IGN);
d1938 1
a1938 1
	return((*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs));
d1948 1
a1948 1
	return(ROFF_IGN);
d1970 1
a1970 1
		return((*roffs[t].proc)(r, t, buf, ln, ppos, pos, offs));
d1992 1
a1992 1
	return(rr ? ROFF_CONT : ROFF_IGN);
d2013 1
a2013 1
	return(rr ? ROFF_CONT : ROFF_IGN);
d2089 1
a2089 1
	return(1);
d2132 1
a2132 1
	return(match);
d2154 1
a2154 1
		return(0);
d2159 1
a2159 1
		return(wanttrue);
d2170 1
a2170 1
		return(!wanttrue);
d2175 1
a2175 1
		return((sz && roff_hasregn(r, name, sz)) == wanttrue);
d2182 1
a2182 1
		return((number > 0) == wanttrue);
d2184 1
a2184 1
		return(roff_evalstrcond(v, pos) == wanttrue);
d2186 1
a2186 1
		return (0);
d2193 1
a2193 1
	return(ROFF_IGN);
d2202 1
a2202 1
	return(ROFF_IGN);
d2211 1
a2211 1
	return(ROFF_IGN);
d2289 1
a2289 1
	return(ROFF_RERUN);
d2314 1
a2314 1
		return(ROFF_IGN);
d2318 1
a2318 1
		return(ROFF_IGN);
d2327 1
a2327 1
	return(ROFF_IGN);
d2393 1
a2393 1
		return(0);
d2397 1
a2397 1
	return(*res);
d2410 1
a2410 1
		return(roff_getnum(v, pos, res, flags));
d2414 1
a2414 1
		return(0);
d2425 1
a2425 1
		return(0);
d2427 1
a2427 1
	return(1);
d2451 1
a2451 1
		return(0);
d2466 1
a2466 1
			return(0);
d2539 1
a2539 1
	return(1);
d2585 1
a2585 1
		return(r->argc);
d2587 1
a2587 1
		return(0);
d2589 1
a2589 1
		return(1);
d2591 1
a2591 1
		return (24);
d2593 1
a2593 1
		return(0);
d2595 1
a2595 1
		return(1);
d2597 1
a2597 1
		return (40);
d2599 1
a2599 1
		return (-1);
d2612 1
a2612 1
			return (val);
d2617 1
a2617 1
			return(reg->val);
d2619 1
a2619 1
	return(0);
d2631 1
a2631 1
			return (val);
d2637 1
a2637 1
			return(reg->val);
d2639 1
a2639 1
	return(0);
d2651 1
a2651 1
			return(1);
d2657 1
a2657 1
			return(1);
d2659 1
a2659 1
	return(0);
d2685 1
a2685 1
		return(ROFF_IGN);
d2689 1
a2689 1
		return(ROFF_IGN);
d2699 1
a2699 1
	return(ROFF_IGN);
d2711 1
a2711 1
		return(ROFF_IGN);
d2727 1
a2727 1
	return(ROFF_IGN);
d2747 1
a2747 1
	return(ROFF_IGN);
d2760 1
a2760 1
		return(ROFF_IGN);
d2776 1
a2776 1
	return(ROFF_IGN);
d2791 1
a2791 1
	return(ROFF_CONT);
d2806 1
a2806 1
	return(ROFF_CONT);
d2820 1
a2820 1
		return(ROFF_REPARSE);
d2822 1
a2822 1
	return(ROFF_IGN);
d2835 1
a2835 1
	return(ROFF_IGN);
d2858 1
a2858 1
		return(ROFF_CONT);
d2901 1
a2901 1
	return(ROFF_REPARSE);
d2926 1
a2926 1
	return(ROFF_IGN);
d2934 1
a2934 1
	return(ROFF_IGN);
d2956 1
a2956 1
	return(ROFF_IGN);
d2964 1
a2964 1
	return(ROFF_CONT);
d2981 1
a2981 1
	return(ROFF_IGN);
d2995 1
a2995 1
		return(ROFF_IGN);
d3007 1
a3007 1
				return(ROFF_IGN);
d3018 1
a3018 1
				return(ROFF_IGN);
d3043 1
a3043 1
	return(ROFF_IGN);
d3069 1
a3069 1
		return(ROFF_REPARSE);
d3073 1
a3073 1
	return(ROFF_SO);
d3201 2
a3202 2
	return(buf->sz > 1 && buf->buf[buf->sz - 2] == '\n' ?
	   ROFF_REPARSE : ROFF_APPEND);
d3213 1
a3213 1
		return(0);
d3240 1
a3240 1
	return(namesz);
d3340 1
a3340 1
			return(n->val.p);
d3345 1
a3345 1
			return(predefs[i].str);
d3347 1
a3347 1
	return(NULL);
d3369 1
a3369 1
	return(r->tbl ? tbl_span(r->tbl) : NULL);
d3376 1
a3376 1
	return(r->last_eqn ? &r->last_eqn->eqn : NULL);
d3394 1
a3394 1
		return(mandoc_strdup(p));
d3396 1
a3396 1
		return(mandoc_strdup(""));
d3468 1
a3468 1
	return(res);
d3475 1
a3475 1
	return(r->format);
d3498 1
a3498 1
		return(0);
d3504 1
a3504 1
		return(0);
d3510 1
a3510 1
	return(1);
@


1.275
log
@If we have to reparse the text line because we spring an input line trap,
we must not escape breakable hyphens yet, or mparse_buf_r() in read.c
will complain and replace the escaped hyphens with question marks.
Bug found in ocserv(8) following a report from Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.274 2015/08/29 21:37:20 schwarze Exp $ */
a1024 1
		/* NOTREACHED */
d2062 1
a2062 1
		/* FALLTROUGH */
d2067 1
a2067 1
		/* FALLTROUGH */
@


1.274
log
@Implement the escape sequence \\$*, expanding to all arguments
of the current user-defined macro.
This is another missing feature required for ocserv(8).
Problem reported by Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.273 2015/08/29 20:26:04 schwarze Exp $ */
d1487 1
a1487 3
 * Process text streams:
 * Convert all breakable hyphens into ASCII_HYPH.
 * Decrement and spring input line trap.
d1498 16
a1541 13

	/* Spring the input line trap. */
	if (roffit_lines == 1) {
		isz = mandoc_asprintf(&p, "%s\n.%s", buf->buf, roffit_macro);
		free(buf->buf);
		buf->buf = p;
		buf->sz = isz + 1;
		*offs = 0;
		free(roffit_macro);
		roffit_lines = 0;
		return(ROFF_REPARSE);
	} else if (roffit_lines > 1)
		--roffit_lines;
@


1.273
log
@Minimal implementation of the read-only number register \n(.$
which returns the number of arguments of the current macro.
This is one of the missing features required for ocserv(8).
Problem reported by Kurt Jaeger <pi at FreeBSD>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.272 2015/06/27 13:29:14 schwarze Exp $ */
d3083 1
a3083 1
	int		  i;
d3117 8
a3124 3
		i = *cp - '1';
		if (0 > i || 8 < i)
			continue;
d3132 7
a3138 5
		asz = 0;
		for (ap = arg[i]; *ap != '\0'; ap++) {
			asz++;
			if (*ap == '"')
				asz += 3;
d3179 10
a3188 6
		for (ap = arg[i]; *ap != '\0'; ap++) {
			if (*ap == '"') {
				memcpy(n2, "\\(dq", 4);
				n2 += 4;
			} else
				*n2++ = *ap;
@


1.272
log
@Ignore blank characters at the beginning of a conditional block,
that is, after "\{".
Issue found by Markus <Waldeck at gmx dot de> in bash(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.271 2015/05/31 23:13:22 schwarze Exp $ */
d338 1
d415 2
a416 1
static	int		 roff_getregro(const char *name);
d2580 1
a2580 1
roff_getregro(const char *name)
d2584 2
d2610 1
a2610 1
		val = roff_getregro(name + 1);
d2629 1
a2629 1
		val = roff_getregro(name + 1);
d2649 1
a2649 1
		val = roff_getregro(name + 1);
d3091 1
d3093 8
a3100 3
	for (i = 0; i < 9; i++)
		arg[i] = *cp == '\0' ? "" :
		    mandoc_getarg(r->parse, &cp, ln, &pos);
@


1.271
log
@Implement the roff(7) `r' (register exists) conditional.
Missing feature found by Markus <Waldeck at gmx dot de>
in Debian's bash(1) manual page.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.270 2015/05/01 16:02:47 schwarze Exp $ */
d2268 2
@


1.270
log
@Setting the "last" member of struct roff_node was done at an extremely
weird place.  Move it to the obviously correct place.
Surprisingly, this didn't cause any misformatting in the test suite
or in any base system manuals, but i cannot believe the code was
really correct for all conceivable input, and it would be very hard
to verify.  At the very least, it cannot have worked for man(7).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.269 2015/04/23 16:17:44 schwarze Exp $ */
d400 1
a400 2
static	int		 roff_evalcond(struct roff *r, int,
				const char *, int *);
d417 2
d2138 1
a2138 1
roff_evalcond(struct roff *r, int ln, const char *v, int *pos)
d2140 2
a2163 2
	case 'r':
		/* FALLTHROUGH */
d2169 5
d2636 20
@


1.269
log
@Unify mdoc_deroff() and man_deroff() into a common function deroff().
No functional change except that for mdoc(7), it now skips leading
escape sequences just like it already did for man(7).
Escape sequences rarely occur in mdoc(7) code and if they do,
skipping them is an improvement in this context.
Minus 30 lines of code.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.268 2015/04/19 14:57:38 schwarze Exp $ */
d1025 1
@


1.268
log
@Unify trickier node handling functions.
* man_elem_alloc() -> roff_elem_alloc()
* man_block_alloc() -> roff_block_alloc()
The functions mdoc_elem_alloc() and mdoc_block_alloc() remain for
now because they need to do mdoc(7)-specific argument processing.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.267 2015/04/19 14:25:41 schwarze Exp $ */
d1233 46
@


1.267
log
@Unify some node handling functions that use TOKEN_NONE.
* mdoc_word_alloc(), man_word_alloc() -> roff_word_alloc()
* mdoc_word_append(), man_word_append() -> roff_word_append()
* mdoc_addspan(), man_addspan() -> roff_addtbl()
* mdoc_addeqn(), man_addeqn() -> roff_addeqn()
Minus 50 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.266 2015/04/19 13:50:26 schwarze Exp $ */
d1099 21
@


1.266
log
@Unify node handling functions:
* node_alloc() for mdoc and man_node_alloc() -> roff_node_alloc()
* node_append() for mdoc and man_node_append() -> roff_node_append()
* mdoc_head_alloc() and man_head_alloc() -> roff_head_alloc()
* mdoc_body_alloc() and man_body_alloc() -> roff_body_alloc()
* mdoc_node_unlink() and man_node_unlink() -> roff_node_unlink()
* mdoc_node_free() and man_node_free() -> roff_node_free()
* mdoc_node_delete() and man_node_delete() -> roff_node_delete()
Minus 130 lines of code, no functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.265 2015/04/18 17:28:36 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2009-2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
a34 1
#include "libmdoc.h"
d1069 30
d1122 30
@


1.265
log
@Unify {mdoc,man}_{alloc,reset,free}() into roff_man_{alloc,reset,free}().
Minus 80 lines of code, no functional change.
Written on the train from Koeln to Wolfsburg returning from p2k15.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.264 2015/04/04 13:53:42 schwarze Exp $ */
d33 1
d35 1
d43 2
d381 2
d447 2
d745 2
d799 2
d841 2
d918 2
d924 2
a925 6
	if (man->first != NULL) {
		if (man->macroset == MACROSET_MDOC)
			mdoc_node_delete(man, man->first);
		else
			man_node_delete(man, man->first);
	}
d981 174
d1574 2
d1886 2
d2405 2
d2571 2
d2917 2
d3187 2
@


1.264
log
@Don't allow breaking the output line after hyphens following escape
sequences.  Improves tic(1), sxpm(1), and a few Perl manuals.
Quirk found by naddy@@ in milter-greylist(8).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.263 2015/02/21 14:46:58 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010, 2011, 2012, 2014 Kristaps Dzonsons <kristaps@@bsd.lv>
d31 1
d416 2
d904 65
@


1.263
log
@Escape quotes when expanding macro arguments.
This fixes a bug naddy@@ found in plan9/rc(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.262 2015/02/17 18:09:14 schwarze Exp $ */
d1131 2
@


1.262
log
@Cope with another one of the many kinds of DocBook stupidity:

Instead of just using .br, DocBook sometimes fiddles with the
utterly unportable internal register \n[an-break-flag] that is
only available in the GNU implementation of man(7) and then arms
an input line trap to call the equally unportable internal macro
.an-trap that, in the GNU implementation, inspects that variable;
all the world is GNU, isn't it?

Since naddy@@ reports that quite a few ports manuals suffer from
this insanity, let's just translate it to the intended .br.

Et ceterum censeo DocBookem esse delendam.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.261 2015/02/17 17:16:52 schwarze Exp $ */
d2656 1
a2656 1
	const char	 *arg[9];
d2659 1
d2665 1
d2674 14
a2687 7
	buf->sz = 0;
	n1 = cp = mandoc_strdup(r->current_string);
	while ((cp = strstr(cp, "\\$")) != NULL) {
		i = cp[2] - '1';
		if (0 > i || 8 < i) {
			/* Not an argument invocation. */
			cp += 2;
d2689 58
a2747 6
		*cp = '\0';
		buf->sz = mandoc_asprintf(&n2, "%s%s%s",
		    n1, arg[i], cp + 3) + 1;
		cp = n2 + (cp - n1);
		free(n1);
		n1 = n2;
d2754 1
a2756 2
	if (buf->sz == 0)
		buf->sz = strlen(buf->buf) + 1;
@


1.261
log
@Let .it accept numerical expressions, not just numerical constants.
For .it, ignore scaling units in roff_getnum().
Inside parentheses, skip whitespace after a sign in roff_getnum().
Parse and ignore unary plus in roff_getnum().
As a bonus, get rid of the only call to mandoc_strntoi() in roff.c.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.260 2015/02/06 16:06:25 schwarze Exp $ */
d2340 8
a2347 1
	/* Arm the input line trap. */
d2350 3
a2352 1
	roffit_macro = mandoc_strdup(buf->buf + pos);
@


1.260
log
@replace the last legacy generic message type, "argument count wrong",
by more specific messages, improving diagnostics for .cc .tr .Bl -column
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.259 2015/01/30 00:19:46 schwarze Exp $ */
d399 1
a399 1
				const char *, int *, int *);
d405 1
a405 1
static	int		 roff_getnum(const char *, int *, int *);
d444 3
d1056 2
a1057 1
			    roff_evalnum(r, ln, stnam, &npos, NULL, 0) &&
d1635 1
a1635 1
roff_getnum(const char *v, int *pos, int *res)
d1637 1
a1637 1
	int	 myres, n, p;
d1644 1
a1644 1
	if (n)
d1647 4
d1663 1
a1663 1
		*res *= 65536;
d1666 1
a1666 1
		*res *= 240;
d1669 1
a1669 2
		*res *= 240;
		*res /= 2.54;
d1674 1
a1674 1
		*res *= 40;
d1679 1
a1679 1
		*res *= 24;
d1682 1
a1682 2
		*res *= 10;
		*res /= 3;
d1685 1
d1688 1
a1688 2
		*res *= 6;
		*res /= 25;
d1691 1
d1695 2
d1786 1
a1786 1
	if (roff_evalnum(r, ln, v, pos, &number, 0))
d2009 1
a2009 1
	const char *v, int *pos, int *res)
d2013 1
a2013 1
		return(roff_getnum(v, pos, res));
d2016 1
a2016 1
	if ( ! roff_evalnum(r, ln, v, pos, res, 1))
d2039 1
a2039 1
	int *pos, int *res, int skipwhite)
d2049 1
a2049 1
	if (skipwhite)
d2053 1
a2053 1
	if ( ! roff_evalpar(r, ln, v, pos, res))
d2057 1
a2057 1
		if (skipwhite)
d2064 1
a2064 1
		if (skipwhite)
d2068 1
a2068 1
		if ( ! roff_evalpar(r, ln, v, pos, &operand2))
d2071 1
a2071 1
		if (skipwhite)
d2275 1
a2275 1
	if (roff_evalnum(r, ln, val, NULL, &iv, 0))
a2329 2
	char		*cp;
	size_t		 len;
d2333 2
a2334 4
	cp = buf->buf + pos;
	len = strcspn(cp, " \t");
	cp[len] = '\0';
	if ((iv = mandoc_strntoi(cp, len, 10)) <= 0) {
a2338 1
	cp += len + 1;
d2341 1
d2343 1
a2343 1
	roffit_macro = mandoc_strdup(cp);
@


1.259
log
@correctly handle table layout lines starting with a dot
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.258 2015/01/28 17:32:07 schwarze Exp $ */
d2541 2
a2542 1
		mandoc_msg(MANDOCERR_ARGCOUNT, r->parse, ln, ppos, NULL);
d2557 1
a2557 1
		mandoc_msg(MANDOCERR_ARGCOUNT, r->parse, ln, ppos, NULL);
d2585 2
a2586 2
			mandoc_msg(MANDOCERR_ARGCOUNT, r->parse,
			    ln, (int)(p - buf->buf), NULL);
@


1.258
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.257 2015/01/28 15:03:45 schwarze Exp $ */
d1205 1
a1205 1
		return(tbl_read(r->tbl, ln, buf->buf, pos));
@


1.257
log
@For now, it can't be helped that mandoc tbl(7) ignores high-level macros,
but stop throwing away their arguments.  This fixes information loss in a
handful of Xenocara manuals, at the price of a small amount of formatting
noise creeping through.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.256 2015/01/24 02:41:49 schwarze Exp $ */
d2379 6
a2384 3
	else
		tbl_end(&r->tbl);

@


1.256
log
@Strangely, ignoring the roff(7) .na request was implemented in the man(7)
parser.  Simplify the code by moving it into the roff(7) parser, also
making it work for mdoc(7).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.255 2015/01/23 20:18:40 schwarze Exp $ */
d1240 7
a1246 1
		return(ROFF_IGN);
@


1.255
log
@While ignoring the .ta (set tab stops) and .ti (temp indent) requests
is sometimes harmless, it often causes seriously ugly output,
so flag these requests as unsupported rather than ignoring them.
Discussed with naddy@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.254 2015/01/23 00:42:00 schwarze Exp $ */
d182 1
a182 1
	/* MAN_na; ignored in mdoc(7) */
d583 1
@


1.254
log
@Wonders of roff(7): Integer numbers in numerical expressions can carry
scaling units, and some manuals (e.g. in devel/grcs) actually use that,
so let's support it.  Missing feature reported by naddy@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.253 2015/01/22 22:51:43 schwarze Exp $ */
d611 1
a611 1
	{ "pshape", roff_line_ignore, NULL, NULL, 0, NULL },
d643 1
a643 1
	{ "ta", roff_line_ignore, NULL, NULL, 0, NULL },
d647 1
a647 1
	{ "ti", roff_line_ignore, NULL, NULL, 0, NULL },
@


1.253
log
@Slightly improve \w width measurements:
Count special characters with the same width as ASCII characters
and treat all other escape sequences as if they had a width of 0.
Certainly not perfect, but a bit better.
For example, GNU RCS ci(1) needs this; reported by naddy@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.252 2015/01/21 02:16:52 schwarze Exp $ */
d1644 40
a1683 2
	*pos = p;
	return 1;
@


1.252
log
@pass empty request lines through to tbl(7); sometimes, they end a layout
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.251 2015/01/20 21:16:51 schwarze Exp $ */
d1007 1
d1009 1
a1009 1
		for (naml = 0; maxl == 0 || naml < maxl; naml++, cp++) {
d1020 17
@


1.251
log
@Split the -Werror message level into -Werror (broken manual, probably
using mandoc is better than using groff) and -Wunsupp (manual using
unsupported low-level roff(7) feature, probably using groff is better
than using mandoc).  Once this feature is complete, it is intended
to help porting, making the decision whether to USE_GROFF easier.

As a first step, distinguish four classes of roff(7) requests:
1. Supported (currently 24 requests)
2. Currently ignored because unimportant (120)  ->  no message
3. Ignored for good because insecure (14)  ->  -Werror
4. Currently unsupported (68)  ->  these trigger the new -Wunsupp messages
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.250 2015/01/16 16:53:49 schwarze Exp $ */
d1169 4
a1172 4
	 * text through the macro's filter.  If a scope isn't open and
	 * we're not a macro, just let it through.
	 * Finally, if there's an equation scope open, divert it into it
	 * no matter our state.
d1175 1
a1175 1
	if (r->last && ! ctl) {
d1183 1
a1183 1
	if (r->eqn)
d1185 3
a1187 3
	if ( ! ctl) {
		if (r->tbl)
			return(tbl_read(r->tbl, ln, buf->buf, pos));
a1188 1
	}
@


1.250
log
@Parse and ignore .IX (generate index entry) macros because pod2man(1)
emits them, by default without defining them, relying on the roff(7)
quirk that undefined macros have no effect.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.249 2015/01/14 22:58:16 schwarze Exp $ */
d41 1
d43 3
d47 1
d49 1
a49 1
	ROFF_am1,
d51 17
d70 18
d89 2
d92 5
a96 1
	ROFF_de1,
d98 6
d105 10
d116 26
d144 5
d152 2
d155 28
d184 1
d186 4
d191 2
d194 11
d206 4
d211 12
d224 2
d227 7
d235 10
d246 9
d256 7
a262 2
	ROFF_Dd,
	ROFF_TH,
d264 18
a281 5
	ROFF_TE,
	ROFF_T_,
	ROFF_EQ,
	ROFF_EN,
	ROFF_IX,
d385 1
d412 1
d435 1
d447 1
d449 3
d453 1
d455 1
a455 1
	{ "am1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
d457 16
d475 18
d494 2
d497 5
a501 1
	{ "de1", roff_block, roff_block_text, roff_block_sub, 0, NULL },
d503 6
d510 10
d521 24
d547 5
d555 1
d557 26
d585 4
d590 2
d593 11
d605 4
d610 12
d623 2
d626 7
d634 9
d644 9
d654 7
a660 2
	{ "Dd", roff_Dd, NULL, NULL, 0, NULL },
	{ "TH", roff_TH, NULL, NULL, 0, NULL },
d662 18
a679 5
	{ "TE", roff_TE, NULL, NULL, 0, NULL },
	{ "T&", roff_T_, NULL, NULL, 0, NULL },
	{ "EQ", roff_EQ, NULL, NULL, 0, NULL },
	{ "EN", roff_EN, NULL, NULL, 0, NULL },
	{ "IX", roff_line_ignore, NULL, NULL, 0, NULL },
d1390 2
d1394 2
d1731 18
d1831 7
d2458 8
@


1.249
log
@downgrade ".so with absolute path" from FATAL to ERROR;
allows to get rid of ROFF_ERR
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.248 2015/01/07 12:19:46 schwarze Exp $ */
d78 1
d278 1
@


1.248
log
@Bugfix: When the invocation of a user-defined macro follows a roff
conditional request on the same input line, don't skip the first few
bytes of its content.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.247 2015/01/01 19:28:49 schwarze Exp $ */
d2106 1
a2106 1
	char *name;
d2121 6
a2126 1
		return(ROFF_ERR);
@


1.247
log
@Fix a buffer overrun triggered by a trailing backslash at EOF in
an unclosed conditional body.  If the memory contained the byte
sequence "\}" after the end of the buffer before the next NUL, this
could even write beyond the end of the buffer, specifically '&' to
the location of the '}'.  Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.246 2014/12/28 14:16:26 schwarze Exp $ */
d2172 1
@


1.246
log
@improve previous: do the size check up front to avoid leaking memory
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.245 2014/12/25 17:23:32 schwarze Exp $ */
d3 2
a4 2
 * Copyright (c) 2010, 2011, 2012 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010-2014 Ingo Schwarze <schwarze@@openbsd.org>
d1166 2
a1167 1
		++ep;
d1187 2
a1188 1
		++ep;
@


1.245
log
@Reduce memory and time consumption on certain malformed input files
by limiting the length of expanded input lines during the
(usually recursive) expansion of user defined strings.
Resource hogging found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.244 2014/12/18 17:43:41 schwarze Exp $ */
d654 4
a665 6
		if (buf->sz > SHRT_MAX) {
			mandoc_msg(MANDOCERR_ROFFLOOP, r->parse,
			    ln, (int)(stesc - buf->buf), NULL);
			return(ROFF_IGN);
		}

@


1.244
log
@Don't let the modulo operator divide by zero.
Found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.243 2014/12/16 23:44:41 schwarze Exp $ */
d24 1
d662 6
@


1.243
log
@Ignore mdoc(7) and man(7) macros inside tbl(7) code because they
would abort the table in an unclean way, causing assertion failures
found by jsg@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.242 2014/12/16 03:53:43 schwarze Exp $ */
d1579 1
a1579 1
			if (0 == operand2) {
d1588 6
@


1.242
log
@When a string comparison condition contains no mismatching character
but ends without the final delimiter, the parse point was advanced
one character too far and the invalid pointer returned to the
caller of roff_parseln().  Later use could potentially advance
the pointer even further and maybe even write to it.
Fixing a buffer overrun found by jsg@@ with afl (the most severe so far).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.241 2014/12/16 01:22:59 schwarze Exp $ */
d733 1
d804 13
d818 2
a819 3
	 * Lastly, as we've no scope open, try to look up and execute
	 * the new macro.  If no macro is found, simply return and let
	 * the compilers handle it.
d822 1
a822 1
	if ((t = roff_parse(r, buf->buf, &pos, ln, ppos)) == ROFF_MAX)
d825 2
@


1.241
log
@When a numerical condition errors out after consuming at least one
character of input, treat it as false, do not retry it as a string
comparison condition.  This also fixes a read buffer overrun that
happened when the numerical condition advanced to the end of the
input line before erroring out, found by jsg@@ with afl.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.240 2014/12/15 23:43:26 schwarze Exp $ */
d1239 1
a1239 1
	else
@


1.240
log
@Empty conditions count as false.
When negated, they still count as false.
Found when investigating crashes jsg@@ found with afl.
Not completely fixing the crashes yet.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.239 2014/11/19 01:20:25 schwarze Exp $ */
d1252 1
a1252 1
	int	 wanttrue, number;
d1285 1
d1288 2
d1291 1
a1291 1
		return(roff_evalstrcond(v, pos) == wanttrue);
@


1.239
log
@Support the ".if v" conditional operator (vroff mode, always false)
for groff compatibility because pod2man(1) uses it that way.
Weirdly, groff documents it as "for compatibility with other
troff versions" but neither Heirloom nor Plan 9 have it.
Issue reported by giovanni@@ via sthen@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.238 2014/11/01 06:03:13 schwarze Exp $ */
d1261 2
@


1.238
log
@Use struct buf in libroff, it is very natural there
and reduces the number of arguments of many functions.
While here, sprinkle some KNF.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.237 2014/10/28 17:36:19 schwarze Exp $ */
d1275 2
@


1.237
log
@Make the character table available to libroff so it can check the
validity of character escape names and warn about unknown ones.
This requires mchars_spec2cp() to report unknown names again.
Fortunately, that doesn't require changing the calling code because
according to groff, invalid character escapes should not produce
output anyway, and now that we warn about them, that's fine.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.236 2014/10/25 15:23:56 schwarze Exp $ */
d145 1
a145 2
			 char **bufp, /* input buffer */ \
			 size_t *szp, /* size of input buffer */ \
d187 1
a187 2
static	enum rofferr	 roff_eqndelim(struct roff *,
				char **, size_t *, int);
d211 2
a212 3
static	enum rofferr	 roff_parsetext(char **, size_t *, int, int *);
static	enum rofferr	 roff_res(struct roff *,
				char **, size_t *, int, int);
d499 1
a499 1
roff_res(struct roff *r, char **bufp, size_t *szp, int ln, int pos)
d507 1
a507 1
	char		*nbuf;	/* new buffer to copy bufp to */
d518 1
a518 1
	start = *bufp + pos;
d524 1
a524 1
		if ('\\' != *stesc)
d530 1
a530 1
			if ('\\' != *cp)
d533 1
a533 1
		if (0 == (stesc - cp) % 2) {
d560 1
a560 1
				    r->parse, ln, (int)(stesc - *bufp),
d567 1
a567 1
			    ln, (int)(stesc - *bufp), NULL);
d577 1
a577 1
		if ('\0' == term) {
d604 2
a605 2
		for (naml = 0; 0 == maxl || naml < maxl; naml++, cp++) {
			if ('\0' == *cp) {
d607 1
a607 1
				    ln, (int)(stesc - *bufp), stesc);
d611 1
a611 1
			if (0 == maxl && *cp == term) {
d648 1
a648 1
		if (NULL == res) {
d650 1
a650 1
			    r->parse, ln, (int)(stesc - *bufp),
d658 2
a659 2
		*szp = mandoc_asprintf(&nbuf, "%s%s%s",
		    *bufp, res, cp) + 1;
d664 3
a666 3
		stesc = nbuf + (stesc - *bufp) + strlen(res);
		free(*bufp);
		*bufp = nbuf;
d677 1
a677 1
roff_parsetext(char **bufp, size_t *szp, int pos, int *offs)
d685 1
a685 1
	start = p = *bufp + pos;
d687 1
a687 1
	while ('\0' != *p) {
d691 1
a691 1
		if ('\0' == *p)
d694 1
a694 1
		if ('\\' == *p) {
d698 1
a698 1
			if (ESCAPE_ERROR == esc)
d713 5
a717 5
	if (1 == roffit_lines) {
		isz = mandoc_asprintf(&p, "%s\n.%s", *bufp, roffit_macro);
		free(*bufp);
		*bufp = p;
		*szp = isz + 1;
d722 1
a722 1
	} else if (1 < roffit_lines)
d728 1
a728 2
roff_parseln(struct roff *r, int ln, char **bufp,
		size_t *szp, int pos, int *offs)
d732 5
a736 1
	int		 ppos, ctl;
d743 1
a743 1
		e = roff_eqndelim(r, bufp, szp, pos);
d751 2
a752 2
	e = roff_res(r, bufp, szp, ln, pos);
	if (ROFF_IGN == e)
d754 1
a754 1
	assert(ROFF_CONT == e);
d756 1
a756 2
	ppos = pos;
	ctl = roff_getcontrol(r, *bufp, &pos);
d769 3
a771 3
		e = (*roffs[t].text)(r, t, bufp, szp, ln, pos, pos, offs);
		assert(ROFF_IGN == e || ROFF_CONT == e);
		if (ROFF_CONT != e)
d775 1
a775 1
		return(eqn_read(&r->eqn, ln, *bufp, ppos, offs));
d778 2
a779 2
			return(tbl_read(r->tbl, ln, *bufp, pos));
		return(roff_parsetext(bufp, szp, pos, offs));
d784 1
a784 1
	if ((*bufp)[pos] == '"') {
d788 1
a788 1
	} else if ((*bufp)[pos] == '\0')
d800 1
a800 2
		return((*roffs[t].sub)(r, t, bufp, szp,
		    ln, ppos, pos, offs));
d809 1
a809 1
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos, ln, ppos)))
d813 1
a813 1
	return((*roffs[t].proc)(r, t, bufp, szp, ln, ppos, pos, offs));
d876 1
a876 1
	if (NULL == r->last) {
d901 1
a901 1
	if ((*bufp)[pos])
d903 1
a903 1
		    ".. %s", *bufp + pos);
d965 1
a965 1
	if (ROFF_de1 == tok)
d967 1
a967 1
	else if (ROFF_am1 == tok)
d972 2
a973 2
	cp = *bufp + pos;
	if (ROFF_ig == tok) {
d984 2
a985 2
	if (namesz && (ROFF_dei == tok || ROFF_ami == tok)) {
		if (NULL == (name = roff_getstrn(r, iname, namesz))) {
d987 1
a987 1
			    r->parse, ln, (int)(iname - *bufp),
d995 1
a995 1
	if (0 == namesz && ROFF_ig != tok) {
d1009 1
a1009 1
	if (ROFF_de == tok || ROFF_dei == tok)
d1012 1
a1012 1
	if ('\0' == *cp)
d1022 2
a1023 2
	if (namesz && (ROFF_dei == tok || ROFF_ami == tok)) {
		if (NULL == (name = roff_getstrn(r, iname, namesz))) {
d1025 1
a1025 1
			    r->parse, ln, (int)(iname - *bufp),
d1036 1
a1036 1
	if ('\0' != *cp)
d1060 1
a1060 1
			if ((*bufp)[i] != r->last->end[j])
d1063 4
a1066 4
		if ('\0' == r->last->end[j] &&
		    ('\0' == (*bufp)[i] ||
		     ' '  == (*bufp)[i] ||
		     '\t' == (*bufp)[i])) {
d1070 1
a1070 1
			while (' ' == (*bufp)[i] || '\t' == (*bufp)[i])
d1074 2
a1075 1
			if (ROFF_MAX != roff_parse(r, *bufp, &pos, ln, ppos))
d1086 1
a1086 1
	t = roff_parse(r, *bufp, &pos, ln, ppos);
d1088 3
a1090 3
	if (ROFF_cblock != t) {
		if (ROFF_ig != tok)
			roff_setstr(r, r->last->name, *bufp + ppos, 2);
d1095 1
a1095 1
	return((*roffs[t].proc)(r, t, bufp, szp, ln, ppos, pos, offs));
d1102 2
a1103 2
	if (ROFF_ig != tok)
		roff_setstr(r, r->last->name, *bufp + pos, 2);
d1117 1
a1117 1
	t = roff_parse(r, *bufp, &pos, ln, ppos);
d1124 2
a1125 2
	if ((ROFF_MAX != t) &&
	    (rr || ROFFMAC_STRUCT & roffs[t].flags)) {
d1127 1
a1127 2
		return((*roffs[t].proc)(r, t, bufp, szp,
		    ln, ppos, pos, offs));
d1135 2
a1136 2
	ep = *bufp + pos;
	if ('\\' == ep[0] && '}' == ep[1])
d1141 2
a1142 2
	while (NULL != (ep = strchr(ep, '\\'))) {
		if ('}' == *(++ep)) {
d1144 1
a1144 1
			roff_ccond(r, ln, ep - *bufp - 1);
d1160 3
a1162 3
	ep = *bufp + pos;
	while (NULL != (ep = strchr(ep, '\\'))) {
		if ('}' == *(++ep)) {
d1164 1
a1164 1
			roff_ccond(r, ln, ep - *bufp - 1);
d1308 1
a1308 1
	r->last->rule = ROFF_el == tok ?
d1310 1
a1310 1
	    roff_evalcond(r, ln, *bufp, &pos);
d1317 1
a1317 1
	if (ROFF_ie == tok) {
d1337 1
a1337 1
	if ('\0' == (*bufp)[pos]) {
d1342 1
a1342 1
	while (' ' == (*bufp)[pos])
d1347 1
a1347 1
	if ('\\' == (*bufp)[pos] && '{' == (*bufp)[pos + 1]) {
d1359 1
a1359 1
	if ('\0' == (*bufp)[pos])
d1383 2
a1384 2
	name = string = *bufp + pos;
	if ('\0' == *name)
d1388 1
a1388 1
	if ('\\' == name[namesz])
d1392 1
a1392 1
	if ('"' == *string)
d1724 2
a1725 2
	key = val = *bufp + pos;
	if ('\0' == *key)
d1729 1
a1729 1
	if ('\\' == key[keysz])
d1734 1
a1734 1
	if ('+' == sign || '-' == sign)
d1750 2
a1751 2
	name = cp = *bufp + pos;
	if ('\0' == *name)
d1759 1
a1759 1
		if (NULL == reg || !strcmp(name, reg->key.p))
d1763 1
a1763 1
	if (NULL != reg) {
d1778 2
a1779 2
	cp = *bufp + pos;
	while ('\0' != *cp) {
d1781 1
a1781 1
		namesz = roff_getname(r, &cp, ln, (int)(cp - *bufp));
d1783 1
a1783 1
		if ('\\' == name[namesz])
d1797 1
a1797 1
	cp = *bufp + pos;
d1802 1
a1802 1
		    ln, ppos, *bufp + 1);
d1873 1
a1873 1
roff_eqndelim(struct roff *r, char **bufp, size_t *szp, int pos)
d1885 1
a1885 1
	cp1 = *bufp + pos;
d1896 1
a1896 1
	if (**bufp != '\0') {
d1924 1
a1924 1
	*szp = mandoc_asprintf(&cp1, "%s%s%s%s%s%s%s", *bufp,
d1926 2
a1927 2
	free(*bufp);
	*bufp = cp1;
d1940 1
a1940 1
	assert(NULL == r->eqn);
d1953 1
a1953 1
	if ((*bufp)[pos])
d1955 1
a1955 1
		    ".EQ %s", *bufp + pos);
d1995 1
a1995 1
	p = *bufp + pos;
d1997 1
a1997 1
	if ('\0' == *p || '.' == (r->control = *p++))
d2000 1
a2000 1
	if ('\0' != *p)
d2013 1
a2013 1
	p = *bufp + pos;
d2015 1
a2015 1
	if ('\0' == *p) {
d2020 1
a2020 1
	while ('\0' != *p) {
d2024 1
a2024 1
		if ('\\' == *first) {
d2026 1
a2026 1
			if (ESCAPE_ERROR == esc) {
d2028 1
a2028 1
				    ln, (int)(p - *bufp), first);
d2035 1
a2035 1
		if ('\\' == *second) {
d2037 1
a2037 1
			if (ESCAPE_ERROR == esc) {
d2039 1
a2039 1
				    ln, (int)(p - *bufp), second);
d2043 1
a2043 1
		} else if ('\0' == *second) {
d2045 1
a2045 1
			    ln, (int)(p - *bufp), NULL);
d2056 1
a2056 1
		if (NULL == r->xtab)
d2073 1
a2073 1
	name = *bufp + pos;
d2083 1
a2083 1
	if ('/' == *name || strstr(name, "../") || strstr(name, "/..")) {
d2104 1
a2104 1
	cp = *bufp + pos;
d2106 1
a2106 1
		arg[i] = '\0' == *cp ? "" :
d2112 1
a2112 1
	*szp = 0;
d2114 1
a2114 1
	while (NULL != (cp = strstr(cp, "\\$"))) {
d2122 1
a2122 1
		*szp = mandoc_asprintf(&n2, "%s%s%s",
d2133 4
a2136 4
	free(*bufp);
	*bufp = n1;
	if (0 == *szp)
		*szp = strlen(*bufp) + 1;
d2138 1
a2138 1
	return(*szp > 1 && '\n' == (*bufp)[(int)*szp - 2] ?
@


1.236
log
@With the current architecture, we can't support inline equations
inside tables, sorry.  So don't even try to parse tbl(7) blocks for
eqn(7) delimiters.
Broken table layout found in glPixelMap(3) while investigating
a bug report by Theo Buehler <theo at math dot ethz dot ch>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.235 2014/10/25 14:35:37 schwarze Exp $ */
d110 1
d480 1
a480 1
roff_alloc(struct mparse *parse, int options)
d486 1
d513 2
d558 4
a561 1
			if (ESCAPE_ERROR == mandoc_escape(&cp, NULL, NULL))
@


1.235
log
@Report arguments to .EQ as an error, and simplify the code:
* drop trivial wrapper function roff_openeqn()
* drop unused first arg of function eqn_alloc()
* drop usused member "name" of struct eqn_node
While here, sync to OpenBSD by killing some trailing blanks.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.234 2014/10/20 19:04:45 kristaps Exp $ */
d733 2
a734 1
	if (r->last_eqn != NULL && r->last_eqn->delim &&
@


1.234
log
@Protect the roff parser from dividing by zero.  ok schwarze@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.233 2014/10/20 15:04:56 schwarze Exp $ */
a209 2
static	void		 roff_openeqn(struct roff *, const char *,
				int, int, const char *);
d1470 1
a1470 1
roff_evalpar(struct roff *r, int ln, 
d1500 1
a1500 1
roff_evalnum(struct roff *r, int ln, const char *v, 
d1552 1
a1552 1
				mandoc_msg(MANDOCERR_DIVZERO, 
d1929 2
a1930 3
static void
roff_openeqn(struct roff *r, const char *name, int line,
		int offs, const char *buf)
a1932 1
	int		 poff;
d1935 1
a1935 1
	e = eqn_alloc(name, offs, line, r->parse);
d1947 3
a1949 9
	if (buf) {
		poff = 0;
		eqn_read(&r->eqn, line, buf, offs, &poff);
	}
}

static enum rofferr
roff_EQ(ROFF_ARGS)
{
a1950 1
	roff_openeqn(r, *bufp + pos, ln, ppos, NULL);
@


1.233
log
@correctly parse spacing around in-line equations
at the beginning and at the end of input lines;
issue reported by kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.232 2014/10/20 02:33:06 schwarze Exp $ */
d189 6
a194 3
static	int		 roff_evalcond(const char *, int *);
static	int		 roff_evalnum(const char *, int *, int *, int);
static	int		 roff_evalpar(const char *, int *, int *);
d628 1
a628 1
			    roff_evalnum(stnam, &npos, NULL, 0) &&
d1246 1
a1246 1
roff_evalcond(const char *v, int *pos)
d1277 1
a1277 1
	if (roff_evalnum(v, pos, &number, 0))
d1306 1
a1306 1
	    roff_evalcond(*bufp, &pos);
d1472 2
a1473 1
roff_evalpar(const char *v, int *pos, int *res)
d1480 1
a1480 1
	if ( ! roff_evalnum(v, pos, res, 1))
d1502 2
a1503 1
roff_evalnum(const char *v, int *pos, int *res, int skipwhite)
d1517 1
a1517 1
	if ( ! roff_evalpar(v, pos, res))
d1532 1
a1532 1
		if ( ! roff_evalpar(v, pos, &operand2))
d1553 6
d1733 1
a1733 1
	if (roff_evalnum(val, NULL, &iv, 0))
@


1.232
log
@correct spacing before inline equations
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.231 2014/10/16 01:28:38 schwarze Exp $ */
d1860 2
a1861 1
	char	*cp1, *cp2;
d1876 15
a1890 1
	/* Replace the delimiter with an equation macro. */
d1892 19
a1910 3
	*cp2++ = '\0';
	*szp = mandoc_asprintf(&cp1, "%s%s%s", *bufp,
	    r->eqn == NULL ? "\\&\n.EQ\n" : "\n.EN\n\\&", cp2) + 1;
@


1.231
log
@oops, don't escape the first token of inline equations
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.230 2014/10/16 01:11:20 schwarze Exp $ */
a1874 9
	/* Found a delimiter; get rid of surrounding blanks. */

	cp1 = cp2++;
	while (cp2[0] == ' ')
		cp2++;
	while (cp1[-1] == ' ')
		cp1--;
	*cp1 = '\0';

d1877 3
a1879 2
	*szp = mandoc_asprintf(&cp1, "%s\n.E%s%s", *bufp,
	    r->eqn == NULL ? "Q\n" : "N\n\\&", cp2) + 1;
@


1.230
log
@Implement in-line equations, much needed by Xenocara manuals.
Put the steering into the roff parser rather than into the mdoc
parser such that it works for all macro languages and on both text
and macro lines.
Line breaks and blank characters generated before and after in-line
equations are not perfect yet, but let's do one thing at a time.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.229 2014/09/07 00:21:53 schwarze Exp $ */
d1886 2
a1887 2
	*szp = mandoc_asprintf(&cp1, "%s\n.E%c\n\\&%s", *bufp,
	    r->eqn == NULL ? 'Q' : 'N', cp2) + 1;
@


1.229
log
@Parse and ignore the .pl (page length) request;
Daniel Levai reports that Slackware Linux uses this.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.228 2014/09/06 23:24:32 schwarze Exp $ */
d123 1
d187 2
d730 11
a740 4
	/*
	 * Run the reserved-word filter only if we have some reserved
	 * words to fill in.
	 */
d1854 5
a1858 3
#if 0
static int
roff_closeeqn(struct roff *r)
d1860 1
d1862 33
a1894 1
	return(r->eqn && ROFF_EQN == eqn_end(&r->eqn) ? 1 : 0);
a1895 1
#endif
d1907 1
a1907 1
	if (r->last_eqn)
d1909 4
a1912 1
	else
@


1.228
log
@Simplify by handling empty request lines at the one logical place
in the roff parser instead of in three other places in other parsers.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.227 2014/09/06 22:39:36 schwarze Exp $ */
d63 1
d260 1
@


1.227
log
@Move main format autodetection from the parser dispatcher to the
roff parser where .Dd and .TH are already detected, anyway.  This
improves robustness because it correctly handles whitespace or an
alternate control character before Dd.  In the parser dispatcher,
provide a fallback looking ahead in the input buffer instead of
always assuming man(7).  This corrects autodetection when Dd is
preceded by other macros or macro-like handled requests like .ll.

Triggered by reports from Daniel Levai about issues on Slackware Linux.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.226 2014/08/19 16:52:32 schwarze Exp $ */
d762 9
@


1.226
log
@libroff depends on libmandoc and so libmandoc should be included first;
merge from OpenBSD, patch by daniel@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.225 2014/08/10 23:54:41 schwarze Exp $ */
d125 1
d460 1
d480 1
d1782 1
a1782 1
	if (0 == ((MPARSE_MDOC | MPARSE_QUICK) & r->options))
d1786 3
d1797 1
a1797 1
	if (0 == (MPARSE_QUICK & r->options))
d1801 3
d2319 7
@


1.225
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.224 2014/08/01 17:27:44 schwarze Exp $ */
d30 1
a31 1
#include "libmandoc.h"
@


1.224
log
@mention requests and macros in more messages
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.223 2014/08/01 15:08:46 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
d19 2
a20 1
#endif
@


1.223
log
@Dynamically allocate the stack of roff(7) .ie condition values
and thus get rid of the last useless fatal error.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.222 2014/07/30 12:58:21 schwarze Exp $ */
d1978 1
a1978 1
	mandoc_vmsg(MANDOCERR_SO, r->parse, ln, ppos, ".so %s", name);
d2070 2
a2071 1
		mandoc_msg(MANDOCERR_NAMESC, r->parse, ln, pos, NULL);
@


1.222
log
@better name and wording for the last two non-generic errors
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.221 2014/07/07 21:36:20 schwarze Exp $ */
a108 1
	int		 options; /* parse options */
d110 1
a110 3
	int		 rstack[RSTACK_MAX]; /* stack of !`ie' rules */
	char		 control; /* control character */
	int		 rstackpos; /* position in rstack */
d122 4
a423 1

a429 1

d435 8
a444 1

a446 4
	roff_freereg(r->regtab);

	r->regtab = NULL;

a449 1

d1287 4
a1290 4
		if (r->rstackpos == RSTACK_MAX - 1) {
			mandoc_msg(MANDOCERR_MEM,
			    r->parse, ln, ppos, NULL);
			return(ROFF_ERR);
@


1.221
log
@Clean up ERROR messages related to document structure and macros:
Hierarchical naming and mention macro names in messages.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.220 2014/07/07 11:35:06 schwarze Exp $ */
d1761 1
a1761 1
		mandoc_msg(MANDOCERR_NUMERIC, r->parse,
@


1.220
log
@implement .dei and .ami
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.219 2014/07/06 19:09:00 schwarze Exp $ */
d789 3
a791 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse,
		    r->last->line, r->last->col, NULL);
d794 2
a795 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse,
		    r->eqn->eqn.ln, r->eqn->eqn.pos, NULL);
d800 2
a801 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse,
		    r->tbl->line, r->tbl->pos, NULL);
d845 2
a846 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d864 2
a865 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d895 2
a896 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d908 2
a909 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d914 2
a915 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1802 2
a1803 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1815 2
a1816 1
		mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1867 1
a1867 1
	mandoc_msg(MANDOCERR_NOSCOPE, r->parse, ln, ppos, NULL);
d1877 2
a1878 1
		mandoc_msg(MANDOCERR_SCOPEBROKEN, r->parse, ln, ppos, NULL);
@


1.219
log
@Clean up messages related to plain text and to escape sequences.
* Mention invalid escape sequences and string names, and fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.218 2014/07/06 18:46:55 schwarze Exp $ */
d850 1
a853 2
	case ROFF_am1:
		/* FALLTHROUGH */
d921 2
a922 1
	char		*name, *cp;
d925 6
a930 2
	name = cp = *bufp + pos;
	namesz = 0;
d932 1
a932 6
	if (ROFF_ig != tok) {
		if ('\0' == *cp) {
			mandoc_msg(MANDOCERR_REQ_EMPTY, r->parse,
			    ln, ppos, roffs[tok].name);
			return(ROFF_IGN);
		}
d934 9
a942 4
		/*
		 * Re-write `de1', since we don't really care about
		 * groff's strange compatibility mode, into `de'.
		 */
d944 1
a944 5
		if (ROFF_de1 == tok)
			tok = ROFF_de;
		else if (ROFF_de != tok)
			mandoc_msg(MANDOCERR_REQUEST, r->parse, ln, ppos,
			    roffs[tok].name);
d946 8
a953 2
		namesz = roff_getname(r, &cp, ln, ppos);
		name[namesz] = '\0';
d955 7
a961 1
		name = NULL;
d971 1
a971 1
	if (namesz && ROFF_de == tok)
d977 1
a977 1
	/* If present, process the custom end-of-line marker. */
d979 1
a979 1
	name = cp;
d981 14
a1048 4
	/*
	 * Macros other than block-end are only significant
	 * in `de' blocks; elsewhere, simply throw them away.
	 */
d1050 1
a1050 1
		if (ROFF_de == tok)
d1063 1
a1063 1
	if (ROFF_de == tok)
@


1.218
log
@Fix expansion of escape sequences with incomplete arguments.
* For \* and \n, discard the incomplete arg, expand to empty string.
* For \B, discard the incomplete arg, expand to the digit 0.
* For \w, use the incomplete arg (behaviour unchanged).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.217 2014/07/04 16:12:08 schwarze Exp $ */
d545 3
a547 2
				mandoc_msg(MANDOCERR_BADESCAPE, r->parse,
				    ln, (int)(stesc - *bufp), NULL);
d592 2
a593 2
				mandoc_msg(MANDOCERR_BADESCAPE, r->parse,
				    ln, (int)(stesc - *bufp), NULL);
d635 3
a637 2
			mandoc_msg(MANDOCERR_BADESCAPE, r->parse,
			    ln, (int)(stesc - *bufp), NULL);
d1899 2
a1900 3
				mandoc_msg(MANDOCERR_BADESCAPE,
				    r->parse, ln,
				    (int)(p - *bufp), NULL);
d1910 2
a1911 3
				mandoc_msg(MANDOCERR_BADESCAPE,
				    r->parse, ln,
				    (int)(p - *bufp), NULL);
@


1.217
log
@Clean up messages regarding excess arguments:
* Downgrade ".Bf -emphasis Em" from FATAL to WARNING.
* Mention the macros, the arguments, and the fallbacks.
* Hierarchical naming.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.216 2014/07/03 21:23:54 schwarze Exp $ */
d503 1
a503 1
	int		 irc;	/* return code from roff_evalnum() */
d588 1
d593 1
d609 2
a610 1
			res = roff_getstrn(r, stnam, naml);
d614 3
a616 3
			irc = roff_evalnum(stnam, &npos, NULL, 0);
			ubuf[0] = irc && stnam + npos + 1 == cp
			    ? '1' : '0';
d620 5
a624 2
			(void)snprintf(ubuf, sizeof(ubuf), "%d",
			    roff_getregn(r, stnam, naml));
d627 1
@


1.216
log
@MANDOCERR_NOARGS reported three completely unrelated classes of problems.
Split the roff(7) parts out of it and report the request names for these cases.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.215 2014/07/01 00:32:29 schwarze Exp $ */
d859 2
a860 1
		mandoc_msg(MANDOCERR_ARGSLOST, r->parse, ln, pos, NULL);
d964 2
a965 1
		mandoc_msg(MANDOCERR_ARGSLOST, r->parse, ln, pos, NULL);
@


1.215
log
@The previous commit to this file broke the control flow keywords \{ and \}
when they immediately follow a request or macro name, without intervening
whitespace.  Minimal fix.

The lesson learnt here is that, despite their appearance, \{ and \} are
not escape sequences, so never skip them when parsing for names.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.214 2014/06/29 23:26:00 schwarze Exp $ */
d920 2
a921 1
			mandoc_msg(MANDOCERR_NOARGS, r->parse, ln, ppos, NULL);
d1289 2
a1290 1
		mandoc_msg(MANDOCERR_NOARGS, r->parse, ln, ppos, NULL);
@


1.214
log
@Use the freshly improved roff_getname() function
for the main roff request parsing routine, roff_parse().

In request or macro invocations, escape sequences now terminate the
request or macro name; what follows is treated as arguments.  Besides,
the names of user-defined macros can now contain backslashes (eek!).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.213 2014/06/29 22:38:47 schwarze Exp $ */
d2021 3
a2026 1
		namesz = cp - name - 1;
@


1.213
log
@Use the freshly improved roff_getname() function
for the .de parsing routine, roff_block(),
to correctly handle names terminated by escape sequences.
Besides, this saves us 20 lines of code.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.212 2014/06/29 22:14:10 schwarze Exp $ */
d203 2
a204 1
static	enum rofft	 roff_parse(struct roff *, const char *, int *);
d768 1
a768 1
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos)))
d801 1
a801 1
roff_parse(struct roff *r, const char *buf, int *pos)
d803 1
d808 3
a810 2
	if ('\0' == buf[*pos] || '"' == buf[*pos] ||
	    '\t' == buf[*pos] || ' ' == buf[*pos])
d813 2
a814 4
	/* We stop the macro parse at an escape, tab, space, or nil. */

	mac = buf + *pos;
	maclen = strcspn(mac, " \\\t\0");
d819 2
a820 4
	*pos += (int)maclen;

	while (buf[*pos] && ' ' == buf[*pos])
		(*pos)++;
d998 1
a998 1
			if (ROFF_MAX != roff_parse(r, *bufp, &pos))
d1009 1
a1009 1
	t = roff_parse(r, *bufp, &pos);
d1044 1
a1044 1
	t = roff_parse(r, *bufp, &pos);
@


1.212
log
@Major roff_getname() cleanup.
* Return the name even if it is terminated by an escape sequence, not a blank.
* Skip the full escape sequence using mandoc_escape(), not just the first byte.
* Make it non-destructive, return the length instead of writing a '\0'.
* Let .ds and .as cope with the above changes to the internal interface.
* Fix .rm and .rr to accept an escape sequence as the end of a name.
* Fix .nr and .rr to not set/delete a register with an empty name.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.211 2014/06/29 21:20:31 schwarze Exp $ */
d913 2
a914 3
	int		sv;
	size_t		sz;
	char		*name;
d916 2
a917 1
	name = NULL;
d920 1
a920 1
		if ('\0' == (*bufp)[pos]) {
d932 1
a932 3
		if (ROFF_de == tok)
			name = *bufp + pos;
		else
d936 4
a939 6
		while ((*bufp)[pos] && ! isspace((unsigned char)(*bufp)[pos]))
			pos++;

		while (isspace((unsigned char)(*bufp)[pos]))
			(*bufp)[pos++] = '\0';
	}
d949 2
a950 2
	if (ROFF_de == tok)
		roff_setstr(r, name, "", 0);
d952 1
a952 1
	if ('\0' == (*bufp)[pos])
d957 4
a960 3
	sv = pos;
	while ((*bufp)[pos] && ! isspace((unsigned char)(*bufp)[pos]))
		pos++;
d962 1
a962 18
	/*
	 * Note: groff does NOT like escape characters in the input.
	 * Instead of detecting this, we're just going to let it fly and
	 * to hell with it.
	 */

	assert(pos > sv);
	sz = (size_t)(pos - sv);

	if (1 == sz && '.' == (*bufp)[sv])
		return(ROFF_IGN);

	r->last->end = mandoc_malloc(sz + 1);

	memcpy(r->last->end, *bufp + sv, sz);
	r->last->end[(int)sz] = '\0';

	if ((*bufp)[pos])
@


1.211
log
@Bugfix in roff_setstrn():
Do not call strcmp() on an array of char that might not be NUL-terminated.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.210 2014/06/25 00:20:19 schwarze Exp $ */
d190 1
a190 1
static	char		*roff_getname(struct roff *, char **, int, int);
d1321 3
a1323 1
	char		*name, *string;
d1326 3
a1328 7
	 * A symbol is named by the first word following the macro
	 * invocation up to a space.  Its value is anything after the
	 * name's trailing whitespace and optional double-quote.  Thus,
	 *
	 *  [.ds foo "bar  "     ]
	 *
	 * will have `bar  "     ' as its value.
d1331 1
a1331 2
	string = *bufp + pos;
	name = roff_getname(r, &string, ln, pos);
d1335 5
a1339 1
	/* Read past initial double-quote. */
d1344 2
a1345 1
	roff_setstr(r, name, string, ROFF_as == tok);
d1659 2
a1660 2
	const char	*key;
	char		*val;
d1664 8
a1671 2
	val = *bufp + pos;
	key = roff_getname(r, &val, ln, pos);
d1687 2
a1688 2
	const char	*name;
	char		*cp;
d1690 5
a1694 2
	cp = *bufp + pos;
	name = roff_getname(r, &cp, ln, pos);
d1716 1
d1720 5
a1724 3
		name = roff_getname(r, &cp, ln, (int)(cp - *bufp));
		if ('\0' != *name)
			roff_setstr(r, name, NULL, 0);
d2024 1
a2024 1
static char *
d2028 1
d2032 1
a2032 1
		return(name);
d2034 6
a2039 2
	/* Read until end of name. */
	for (cp = name; '\0' != *cp && ' ' != *cp; cp++) {
d2045 1
d2047 2
a2048 2
		*cp = '\0';
		name = cp;
a2050 4
	/* Nil-terminate name. */
	if ('\0' != *cp)
		*(cp++) = '\0';

d2056 1
a2056 1
	return(name);
@


1.210
log
@Improve messages related to the roff(7) .so request.

In all these messages, show the filename argument that was passed
to the .so request.

In case of failure, show an additional message reporting the file
and the line number where the failing request was found.
The existing message reporting the reason for the failure -
for example, "Permission denied" - is left in place, unchanged.

Inspired by a question asked by Nick@@ after he saw the
confusing old messages that used to be emitted in this area.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.209 2014/04/23 16:08:33 schwarze Exp $ */
d2071 2
a2072 1
	while (n && strcmp(name, n->key.p))
@


1.209
log
@Audit strlcpy(3)/strlcat(3) usage.

* Repair three instances of silent truncation, use asprintf(3).
* Change two instances of strlen(3)+malloc(3)+strlcpy(3)+strlcat(3)+...
to use asprintf(3) instead to make them less error prone.
* Cast the return value of four instances where the destination
buffer is known to be large enough to (void).
* Completely remove three useless instances of strlcpy(3)/strlcat(3).
* Mark two places in -Thtml with XXX that can cause information loss
and crashes but are not easy to fix, requiring design changes of
some internal interfaces.
* The file mandocdb.c remains to be audited.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.208 2014/04/20 19:40:13 schwarze Exp $ */
d1941 2
a1942 1
	mandoc_msg(MANDOCERR_SO, r->parse, ln, ppos, NULL);
a1950 1
	name = *bufp + pos;
d1952 2
a1953 1
		mandoc_msg(MANDOCERR_SOPATH, r->parse, ln, pos, NULL);
@


1.208
log
@make sure static buffers for snprintf(3) are large enough
and cast snprintf return value to (void) where they are
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.207 2014/04/20 16:46:05 schwarze Exp $ */
d493 1
a493 1
	const char	*stesc;	/* start of an escape sequence ('\\') */
a499 1
	size_t		 ressz;	/* size of the replacement string */
d522 1
a522 1
			stesc = cp;
a629 1
		ressz = strlen(res);
d633 3
a635 6
		*szp += ressz + 1;
		nbuf = mandoc_malloc(*szp);

		strlcpy(nbuf, *bufp, (size_t)(stesc - *bufp + 1));
		strlcat(nbuf, res, *szp);
		strlcat(nbuf, cp, *szp);
d640 1
a640 1
		stesc = nbuf + (stesc - *bufp) + ressz;
d1988 3
a1990 8

		*szp = strlen(n1) - 3 + strlen(arg[i]) + 1;
		n2 = mandoc_malloc(*szp);

		strlcpy(n2, n1, (size_t)(cp - n1 + 1));
		strlcat(n2, arg[i], *szp);
		strlcat(n2, cp + 3, *szp);

@


1.207
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.206 2014/04/08 01:37:27 schwarze Exp $ */
d491 1
a491 1
	char		 ubuf[12]; /* buffer to print the number */
d617 1
a617 1
			snprintf(ubuf, sizeof(ubuf), "%d",
d621 1
a621 1
			snprintf(ubuf, sizeof(ubuf), "%d",
@


1.206
log
@Fully implement the \B (validate numerical expression) and
partially implement the \w (measure text width) escape sequence
in a way that makes them usable in numerical expressions and in
conditional requests, similar to how \n (interpolate number register)
and \* (expand user-defined string) are implemented.

This lets mandoc(1) handle the baroque low-level roff code
found at the beginning of the ggrep(1) manual.
Thanks to pascal@@ for the report.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.205 2014/04/07 21:00:08 schwarze Exp $ */
d140 1
a140 1
		 	 char **bufp, /* input buffer */ \
d196 1
a196 1
static	const char	*roff_getstrn(const struct roff *, 
d205 1
a205 1
static	enum rofferr	 roff_res(struct roff *, 
d211 1
a211 1
static	void		 roff_setstrn(struct roffkv **, const char *, 
d318 1
a370 1

d381 1
a381 1
	p = r->last; 
a388 1

a410 1

a459 1

a467 1

d477 1
a477 1
	
d532 1
a532 1
		case ('*'):
d535 1
a535 1
		case ('B'):
d537 1
a537 1
		case ('w'):
d540 1
a540 1
		case ('n'):
d564 1
a564 1
			case ('\0'):
d567 1
a567 1
			case ('('):
d571 1
a571 1
			case ('['):
d590 2
a591 4
				mandoc_msg
					(MANDOCERR_BADESCAPE, 
					 r->parse, ln, 
					 (int)(stesc - *bufp), NULL);
d606 1
a606 1
		case ('*'):
d609 1
a609 1
		case ('B'):
d616 1
a616 1
		case ('n'):
d620 1
a620 1
		case ('w'):
d627 2
a628 3
			mandoc_msg
				(MANDOCERR_BADESCAPE, r->parse, 
				 ln, (int)(stesc - *bufp), NULL);
d709 1
a709 1
roff_parseln(struct roff *r, int ln, char **bufp, 
d740 1
a740 2
		e = (*roffs[t].text)
			(r, t, bufp, szp, ln, pos, pos, offs);
d762 2
a763 3
		return((*roffs[t].sub)
				(r, t, bufp, szp, 
				 ln, ppos, pos, offs));
d776 1
a776 3
	return((*roffs[t].proc)
			(r, t, bufp, szp, 
			 ln, ppos, pos, offs));
a778 1

d785 1
a785 1
				r->last->line, r->last->col, NULL);
d788 2
a789 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse, 
				r->eqn->eqn.ln, r->eqn->eqn.pos, NULL);
d794 2
a795 2
		mandoc_msg(MANDOCERR_SCOPEEXIT, r->parse, 
				r->tbl->line, r->tbl->pos, NULL);
d811 2
a812 2
	if ('\0' == buf[*pos] || '"' == buf[*pos] || 
			'\t' == buf[*pos] || ' ' == buf[*pos])
a830 1
/* ARGSUSED */
d846 1
a846 1
	case (ROFF_am):
d848 1
a848 1
	case (ROFF_ami):
d850 1
a850 1
	case (ROFF_am1):
d852 1
a852 1
	case (ROFF_de):
d855 1
a855 1
	case (ROFF_dei):
d857 1
a857 1
	case (ROFF_ig):
a872 1

a883 1

d894 1
a894 1
	case (ROFF_el):
d896 1
a896 1
	case (ROFF_ie):
d898 1
a898 1
	case (ROFF_if):
a914 2

/* ARGSUSED */
a992 2

/* ARGSUSED */
d1013 4
a1016 4
		if ('\0' == r->last->end[j] && 
				('\0' == (*bufp)[i] ||
				 ' ' == (*bufp)[i] ||
				 '\t' == (*bufp)[i])) {
d1048 1
a1048 2
	return((*roffs[t].proc)(r, t, bufp, szp, 
				ln, ppos, pos, offs));
a1050 2

/* ARGSUSED */
a1060 2

/* ARGSUSED */
d1081 1
a1081 1
					ln, ppos, pos, offs));
a1104 1
/* ARGSUSED */
d1215 1
a1215 1
	case ('n'):
d1217 1
a1217 1
	case ('o'):
d1220 1
a1220 1
	case ('c'):
d1222 1
a1222 1
	case ('d'):
d1224 1
a1224 1
	case ('e'):
d1226 1
a1226 1
	case ('r'):
d1228 1
a1228 1
	case ('t'):
a1240 1
/* ARGSUSED */
a1247 1
/* ARGSUSED */
d1254 1
a1254 1
	/* 
d1257 1
a1257 1
	 * defaults to DENY.  
d1263 2
a1264 2
		(r->rstackpos < 0 ? 0 : r->rstack[r->rstackpos--]) :
		roff_evalcond(*bufp, &pos);
d1273 2
a1274 2
			mandoc_msg(MANDOCERR_MEM, 
				r->parse, ln, ppos, NULL);
d1305 1
a1305 1
	} 
a1322 2

/* ARGSUSED */
d1364 1
a1364 1
	case ('+'):
d1366 1
a1366 1
	case ('-'):
d1368 1
a1368 1
	case ('*'):
d1370 1
a1370 1
	case ('/'):
d1372 1
a1372 1
	case ('%'):
d1374 1
a1374 1
	case ('&'):
d1376 1
a1376 1
	case (':'):
d1380 1
a1380 1
		case ('='):
d1384 1
a1384 1
		case ('>'):
d1388 1
a1388 1
		case ('?'):
d1398 1
a1398 1
		case ('='):
d1402 1
a1402 1
		case ('?'):
d1496 1
a1496 1
		case ('+'):
d1499 1
a1499 1
		case ('-'):
d1502 1
a1502 1
		case ('*'):
d1505 1
a1505 1
		case ('/'):
d1508 1
a1508 1
		case ('%'):
d1511 1
a1511 1
		case ('<'):
d1514 1
a1514 1
		case ('>'):
d1517 1
a1517 1
		case ('l'):
d1520 1
a1520 1
		case ('g'):
d1523 1
a1523 1
		case ('='):
d1526 1
a1526 1
		case ('!'):
d1529 1
a1529 1
		case ('&'):
d1532 1
a1532 1
		case (':'):
d1535 1
a1535 1
		case ('i'):
d1539 1
a1539 1
		case ('a'):
d1590 1
a1590 1
	case ('A'):  /* ASCII approximation mode is always off. */
d1592 1
a1592 1
	case ('g'):  /* Groff compatibility mode is always on. */
d1594 1
a1594 1
	case ('H'):  /* Fixed horizontal resolution. */
d1596 1
a1596 1
	case ('j'):  /* Always adjust left margin only. */
d1598 1
a1598 1
	case ('T'):  /* Some output device is always defined. */
d1600 1
a1600 1
	case ('V'):  /* Fixed vertical resolution. */
a1704 1
/* ARGSUSED */
a1719 1
/* ARGSUSED */
d1733 1
a1733 1
				ln, ppos, *bufp + 1);
a1743 1
/* ARGSUSED */
a1755 1
/* ARGSUSED */
a1767 1
/* ARGSUSED */
a1779 1
/* ARGSUSED */
d1802 1
a1802 1
roff_openeqn(struct roff *r, const char *name, int line, 
a1823 1
/* ARGSUSED */
a1831 1
/* ARGSUSED */
a1839 1
/* ARGSUSED */
a1860 1
/* ARGSUSED */
a1876 1
/* ARGSUSED */
d1898 3
a1900 3
				mandoc_msg
					(MANDOCERR_BADESCAPE, r->parse, 
					 ln, (int)(p - *bufp), NULL);
d1910 3
a1912 3
				mandoc_msg
					(MANDOCERR_BADESCAPE, r->parse, 
					 ln, (int)(p - *bufp), NULL);
d1917 2
a1918 2
			mandoc_msg(MANDOCERR_ARGCOUNT, r->parse, 
					ln, (int)(p - *bufp), NULL);
d1924 2
a1925 2
			roff_setstrn(&r->xmbtab, first, 
					fsz, second, ssz, 0);
d1930 2
a1931 2
			r->xtab = mandoc_calloc
				(128, sizeof(struct roffstr));
a1940 1
/* ARGSUSED */
a1964 1
/* ARGSUSED */
d2065 1
a2065 1
			string ? strlen(string) : 0, append);
d2146 2
a2147 2
		if (0 == strncmp(name, n->key.p, len) && 
				'\0' == n->key.p[(int)len])
d2174 1
a2174 1
	
d2181 1
a2181 1
	
d2240 2
a2241 2
			res = mandoc_realloc
				(res, ssz + cp->val.sz + 1);
d2262 2
a2263 2
		/* 
		 * We bail out on bad escapes. 
d2278 1
a2278 1
 * Find out whether a line is a macro line or not.  
@


1.205
log
@We already supported (outer) user-defined strings containing references
to other (inner) user-defined strings in their values, such that the inner
ones get expanded at expansion time of the outer ones (delayed evaluation).
Now we also support specifying the name of an (outer) user-defined
string to expand using the expanded values of some other (inner)
user-defined strings (indirect reference).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.204 2014/04/07 15:07:13 schwarze Exp $ */
d488 3
a490 3
 * In the current line, expand user-defined strings ("\*")
 * and references to number registers ("\n").
 * Also check the syntax of other escape sequences.
d506 3
d531 1
a531 4
		/*
		 * Everything except user-defined strings and number
		 * registers is only checked, not expanded.
		 */
d533 1
d539 5
d566 20
a585 9
		switch (*++cp) {
		case ('\0'):
			continue;
		case ('('):
			cp++;
			maxl = 2;
			break;
		case ('['):
			cp++;
a586 4
			break;
		default:
			maxl = 1;
			break;
d598 1
a598 1
				continue;
d600 2
a601 1
			if (0 == maxl && ']' == *cp)
d603 1
d611 2
a612 1
		if (NULL == res)
d614 9
a622 1
		else
d625 6
d647 1
a647 1
		strlcat(nbuf, cp + (maxl ? 0 : 1), *szp);
d1159 4
a1162 1
	int p, n;
d1466 6
a1471 1
	/* If the trailing parenthesis is missing, ignore the error. */
d1474 2
d1521 3
@


1.204
log
@Almost complete implementation of roff(7) numerical expressions.
Support all binary operators except ';' (scale conversion).
Fully support chained operations and nested parentheses.
Use this for the .nr, .if, and .ie requests.
While here, fix parsing of integer numbers in roff_getnum().
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.203 2014/04/05 20:34:57 schwarze Exp $ */
d496 1
a501 1
	size_t		 nsz;	/* size of the new buffer */
d504 1
d508 3
d512 15
a526 4
again:
	cp = *bufp + pos;
	while (NULL != (cp = strchr(cp, '\\'))) {
		stesc = cp++;
d529 2
a530 3
		 * The second character must be an asterisk or an n.
		 * If it isn't, skip it anyway:  It is escaped,
		 * so it can't start another escape sequence.
d533 1
a533 3
		if ('\0' == *cp)
			return(ROFF_CONT);

d542 4
a545 6
			if (ESCAPE_ERROR != mandoc_escape(&cp, NULL, NULL))
				continue;
			mandoc_msg
				(MANDOCERR_BADESCAPE, r->parse, 
				 ln, (int)(stesc - *bufp), NULL);
			return(ROFF_CONT);
d548 5
a552 1
		cp++;
d560 1
a560 1
		switch (*cp) {
d562 1
a562 1
			return(ROFF_CONT);
d585 1
a585 1
				return(ROFF_CONT);
d608 1
d612 2
a613 1
		pos = stesc - *bufp;
d615 3
a617 2
		nsz = *szp + strlen(res) + 1;
		nbuf = mandoc_malloc(nsz);
d619 1
a619 3
		strlcpy(nbuf, *bufp, (size_t)(stesc - *bufp + 1));
		strlcat(nbuf, res, nsz);
		strlcat(nbuf, cp + (maxl ? 0 : 1), nsz);
d621 2
a623 1

a624 8
		*szp = nsz;

		if (EXPAND_LIMIT >= ++expand_count)
			goto again;

		/* Just leave the string unexpanded. */
		mandoc_msg(MANDOCERR_ROFFLOOP, r->parse, ln, pos, NULL);
		return(ROFF_IGN);
@


1.203
log
@Implement the roff(7) .rr (remove register) request.
As reported by sthen@@, the perl-5.18 pod2man(1) preamble
thinks cool kids use that in manuals.  I hope *you* know better.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.202 2014/03/23 12:11:18 schwarze Exp $ */
d184 2
d1112 6
d1129 1
a1129 1
		*res += 10 * *res + v[p] - '0';
a1139 28
static int
roff_getop(const char *v, int *pos, char *res)
{
	int e;

	*res = v[*pos];
	e = v[*pos + 1] == '=';

	switch (*res) {
	case '=':
		break;
	case '>':
		if (e)
			*res = 'g';
		break;
	case '<':
		if (e)
			*res = 'l';
		break;
	default:
		return(0);
	}

	*pos += 1 + e;

	return(*res);
}

d1183 4
d1190 1
a1190 2
	int	 wanttrue, lh, rh;
	char	 op;
d1219 3
a1221 1
	if (!roff_getnum(v, pos, &lh))
a1222 19
	if (!roff_getop(v, pos, &op))
		return((lh > 0) == wanttrue);
	if (!roff_getnum(v, pos, &rh))
		return(0);

	switch (op) {
	case 'g':
		return((lh >= rh) == wanttrue);
	case 'l':
		return((lh <= rh) == wanttrue);
	case '=':
		return((lh == rh) == wanttrue);
	case '>':
		return((lh > rh) == wanttrue);
	case '<':
		return((lh < rh) == wanttrue);
	default:
		return(0);
	}
d1340 188
a1636 1
/* ARGSUSED */
a1641 1
	size_t		 sz;
d1652 2
a1653 4
	sz = strspn(val, "0123456789");
	iv = sz ? mandoc_strntoi(val, sz, 10) : 0;

	roff_setreg(r, key, iv, sign);
@


1.202
log
@avoid repetitive code for asprintf error handling
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.201 2014/03/23 11:25:26 schwarze Exp $ */
d65 1
d206 1
d256 1
d1508 25
@


1.201
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.200 2014/03/20 02:57:28 schwarze Exp $ */
d659 1
a659 5
		isz = asprintf(&p, "%s\n.%s", *bufp, roffit_macro);
		if (-1 == isz) {
			perror(NULL);
			exit((int)MANDOCLEVEL_SYSERR);
		}
@


1.200
log
@Remove currently unimplemented macros from the lists of used-defined
macros to be cleared during .Dd and .TH because clearing them at that
point defeats the purpose of backup implementations provided in the
manual page itself, some of which _do_ work with mandoc(1).
While here, add the new .%C macro to the list to be cleared.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.199 2014/03/19 21:51:20 schwarze Exp $ */
d29 1
@


1.199
log
@Generalize the mparse_alloc() and roff_alloc() functions by giving
them an "options" argument, replacing the existing "inttype" and
"quick" arguments, preparing for a future MPARSE_SO option.
Store this argument in struct mparse and struct roff, replacing the
existing "inttype", "parsetype", and "quick" members.
No functional change except one tiny cosmetic fix in roff_TH().
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.198 2014/03/08 04:43:54 schwarze Exp $ */
d267 1
d273 3
a275 3
	"Ds", "Dt", "Dv", "Dx", "D1",
	"Ec", "Ed", "Ef", "Ek", "El", "Em", "em",
	"En", "Eo", "Eq", "Er", "Es", "Ev", "Ex",
d277 2
a278 2
	"Hf", "Ic", "In", "It", "Lb", "Li", "Lk", "Lp", "LP",
	"Me", "Ms", "Mt", "Nd", "Nm", "No", "Ns", "Nx",
d280 3
a282 3
	"Pa", "Pc", "Pf", "Po", "Pp", "PP", "pp", "Pq",
	"Qc", "Ql", "Qo", "Qq", "Or", "Rd", "Re", "Rs", "Rv",
	"Sc", "Sf", "Sh", "SH", "Sm", "So", "Sq",
d285 1
a285 1
	"%A", "%B", "%D", "%I", "%J", "%N", "%O",
d290 1
d292 5
a296 5
	"AT", "B", "BI", "BR", "BT", "DE", "DS", "DT",
	"EE", "EN", "EQ", "EX", "HF", "HP", "I", "IB", "IP", "IR",
	"LP", "ME", "MT", "OP", "P", "PD", "PP", "PT",
	"R", "RB", "RE", "RI", "RS", "SB", "SH", "SM", "SS", "SY",
	"TE", "TH", "TP", "TQ", "TS", "T&", "UC", "UE", "UR", "YS",
@


1.198
log
@Improve .if/.ie condition handling.
* Support string comparisons.
* Support negation not only for numerical, but for all conditions.
* Switch the `o' condition from false to true.
* Handle the `c', `d', and `r' conditions as false for now.
* Use int for boolean data instead of rolling our own "enum roffrule";
needed such that we can use the standard ! and == operators.

Havard Eidnes reported via the NetBSD bug tracking system that some
Tcl*(3) manuals need this, and Thomas Klausner <wiz at NetBSD>
forwarded the report to me.  This doesn't make the crazy Tcl*(3)
macrology maze happy yet, but brings us a bit closer.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.197 2014/03/07 18:37:37 schwarze Exp $ */
a105 1
	enum mparset	 parsetype; /* requested parse type */
d107 1
a107 1
	int		 quick; /* skip standard macro deletion */
d465 1
a465 1
roff_alloc(enum mparset type, struct mparse *parse, int quick)
a469 1
	r->parsetype = type;
d471 1
a471 1
	r->quick = quick;
d1553 1
a1553 1
	if (0 == r->quick && MPARSE_MDOC != r->parsetype)
d1566 1
a1566 1
	if (0 == r->quick && MPARSE_MDOC != r->parsetype)
@


1.197
log
@In roff_cond_sub(), make sure that the incorrect input sequence `\\}',
when found on a macro line, does not close a conditional block.
The companion function roff_cond_text() already did this correctly,
but make the code more readable without functional change.
While here, report the correct column number in related error messages.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.196 2014/03/07 18:30:11 schwarze Exp $ */
a78 5
enum	roffrule {
	ROFFRULE_DENY,
	ROFFRULE_ALLOW
};

d110 1
a110 1
	enum roffrule	 rstack[RSTACK_MAX]; /* stack of !`ie' rules */
d134 1
a134 1
	enum roffrule	 rule; /* current evaluation rule */
d182 2
a183 1
static	enum roffrule	 roff_evalcond(const char *, int *);
d400 1
a400 1
	p->rule = p->parent ? p->parent->rule : ROFFRULE_DENY;
a1048 1
	enum roffrule	 rr;
d1050 1
d1062 1
a1062 2
	    (ROFFRULE_ALLOW == rr ||
	     ROFFMAC_STRUCT & roffs[t].flags)) {
d1075 1
a1075 1
		rr = ROFFRULE_DENY;
d1086 1
a1086 1
	return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
d1094 1
a1094 1
	enum roffrule	 rr;
d1107 1
a1107 1
	return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
d1160 44
a1203 1
static enum roffrule
d1206 1
a1206 1
	int	 not, lh, rh;
d1209 6
d1217 2
d1220 5
a1224 1
		return(ROFFRULE_ALLOW);
d1227 1
a1227 1
	case ('o'):
d1231 1
a1231 5
		return(ROFFRULE_DENY);
	case ('!'):
		(*pos)++;
		not = 1;
		break;
a1232 1
		not = 0;
d1237 3
a1239 6
		return ROFFRULE_DENY;
	if (!roff_getop(v, pos, &op)) {
		if (lh < 0)
			lh = 0;
		goto out;
	}
d1241 2
a1242 1
		return ROFFRULE_DENY;
d1245 1
a1245 2
		lh = lh >= rh;
		break;
d1247 1
a1247 2
		lh = lh <= rh;
		break;
d1249 1
a1249 2
		lh = lh == rh;
		break;
d1251 1
a1251 2
		lh = lh > rh;
		break;
d1253 1
a1253 2
		lh = lh < rh;
		break;
d1255 1
a1255 1
		return ROFFRULE_DENY;
a1256 4
out:
	if (not)
		lh = !lh;
	return lh ? ROFFRULE_ALLOW : ROFFRULE_DENY;
d1283 1
a1283 2
		(r->rstackpos < 0 ? 
		 ROFFRULE_DENY : r->rstack[r->rstackpos--]) :
d1297 1
a1297 3
		r->rstack[++r->rstackpos] = 
			ROFFRULE_DENY == r->last->rule ?
			ROFFRULE_ALLOW : ROFFRULE_DENY;
d1302 2
a1303 2
	if (r->last->parent && ROFFRULE_DENY == r->last->parent->rule)
		r->last->rule = ROFFRULE_DENY;
@


1.196
log
@Even on macro lines, \} must not cause whitespace.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.195 2014/03/07 02:22:05 schwarze Exp $ */
d1085 5
a1089 4
		if ('}' != *(++ep))
			continue;
		*ep = '&';
		roff_ccond(r, ln, pos);
d1104 7
a1110 7
	ep = &(*bufp)[pos];
	for ( ; NULL != (ep = strchr(ep, '\\')); ep++) {
		ep++;
		if ('}' != *ep)
			continue;
		*ep = '&';
		roff_ccond(r, ln, pos);
@


1.195
log
@Three bugfixes related to the closing of conditional blocks:
1. Handle more than one `\}' on macro lines, as it was already done
for text lines.
2. Do not treat `\}' as a macro invocation after a dot at the beginning
of a line.  That allows more than one `\}' to work on lines starting
with `.\}'.  It also simplifies the code.
3. Do not complain about characters following `\}'.  Those are not lost,
but handled normally both on text and macro lines.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.194 2014/02/14 23:24:26 schwarze Exp $ */
d1073 9
a1083 1
	ep = &(*bufp)[pos];
d1087 1
a1087 13

		/*
		 * If we're at the end of line, then just chop
		 * off the \} and resize the buffer.
		 * If we aren't, then convert it to spaces.
		 */

		if ('\0' == *(ep + 1)) {
			*--ep = '\0';
			*szp -= 2;
		} else
			*(ep - 1) = *ep = ' ';

@


1.194
log
@Parse and ignore the roff(7) .ce request (center some lines).

We even parse and ignore the .ad request (adjustment mode),
and it doesn't make sense to more prominently warn about
temporary than about permanent adjustment changes.

Request found by naddy@@ in xloadimage(1) and by juanfra@@ in racket(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.193 2014/02/14 23:05:20 schwarze Exp $ */
a74 1
	ROFF_ccond,
d182 1
a182 1
static	enum rofferr	 roff_ccond(ROFF_ARGS);
a268 1
	{ "\\}", roff_ccond, NULL, NULL, 0, NULL },
d791 1
a791 5
	/*
	 * We stop the macro parse at an escape, tab, space, or nil.
	 * However, `\}' is also a valid macro, so make sure we don't
	 * clobber it by seeing the `\' as the end of token.
	 */
d794 1
a794 1
	maclen = strcspn(mac + 1, " \\\t\0") + 1;
d863 2
a864 3
/* ARGSUSED */
static enum rofferr
roff_ccond(ROFF_ARGS)
d869 1
a869 1
		return(ROFF_IGN);
d881 1
a881 1
		return(ROFF_IGN);
d886 1
a886 1
		return(ROFF_IGN);
a888 3
	if ((*bufp)[pos])
		mandoc_msg(MANDOCERR_ARGSLOST, r->parse, ln, pos, NULL);

d891 1
a891 1
	return(ROFF_IGN);
d1066 1
a1066 1
	    (ROFF_ccond == t || ROFFRULE_ALLOW == rr ||
d1092 1
a1092 3
		roff_ccond(r, ROFF_ccond, bufp, szp, 
				ln, pos, pos + 2, offs);
		break;
d1113 1
a1113 2
		roff_ccond(r, ROFF_ccond, bufp, szp, 
				ln, pos, pos + 2, offs);
@


1.193
log
@Implement the roff(7) .as request (append to user-defined string).
Missing feature found by jca@@ in ratpoison(1).
The ratpoison(1) manual still doesn't work because it uses .shift
and .while, too (apparently, ratpoison is so complex that it
needs a Turing-complete language to even format its manual :-).

Written at Christchurch International Airport.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.192 2014/02/14 22:27:41 schwarze Exp $ */
d45 1
d240 1
@


1.192
log
@Handle some predefined read-only number registers, e.g. .H and .V.
In particular, this improves handling of the pod2man(1) preamble;
for examples of the effect, see some author names in perlthrtut(1).

Missing feature reported by Andreas Voegele <mail at andreasvoegele dot com>
more than two years ago.  Written at Christchurch International Airport.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.191 2014/01/06 23:46:07 schwarze Exp $ */
d43 1
d237 1
d944 1
a944 1
	 * added from roff_block_text() in multiline mode.
d1034 1
a1034 1
			roff_setstr(r, r->last->name, *bufp + ppos, 1);
d1050 1
a1050 1
		roff_setstr(r, r->last->name, *bufp + pos, 1);
d1353 1
a1353 1
	roff_setstr(r, name, string, 0);
a1852 2
 * In multiline mode, append to an existing entry and append '\n';
 * else replace the existing entry, if there is one.
d1854 3
d1860 1
a1860 1
	int multiline)
d1864 1
a1864 1
			string ? strlen(string) : 0, multiline);
d1869 1
a1869 1
		const char *string, size_t stringsz, int multiline)
d1891 1
a1891 2
	} else if (0 == multiline) {
		/* In multiline mode, append; else replace. */
d1904 1
a1904 1
	newch = stringsz + (multiline ? 2u : 1u);
d1931 1
a1931 1
	if (multiline)
@


1.191
log
@Gprof(1) is fun.  You should use it more often.

Another 10% speedup for mandocdb(8) -Q, and even 3% without -Q.
With -Q, we are now at 41% of the time required by makewhatis(8).

Do not copy predefined strings into the dynamic string table, just
leave them in their own static table and use that one as a fallback
at lookup time.  This saves us copying and deleting them for each manual.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.190 2014/01/06 21:34:31 schwarze Exp $ */
d195 1
d1384 28
d1416 7
d1435 7
@


1.190
log
@Another 25% speedup for mandocdb(8) -Q mode, found with gprof(1).
For /usr/share/man, we only need 56% of the time of makewhatis(8) now.

In groff, user-defined macros clashing with mdoc(7) or man(7)
standard macros are cleared when parsing the .Dd or .TH macro,
respectively.  Of course, we continue doing that in standard mode
to assure full groff bug compatibility.

However, in -Q mode, full groff bug compatibility makes no sense
when it's unreasonably expensive, so skip this step in -Q mode.
Real-world manuals hardly ever redefine standard macros,
that's terrible style, and if they do, it's pointless to do so
before .Dd or .TH because it has no effect.  Even if someone does,
it's extremely unlikely to break mandocdb(8) -Q parsing because we
abort the parse sequence after the NAME section, anyway.

So if you manually redefine .Sh, .Nm, .Nd, or .SH in a way that doesn't
work at all and rely on .Dd or .TH to fix it up for you, your broken
manual will no longer get a perfect apropos(1) entry until you re-run
mandocdb(8) without -Q.  It think that consequence is acceptable
in order to get a 25% speedup for everyone else.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.189 2013/12/30 18:44:06 schwarze Exp $ */
a450 1
	int		 i;
a452 1

a453 3

	for (i = 0; i < PREDEFS_MAX; i++) 
		roff_setstr(r, predefs[i].name, predefs[i].str, 0);
a469 1
	int		 i;
a478 3
	for (i = 0; i < PREDEFS_MAX; i++) 
		roff_setstr(r, predefs[i].name, predefs[i].str, 0);

d1897 1
d1904 5
@


1.189
log
@Oops, missed one:
Remove duplicate const specifier from a call to mandoc_escape().
Found by Thomas Klausner <wiz at NetBSD dot org> using clang.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.188 2013/12/25 00:50:05 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012, 2013 Ingo Schwarze <schwarze@@openbsd.org>
d112 1
d472 1
a472 1
roff_alloc(enum mparset type, struct mparse *parse)
d480 1
d1502 1
a1502 1
	if (MPARSE_MDOC != r->parsetype)
d1515 1
a1515 1
	if (MPARSE_MDOC != r->parsetype)
@


1.188
log
@s/[Nn]ull/NUL/ in comments where appropriate;
suggested by Thomas Klausner <wiz @@ NetBSD dot org>.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.187 2013/12/15 21:23:52 schwarze Exp $ */
d649 1
a649 2
			esc = mandoc_escape
				((const char const **)&p, NULL, NULL);
@


1.187
log
@The "value" argument to the roff(7) .nr requests ends right before
the first non-digit character.  While here, implement and document
an optional sign, requesting increment or decrement, as documented
in the Ossanna/Kernighan/Ritter troff manual and supported by groff.

Reported by bentley@@ on discuss@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.186 2013/10/22 20:38:00 schwarze Exp $ */
d1736 1
a1736 1
	 * and null-terminate them.
@


1.186
log
@Parse and ignore .hw (hyphenation points in words); this is safe because
we don't do hyphenation anyway, so there is no point in throwing an ERROR
when encountering .hw.
Real-world usage of the request found by naddy@@ in sysutils/dwdiff(1).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.185 2013/10/14 01:43:14 schwarze Exp $ */
d1363 1
a1363 1
roff_setreg(struct roff *r, const char *name, int val)
d1378 1
d1383 6
a1388 1
	reg->val = val;
d1435 1
d1437 1
d1442 6
a1447 1
	iv = mandoc_strntoi(val, strlen(val), 10);
d1449 1
a1449 1
	roff_setreg(r, key, iv);
@


1.185
log
@Parse and ignore the .fam (font family) request.
Fixes irunner(1) in devel/ipython and uim-xim(1) in inputmethods/uim.
Thanks to naddy@@ for bringing these to my attention.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.184 2013/10/05 22:25:12 schwarze Exp $ */
d50 1
d241 1
@


1.184
log
@Support simple numerical conditions.

Original code from Christos Zoulas, NetBSD rev. 1.11-1.13, April 3, 2013.

I tweaked the code as follows:
* In roff_getnum(), don't skip a minus that isn't followed by a digit.
* In roff_getop(), do not handle "!=", groff doesn't support it either.
* In roff_evalcond(), treat negative numbers as false, like groff.
Besides, make the interfaces of roff_getnum() and roff_getop() more
similar to each other and simplify parts of the code a bit.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.183 2013/10/05 22:21:20 schwarze Exp $ */
d49 1
d239 1
@


1.183
log
@ROFFRULE_ALLOW = 0, ROFFRULE_DENY = 1 was confusing,
so exchange the two entries in enum roffrule; no functional change;
from Christos Zoulas, NetBSD rev. 1.11, April 4, 2013.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.182 2013/10/05 22:19:10 schwarze Exp $ */
d188 2
d1130 50
d1183 2
d1197 4
d1202 1
d1206 32
a1237 3
	while (v[*pos] && ' ' != v[*pos])
		(*pos)++;
	return(ROFFRULE_DENY);
@


1.182
log
@Avoid code duplication in roff_parseln() as suggested by
Christos Zoulas in NetBSD rev. 1.11;
i'm even going a step further and making this yet a bit shorter.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.181 2013/10/05 22:15:03 schwarze Exp $ */
d77 2
a78 2
	ROFFRULE_ALLOW,
	ROFFRULE_DENY
@


1.181
log
@Expand references to number registers in exactly the same way as
references to user-defined strings.  While here, make number registers
signed int, like in groff.

Inspired by NetBSD roff.c rev. 1.8 and read.c rev. 1.7
written by Christos Zoulas on March 21, 2013, but implemented
in a completely different way, without hacking into read.c,
where this functionality really doesn't belong.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.180 2013/10/05 22:08:12 schwarze Exp $ */
d715 4
a718 2
		if (r->eqn)
			return(eqn_read(&r->eqn, ln, *bufp, pos, offs));
d722 1
a722 8
	} else if ( ! ctl) {
		if (r->eqn)
			return(eqn_read(&r->eqn, ln, *bufp, pos, offs));
		if (r->tbl)
			return(tbl_read(r->tbl, ln, *bufp, pos));
		return(roff_parsetext(bufp, szp, pos, offs));
	} else if (r->eqn)
		return(eqn_read(&r->eqn, ln, *bufp, ppos, offs));
@


1.180
log
@Support setting arbitrary roff(7) number registers,
preserving read support for the ".nr nS" SYNOPSIS state register.

Inspired by NetBSD roff.c rev. 1.18 (Christos Zoulas, March 21, 2013),
but implemented differently.  I don't want to have yet another different
implementation of a hash table in mandoc - it would be the second one
in roff.c alone and the fifth one in mandoc grand total.
Instead, i designed and implemented roff_setreg() and roff_getreg()
to be similar to roff_setstrn() and roff_getstrn().

Once we feel the need to optimize, we can introduce one common
hash table implementation for everything in mandoc.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.179 2013/10/05 20:30:05 schwarze Exp $ */
a99 1
 * Registers are assumed to be unsigned ints for now.
d103 1
a103 1
	unsigned int	 u;
d188 2
d484 3
a486 4
 * Pre-filter each and every line for reserved words (one beginning with
 * `\*', e.g., `\*(ab').  These must be handled before the actual line
 * is processed. 
 * This also checks the syntax of regular escapes.
d491 1
a491 1
	enum mandoc_esc	 esc;
d496 5
a500 3
	int		 i, maxl, expand_count;
	size_t		 nsz;
	char		*n;
d510 1
a510 1
		 * The second character must be an asterisk.
d518 9
a526 4
		if ('*' != *cp) {
			res = cp;
			esc = mandoc_escape(&cp, NULL, NULL);
			if (ESCAPE_ERROR != esc)
a527 1
			cp = res;
d538 1
a538 1
		 * of the name of the string.
d561 1
a561 1
		for (i = 0; 0 == maxl || i < maxl; i++, cp++) {
d578 5
a582 1
		res = roff_getstrn(r, stnam, (size_t)i);
d596 1
a596 1
		n = mandoc_malloc(nsz);
d598 3
a600 3
		strlcpy(n, *bufp, (size_t)(stesc - *bufp + 1));
		strlcat(n, res, nsz);
		strlcat(n, cp + (maxl ? 0 : 1), nsz);
d604 1
a604 1
		*bufp = n;
d1276 1
a1276 1
roff_setreg(struct roff *r, const char *name, unsigned int val)
d1295 1
a1295 1
	reg->u = val;
d1298 1
a1298 1
unsigned int
d1305 14
a1318 1
			return(reg->u);
a1347 2
	if (0 > iv)
		iv = 0;
d1349 1
a1349 1
	roff_setreg(r, key, (unsigned)iv);
@


1.179
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- do not complain about unused variables in test-*.c
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.178 2013/07/13 12:52:07 schwarze Exp $ */
a81 10
 * A single register entity.  If "set" is zero, the value of the
 * register should be the default one, which is per-register.
 * Registers are assumed to be unsigned ints for now.
 */
struct	reg {
	int		 set; /* whether set or not */
	unsigned int	 u; /* unsigned integer */
};

/*
d98 10
d115 1
a115 1
	struct reg	 regs[REG__MAX];
d186 1
d428 4
a447 1
	memset(&r->regs, 0, sizeof(struct reg) * REG__MAX);
d1265 2
a1266 2
int
roff_regisset(const struct roff *r, enum regs reg)
d1268 7
d1276 10
a1285 1
	return(r->regs[(int)reg].set);
d1289 1
a1289 1
roff_regget(const struct roff *r, enum regs reg)
d1291 5
d1297 1
a1297 1
	return(r->regs[(int)reg].u);
d1300 2
a1301 2
void
roff_regunset(struct roff *r, enum regs reg)
d1303 1
d1305 6
a1310 1
	r->regs[(int)reg].set = 0;
d1324 5
a1328 7
	if (0 == strcmp(key, "nS")) {
		r->regs[(int)REG_nS].set = 1;
		if ((iv = mandoc_strntoi(val, strlen(val), 10)) >= 0)
			r->regs[(int)REG_nS].u = (unsigned)iv;
		else
			r->regs[(int)REG_nS].u = 0u;
	}
@


1.178
log
@Rudimentary implementation of the .it request (input line trap).
As with any low-level roff request involving subtle interactions
with macro internals, this implementation is not exact, but it
does handle the simplest cases.

This request occurs in man(7) code generated from DocBook,
for example mysql(1) and yasm_arch(7).
Thanks to brad@@ for reporting the issue back in January 2011.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.177 2013/06/27 09:49:47 schwarze Exp $ */
d630 1
a630 1
				((const char **)&p, NULL, NULL);
@


1.177
log
@Parse for the closing delimiter `\}' for conditionals
even when the conditional evaluated to false.

While here, reshuffle the code to reduce indentation and make it
more readable; that way, we can even trim down the comments because
it becomes obvious what the code does.

Found in zipinfo(1) - thanks to espie@@ and naddy@@
for making me look at that manual page.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.176 2013/05/31 22:08:09 schwarze Exp $ */
d24 1
d190 1
d196 1
a196 1
static	enum rofferr	 roff_parsetext(char *);
d238 1
a238 1
	{ "it", roff_line_ignore, NULL, NULL, 0, NULL },
d300 3
d604 3
a606 1
 * Process text streams: convert all breakable hyphens into ASCII_HYPH.
d609 1
a609 1
roff_parsetext(char *p)
d613 2
d617 1
a617 1
	start = p;
d645 16
d705 1
a705 1
		return(roff_parsetext(*bufp + pos));
d711 1
a711 1
		return(roff_parsetext(*bufp + pos));
a1147 3
	if (ROFF_it == tok)
		mandoc_msg(MANDOCERR_REQUEST, r->parse, ln, ppos, "it");

d1322 25
@


1.176
log
@More cleanup: Consistently use the name "struct tbl_node *tbl"
that is already used almost everywhere instead of gratuitiously
inventing different names at four places.  No functional change.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.175 2012/11/19 17:57:23 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011, 2012 Ingo Schwarze <schwarze@@openbsd.org>
d1031 1
d1034 2
a1035 4
	 * If the macro is unknown, first check if it contains a closing
	 * delimiter `\}'.  If it does, close out our scope and return
	 * the currently-scoped rule (ignore or continue).  Else, drop
	 * into the currently-scoped rule.
d1038 7
a1044 6
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos))) {
		ep = &(*bufp)[pos];
		for ( ; NULL != (ep = strchr(ep, '\\')); ep++) {
			ep++;
			if ('}' != *ep)
				continue;
d1046 1
a1046 8
			/*
			 * Make the \} go away.
			 * This is a little haphazard, as it's not quite
			 * clear how nroff does this.
			 * If we're at the end of line, then just chop
			 * off the \} and resize the buffer.
			 * If we aren't, then conver it to spaces.
			 */
d1048 4
a1051 5
			if ('\0' == *(ep + 1)) {
				*--ep = '\0';
				*szp -= 2;
			} else
				*(ep - 1) = *ep = ' ';
d1053 5
a1057 6
			roff_ccond(r, ROFF_ccond, bufp, szp, 
					ln, pos, pos + 2, offs);
			break;
		}
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
	}
d1059 5
a1063 5
	/*
	 * A denied conditional must evaluate its children if and only
	 * if they're either structurally required (such as loops and
	 * conditionals) or a closing macro.
	 */
d1065 5
a1069 8
	if (ROFFRULE_DENY == rr)
		if ( ! (ROFFMAC_STRUCT & roffs[t].flags))
			if (ROFF_ccond != t)
				return(ROFF_IGN);

	assert(roffs[t].proc);
	return((*roffs[t].proc)(r, t, bufp, szp, 
				ln, ppos, pos, offs));
@


1.175
log
@In groff, trying to redefine standard man(7) macros before .TH has no effect;
after .TH, it works.  Trying to redefine standard mdoc(7) macros before .Dd
works when calling groff with the -mdoc command line option, but does not
when calling groff with -mandoc; after .Dd, it always works.

Arguably, one might call that buggy behaviour in groff, but it is very
unlikely that anybody will change groff in this respect (certainly, i'm
not volunteering).  So let's be bug-compatible.

This fixes the vertical spacing in sox(1).

Merging from OpenBSD libmandoc.h 1.18, read.c 1.8, roff.c 1.47, June 2, 2012.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.174 2012/06/12 20:21:04 kristaps Exp $ */
d396 1
a396 1
	struct tbl_node	*t;
d400 3
a402 3
	while (NULL != (t = r->first_tbl)) {
		r->first_tbl = t->next;
		tbl_free(t);
d1416 1
a1416 1
	struct tbl_node	*t;
d1423 1
a1423 1
	t = tbl_alloc(ppos, ln, r->parse);
d1426 1
a1426 1
		r->last_tbl->next = t;
d1428 1
a1428 1
		r->first_tbl = r->last_tbl = t;
d1430 1
a1430 1
	r->tbl = r->last_tbl = t;
@


1.174
log
@Add `cc' support.
This was reported by espie@@ and in the TODO.
Caveat: `cc' has buggy behaviour when invoked in groff(1) and followed
by a line-breaking control character macro, e.g., in a -man doc,

  .cc |
  .B foo
  'B foo
  |cc
  'B foo

will cause groff(1) to behave properly for `.B' but inline the macro
definition for `B' when invoked with the line-breaking macro.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.173 2012/05/31 22:41:19 schwarze Exp $ */
d3 1
a3 1
 * Copyright (c) 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
d62 2
d108 1
d204 2
d246 2
d258 31
d455 1
a455 1
roff_alloc(struct mparse *parse)
d461 1
d1312 26
@


1.173
log
@Fix blank line handling in .if.

In particular, two cases were wrong:
- single-line .if with trailing whitespace gave no blank line
- multiline .if with \{ but without \{\ gave no blank line

While here, simplify roff_cond() by partially reordering the code.

"good one" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.172 2011/10/24 21:41:45 schwarze Exp $ */
d42 1
d109 1
d174 1
d221 1
d399 1
d619 1
a619 1
	ctl = mandoc_getcontrol(*bufp, &pos);
d1371 17
d1782 35
@


1.172
log
@Handle infinite recursion the same way as groff:
When string expansion exceeds the recursion limit, drop the whole
input line, instead of leaving just the string unexpanded.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.171 2011/09/19 08:34:45 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2010, 2011 Ingo Schwarze <schwarze@@openbsd.org>
d781 1
a781 1
		if (--r->last->endspan < 0)
d1101 2
a1102 2
	int		 sv;
	enum roffrule	 rule;
d1112 1
a1112 1
	rule = ROFF_el == tok ?
a1116 20
	sv = pos;
	while (' ' == (*bufp)[pos])
		pos++;

	/*
	 * Roff is weird.  If we have just white-space after the
	 * conditional, it's considered the BODY and we exit without
	 * really doing anything.  Warn about this.  It's probably
	 * wrong.
	 */

	if ('\0' == (*bufp)[pos] && sv != pos) {
		mandoc_msg(MANDOCERR_NOARGS, r->parse, ln, ppos, NULL);
		return(ROFF_IGN);
	}

	roffnode_push(r, tok, NULL, ln, ppos);

	r->last->rule = rule;

d1139 3
a1141 3
	 * Determine scope.  If we're invoked with "\{" trailing the
	 * conditional, then we're in a multiline scope.  Else our scope
	 * expires on the next line.
d1144 9
a1152 1
	r->last->endspan = 1;
d1157 1
d1161 3
a1163 2
	 * If there are no arguments on the line, the next-line scope is
	 * assumed.
d1167 1
a1167 1
		return(ROFF_IGN);
d1169 1
a1169 1
	/* Otherwise re-run the roff parser after recalculating. */
d1171 1
@


1.171
log
@Breaking the line at a hyphen is only allowed if the hyphen
is both preceded and followed by an alphabetic character.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.170 2011/09/18 23:51:31 schwarze Exp $ */
d189 1
a189 1
static	void		 roff_res(struct roff *, 
d435 1
a435 1
static void
d461 1
a461 1
			return;
d472 1
a472 1
			return;
d485 1
a485 1
			return;
d508 1
a508 1
				return;
d549 1
a549 1
		return;
d551 1
d608 4
a611 1
	roff_res(r, bufp, szp, ln, pos);
@


1.170
log
@Fix another regression introduced in 1.11.7:
If a string is defined in terms of itself, the REPARSE_LIMIT in read.c
used to break the cycle.  This no longer works since all the work
is now done in the function roff_res(), looping indefinitely.

Make this loop finite by arbitrarily limiting the number of times one
string may be expanded; when that limit is reached, leave the remaining
string references unexpanded.

This changes behaviour compared to 1.11.5, where the whole line would
have been dropped.  The new behaviour is better because it loses less
information.  We don't want to imitate groff-1.20.1 behaviour anyway
because groff aborts parsing of the whole file.

ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.169 2011/09/18 14:14:15 schwarze Exp $ */
a558 1
	char		 l, r;
d585 2
a586 8
		l = *(p - 1);
		r = *(p + 1);
		if ('\\' != l &&
				'\t' != r && '\t' != l &&
				' ' != r && ' ' != l &&
				'-' != r && '-' != l &&
				! isdigit((unsigned char)l) &&
				! isdigit((unsigned char)r))
@


1.169
log
@forgotten Copyright bumps; no code change
found while syncing to OpenBSD
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.168 2011/08/16 12:30:12 kristaps Exp $ */
d34 3
d443 1
a443 1
	int		 i, maxl;
d447 2
d543 7
a549 1
		goto again;
@


1.168
log
@Lint check.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.167 2011/07/29 10:16:59 kristaps Exp $ */
d182 1
a182 1
static	void		 roff_openeqn(struct roff *, const char *, 
@


1.167
log
@Use a character-table for quick per-character substitution in `tr'.  As
suggested by joerg@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.166 2011/07/29 09:19:48 kristaps Exp $ */
a1669 7
char
roff_eqndelim(const struct roff *r)
{

	return('\0');
}

@


1.166
log
@Renamed roffstr as roffkv (key-value) and split out char/size_t into
roffstr.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.165 2011/07/28 14:53:22 kristaps Exp $ */
d84 3
d88 2
a89 2
	char		*p;
	size_t		 sz;
d93 1
a93 1
 * A key-value string pair with lengths.
d108 2
a109 1
	struct roffkv	*chrtab; /* user-defined characters */
d176 1
a176 1
static	void		 roff_freestr(struct roffkv **);
d353 1
d372 11
a382 2
	roff_freestr(&r->strtab);
	roff_freestr(&r->chrtab);
a384 1

d1412 13
a1424 1
		roff_setstrn(&r->chrtab, first, fsz, second, ssz, 0);
d1644 1
a1644 1
roff_freestr(struct roffkv **r)
d1648 1
a1648 1
	for (n = *r; n; n = nn) {
a1653 2

	*r = NULL;
d1691 1
a1691 1
	if (NULL == r->chrtab)
d1708 13
d1722 1
a1722 1
		for (cp = r->chrtab; cp; cp = cp->next)
d1740 10
a1749 21
		if ('\\' == *p) {
			/*
			 * Handle escapes carefully: we need to copy
			 * over just the escape itself, or else we might
			 * do replacements within the escape itself.
			 * Make sure to pass along the bogus string.
			 */
			pp = p++;
			esc = mandoc_escape(&p, NULL, NULL);
			if (ESCAPE_ERROR == esc) {
				sz = strlen(pp);
				res = mandoc_realloc(res, ssz + sz + 1);
				memcpy(res + ssz, pp, sz);
				break;
			}
			/* 
			 * We bail out on bad escapes. 
			 * No need to warn: we already did so when
			 * roff_res() was called.
			 */
			sz = (int)(p - pp);
d1752 1
a1752 2
			ssz += sz;
			continue;
d1754 9
a1762 4

		/* Just append the charater. */
		res = mandoc_realloc(res, ssz + 2);
		res[ssz++] = *p++;
@


1.165
log
@Fix border condition in `tr' grokking arguments.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.164 2011/07/28 14:17:11 kristaps Exp $ */
d80 2
a81 2
	int		  set; /* whether set or not */
	unsigned int	  u; /* unsigned integer */
d85 11
a95 5
	char		*key; /* key of symbol */
	size_t		 keysz;
	char		*val; /* current value */
	size_t		 valsz;
	struct roffstr	*next; /* next in list */
d104 2
a105 2
	struct roffstr	*strtab; /* user-defined strings & macros */
	struct roffstr	*chrtab; /* user-defined characters */
d172 1
a172 1
static	void		 roff_freestr(struct roffstr **);
d187 1
a187 1
static	void		 roff_setstrn(struct roffstr **, const char *, 
d1534 1
a1534 1
roff_setstrn(struct roffstr **r, const char *name, size_t namesz,
d1537 1
a1537 1
	struct roffstr	*n;
d1545 1
a1545 1
	while (n && strcmp(name, n->key))
d1550 5
a1554 5
		n = mandoc_malloc(sizeof(struct roffstr));
		n->key = mandoc_strndup(name, namesz);
		n->keysz = namesz;
		n->val = NULL;
		n->valsz = 0;
d1559 3
a1561 3
		free(n->val);
		n->val = NULL;
		n->valsz = 0;
d1573 3
a1575 3
	if (NULL == n->val) {
		n->val = mandoc_malloc(newch);
		*n->val = '\0';
d1578 2
a1579 2
		oldch = n->valsz;
		n->val = mandoc_realloc(n->val, oldch + newch);
d1583 1
a1583 1
	c = n->val + (int)oldch;
d1602 1
a1602 1
	n->valsz = (int)(c - n->val);
d1608 1
a1608 1
	const struct roffstr *n;
d1611 3
a1613 3
		if (0 == strncmp(name, n->key, len) && 
				'\0' == n->key[(int)len])
			return(n->val);
d1619 1
a1619 1
roff_freestr(struct roffstr **r)
d1621 1
a1621 1
	struct roffstr	 *n, *nn;
d1624 2
a1625 2
		free(n->key);
		free(n->val);
d1662 1
a1662 1
	const struct roffstr *cp;
d1687 1
a1687 1
			if (0 == strncmp(p, cp->key, cp->keysz))
d1696 5
a1700 4
			res = mandoc_realloc(res, ssz + cp->valsz + 1);
			memcpy(res + ssz, cp->val, cp->valsz);
			ssz += cp->valsz;
			p += (int)cp->keysz;
@


1.164
log
@An implementation of `tr'.  This routes allocations of TEXT nodes
through libroff, which does the appropriate translations of `tr'.  This
is SLOW: it uses the backend of `ds' and `de', which is a simple linear
list.  However, unlike `ds' and `de', it iterates over EACH CHARACTER of
the entire file looking for replacements.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.163 2011/07/27 20:55:28 kristaps Exp $ */
d1386 1
a1386 1
		} else if ('\0' == *p) {
d1390 1
@


1.163
log
@Correctly set valsz this time.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.162 2011/07/27 17:25:30 kristaps Exp $ */
d98 2
a99 1
	struct roffstr	*first_string; /* user-defined strings & macros */
d166 1
a166 1
static	void		 roff_freestr(struct roff *);
d181 2
d184 1
d223 1
a223 1
	{ "tr", roff_line_ignore, NULL, NULL, 0, NULL },
d361 2
a362 1
	roff_freestr(r);
d1348 52
d1521 13
a1533 3
	struct roffstr	 *n;
	char		 *c;
	size_t		  oldch, newch;
d1536 2
a1537 1
	n = r->first_string;
d1544 2
a1545 2
		n->key = mandoc_strdup(name);
		n->keysz = strlen(name);
d1548 2
a1549 2
		n->next = r->first_string;
		r->first_string = n;
d1564 2
a1565 1
	newch = strlen(string) + (multiline ? 2u : 1u);
d1579 2
a1580 1
	while (*string) {
d1585 3
a1587 3
		if ('\\' == *string && '\\' == *(string + 1))
			string++;
		*c++ = *string++;
d1603 1
a1603 1
	for (n = r->first_string; n; n = n->next)
d1612 1
a1612 1
roff_freestr(struct roff *r)
d1616 1
a1616 1
	for (n = r->first_string; n; n = nn) {
d1623 1
a1623 1
	r->first_string = NULL;
d1646 85
@


1.162
log
@Have roffstr keep track of string lengths.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.161 2011/07/27 14:58:28 kristaps Exp $ */
a1499 1
		n->valsz = newch - 1;
d1503 1
a1503 2
		n->val = mandoc_realloc(n->val, n->valsz + newch);
		n->valsz += newch - 1;
d1523 1
d1525 1
@


1.161
log
@Fix a memory-offset bug that was hell tracking down.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.160 2011/07/27 14:23:27 kristaps Exp $ */
d86 1
d88 1
d1477 1
d1479 1
d1486 1
d1500 1
d1503 3
a1505 2
		oldch = strlen(n->val);
		n->val = mandoc_realloc(n->val, oldch + newch);
@


1.160
log
@Rename some terms (incremental part of a larger set of check-ins).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.159 2011/07/27 14:19:26 kristaps Exp $ */
d499 1
a499 1
		pos += (stesc - *bufp);
@


1.159
log
@Fix hyphen-replacement loop.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.158 2011/07/27 13:47:26 kristaps Exp $ */
d85 2
a86 2
	char		*name; /* key of symbol */
	char		*string; /* current value */
d1468 1
a1468 1
	while (n && strcmp(name, n->name))
d1474 2
a1475 2
		n->name = mandoc_strdup(name);
		n->string = NULL;
d1480 2
a1481 2
		free(n->string);
		n->string = NULL;
d1492 3
a1494 3
	if (NULL == n->string) {
		n->string = mandoc_malloc(newch);
		*n->string = '\0';
d1497 2
a1498 2
		oldch = strlen(n->string);
		n->string = mandoc_realloc(n->string, oldch + newch);
d1502 1
a1502 1
	c = n->string + (int)oldch;
d1527 3
a1529 3
		if (0 == strncmp(name, n->name, len) && 
				'\0' == n->name[(int)len])
			return(n->string);
d1540 2
a1541 2
		free(n->name);
		free(n->string);
@


1.158
log
@Critical fix to avoid looping forever.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.157 2011/07/27 13:42:27 kristaps Exp $ */
d533 3
d544 1
a544 1
		} else if ('-' != *p || p == start) {
a550 1

d556 1
a556 1
			       	! isdigit((unsigned char)r))
@


1.157
log
@Clean up roff_getstrn() function.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.156 2011/07/27 12:41:02 kristaps Exp $ */
d541 2
a542 1
		} else if ('-' != *p || p == start)
d544 1
@


1.156
log
@Disable in-line eqn processing for a bit.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.155 2011/07/27 07:32:26 kristaps Exp $ */
d1522 4
a1525 3
	n = r->first_string;
	while (n && (strncmp(name, n->name, len) || '\0' != n->name[(int)len]))
		n = n->next;
d1527 1
a1527 1
	return(n ? n->string : NULL);
@


1.155
log
@Move mandoc_hyph() into roff_parsetext() as a single conditional.  While
here, do some function renames for clarity and make all function
prototypes be in one place.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.154 2011/07/27 07:09:41 kristaps Exp $ */
d169 2
d1263 2
a1264 1
int
d1270 1
d1272 1
a1272 1
void
@


1.154
log
@First, roff_res() has no need to invoke ROFF_RERUN: since it's executed
before any other roff processing occurs, it's Ok to just let it do its
thing and pass through.  Also, make sure this function is ALWAYS called,
not just when first_string is defined.

Second, add a new function, roff_parsetext(), that post-processes
non-macro lines.  This, for the time being, amounts to detecting soft
hyphens.  This fixes a long-standing bug in that -man now has proper
hyphen breaking!
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.153 2011/07/26 14:24:06 kristaps Exp $ */
d146 6
d162 1
d169 2
d184 1
a184 1
/* See roff_hash_find() */
d232 1
a232 10
static	void		 roff_free1(struct roff *);
static	enum rofft	 roff_hash_find(const char *, size_t);
static	void		 roff_hash_init(void);
static	void		 roffnode_cleanscope(struct roff *);
static	void		 roffnode_push(struct roff *, enum rofft,
				const char *, int, int);
static	void		 roffnode_pop(struct roff *);
static	enum rofft	 roff_parse(struct roff *, const char *, int *);

/* See roff_hash_find() */
d236 1
a236 1
roff_hash_init(void)
d261 1
a261 1
roff_hash_find(const char *p, size_t s)
d390 1
a390 1
	roff_hash_init();
d520 1
d538 15
a552 5
		} else if ('-' == *p) {
			if (mandoc_hyph(start, p))
				*p = ASCII_HYPH;
			p++;
		}
d682 1
a682 1
	    ? ROFF_USERDEF : roff_hash_find(mac, maclen);
@


1.153
log
@Use correct column of warning messages and make sure this function is
run even when `first_string' isn't defined.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.152 2011/07/26 14:09:01 kristaps Exp $ */
d162 1
a162 1
static	int		 roff_res(struct roff *, 
d403 2
a404 2
*/
static int
d416 1
a416 2
	/* Search for a leading backslash and save a pointer to it. */

d428 1
a428 1
			return(1);
d439 1
a439 1
			continue;
d452 1
a452 1
			return(1);
d475 1
a475 1
				return(1); 
d497 2
d510 1
a510 1
		return(0);
d512 1
d514 31
a544 1
	return(1);
d560 1
a560 2
	if ( ! roff_res(r, bufp, szp, ln, pos))
		return(ROFF_REPARSE);
d585 1
a585 1
		return(ROFF_CONT);
d591 1
a591 1
		return(ROFF_CONT);
@


1.152
log
@Move checking of escapes into roff.c, where we're already stepping
through looking for user-defined escapes.  This clears up a nice bit of
validation code.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.151 2011/07/25 15:37:00 kristaps Exp $ */
a397 1

d402 2
a403 1
 */
a435 2
			mandoc_msg(MANDOCERR_BADESCAPE, 
					r->parse, ln, pos, NULL);
d437 3
d471 7
a477 2
			if ('\0' == *cp)
				return(1); /* Error. */
d490 3
a492 2
			/* TODO: keep track of the correct position. */
			mandoc_msg(MANDOCERR_BADESCAPE, r->parse, ln, pos, NULL);
a514 1

d528 1
a528 1
	if (r->first_string && ! roff_res(r, bufp, szp, ln, pos))
@


1.151
log
@Implement the first steps of equation parsing from within libmdoc.
This consists of a shim around the text parser that calls out to libroff
if equation components exist on the line.  Right now this will do
nothing, as the equation delimiter always returns nil.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.150 2011/07/23 18:41:18 kristaps Exp $ */
d407 1
d430 9
a438 1
		if ('*' != *cp++)
d440 3
@


1.150
log
@Add support for tdefine and ndefine.  Consolidate some error messages.  Add
somem more version notes (getting there).  Have the equation nanme be captured.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.149 2011/07/21 15:21:13 kristaps Exp $ */
d587 1
a587 2
		eqn_end(r->eqn);
		r->eqn = NULL;
d593 1
a593 2
		tbl_end(r->tbl);
		r->tbl = NULL;
d1183 1
a1183 1
		tbl_end(r->tbl);
a1184 1
	r->tbl = NULL;
d1201 10
a1210 3
/* ARGSUSED */
static enum rofferr
roff_EQ(ROFF_ARGS)
d1212 2
a1213 1
	struct eqn_node	*e;
d1216 1
a1216 1
	e = eqn_alloc(*bufp + pos, ppos, ln, r->parse);
d1224 13
d1257 1
a1257 1
		tbl_end(r->tbl);
d1493 7
@


1.149
log
@Support `size' constructs in eqn.7.  Generalise mandoc_strontou to this
effect.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.148 2011/07/21 10:24:35 kristaps Exp $ */
d1211 1
a1211 1
	e = eqn_alloc(ppos, ln, r->parse);
@


1.148
log
@Finish the eqn syntactic parser.  This correctly parses terms and does
the proper `define' dance, which amounts to pure word-replace (you can,
say, define `foo' as `define' then define `define' as something else).
eqn.c is now ready for some semantic parsing of `box' and `eqn'
productions as defined by the grammar.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.147 2011/07/18 07:46:41 kristaps Exp $ */
d1152 1
a1152 1
		if ((iv = mandoc_strntou(val, strlen(val), 10)) >= 0)
@


1.147
log
@Make `struct roff' be passed into libmdoc and libman upon creation.
This is required for supporting in-line equations.  While here, push
registers properly into roff and add an set/get/mod interface.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.146 2011/07/17 12:13:37 kristaps Exp $ */
d586 1
a586 1
				r->eqn->eqn.line, r->eqn->eqn.pos, NULL);
@


1.146
log
@Add initial `define' support for eqn(7).
This works by iterating over a simple list.  It's a slow, auditable
early implementation.  Data is read (the reading function will be
reused) then parsed, then the line re-run if remaining stuff exists.
Note this function isn't the same as mandoc_getarg(), as eqn(7) uses a
different system for reading quoted strings.
This doesn't actually use the defines.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.145 2011/07/12 21:32:43 kristaps Exp $ */
d74 10
d95 1
a95 1
	struct regset	*regs; /* read/writable registers */
d364 2
d381 1
a381 1
roff_alloc(struct regset *regs, struct mparse *parse)
a386 1
	r->regs = regs;
d1118 20
a1145 1
	struct reg	*rg;
a1148 1
	rg = r->regs->regs;
d1151 1
a1151 1
		rg[(int)REG_nS].set = 1;
d1153 1
a1153 1
			rg[REG_nS].v.u = (unsigned)iv;
d1155 1
a1155 1
			rg[(int)REG_nS].v.u = 0u;
@


1.145
log
@Have equation be allocated with mparse.  Will be needed for logging of
messages.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.144 2011/07/08 09:28:33 kristaps Exp $ */
d522 1
a522 1
			return(eqn_read(&r->eqn, ln, *bufp, pos));
d528 1
a528 1
			return(eqn_read(&r->eqn, ln, *bufp, pos));
d533 1
a533 1
		return(eqn_read(&r->eqn, ln, *bufp, ppos));
@


1.144
log
@Fix two issues: the first, where a `.\}' wasn't being interpreted as a
proper macro in some conditions, resulting in strange parse errors.  The
second, where `\}' was being re-written as `\&'.  Instead, we re-write
this as two spaces OR nothing at all, if at the end of line.  This isn't
exactly what groff does (who knows...) but is a much safer and better
way than how I was doing it before.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.143 2011/06/30 08:05:13 kristaps Exp $ */
d1182 1
a1182 1
	e = eqn_alloc(ppos, ln);
@


1.143
log
@Ouch: predefined strings moved into roff.c weren't being reinitalised
after the first parse.  Do this, but note there are more efficient ways
just waiting for a table of macros.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.142 2011/05/26 11:58:25 kristaps Exp $ */
d599 2
a600 1
	if ('\0' == buf[*pos] || '"' == buf[*pos])
d603 6
d610 1
a610 1
	maclen = strcspn(mac, " \\\t\0");
d892 16
a907 1
			*ep = '&';
@


1.142
log
@If a predefined string is missing, emit a warning and make it an empty
string instead of passing it along to libmdoc/libman (where it'll be
printed verbatim, now).  This is what groff seems to do, too (of course
without a warning).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.141 2011/05/24 21:18:06 kristaps Exp $ */
d350 1
d353 3
@


1.141
log
@Most important move in getting predefined strings entirely contained
within roff.c.  These are now grokked from a table in the roff
allocation routine and rest in the newly-created predefs.in (for
consistency with chars.in).  This is a first implementation and will
likely be optimised along with the ds/de lookup table itself.

This allows mandoc-defined predefined strings to be correctly removed or
whatnot; earlier they couldn't.  What will follow is the stripping-away
of all predefined-string crud in the other parts of the system.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.140 2011/05/24 15:22:14 kristaps Exp $ */
d153 1
a153 1
				char **, size_t *, int);
d390 1
a390 1
roff_res(struct roff *r, char **bufp, size_t *szp, int pos)
d457 3
a459 2
			cp -= maxl ? 1 : 0;
			continue;
d495 1
a495 1
	if (r->first_string && ! roff_res(r, bufp, szp, pos))
@


1.140
log
@Have conditional closure for both text and macro lines call through to
ccond().  Fix the text handler to behave like the macro handler
regarding escaped \}.  Make \} actually become a zero-width space, too,
and clean up the documentation in this regard.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.139 2011/05/24 14:00:39 kristaps Exp $ */
d31 1
d64 1
a64 1
	ROFF_ccond, /* FIXME: remove this. */
d128 8
d207 6
a245 1

d368 1
d376 4
@


1.139
log
@Fix a TODO to the effect that `.if n \{\ foo .br \}' was failing due to
the `\}' not being directly after the `.br'.  Now we check for `\}' in
arbitrary parts of the line, and account for if it's escaped in funny
ways.

This behaviour diverges somewhat from groff in that the text at and
following the `\}' is lost, while groff keeps it (sort-of).  I'll add a
COMPATIBILITY note to this effect.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.138 2011/05/14 16:06:08 kristaps Exp $ */
a855 5
		/*
		 * Jump through hoops to detect a \}, because it could
		 * be (say) \\}, which is something completely
		 * different.
		 */
d861 1
a861 1
			*--ep = '\0';
a884 1

d889 1
a889 1
	char		*ep, *st;
d893 1
d895 8
a902 11
	/*
	 * We display the value of the text if out current evaluation
	 * scope permits us to do so.
	 */

	/* FIXME: use roff_ccond? */

	st = &(*bufp)[pos];
	if (NULL == (ep = strstr(st, "\\}"))) {
		roffnode_cleanscope(r);
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);
a903 5

	if (ep == st || (ep > st && '\\' != *(ep - 1)))
		roffnode_pop(r);

	roffnode_cleanscope(r);
a906 1

@


1.138
log
@Move roff.c's strtol into libmandoc.h for use by other parts of the code
(which will come).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.137 2011/04/24 23:51:17 schwarze Exp $ */
d843 1
d846 1
d848 5
a852 3
	/* 
	 * Clean out scope.  If we've closed ourselves, then don't
	 * continue. 
a854 2
	roffnode_cleanscope(r);

d856 15
a870 4
		if ('\\' == (*bufp)[pos] && '}' == (*bufp)[pos + 1])
			return(roff_ccond
				(r, ROFF_ccond, bufp, szp,
				 ln, pos, pos + 2, offs));
d879 1
@


1.137
log
@User defined macros may invoke high-level macros.
The latter got lost due to a regression in rev. 1.130.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.136 2011/04/19 16:38:48 kristaps Exp $ */
a22 1
#include <errno.h>
a23 1
#include <limits.h>
a25 1
#include <stdio.h>
a205 1
static	int		 roff_parse_nat(const char *, unsigned int *);
a591 21

static int
roff_parse_nat(const char *buf, unsigned int *res)
{
	char		*ep;
	long		 lval;

	errno = 0;
	lval = strtol(buf, &ep, 10);
	if (buf[0] == '\0' || *ep != '\0')
		return(0);
	if ((errno == ERANGE && 
			(lval == LONG_MAX || lval == LONG_MIN)) ||
			(lval > INT_MAX || lval < 0))
		return(0);

	*res = (unsigned int)lval;
	return(1);
}


d1068 1
d1077 4
a1080 2
		if ( ! roff_parse_nat(val, &rg[(int)REG_nS].v.u))
			rg[(int)REG_nS].v.u = 0;
@


1.136
log
@Clean up parsing of delimiters in -mdoc.  First, remove the "dowarn"
variable from mandoc_getarg() so that it prints the warning every time.
Then, remove the warning from args_checkpunct().  This way, warnings
are being posted at the correct time.  This makes the flag argument to
mdoc_zargs() superfluous, so make it be zero when it's invoked.  Finally,
move the args() flags into mdoc_argv.c and make them enums.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.135 2011/04/17 09:08:19 kristaps Exp $ */
d832 1
a832 2
	if (ROFF_MAX == (t = roff_parse(r, *bufp, &pos)))
		return(ROFF_IGN);
@


1.135
log
@Get mdoc_argv.c ready to use [some of] mandoc_getarg() by giving said
function a parameter to suppress warnings.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.134 2011/04/13 16:26:11 kristaps Exp $ */
d1241 1
a1241 1
		    mandoc_getarg(r->parse, &cp, ln, 1, &pos);
@


1.134
log
@Check in fix to roff conditional if/else stack running out of space.
This transforms the stack pop to occur prior to body execution, instead
of afterward.  Floated to tech@@ without response, but it makes sense
that this is alright and doesn't cause problems during extensive
testing.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.133 2011/04/13 10:01:27 kristaps Exp $ */
d1241 1
a1241 1
		    mandoc_getarg(r->parse, &cp, ln, &pos);
@


1.133
log
@Back out commit to roff.c that needs to go in on its own.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.131 2011/04/05 22:22:33 schwarze Exp $ */
a279 4
	if (ROFF_el == p->tok)
		if (r->rstackpos > -1)
			r->rstackpos--;

d975 7
a981 1
	/* Stack overflow! */
d983 4
a986 18
	if (ROFF_ie == tok && r->rstackpos == RSTACK_MAX - 1) {
		mandoc_msg(MANDOCERR_MEM, r->parse, ln, ppos, NULL);
		return(ROFF_ERR);
	}

	/* First, evaluate the conditional. */

	if (ROFF_el == tok) {
		/* 
		 * An `.el' will get the value of the current rstack
		 * entry set in prior `ie' calls or defaults to DENY.
	 	 */
		if (r->rstackpos < 0)
			rule = ROFFRULE_DENY;
		else
			rule = r->rstack[r->rstackpos];
	} else
		rule = roff_evalcond(*bufp, &pos);
a988 1

d1008 5
d1014 8
a1021 9
		/*
		 * An if-else will put the NEGATION of the current
		 * evaluated conditional into the stack.
		 */
		r->rstackpos++;
		if (ROFFRULE_DENY == r->last->rule)
			r->rstack[r->rstackpos] = ROFFRULE_ALLOW;
		else
			r->rstack[r->rstackpos] = ROFFRULE_DENY;
@


1.132
log
@Remove TODO from prior commit of lifting warnings from `Sh', `Ss', `SH',
and `SS' bodies.
@
text
@d280 4
d979 8
a986 7
	/* 
	 * An `.el' has no conditional body: it will consume the value
	 * of the current rstack entry set in prior `ie' calls or
	 * defaults to DENY.  
	 *
	 * If we're not an `el', however, then evaluate the conditional.
	 */
d988 11
a998 4
	rule = ROFF_el == tok ?
		(r->rstackpos < 0 ? 
		 ROFFRULE_DENY : r->rstack[r->rstackpos--]) :
		roff_evalcond(*bufp, &pos);
d1001 1
a1020 5
	/*
	 * An if-else will put the NEGATION of the current evaluated
	 * conditional into the stack of rules.
	 */

d1022 9
a1030 8
		if (r->rstackpos == RSTACK_MAX - 1) {
			mandoc_msg(MANDOCERR_MEM, 
				r->parse, ln, ppos, NULL);
			return(ROFF_ERR);
		}
		r->rstack[++r->rstackpos] = 
			ROFFRULE_DENY == r->last->rule ?
			ROFFRULE_ALLOW : ROFFRULE_DENY;
@


1.131
log
@On .de macro lines, after the macro name, space and tab are equivalent.
Bug reported by Tristan dot LeGuern at gmail dot com in fvwm2(1).
tweaks and ok kristaps@@; earlier version looked good to espie@@ as well
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.130 2011/03/29 09:00:48 kristaps Exp $ */
a279 4
	if (ROFF_el == p->tok)
		if (r->rstackpos > -1)
			r->rstackpos--;

d975 7
a981 1
	/* Stack overflow! */
d983 4
a986 18
	if (ROFF_ie == tok && r->rstackpos == RSTACK_MAX - 1) {
		mandoc_msg(MANDOCERR_MEM, r->parse, ln, ppos, NULL);
		return(ROFF_ERR);
	}

	/* First, evaluate the conditional. */

	if (ROFF_el == tok) {
		/* 
		 * An `.el' will get the value of the current rstack
		 * entry set in prior `ie' calls or defaults to DENY.
	 	 */
		if (r->rstackpos < 0)
			rule = ROFFRULE_DENY;
		else
			rule = r->rstack[r->rstackpos];
	} else
		rule = roff_evalcond(*bufp, &pos);
a988 1

d1008 5
d1014 8
a1021 9
		/*
		 * An if-else will put the NEGATION of the current
		 * evaluated conditional into the stack.
		 */
		r->rstackpos++;
		if (ROFFRULE_DENY == r->last->rule)
			r->rstack[r->rstackpos] = ROFFRULE_ALLOW;
		else
			r->rstack[r->rstackpos] = ROFFRULE_DENY;
@


1.130
log
@Carefully let mandoc_getcontrol() handle libroff's detection of a macro
line.  Note that we now properly ignore \.", which earlier would have
been pushed through macro detection.  This required attention to all
entries of roff_parse().

This removes a TODO by schwarze@@ to the effect that \. can be a control
character, which is now handled in mandoc_getcontrol().
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.129 2011/03/22 09:50:11 kristaps Exp $ */
d742 1
a742 1
		while ((*bufp)[pos] && ' ' != (*bufp)[pos])
d745 1
a745 1
		while (' ' == (*bufp)[pos])
d766 1
a766 3
	while ((*bufp)[pos] &&
			' ' != (*bufp)[pos] && 
			'\t' != (*bufp)[pos])
@


1.129
log
@Step 2: blow away roff.h, as all of its functions have been moved into
libmandoc.h and there's nothing left.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.128 2011/03/20 16:02:05 kristaps Exp $ */
a35 3
#define	ROFF_CTL(c) \
	('.' == (c) || '\'' == (c))

d476 1
a476 1
	int		 ppos;
d486 3
d497 1
a497 1
	if (r->last && ! ROFF_CTL((*bufp)[pos])) {
d506 1
a506 1
			return(eqn_read(&r->eqn, ln, *bufp, *offs));
d508 1
a508 1
			return(tbl_read(r->tbl, ln, *bufp, *offs));
d510 1
a510 1
	} else if ( ! ROFF_CTL((*bufp)[pos])) {
d512 1
a512 1
			return(eqn_read(&r->eqn, ln, *bufp, *offs));
d514 1
a514 1
			return(tbl_read(r->tbl, ln, *bufp, *offs));
d517 1
a517 1
		return(eqn_read(&r->eqn, ln, *bufp, *offs));
d530 1
a530 1
				 ln, pos, pos, offs));
a538 1
	ppos = pos;
a571 1

d583 1
a583 7
	assert(ROFF_CTL(buf[*pos]));
	(*pos)++;

	while (' ' == buf[*pos] || '\t' == buf[*pos])
		(*pos)++;

	if ('\0' == buf[*pos])
d593 1
d812 1
a812 5
		i = pos + 1;
		while (' ' == (*bufp)[i] || '\t' == (*bufp)[i])
			i++;

		for (j = 0; r->last->end[j]; j++, i++)
d823 4
d838 2
a839 2
	ppos = pos;
	t = roff_parse(r, *bufp, &pos);
a875 1
	ppos = pos;
@


1.128
log
@Consolidate messages.  Have all parse-time messages (in libmdoc,
libroff, etc., etc.) route into mandoc_msg() and mandoc_vmsg(), for the
time being in libmandoc.h.  This requires struct mparse to be passed
into the allocation routines instead of mandocmsg and a void pointer.
Then, move some of the functionality of the old mmsg() into read.c's
mparse_mmsg() (check against wlevel and setting of file_status) and use
main.c's mmsg() as simply a printing tool.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.127 2011/03/15 16:23:51 kristaps Exp $ */
a30 1
#include "roff.h"
@


1.127
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.126 2011/02/09 09:05:52 kristaps Exp $ */
d87 1
a88 2
	mandocmsg	 msg; /* err/warn/fatal messages */
	void		*data; /* privdata for messages */
d363 1
a363 1
roff_alloc(struct regset *regs, void *data, const mandocmsg msg)
d369 1
a369 2
	r->msg = msg;
	r->data = data;
d556 1
a556 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data,
d560 1
a560 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
d567 1
a567 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
d640 1
a640 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d659 1
a659 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d664 1
a664 1
		(*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL);
d691 1
a691 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d703 1
a703 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d708 1
a708 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d713 1
a713 1
		(*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL);
d733 1
a733 1
			(*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL);
d747 1
a747 1
			(*r->msg)(MANDOCERR_REQUEST, r->data, ln, ppos,
d797 1
a797 1
		(*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL);
d978 1
a978 1
		(*r->msg)(MANDOCERR_REQUEST, r->data, ln, ppos, "it");
d993 1
a993 1
		(*r->msg)(MANDOCERR_MEM, r->data, ln, ppos, NULL);
d1024 1
a1024 1
		(*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL);
d1151 1
a1151 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d1165 1
a1165 1
		(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d1195 1
a1195 1
	(*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL);
d1206 1
a1206 1
		(*r->msg)(MANDOCERR_SCOPEBROKEN, r->data, ln, ppos, NULL);
d1210 1
a1210 1
	t = tbl_alloc(ppos, ln, r->data, r->msg);
d1227 1
a1227 1
	(*r->msg)(MANDOCERR_SO, r->data, ln, ppos, NULL);
d1238 1
a1238 1
		(*r->msg)(MANDOCERR_SOPATH, r->data, ln, pos, NULL);
d1261 1
a1261 1
		    mandoc_getarg(&cp, r->msg, r->data, ln, &pos);
d1317 1
a1317 1
		(*r->msg)(MANDOCERR_NAMESC, r->data, ln, pos, NULL);
@


1.126
log
@Allow EQN data to be pushed down into libmdoc via mdoc_addeqn().  Only
the adding itself is implemented; equation data is not yet shown.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.125 2011/02/06 20:36:36 kristaps Exp $ */
d603 1
a603 1
	*pos += maclen;
d1140 1
a1140 1
		name = roff_getname(r, &cp, ln, cp - *bufp);
d1375 1
a1375 1
	newch = strlen(string) + (multiline ? 2 : 1);
d1386 1
a1386 1
	c = n->string + oldch;
@


1.125
log
@Add initial EQN support to mandoc.  This parses, then throws away, data
between EQ and EN roff blocks.  EQN is different from TBL in that data
after .EQ is unilaterally considered an equation until an .EN.  Thus,
there's no need to jump through hoops in having table spans and so on.
This is ONLY the parse code framework in libroff.  EQN is not yet passed
into the backends.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.124 2011/01/25 01:12:02 schwarze Exp $ */
d563 1
a563 1
				r->eqn->line, r->eqn->pos, NULL);
@


1.124
log
@Ignore .ns (no-space mode), .ps (change point size), .ta (tab control)
for now.  All of these just cause a bit too much or too little
whitespace, but no serious formatting problems.
Triggered by reports from brad@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.123 2011/01/22 13:16:02 schwarze Exp $ */
d67 2
d98 3
d159 2
d199 2
d323 1
d325 1
a325 2
	while (r->first_tbl) {
		t = r->first_tbl;
d332 7
d496 2
d506 5
a510 1
		if (ROFF_CONT == e && r->tbl)
d512 1
a512 1
		return(e);
d514 2
d519 2
a520 1
	}
d525 1
d561 7
d1176 27
a1302 1

a1335 1

a1404 1

a1416 1

d1438 7
@


1.123
log
@When finding the roff .it request (line trap),
make it clear that you cannot use mandoc to format that page (yet).
Triggered by a report from brad@@, ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.122 2011/01/16 04:00:34 schwarze Exp $ */
d58 2
d62 1
d183 2
d187 1
@


1.122
log
@Implement the roff .rm request (remove macro).
Using the new roff_getname() function, this is really simple.
Breaks mandoc of the habit of reporting an error in each pod2man(1) preamble.
Reminded by a report from brad@@; ok kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.121 2011/01/11 00:11:45 schwarze Exp $ */
d54 1
d176 1
d940 3
@


1.121
log
@Refactoring in preparation for .rm support:
Unify parsing of names given as roff request arguments into a new
function roff_getname(), which is rather different from the parsing
function for normal arguments, mandoc_getarg(), because names cannot
be quoted and cannot contain whitespace or escaped characters.
The new function now throws an ERROR when finding escaped characters
in a name.
"I'm fine with this." kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.120 2011/01/03 23:24:16 schwarze Exp $ */
a140 1
static	enum rofferr	 roff_line_error(ROFF_ARGS);
d144 1
d178 1
a178 1
	{ "rm", roff_line_error, NULL, NULL, 0, NULL },
a942 9
roff_line_error(ROFF_ARGS)
{

	(*r->msg)(MANDOCERR_REQUEST, r->data, ln, ppos, roffs[tok].name);
	return(ROFF_IGN);
}

/* ARGSUSED */
static enum rofferr
d1089 16
@


1.120
log
@Calling a macro with fewer arguments than it is defined with is OK;
the remaining ones default to the empty string, not to NULL.
Regression reported and fix tested by kristaps@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.119 2011/01/03 22:42:37 schwarze Exp $ */
d137 1
d524 1
a524 1
		(*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
d1060 2
a1061 1
	name = *bufp + pos;
d1065 2
a1066 15
	string = name;
	/* Read until end of name. */
	while (*string && ' ' != *string)
		string++;

	/* Nil-terminate name. */
	if (*string)
		*(string++) = '\0';
	
	/* Read past spaces. */
	while (*string && ' ' == *string)
		string++;

	/* Read passed initial double-quote. */
	if (*string && '"' == *string)
d1079 2
a1080 1
	const char	*key, *val;
d1083 2
a1084 1
	key = &(*bufp)[pos];
a1086 19
	/* Parse register request. */
	while ((*bufp)[pos] && ' ' != (*bufp)[pos])
		pos++;

	/*
	 * Set our nil terminator.  Because this line is going to be
	 * ignored anyway, we can munge it as we please.
	 */
	if ((*bufp)[pos])
		(*bufp)[pos++] = '\0';

	/* Skip whitespace to register token. */
	while ((*bufp)[pos] && ' ' == (*bufp)[pos])
		pos++;

	val = &(*bufp)[pos];

	/* Process register token. */

d1225 35
@


1.119
log
@Unify roff macro argument parsing (in roff.c, roff_userdef()) and man macro
argument parsing (in man_argv.c, man_args()), both having different bugs,
to use one common macro argument parser (in mandoc.c, mandoc_getarg()),
because from the point of view of roff, man macros are just roff macros,
hence their arguments are parsed in exactly the same way.

While doing so, fix these bugs:
 * Escaped blanks (i.e. those preceded by an odd number of backslashes)
   were mishandled as argument separators in unquoted arguments to
   user-defined roff macros.
 * Unescaped blanks preceded by an even number of backslashes were not
   recognized as argument separators in unquoted arguments to man macros.
 * Escaped backslashes (i.e. pairs of backslashes) were not reduced
   to single backslashes both in unquoted and quoted arguments both
   to user-defined roff macros and to man macros.
 * Escaped quotes (i.e. pairs of quotes inside quoted arguments) were
   not reduced to single quotes in man macros.

OK kristaps@@

Note that mdoc macro argument parsing is yet another beast for no good
reason and is probably afflicted by similar bugs.  But i don't attempt
to fix that right now because it is intricately entangled with lots of
unrelated high-level mdoc(7) functionality, like delimiter handling and
column list phrase handling.  Disentagling that would waste too much
time now.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.118 2011/01/02 10:10:57 kristaps Exp $ */
d1212 1
a1212 1
		arg[i] = '\0' == *cp ? NULL :
@


1.118
log
@Churn to get parts of 'struct tbl' visible from mandoc.h: rename the
existing 'struct tbl' as 'struct tbl_node', then move all option stuff
into a 'struct tbl' in mandoc.h.

This conflicted with a structure in chars.c, which was renamed.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.117 2011/01/01 16:18:39 kristaps Exp $ */
d3 2
a4 2
 * Copyright (c) 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2010 Ingo Schwarze <schwarze@@openbsd.org>
d1204 1
a1204 1
	int		  i, quoted, pairs;
d1211 3
a1213 40
	for (i = 0; i < 9; i++) {
		/* Quoting can only start with a new word. */
		if ('"' == *cp) {
			quoted = 1;
			cp++;
		} else
			quoted = 0;
		arg[i] = cp;
		for (pairs = 0; '\0' != *cp; cp++) {
			/* Unquoted arguments end at blanks. */
			if (0 == quoted) {
				if (' ' == *cp)
					break;
				continue;
			}
			/* After pairs of quotes, move left. */
			if (pairs)
				cp[-pairs] = cp[0];
			/* Pairs of quotes do not end words, ... */
			if ('"' == cp[0] && '"' == cp[1]) {
				pairs++;
				cp++;
				continue;
			}
			/* ... but solitary quotes do. */
			if ('"' != *cp)
				continue;
			if (pairs)
				cp[-pairs] = '\0';
			*cp = ' ';
			break;
		}
		/* Last argument; the remaining ones are empty strings. */
		if ('\0' == *cp)
			continue;
		/* Null-terminate argument and move to the next one. */
		*cp++ = '\0';
		while (' ' == *cp)
			cp++;
	}
@


1.117
log
@More checks for proper table exit.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.116 2011/01/01 16:10:40 kristaps Exp $ */
d89 3
a91 3
	struct tbl	*first_tbl; /* first table parsed */
	struct tbl	*last_tbl; /* last table parsed */
	struct tbl	*tbl; /* current table being parsed */
d304 1
a304 1
	struct tbl	*t;
d1155 1
a1155 1
	struct tbl	*t;
@


1.116
log
@Raise an error if a table is closed without data.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.115 2011/01/01 15:45:18 kristaps Exp $ */
d518 1
a518 1
int
a521 1
	/* FIXME: if r->tbl */
d525 7
a531 1
	return(1);
@


1.115
log
@Add documentation bits for libroff's new roff_span().

Add bits to remember tbl's invocation point.

Add ERROR class message if no data's in the table.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.114 2010/12/31 18:19:43 kristaps Exp $ */
d1141 1
a1141 1
		tbl_restart(r->tbl);
@


1.114
log
@Expose the parsed table API to the world and add accessors through the
roff.h interface.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.113 2010/12/31 14:52:41 kristaps Exp $ */
d1126 2
d1152 1
a1152 1
	if (r->tbl)
d1154 2
d1157 1
a1157 1
	t = tbl_alloc(r->data, r->msg);
@


1.113
log
@Put parsed tables into a queue that's cleared at the end of parsing.
This completes the parsing phase of the new tbl implementation.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.112 2010/12/29 14:53:31 kristaps Exp $ */
d1378 7
@


1.112
log
@Add handling for `T&', which restarts a table except for its options.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.111 2010/12/29 01:16:57 kristaps Exp $ */
d89 3
a91 1
	struct tbl	*tbl;
d304 1
d306 4
a309 3
	if (r->tbl) {
		tbl_free(r->tbl);
		r->tbl = NULL;
d312 2
a1125 2
	else
		tbl_free(r->tbl);
d1148 1
d1150 1
a1150 1
	if (r->tbl) {
a1151 3
		tbl_reset(r->tbl);
	} else
		r->tbl = tbl_alloc(r->data, r->msg);
d1153 8
@


1.111
log
@Significant update to options handling, which now departs almost
completely with the BSD.lv code due to performance issues and flat-out
errors.

Performance issues: functions called per character.  Ugly.

Flat-out errors: disallowing "reserved" tokens as arguments to those
options accepting arguments.

Also added are two mandoc.h error codes for general tbl syntax errors
and for bad options.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.110 2010/12/28 10:59:07 kristaps Exp $ */
d62 1
d147 1
d180 1
d1129 13
@


1.110
log
@Temporarily remove check for r->tbl at end of parse since we need the
original parse point to generate a useful error message.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.109 2010/12/28 10:51:03 kristaps Exp $ */
d1133 1
a1133 1
		r->tbl = tbl_alloc();
@


1.109
log
@Initial tbl framework.  Parse point is in libroff, which keeps a
reference to a current tbl parse and routes ALL text into the tbl parse
after stripping reserved words and making block-level pre-processing
(e.g., `ig').  This is consistent with an analysis of embedded `TS/TE'
in manuals with sprinkled -mdoc, roff, and -man macros.

Fact of a parse is exposed to main.c by a return value (ROFF_TBL), which
will trigger main.c to add a foreign parsed body to the -mdoc or -man
parse stream.  This interface isn't in yet, but will follow the
parse-text functions in both libraries.  I put this login in main.c
because I don't want libroff calling directly into libmdoc or libman.

As a consequence, a parsed row can be pushed directly into any -mdoc or
-man context (put a `Bd -literal -offset indent' into a `TE/TS' block to
see why this is necessary).  It will then absorb formatting cues in the
front-ends.

A note on naming.  I decided on libroff.h instead of tbl.h because this
is purely within the roff layer.  Separate tbl implementations will
need, then, to interface with libroff.  This is "how it should be"
because tbl is tightly linked with roff in terms of `ds' and other
formatting macros, as well as, of course, special characters and other
roffisms.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.108 2010/12/21 01:46:44 schwarze Exp $ */
d513 2
a514 1
	if (r->last || r->tbl)
@


1.108
log
@Sync to OpenBSD:
1) Now that growing buffers in main.c is safe, bring back the bugfix
distinguishing empty and undefined macros that was backed out in
the previous roff.c commit:  `de' initializes to "", not to NULL.
2) Roff only interpolates \* strings when the leading backslash is
not escaped; using optimizations suggested by joerg@@ and kristaps@@.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.24 2010/12/21 01:30:58 schwarze Exp $ */
d32 1
a39 8
#if 1
#define	ROFF_DEBUG(fmt, args...) \
	do { /* Nothing. */ } while (/*CONSTCOND*/ 0)
#else
#define	ROFF_DEBUG(fmt, args...) \
	do { fprintf(stderr, fmt , ##args); } while (/*CONSTCOND*/ 0)
#endif

d60 2
a72 1

d88 1
d144 2
d176 2
a265 1
	ROFF_DEBUG("roff: popping scope\n");
d300 5
d307 1
a423 2
		ROFF_DEBUG("roff: splicing reserved: [%.*s]\n", i, st);

d447 1
d467 9
a475 6
		ROFF_DEBUG("roff: intercept scoped text: %s, [%s]\n", 
				roffs[t].name, &(*bufp)[pos]);
		return((*roffs[t].text)
				(r, t, bufp, szp, 
				 ln, pos, pos, offs));
	} else if ( ! ROFF_CTL((*bufp)[pos]))
d477 1
a486 2
		ROFF_DEBUG("roff: intercept scoped context: %s, [%s]\n", 
				roffs[t].name, &(*bufp)[pos]);
a501 4
	ROFF_DEBUG("roff: intercept new-scope: [%s], [%s]\n", 
			ROFF_USERDEF == t ? r->current_string : roffs[t].name, 
			&(*bufp)[pos]);

d513 4
a516 4
	if (NULL == r->last)
		return(1);
	return((*r->msg)(MANDOCERR_SCOPEEXIT, r->data, r->last->line, 
				r->last->col, NULL));
d585 1
a585 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d604 1
a604 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d609 1
a609 2
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL))
			return(ROFF_ERR);
d636 1
a636 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d648 1
a648 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d653 1
a653 2
		if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
d658 1
a658 2
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL))
			return(ROFF_ERR);
a982 3
	ROFF_DEBUG("roff: cond: %s -> %s\n", roffs[tok].name, 
			ROFFRULE_ALLOW == rule ?  "allow" : "deny");

d997 1
a997 1
	if (r->last->parent && ROFFRULE_DENY == r->last->parent->rule) {
a998 3
		ROFF_DEBUG("roff: cond override: %s -> deny\n",
				roffs[tok].name);
	}
d1011 1
a1011 5
		ROFF_DEBUG("roff: cond-scope: %s, multi-line\n", 
				roffs[tok].name);
	} else
		ROFF_DEBUG("roff: cond-scope: %s, one-line\n", 
				roffs[tok].name);
d1104 23
d1128 3
a1130 2
		ROFF_DEBUG("roff: register nS: %u\n", 
				rg[(int)REG_nS].v.u);
d1132 1
a1132 1
		ROFF_DEBUG("roff: ignoring register: %s\n", key);
@


1.107
log
@Track down a bug of empty `de XX' macros causing uncertain behaviour by
returning empty strings in roff_getstrn() instead of NULL.  This caused
maddeningly irregular segfaults in the pod2man preamble for `de IX'.
But only on DEC alpha.

Also integrate the kinda-probably-safe assertion relaxation in term.c,
field-tested by schwarze@@.  This allows ALL [unpreprocessed] base and
xenocara manuals for all BSD systems to run without segfault.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.106 2010/12/02 10:53:03 kristaps Exp $ */
d349 4
a352 1
	const char	*cp, *cpp, *st, *res;
d357 23
a379 3
	/* LINTED */
	for (cp = &(*bufp)[pos]; (cpp = strstr(cp, "\\*")); cp++) {
		cp = cpp + 2;
d381 2
d395 1
d397 1
a397 1
		st = cp;
d406 6
a411 1
		res = roff_getstrn(r, st, (size_t)i);
d418 2
d425 1
a425 3
		*n = '\0';

		strlcat(n, *bufp, (size_t)(cpp - *bufp + 1));
d597 1
d717 1
a717 1
		roff_setstr(r, name, NULL, 0);
d725 1
a725 1
	while ((*bufp)[pos] && 
@


1.106
log
@Merge schwarze@@'s changes to allow for user-defined strings.  This
primarily adds a roff_userdef() function for parsing new defines and
modifies the look-up procedure.

NOTE: there is a bug hidden away in this update that causes an infinite
loop in some pages.  The cause is for the moment unknown.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.105 2010/12/01 16:54:25 kristaps Exp $ */
d466 4
a469 2
	ROFF_DEBUG("roff: intercept new-scope: %s, [%s]\n", 
			roffs[t].name, &(*bufp)[pos]);
d655 6
d668 1
d671 1
d683 1
d685 1
a685 1
		roff_setstr(r, name, "", 0);
d690 2
d693 2
a694 1
	while ((*bufp)[pos] && ' ' != (*bufp)[pos] && 
d716 1
a716 2
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, pos, NULL))
			return(ROFF_ERR);
d949 2
a950 3
		if ((*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL))
			return(ROFF_IGN);
		return(ROFF_ERR);
@


1.105
log
@Merge OpenBSD's `so' handling (plus some documentation).  Great work to
schwarze@@ and joerg@@ for his comments!
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.104 2010/12/01 10:31:35 kristaps Exp $ */
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d69 1
d92 2
a93 1
	struct roffstr	*first_string;
d101 1
d147 1
a147 1
				const char *, const char *);
d149 1
a149 1
static	char		*roff_strdup(const char *);
d181 1
d185 1
a185 1
static	enum rofft	 roff_hash_find(const char *);
d188 2
a189 2
static	void		 roffnode_push(struct roff *, 
				enum rofft, int, int);
d191 1
a191 1
static	enum rofft	 roff_parse(const char *, int *);
d203 1
a203 1
	for (i = 0; i < (int)ROFF_MAX; i++) {
d224 1
a224 1
roff_hash_find(const char *p)
d244 1
a244 1
		if (0 == strcmp(n->name, p))
d269 2
a270 2
	if (p->end)
		free(p->end);
d280 2
a281 1
roffnode_push(struct roff *r, enum rofft tok, int line, int col)
d287 2
d422 1
a422 1
		return(ROFF_RERUN);
d463 1
a463 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
d491 1
a491 1
roff_parse(const char *buf, int *pos)
d493 2
a494 2
	int		 j;
	char		 mac[5];
d500 1
a500 1
	while (buf[*pos] && (' ' == buf[*pos] || '\t' == buf[*pos]))
d506 2
a507 8
	for (j = 0; j < 4; j++, (*pos)++)
		if ('\0' == (mac[j] = buf[*pos]))
			break;
		else if (' ' == buf[*pos] || (j && '\\' == buf[*pos]))
			break;

	if (j == 4 || j < 1)
		return(ROFF_MAX);
d509 2
a510 4
	mac[j] = '\0';

	if (ROFF_MAX == (t = roff_hash_find(mac)))
		return(t);
d512 1
a566 2
	case (ROFF_de1):
		/* FALLTHROUGH */
d644 3
d648 12
a659 5
	if (ROFF_ig != tok && '\0' == (*bufp)[pos]) {
		if ( ! (*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
		return(ROFF_IGN);
	} else if (ROFF_ig != tok) {
d663 1
a663 1
			pos++;
d666 9
a674 1
	roffnode_push(r, tok, ln, ppos);
d741 1
a741 1
			if (ROFF_MAX != roff_parse(*bufp, &pos))
d753 1
a753 1
	t = roff_parse(*bufp, &pos);
d755 7
a761 2
	/* If we're not a comment-end, then throw it away. */
	if (ROFF_cblock != t)
d763 1
d776 3
d800 1
a800 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos))) {
d803 1
a803 1
				(r, ROFF_ccond, bufp, szp, 
d941 1
a941 1
	roffnode_push(r, tok, ln, ppos);
d1038 1
a1038 1
	roff_setstr(r, name, string);
d1110 3
a1112 2
static char *
roff_strdup(const char *name)
d1114 49
a1162 1
	char		*namecopy, *sv;
d1164 2
a1165 3
	/* 
	 * This isn't a nice simple mandoc_strdup() because we must
	 * handle roff's stupid double-escape rule. 
d1167 20
a1186 5
	sv = namecopy = mandoc_malloc(strlen(name) + 1);
	while (*name) {
		if ('\\' == *name && '\\' == *(name + 1))
			name++;
		*namecopy++ = *name++;
d1189 11
a1199 2
	*namecopy = '\0';
	return(sv);
d1202 6
a1207 1

d1209 2
a1210 1
roff_setstr(struct roff *r, const char *name, const char *string)
d1213 2
a1214 1
	char		 *namecopy;
d1216 1
d1222 1
a1222 1
		namecopy = mandoc_strdup(name);
d1224 2
a1225 1
		n->name = namecopy;
d1228 2
a1229 1
	} else
d1231 33
d1265 4
a1268 3
	/* Don't use mandoc_strdup: clean out double-escapes. */
	n->string = string ? roff_strdup(string) : NULL;
	ROFF_DEBUG("roff: new symbol: [%s] = [%s]\n", name, n->string);
@


1.104
log
@Re-ordering of roff requests as per OpenBSD.

Made `rm' be an error (again, OpenBSD...).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.103 2010/12/01 10:21:25 kristaps Exp $ */
d65 1
d145 1
d174 1
d1060 24
@


1.103
log
@Low-hanging fruit: add OpenBSD's `ad', `hy', `ne', and `nh' handling.

Rename roff_line() -> roff_line_ignore().
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.102 2010/09/04 20:18:53 kristaps Exp $ */
d63 1
a67 1
	ROFF_nr,
d138 1
d170 2
a171 1
	{ "rm", roff_line_ignore, NULL, NULL, 0, NULL },
a174 1
	{ "nr", roff_nr, NULL, NULL, 0, NULL },
a849 1

d858 8
@


1.102
log
@Churny commit to quiet lint.  No functional changes.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.101 2010/09/04 18:31:44 kristaps Exp $ */
d48 1
d57 1
d61 2
d137 1
a137 1
static	enum rofferr	 roff_line(ROFF_ARGS);
d154 1
d163 1
d167 4
a170 2
	{ "rm", roff_line, NULL, NULL, 0, NULL },
	{ "tr", roff_line, NULL, NULL, 0, NULL },
d852 1
a852 1
roff_line(ROFF_ARGS)
@


1.101
log
@Fix premature return from sub-conditional roff statements.  This fix
fully accomodates for the pod2man standard preamble!
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.100 2010/08/29 11:29:51 kristaps Exp $ */
a751 1
	struct roffnode	*l;
a760 1
	l = r->last;
@


1.100
log
@Allow `.xx\}' where xx is a macro (e.g., `.br\}') to close scope.  This is
experimental and hasn't been rigorously tested.  It's only implemented in
-mdoc for the time being.  This is absolutely required for pod2man.  It
does, however, make the pod2man preamble be processed in full.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.99 2010/08/24 12:48:43 kristaps Exp $ */
d251 1
d430 2
a431 2
		ROFF_DEBUG("roff: intercept scoped context: %s\n", 
				roffs[t].name);
a764 3
	if (l != r->last)
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);

@


1.99
log
@Have the `ds' processor strip out `\\' as stipulated in groff.7.  I only
care because pod2man uses this construct.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.98 2010/08/20 01:02:07 schwarze Exp $ */
d62 1
a62 1
	ROFF_ccond,
d767 5
a771 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
d773 1
d805 2
@


1.98
log
@Implement a simple, consistent user interface for error handling.
We now have sufficient practical experience to know what we want,
so this is intended to be final:
- provide -Wlevel (warning, error or fatal) to select what you care about
- provide -Wstop to stop after parsing a file with warnings you care about
- provide consistent exit status codes for those warnings you care about
- fully document what warnings, errors and fatal errors mean
- remove all other cruft from the user interface, less is more:
- remove all -f knobs along with the whole -f option
- remove the old -Werror because calling warnings "fatal" is silly
- always finish parsing each file, unless fatal errors prevent that
This commit also includes a couple of related simplifications behind
the scenes regarding error handling.
Feedback and OK  kristaps@@;  Joerg Sonnenberger (NetBSD) and
Sascha Wildner (DragonFly BSD) agree with the general direction.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.97 2010/07/27 19:56:50 kristaps Exp $ */
d139 1
d1039 21
d1079 3
a1081 2
	ROFF_DEBUG("roff: new symbol: [%s] = [%s]\n", name, string);
	n->string = string ? strdup(string) : NULL;
@


1.97
log
@No-op to shut up lint.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.96 2010/07/27 13:16:00 kristaps Exp $ */
d171 1
a171 1
static	int		 roffnode_push(struct roff *, 
d261 1
a261 1
static int
d266 1
a266 5
	if (NULL == (p = calloc(1, sizeof(struct roffnode)))) {
		(*r->msg)(MANDOCERR_MEM, r->data, line, col, NULL);
		return(0);
	}

a273 1
	return(1);
d305 1
a305 1
roff_alloc(struct regset *regs, const mandocmsg msg, void *data)
d309 1
a309 5
	if (NULL == (r = calloc(1, sizeof(struct roff)))) {
		(*msg)(MANDOCERR_MEM, data, 0, 0, NULL);
		return(0);
	}

d644 1
a644 2
	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);
d666 1
a666 6
	r->last->end = malloc(sz + 1);

	if (NULL == r->last->end) {
		(*r->msg)(MANDOCERR_MEM, r->data, ln, pos, NULL);
		return(ROFF_ERR);
	}
d893 1
a893 2
	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);
@


1.96
log
@Fix `ds' handling.  This was stripping characters from "val", when the
syntax of `ds' is such that ALL text following the first
non-space/non-double-quote is part of the value.  This also fixes the
warning of *(string++) = NULL report by kristaps@@ and joerg@@.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.95 2010/07/21 09:15:48 kristaps Exp $ */
d1084 1
a1084 1
	while (n && (strncmp(name, n->name, len) || '\0' != n->name[len]))
@


1.95
log
@Lint-fixes (NetBSD).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.94 2010/07/07 15:04:54 kristaps Exp $ */
d972 11
a982 1
	char *name, *string, *end;
d989 1
d992 2
d995 7
a1001 1
		*(string++) = NULL;
a1003 10
	while (*string && ' ' == *string)
		string++;
	end = string;
	while (*end)
		end++;
	if (string < end) {
		end--;
		if (*end == '"')
			*end = '\0';
	}
d1005 1
d1073 1
@


1.94
log
@Re-constitution of `ds' symbol processing.  First, push the
roff_getstr() family of functions into roff.c with the "first_string"
directly in struct roff.  Second, pre-process each line for reserved
words in libroff, splicing and re-running a line if it has one (this
allows defined symbols to be macros).  Remove term.c's invocation of the
roff_getstrn() function.  Removed function documentation in roff.3 and
added roff.7 `ds' documentation.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.93 2010/07/04 22:04:04 schwarze Exp $ */
d135 2
a136 2
static	int		 roff_res(struct roff *, int, 
				char **, size_t *, int, int *);
d335 1
a335 2
roff_res(struct roff *r, int ln, char **bufp,
		size_t *szp, int pos, int *offs)
d342 1
d409 1
a409 1
	if (r->first_string && ! roff_res(r, ln, bufp, szp, pos, offs))
@


1.93
log
@Assert my copyright, making it explicit that i'm granting the same license
on those parts of the code and text that i have written as Kristaps is.
"fine with me" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.92 2010/07/03 16:02:12 schwarze Exp $ */
a30 1
#include "regs.h"
d32 1
d72 7
d86 1
a119 6
struct roffstr {
	char		*name;
	char		*string;
	struct roffstr	*next;
} *first_string;

d129 4
d135 4
a138 1
static	enum roffrule	 roff_evalcond(const char *, int *);
d288 1
a288 1
	roff_freestr();
d329 68
d405 8
d426 1
a426 3
	} else if ( ! ROFF_CTL((*bufp)[pos])) {
		ROFF_DEBUG("roff: pass non-scoped text: [%s]\n", 
				&(*bufp)[pos]);
a427 1
	}
d451 1
a451 3
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos))) {
		ROFF_DEBUG("roff: pass non-scoped non-macro: [%s]\n", 
				&(*bufp)[pos]);
a452 1
	}
d996 1
a996 1
	roff_setstr(name, string);
d1044 2
a1045 2
char *
roff_setstr(const char *name, const char *string)
d1050 1
a1050 1
	n = first_string;
d1053 8
a1060 1
	if (n) {
d1062 2
a1063 16
	} else {
		if (NULL == (namecopy = strdup(name)))
			return(NULL);
		if (NULL == (n = malloc(sizeof(struct roffstr)))) {
			free(n);
			return(NULL);
		}
		n->name = namecopy;
		n->next = first_string;
		first_string = n;
	}
	if (string)
		n->string = strdup(string);
	else
		n->string = NULL;
	return(n->string);
a1065 4
char *
roff_getstr(const char *name)
{
	struct roffstr	 *n;
d1067 2
a1068 11
	n = first_string;
	while (n && strcmp(name, n->name))
		n = n->next;
	if (n)
		return(n->string);
	else
		return(NULL);
}

char *
roff_getstrn(const char *name, size_t len)
d1070 1
a1070 1
	struct roffstr	 *n;
d1072 1
a1072 1
	n = first_string;
d1075 2
a1076 4
	if (n)
		return(n->string);
	else
		return(NULL);
d1079 3
a1081 2
void
roff_freestr(void)
d1085 1
a1085 1
	for (n = first_string; n; n = nn) {
d1091 2
a1092 1
	first_string = NULL;
@


1.92
log
@Rudimentary implementation of user-defined strings;
no time for more refinement right now.
In particular, fixes terminfo(3) and mdoc.samples(7).
ok kristaps@@, who will add the HTML frontend bits
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.91 2010/06/27 16:36:22 kristaps Exp $ */
d4 1
@


1.91
log
@Allow registers to be unset.  Implement and document the `.nr nS val'.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.90 2010/06/27 15:52:41 kristaps Exp $ */
d111 6
d125 1
d145 1
a145 1
	{ "ds", roff_line, NULL, NULL, 0, NULL },
d278 1
d890 33
d962 72
@


1.90
log
@Downstream maintainers: this removes UGLY!  I don't want diverging
functionality and UGLY works quite well thanks to schwarze@@'s careful
attention.

This also backs out function-prototype changes for struct regset,
instead stuffing a pointer to the regset directly into struct
mdoc/man/roff.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.89 2010/06/26 15:22:19 kristaps Exp $ */
d158 1
a158 1
static	int		 roff_parse_nat(const char *, int *);
d428 1
a428 1
roff_parse_nat(const char *buf, int *res)
d439 1
a439 1
			(lval > INT_MAX || lval <= 0))
d442 1
a442 1
	*res = (int)lval;
d885 1
d888 1
d910 3
a912 2
		if ( ! roff_parse_nat(val, &r->regs->regs[(int)REG_nS].i))
			r->regs->regs[(int)REG_nS].i = 0;
d914 2
a915 2
		ROFF_DEBUG("roff: register nS: %d\n", 
				r->regs->regs[(int)REG_nS].i);
@


1.89
log
@First step of adding register support.  This is inspired by a significant
patch by schwarze@@.  This commit adds support to libroff parsing `nr'
into register set defined in regs.h.  This will propogate into libmdoc
and libman in later commits.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.88 2010/06/10 21:42:02 kristaps Exp $ */
d77 1
a90 1
			 struct regset *regs, /* registers */ \
d292 1
a292 1
roff_alloc(const mandocmsg msg, void *data)
d301 1
d312 2
a313 2
roff_parseln(struct roff *r, struct regset *regs, int ln, 
		char **bufp, size_t *szp, int pos, int *offs)
d330 2
a331 2
				(r, regs, t, bufp, 
				 szp, ln, pos, pos, offs));
d349 2
a350 2
				(r, regs, t, bufp, 
				 szp, ln, pos, pos, offs));
d370 2
a371 2
			(r, regs, t, bufp, 
			 szp, ln, ppos, pos, offs));
d657 2
a658 2
	return((*roffs[t].proc)(r, regs, t, bufp, 
			szp, ln, ppos, pos, offs));
d707 2
a708 2
	return((*roffs[t].proc)
			(r, regs, t, bufp, szp, ln, ppos, pos, offs));
d908 2
a909 2
		if ( ! roff_parse_nat(val, &regs->regs[(int)REG_nS].i))
			regs->regs[(int)REG_nS].i = 0;
d912 1
a912 1
				regs->regs[(int)REG_nS].i);
@


1.88
log
@Fix adding some minimal intelligence to conditional parser.  See roff.7
for what's supported.  This simplified the roff_cond() function quite
nicely.  From a bug report by uqs@@.

Added regression test based on bug-report example by uqs@@.

Also added ROFF_DEBUG to see what the hell the parser is actually doing.
Obviously turned off by default.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.87 2010/06/09 20:00:38 kristaps Exp $ */
d22 1
d24 1
d30 1
d62 1
d90 1
d119 2
a121 1
static	enum rofferr	 roff_line(ROFF_ARGS);
d147 1
d158 1
d311 1
a311 1
roff_parseln(struct roff *r, int ln, 
d329 2
a330 1
				(r, t, bufp, szp, ln, pos, pos, offs));
d348 2
a349 1
				(r, t, bufp, szp, ln, pos, pos, offs));
d369 2
a370 1
			(r, t, bufp, szp, ln, ppos, pos, offs));
d426 20
d656 1
a656 1
	return((*roffs[t].proc)(r, t, bufp, 
d707 1
a707 1
			(r, t, bufp, szp, ln, ppos, pos, offs));
d766 9
d881 1
a881 1
roff_line(ROFF_ARGS)
d883 31
@


1.87
log
@Make "sub" for conditionals run roffnode_cleanscope() before calling
down to sub-arguments.  From a bug report by Ulrich Spoerlein.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.86 2010/06/01 11:47:28 kristaps Exp $ */
d35 8
d114 1
d318 2
d322 3
a324 1
	} else if ( ! ROFF_CTL((*bufp)[pos]))
d326 1
d336 2
d349 3
a351 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
d353 1
d355 2
d708 25
a736 1
	int		 cpos;  /* position of the condition */
d738 1
d747 1
a747 1
	cpos = pos;
d749 11
a759 10
	if (ROFF_if == tok || ROFF_ie == tok) {
		/*
		 * Read ahead past the conditional.  FIXME: this does
		 * not work, as conditionals don't end on whitespace,
		 * but are parsed according to a formal grammar.  It's
		 * good enough for now, however.
		 */
		while ((*bufp)[pos] && ' ' != (*bufp)[pos])
			pos++;
	}
d762 1
d772 1
d774 3
a776 3
		if ( ! (*r->msg)(MANDOCERR_NOARGS, r->data, ln, ppos, NULL))
			return(ROFF_ERR);
		return(ROFF_IGN);
d782 4
a785 1
	/* XXX: Implement more conditionals. */
a786 13
	if (ROFF_if == tok || ROFF_ie == tok)
		r->last->rule = 'n' == (*bufp)[cpos] ?
		    ROFFRULE_ALLOW : ROFFRULE_DENY;
	else if (ROFF_el == tok) {
		/* 
		 * An `.el' will get the value of the current rstack
		 * entry set in prior `ie' calls or defaults to DENY.
	 	 */
		if (r->rstackpos < 0)
			r->last->rule = ROFFRULE_DENY;
		else
			r->last->rule = r->rstack[r->rstackpos];
	}
d798 4
a801 1
	if (r->last->parent && ROFFRULE_DENY == r->last->parent->rule)
d803 9
d818 5
a822 1
	} 
@


1.86
log
@Fixed condition of `\}' closing a conditional at the start of the line.

Fixed flushed-out condition of \} causing subsequent arguments to be
truncated, when in fact the whole line should be passed through (if the
conditional succeeds) to the front-end and the \} ignored there.

Added regression test of this behaviour.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.85 2010/05/29 19:41:47 kristaps Exp $ */
d624 1
d629 10
a638 1
	roff_cond_text(r, tok, bufp, szp, ln, ppos, pos, offs);
@


1.85
log
@Give libroff an extremely simple table-lookup instead of iterating over
each and every macro.  The table keys on the first character then walks
a chain.  Good enough for now.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.84 2010/05/24 23:54:18 schwarze Exp $ */
d669 1
a669 2
	if (ep > st && '\\' != *(ep - 1)) {
		ep = '\0';
a670 1
	}
@


1.84
log
@recognize ".if n" as true;
nothing fancy yet, no negation, no grammer, just that one letter;
from OpenBSD;
"looks fine" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.83 2010/05/24 22:25:58 schwarze Exp $ */
d22 1
d95 1
d108 24
a131 16
const	struct roffmac	 roffs[ROFF_MAX] = {
	{ "am", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "ami", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "am1", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "de", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "dei", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "de1", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "ds", roff_line, NULL, NULL, 0 },
	{ "el", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },
	{ "ie", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },
	{ "if", roff_cond, roff_cond_text, roff_cond_sub, ROFFMAC_STRUCT },
	{ "ig", roff_block, roff_block_text, roff_block_sub, 0 },
	{ "rm", roff_line, NULL, NULL, 0 },
	{ "tr", roff_line, NULL, NULL, 0 },
	{ ".", roff_cblock, NULL, NULL, 0 },
	{ "\\}", roff_ccond, NULL, NULL, 0 },
d136 1
d143 24
d175 2
a176 1
	int		 i;
d178 6
a183 1
	/* FIXME: make this be fast and efficient. */
d185 10
a194 3
	for (i = 0; i < (int)ROFF_MAX; i++)
		if (0 == strcmp(roffs[i].name, p))
			return((enum rofft)i);
d287 2
@


1.83
log
@provide stubs to ignore .ds, .rm and .tr,
which occur in the standard pod2man preamble;
from OpenBSD;
"sounds good" joerg@@, "can be checked in" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.82 2010/05/17 02:01:05 kristaps Exp $ */
d578 1
a578 1
	roffnode_cleanscope(r);
d619 2
a620 1
	if (ep > st && '\\' != *(ep - 1))
d622 1
d633 1
d643 2
d675 1
a675 1
	/* TODO: here we would evaluate the conditional. */
d677 4
a680 1
	if (ROFF_el == tok) {
d689 2
a690 1
	} else if (ROFF_ie == tok) {
d701 2
@


1.82
log
@Full support for ie/el.  This completes the initial roff support.
Added test files for ie/el.
Using `if 0' as a baseline for "false" roff instructions instead of `if t'.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.81 2010/05/17 00:46:35 kristaps Exp $ */
d41 1
d46 2
d104 1
d113 1
d118 2
d713 9
@


1.81
log
@Oops: forgot to make roff_cblock() understand the new macros.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.80 2010/05/17 00:37:26 kristaps Exp $ */
d29 2
d41 2
a46 4
#if 0
	ROFF_ie,
	ROFF_el,
#endif
d50 5
d59 2
a60 5
};

enum	roffrule {
	ROFFRULE_ALLOW,
	ROFFRULE_DENY
d70 1
a70 1
	enum roffrule	 rule;
d98 3
a100 3
static	enum rofferr	 roff_if(ROFF_ARGS);
static	enum rofferr	 roff_if_text(ROFF_ARGS);
static	enum rofferr	 roff_if_sub(ROFF_ARGS);
d109 3
a111 1
	{ "if", roff_if, roff_if_text, roff_if_sub, ROFFMAC_STRUCT },
d156 5
d231 1
d319 1
a319 1
		else if (' ' == buf[*pos])
d408 8
a415 1
	if (ROFF_if != r->last->tok) {
a497 30
roff_if_sub(ROFF_ARGS)
{
	enum rofft	 t;
	enum roffrule	 rr;

	ppos = pos;
	rr = r->last->rule;
	roffnode_cleanscope(r);

	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
		return(ROFFRULE_DENY == rr ? ROFF_IGN : ROFF_CONT);

	/*
	 * A denied conditional must evaluate its children if and only
	 * if they're either structurally required (such as loops and
	 * conditionals) or a closing macro.
	 */
	if (ROFFRULE_DENY == rr)
		if ( ! (ROFFMAC_STRUCT & roffs[t].flags))
			if (ROFF_ccond != t)
				return(ROFF_IGN);

	assert(roffs[t].proc);
	return((*roffs[t].proc)
			(r, t, bufp, szp, ln, ppos, pos, offs));
}


/* ARGSUSED */
static enum rofferr
d563 32
a594 1
roff_if_text(ROFF_ARGS)
d597 8
d609 1
a609 1
		return(ROFF_IGN);
d616 1
a616 1
	return(ROFF_IGN);
d622 1
a622 1
roff_if(ROFF_ARGS)
d626 6
a631 6
	/*
	 * Read ahead past the conditional.
	 * FIXME: this does not work, as conditionals don't end on
	 * whitespace, but are parsed according to a formal grammar.
	 * It's good enough for now, however.
	 */
d633 10
a642 2
	while ((*bufp)[pos] && ' ' != (*bufp)[pos])
		pos++;
a653 1

d663 22
a684 1
	/* Don't evaluate: just assume NO. */
@


1.80
log
@libroff now intelligently throws away `am', `ami', `am1', `de', `dei',
and `de1'.  This is also documented in roff.7.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.79 2010/05/17 00:06:36 kristaps Exp $ */
d343 16
a358 1
	if (ROFF_ig != r->last->tok) {
@


1.79
log
@libroff now is aware of which sub-nodes should be interpreted even in a
conditional-negative context so as to preserve structural integrity.
Initial "rules" (deny/allow) are now inherited for future work in
evaluating conditionals.

Lint-fix noted by Joerg.

Added regression tests for zany constructs.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.78 2010/05/16 22:28:33 kristaps Exp $ */
d33 6
a43 4
	ROFF_am,
	ROFF_ami,
	ROFF_de,
	ROFF_dei,
d91 5
a98 5
static	enum rofferr	 roff_ig(ROFF_ARGS);
static	enum rofferr	 roff_ig_text(ROFF_ARGS);
static	enum rofferr	 roff_ig_sub(ROFF_ARGS);
static	enum rofferr	 roff_cblock(ROFF_ARGS);
static	enum rofferr	 roff_ccond(ROFF_ARGS);
d101 6
d108 1
a108 1
	{ "ig", roff_ig, roff_ig_text, roff_ig_sub, 0 },
d407 1
a407 1
roff_ig(ROFF_ARGS)
d412 11
d496 1
a496 1
roff_ig_sub(ROFF_ARGS)
d552 1
a552 1
roff_ig_text(ROFF_ARGS)
@


1.78
log
@`ig' support in all its glory.  Try

  .ig ig
  asdf
  .ig
  fdsa
  ..

or

  .ig if
  asdf
  .if n \
  foo

for a laugh.  It all works.  Lots of regression tests supporting this
and documentation for the same.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.77 2010/05/16 19:08:11 kristaps Exp $ */
a30 8
#if	0
#define	ROFF_MDEBUG(p, str) \
	fprintf(stderr, "%s: %s (%d:%d)\n", (str), \
		roffs[(p)->last->tok].name, \
	       	(p)->last->line, (p)->last->col)
#else
#define	ROFF_MDEBUG(p, str) while (/* CONSTCOND */ 0)
#endif
d42 2
a43 1
	ROFF_close,
d54 5
a61 1
	char		*end; /* end-token: custom */
d64 3
a66 1
	int		 endspan;
d82 5
a86 2
	roffproc	 proc;
	roffproc	 text;
d91 1
d94 1
d99 4
a102 4
	{ "if", roff_if, roff_if_text },
	{ "ig", roff_ig, roff_ig_text },
	{ ".", roff_cblock, NULL },
	{ "\\}", roff_ccond, NULL },
d169 1
d223 7
a229 1
	int		 ppos, i, j, wtf;
a231 5
		/*
		 * If a scope is open and we're not a macro, pass it
		 * through our text detector and continue as quickly as
		 * possible.
		 */
a236 3
		/*
		 * Don't do anything if we're free-form text.
		 */
d239 4
a242 1
	/* A macro-ish line with a possibly-open macro context. */
d244 6
a249 1
	wtf = 0;
d251 5
a255 22
	if (r->last && r->last->end) {
		/*
		 * We have a scope open that has a custom end-macro
		 * handler.  Try to match it against the input.
		 */
		i = pos + 1;
		while (' ' == (*bufp)[i] || '\t' == (*bufp)[i])
			i++;

		for (j = 0; r->last->end[j]; j++, i++)
			if ((*bufp)[i] != r->last->end[j])
				break;

		if ('\0' == r->last->end[j] && 
				('\0' == (*bufp)[i] ||
				 ' ' == (*bufp)[i] ||
				 '\t' == (*bufp)[i])) {
			roffnode_pop(r);
			roffnode_cleanscope(r);
			wtf = 1;
		}
	}
d258 2
a259 16
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos))) {
		/* 
		 * This is some of groff's stranger behaviours.  If we
		 * encountered a custom end-scope tag and that tag also
		 * happens to be a "real" macro, then we need to try
		 * interpreting it again as a real macro.  If it's not,
		 * then return ignore.  Else continue.
		 */
		if (wtf)
			return(ROFF_IGN);
		else if (NULL == r->last)
			return(ROFF_CONT);

		/* FIXME: this assumes that we ignore!? */
		return(ROFF_IGN);
	}
d324 5
a344 1
	ROFF_MDEBUG(r, "closing ignore block");
a358 1
		ROFF_MDEBUG(r, "closing implicit scope");
a390 1
	ROFF_MDEBUG(r, "closing explicit scope");
d407 1
a407 2
	if ('\0' == (*bufp)[pos]) {
		ROFF_MDEBUG(r, "opening ignore block");
a408 1
	}
d424 3
a436 2
	ROFF_MDEBUG(r, "opening explicit ignore block");

d447 86
d552 1
a552 2
	if (ep > st && '\\' != *(ep - 1)) {
		ROFF_MDEBUG(r, "closing explicit scope (in-line)");
a553 1
	}
a600 1
		ROFF_MDEBUG(r, "opening explicit scope");
d603 1
a603 2
	} else
		ROFF_MDEBUG(r, "opening implicit scope");
@


1.77
log
@Regression tests in place for `.if' in libroff.
Check against some strange `.if' constructs I missed.
Added initial roff.7 manual.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.76 2010/05/16 14:47:19 kristaps Exp $ */
d84 1
d88 1
d90 1
d95 4
a98 10
	{ "if", roff_if },
	{ "ig", roff_ig },
	{ ".", roff_cblock },
	{ "\\}", roff_ccond },
#if 0
	{ "am", roff_sub_ig, roff_new_ig },
	{ "ami", roff_sub_ig, roff_new_ig },
	{ "de", roff_sub_ig, roff_new_ig },
	{ "dei", roff_sub_ig, roff_new_ig },
#endif
d218 1
a218 1
	int		 ppos;
d221 9
a229 5
		if (ROFF_ig == r->last->tok)
			return(ROFF_IGN);
		roffnode_cleanscope(r);
		/* FIXME: this assumes we're discarding! */
		return(ROFF_IGN);
d231 3
d236 26
a261 1
	/* There's nothing on the stack: make us anew. */
d265 8
a272 1
		if (r->last && ROFF_ig == r->last->tok)
d274 5
a278 1
		return(ROFF_CONT);
d282 2
a283 1
	return((*roffs[t].proc)(r, t, bufp, szp, ln, ppos, pos, offs));
d419 2
d425 30
a454 1
	ROFF_MDEBUG(r, "opening ignore block");
d466 31
@


1.76
log
@Re-admit the simple case of `.ig' that works with groff's stranger invocations.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.75 2010/05/16 13:49:23 kristaps Exp $ */
d384 3
a386 1
	/* FIXME: warn about end of line. */
d396 1
a404 3
	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);

d407 2
d412 16
d439 5
d447 2
@


1.75
log
@Support for the general case of `if', which will boil out into other
constructs: single-level and multi-level blocks; nested, varied-level
blocks; recalculating buffer (begin) boundaries pushed correctly into
the back-ends, and so on.  This will allow, once conditions are turned
on, for things like `.ie n .TH FOO 1' then `.el .Dd Mdocdate'.  Read
it and weep.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.74 2010/05/16 10:59:36 kristaps Exp $ */
d31 1
a31 1
#ifdef	ROFF_DEBUG
d42 2
a49 1
	ROFF_ig,
d87 2
a89 5
#if 0
static	enum rofferr	 roff_new_close(ROFF_ARGS);
static	enum rofferr	 roff_new_ig(ROFF_ARGS);
static	enum rofferr	 roff_sub_ig(ROFF_ARGS);
#endif
d93 2
a100 2
	{ "ig", roff_sub_ig, roff_new_ig },
	{ ".", NULL, roff_new_close },
d106 1
a222 2
	/* Return when in free text without a context. */

d224 4
a227 7
		/* XXX: this assumes we're just discarding. */
		while (r->last) {
			if (r->last->endspan-- < 0)
				break;
			ROFF_MDEBUG(r, "closing implicit scope");
			roffnode_pop(r);
		}
d235 3
a237 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &pos)))
d239 1
a297 1
#if 0
d300 1
a300 1
roff_sub_ig(ROFF_ARGS)
a301 1
	int		 i, j;
d303 5
a307 1
	/* Ignore free-text lines. */
d309 3
a311 1
	if ('.' != (*bufp)[ppos] && '\'' != (*bufp)[ppos])
d313 1
d315 3
a317 20
	if (r->last->end) {
		i = ppos + 1;

		while ((*bufp)[i] && ' ' == (*bufp)[i])
			i++;

		for (j = 0; r->last->end[j]; i++, j++)
			if ((*bufp)[i] != r->last->end[j])
				return(ROFF_IGN);

		if (r->last->end[j])
			return(ROFF_IGN);
		if ((*bufp)[i] && ' ' != (*bufp)[i])
			return(ROFF_IGN);

		while (' ' == (*bufp)[i])
			i++;

	} else if (ROFF_close != roff_parse(*bufp, &i))
		return(ROFF_IGN);
d319 1
d321 2
a323 6
	if ('\0' == (*bufp)[i])
		return(ROFF_IGN);
	if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, i, NULL))
		return(ROFF_ERR);

	return(ROFF_IGN);
d327 2
a328 3
/* ARGSUSED */
static enum rofferr
roff_new_close(ROFF_ARGS)
d331 6
a336 4
	if ( ! (*r->msg)(MANDOCERR_NOSCOPE, r->data, ln, ppos, NULL))
		return(ROFF_ERR);

	return(ROFF_IGN);
a337 1
#endif
d345 7
a351 1
	if (NULL == r->last || ROFF_if != r->last->tok || r->last->endspan > -1) {
d357 10
d369 4
d374 9
a382 3
	while (r->last) {
		if (--r->last->endspan < 0)
			break;
d384 1
a384 3
		ROFF_MDEBUG(r, "closing implicit scope");
		roffnode_pop(r);
	}
a426 58


#if 0
static enum rofferr
roff_new_ig(ROFF_ARGS)
{
	int		 i;

	if ( ! roffnode_push(r, tok, ln, ppos))
		return(ROFF_ERR);
	
	/*
	 * Other macros (not `ig') using this routine have additional
	 * crap here that we discard. 
	 */

	if (ROFF_ig != tok) {
		while ((*bufp)[ppos] && ' ' != (*bufp)[ppos])
			ppos++;
		while (' ' == (*bufp)[ppos])
			ppos++;
	}

	i = (int)ppos;

	while ((*bufp)[i] && ' ' != (*bufp)[i])
		i++;

	if (i == (int)ppos)
		return(ROFF_IGN);

	if ((*bufp)[i])
		if ( ! (*r->msg)(MANDOCERR_ARGSLOST, r->data, ln, i, NULL))
			return(ROFF_ERR);

	/*
	 * If the macro has arguments, the first argument (up to the
	 * next whitespace) is interpreted as an argument marking the
	 * macro close.  Thus, `.ig foo' will close at `.foo'.
	 *
	 * NOTE: the closing macro `.foo' in the above case is not
	 * allowed to have leading spaces with old groff!  Thus `.foo'
	 * != `. foo'.  Oh yeah, everything after the `.foo' is lost.
	 * Merry fucking Christmas.
	 */

	r->last->end = malloc((size_t)(i - ppos) + 1);
	if (NULL == r->last->end) {
		(*r->msg)(MANDOCERR_MEM, r->data, ln, ppos, NULL);
		return(ROFF_ERR);
	}

	memcpy(r->last->end, &(*bufp)[ppos], (size_t)(i - ppos));
	r->last->end[i - ppos] = '\0';

	return(ROFF_IGN);
}
#endif
@


1.74
log
@Allow roff_parseln() to be re-run.
Allow roff_parseln() to manipulate the line buffer offset.  This is used
in situations like `.ie n .TH FOO 1' or `.ie n .ie n', where the line
buffer offset is recalculated then the roff parser re-run.
Fix mdoc_parseln() and man_parseln() to accept the initial line offset.
WARNING: backed-out ALL roff macros whilst accomodating for how roff
handles multi-line conditionals (in short, re-running the parser).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.73 2010/05/15 22:28:22 kristaps Exp $ */
d24 1
d29 11
d41 2
a47 1
	ROFF_if,
d66 1
a66 2
	int		 flags;
#define	ROFF_PARSEONLY	(1 << 0)
d74 2
a75 1
			 int ppos, /* current pos in buffer */ \
d82 1
a82 2
	roffproc	 sub; /* child of control black */
	roffproc	 new; /* root of stack (type = ROFF_MAX) */
d85 2
a88 2
static	enum rofferr	 roff_new_if(ROFF_ARGS);
static	enum rofferr	 roff_sub_if(ROFF_ARGS);
d94 2
a100 1
	{ "if", roff_sub_if, roff_new_if },
d142 3
a144 3
	if (NULL == (p = r->last))
		return;
	r->last = p->parent;
d222 1
a223 8
	/* If stacked, jump directly into its processing function. */

	if (NULL != r->last) {
		t = r->last->tok;
		assert(roffs[t].sub);
		return((*roffs[t].sub)(r, t, bufp, szp, ln, pos, offs));
	} 
	
d226 10
a235 1
	if ('.' != (*bufp)[0] && '\'' != (*bufp)[0] && NULL == r->last)
d240 1
d244 2
a245 2
	assert(roffs[t].new);
	return((*roffs[t].new)(r, t, bufp, szp, ln, pos, offs));
d271 2
a272 2
	assert('.' == buf[0] || '\'' == buf[0]);
	*pos = 1;
d355 1
d358 1
d360 1
a360 1
roff_sub_if(ROFF_ARGS)
a361 2
	int		 i;
	enum rofft	 t;
d363 8
a370 1
	i = (int)strlen(*bufp);
d372 5
a376 1
	if (i > 1 && '}' == (*bufp)[i - 1] && '\\' == (*bufp)[i - 2])
d378 1
d384 1
d386 1
a386 1
roff_new_if(ROFF_ARGS)
a387 2
	struct roffnode	*n;
	enum rofferr	 re;
a395 5
	while ((*bufp)[ppos] && ' ' != (*bufp)[ppos])
		ppos++;
	while (' ' == (*bufp)[ppos])
		ppos++;

d399 4
a402 1
	n = r->last;
d406 8
a413 1
	r->last->flags |= ROFF_PARSEONLY;
d415 2
a416 8
	if ('\\' == (*bufp)[ppos] && '{' == (*bufp)[ppos + 1]) {
		re = roff_parseln(r, ln, bufp, szp, pos);
		if (ROFF_ERR == re)
			return(re);
		if (r->last == n)
			roffnode_pop(r, tok, ln, ppos);
		return(re);
	}
d418 2
a419 1
	return(ROFF_IGN);
d423 1
@


1.73
log
@Backed-out warning messages (lots).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.71 2010/05/15 21:53:11 kristaps Exp $ */
d29 3
d34 1
a34 2
	ROFF_am,
	ROFF_ami,
d37 1
d50 1
a50 1
	char		*end; /* custom end-token */
d53 2
d62 2
a63 1
			 int ppos /* current pos in buffer */
d73 1
d75 2
d79 1
d82 3
d87 1
a87 2
	{ "am", roff_sub_ig, roff_new_ig },
	{ "ami", roff_sub_ig, roff_new_ig },
d90 1
d132 2
d205 2
a206 1
roff_parseln(struct roff *r, int ln, char **bufp, size_t *szp)
d209 2
a210 1
	int		 ppos;
a212 4
		/*
		 * If there's a node on the stack, then jump directly
		 * into its processing function.
		 */
d215 6
a220 3
		return((*roffs[t].sub)(r, t, bufp, szp, ln, 0));
	} else if ('.' != (*bufp)[0] && NULL == r->last)
		/* Return when in free text without a context. */
d225 1
a225 1
	if (ROFF_MAX == (t = roff_parse(*bufp, &ppos)))
d229 12
a240 1
	return((*roffs[t].new)(r, t, bufp, szp, ln, ppos));
d255 1
a255 1
	assert('.' == buf[0]);
d285 1
d294 1
a294 1
	if ('.' != (*bufp)[ppos])
d341 55
a395 1
/* ARGSUSED */
d403 5
d450 1
a450 11


int
roff_endparse(struct roff *r)
{

	if (NULL == r->last)
		return(1);
	return((*r->msg)(MANDOCERR_SCOPEEXIT, r->data, 
				r->last->line, r->last->col, NULL));
}
@


1.72
log
@The `am', `ami', `de', and holy `dei' are all being properly ignored.
@
text
@d352 1
a352 1
	r->last->end = malloc((size_t)i - ppos + 1);
d358 2
a359 2
	memcpy(r->last->end, &(*bufp)[ppos], (size_t)i - ppos);
	r->last->end[(size_t)i - ppos] = '\0';
@


1.71
log
@The `ig' now supports `ig end-macro'.
Initial warning/error messages in place (still experimental).
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.70 2010/05/15 20:51:40 kristaps Exp $ */
d53 1
a66 1
static	enum rofferr	 roff_ignore(ROFF_ARGS);
d72 4
a75 4
	{ "de", NULL, roff_ignore },
	{ "dei", NULL, roff_ignore },
	{ "am", NULL, roff_ignore },
	{ "ami", NULL, roff_ignore },
d202 1
a202 1
		return((*roffs[t].sub)(r, bufp, szp, ln, 0));
d213 1
a213 1
	return((*roffs[t].new)(r, bufp, szp, ln, ppos));
a259 9
roff_ignore(ROFF_ARGS)
{

	return(ROFF_IGN);
}


/* ARGSUSED */
static enum rofferr
a269 5
		/*
		 * Allow a macro to break us, if we've defined a special
		 * one for the case.  Old groff didn't allow spaces to
		 * buffer the macro, but new groff does.  Whee!
		 */
d271 1
a274 3
		if ('\0' == (*bufp)[i])
			return(ROFF_IGN);

d286 1
a289 5
	/*
	 * Pop off the ignoring context and warn if we're going to lose
	 * any of our remaining arguments.
	 */

a305 1
	/*
d308 1
a308 1
	*/
d319 1
a319 1
	if ( ! roffnode_push(r, ROFF_ig, ln, ppos))
d322 7
d330 1
d336 1
d342 3
a344 3
	 * If `.ig' has arguments, the first argument (up to the next
	 * whitespace) is interpreted as an argument marking the macro
	 * close.  Thus, `.ig foo' will close at `.foo'.
@


1.70
log
@Pull `ig' out of -man and leave it the roff preparser.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.69 2010/05/15 18:48:32 kristaps Exp $ */
d47 1
d271 1
a271 2
	enum rofft	 t;
	int		 pos;
d278 31
a308 1
	/* Ignore macros unless it's a closing macro. */
d310 3
a312 2
	t = roff_parse(*bufp, &pos);
	if (ROFF_close != t)
d314 2
a316 1
	roffnode_pop(r);
d338 1
d340 34
a373 2
	return(roffnode_push(r, ROFF_ig, ln, ppos) ? 
			ROFF_IGN : ROFF_ERR);
@


1.69
log
@Magic fix for bogus manuals making -man puke: I don't care if it's magic because roff instructions will be nixed from the underlying systems anyway.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.68 2010/05/15 18:43:59 kristaps Exp $ */
a78 1
static	void		 roff_alloc1(struct roff *);
a154 8
static void
roff_alloc1(struct roff *r)
{

	/* Do nothing for now. */
}


a159 1
	roff_alloc1(r);
@


1.68
log
@Segfault fix and letting warnings slip through for now.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.67 2010/05/15 18:35:14 kristaps Exp $ */
d308 1
a308 1
	return(ROFF_CONT);
@


1.67
log
@Add mandoc.h, which will eventually replace compilers' inner enum errors with unified ones.
Add initial roff pre-processor shim, a compiler sitting outside of the other compilers that processes pure roff instructions.
@
text
@d1 1
a1 1
/*	$Id: roff.c,v 1.66 2010/05/15 07:52:11 kristaps Exp $ */
d160 1
a160 1
	memset(r, 0, sizeof(struct roff));
d304 1
d307 2
a308 1
	return(ROFF_IGN);
@


1.66
log
@Initial roff shim skeleton in place.
@
text
@d1 1
a1 1
/*	$Id: mdoc.c,v 1.131 2010/05/14 17:31:25 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2008, 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
d21 1
d23 1
d25 1
d28 301
@


1.65
log
@More file pruning.
@
text
@d1 24
@


1.64
log
@*** empty log message ***
@
text
@a0 1724
/* $Id: roff.c,v 1.63 2008/12/10 16:03:12 kristaps Exp $ */
/*
 * Copyright (c) 2008 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/param.h>
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <err.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>

#include "private.h"
#include "roff.h"

/* FIXME: First letters of quoted-text interpreted in rofffindtok. */
/* FIXME: `No' not implemented. */
/* TODO: warn if Pp occurs before/after Sh etc. (see mdoc.samples). */
/* TODO: warn about empty lists. */
/* TODO: (warn) some sections need specific elements. */
/* TODO: (warn) NAME section has particular order. */
/* TODO: macros with a set number of arguments? */
/* FIXME: Bl -diag supposed to ignore callable children. */

struct	roffnode {
	int		  tok;		/* Token id. */
	struct roffnode	 *parent;	/* Parent (or NULL). */
};

enum	rofferr {
	ERR_ARGEQ1,			/* Macro requires arg == 1. */
	ERR_ARGEQ0,			/* Macro requires arg == 0. */
	ERR_ARGGE1,			/* Macro requires arg >= 1. */
	ERR_ARGGE2,			/* Macro requires arg >= 2. */
	ERR_ARGLEN,			/* Macro argument too long. */
	ERR_BADARG,			/* Macro has bad arg. */
	ERR_ARGMNY,			/* Too many macro arguments. */
	ERR_NOTSUP,			/* Macro not supported. */
	ERR_DEPREC,			/* Macro deprecated. */
	ERR_PR_OOO,			/* Prelude macro bad order. */
	ERR_PR_REP,			/* Prelude macro repeated. */
	ERR_NOT_PR,			/* Not allowed in prelude. */
	WRN_SECORD			/* Sections out-of-order. */
};

struct	rofftree {
	struct roffnode	 *last;			/* Last parsed node. */
	char		 *cur;			/* Line start. */
	struct tm	  tm;			/* `Dd' results. */
	char		  name[64];		/* `Nm' results. */
	char		  os[64];		/* `Os' results. */
	char		  title[64];		/* `Dt' results. */
	enum roffmsec	  section;
	enum roffvol	  volume;
	struct roffcb	  cb;			/* Callbacks. */
	void		 *arg;			/* Callbacks' arg. */
	int		  csec;			/* Current section. */
	int		  asec;			/* Thus-far sections. */
	int		  literal;		/* Literal mode. */
};

static	struct roffnode	 *roffnode_new(int, struct rofftree *);
static	void		  roffnode_free(struct rofftree *);
static	int		  roff_warn(const struct rofftree *, 
				const char *, char *, ...);
static	int		  roff_warnp(const struct rofftree *, 
				const char *, int, enum rofferr);
static	int		  roff_err(const struct rofftree *, 
				const char *, char *, ...);
static	int		  roff_errp(const struct rofftree *, 
				const char *, int, enum rofferr);
static	int		  roffpurgepunct(struct rofftree *, char **);
static	int		  roffscan(int, const int *);
static	int		  rofffindtok(const char *);
static	int		  rofffindarg(const char *);
static	int		  rofffindcallable(const char *);
static	int		  roffispunct(const char *);
static	int		  roffchecksec(struct rofftree *, 
				const char *, int, int);
static	int		  roffargs(const struct rofftree *,
				int, char *, char **);
static	int		  roffargok(int, int);
static	int		  roffnextopt(const struct rofftree *,
				int, char ***, char **);
static	int		  roffparseopts(struct rofftree *, int, 
				char ***, int *, char **);
static	int		  roffcall(struct rofftree *, int, char **);
static	int		  roffexit(struct rofftree *, int);
static	int 		  roffparse(struct rofftree *, char *);
static	int		  textparse(struct rofftree *, char *);
static	int		  roffdata(struct rofftree *, int, char *);
static	int		  roffspecial(struct rofftree *, int, 
				const char *, const int *,
				const char **, size_t, char **);
static	int		  roffsetname(struct rofftree *, char **);

#ifdef __linux__ 
extern	size_t		  strlcat(char *, const char *, size_t);
extern	size_t		  strlcpy(char *, const char *, size_t);
extern	int		  vsnprintf(char *, size_t, 
				const char *, va_list);
extern	char		 *strptime(const char *, const char *,
				struct tm *);
#endif

int
roff_free(struct rofftree *tree, int flush)
{
	int		 error, t;
	struct roffnode	*n;

	error = 0;

	if ( ! flush)
		goto end;

	error = 1;

	if ( ! (ROFFSec_NAME & tree->asec)) {
		(void)roff_err(tree, NULL, "missing `NAME' section");
		goto end;
	} else if ( ! (ROFFSec_NMASK & tree->asec))
		(void)roff_warn(tree, NULL, "missing suggested `NAME', "
				"`SYNOPSIS', `DESCRIPTION' sections");

	for (n = tree->last; n; n = n->parent) {
		if (0 != tokens[n->tok].ctx) 
			continue;
		(void)roff_err(tree, NULL, "closing explicit scope "
				"`%s'", toknames[n->tok]);
		goto end;
	}

	while (tree->last) {
		t = tree->last->tok;
		if ( ! roffexit(tree, t))
			goto end;
	}

	if ( ! (*tree->cb.rofftail)(tree->arg, &tree->tm,
				tree->os, tree->title, 
				tree->section, tree->volume))
		goto end;

	error = 0;

end:

	while (tree->last) 
		roffnode_free(tree);

	free(tree);

	return(error ? 0 : 1);
}


struct rofftree *
roff_alloc(const struct roffcb *cb, void *args)
{
	struct rofftree	*tree;

	assert(args);
	assert(cb);

	if (NULL == (tree = calloc(1, sizeof(struct rofftree))))
		err(1, "calloc");

	tree->arg = args;
	tree->section = ROFF_MSEC_MAX;

	(void)memcpy(&tree->cb, cb, sizeof(struct roffcb));

	return(tree);
}


int
roff_engine(struct rofftree *tree, char *buf)
{

	tree->cur = buf;
	assert(buf);

	if (0 == *buf) 
		return(roff_err(tree, buf, "blank line"));
	else if ('.' != *buf)
		return(textparse(tree, buf));

	return(roffparse(tree, buf));
}


static int
textparse(struct rofftree *tree, char *buf)
{
	char		*bufp;

	/* TODO: literal parsing. */

	if ( ! (ROFFSec_NAME & tree->asec))
		return(roff_err(tree, buf, "data before `NAME' section"));

	if (tree->literal)
		return(roffdata(tree, 0, buf));

	/* LINTED */
	while (*buf) {
		while (*buf && isspace(*buf))
			buf++;

		if (0 == *buf)
			break;

		bufp = buf++;

		while (*buf && ! isspace(*buf))
			buf++;

		if (0 != *buf) {
			*buf++ = 0;
			if ( ! roffdata(tree, 1, bufp))
				return(0);
			continue;
		}

		if ( ! roffdata(tree, 1, bufp))
			return(0);
		break;
	}

	return(1);
}


static int
roffargs(const struct rofftree *tree, 
		int tok, char *buf, char **argv)
{
	int		 i;
	char		*p;

	assert(tok >= 0 && tok < ROFF_MAX);
	assert('.' == *buf);

	p = buf;

	/*
	 * This is an ugly little loop.  It parses a line into
	 * space-delimited tokens.  If a quote mark is encountered, a
	 * token is alloted the entire quoted text.  If whitespace is
	 * escaped, it's included in the prior alloted token.
	 */

	/* LINTED */
	for (i = 0; *buf && i < ROFF_MAXLINEARG; i++) {
		if ('\"' == *buf) {
			argv[i] = ++buf;
			while (*buf && '\"' != *buf)
				buf++;
			if (0 == *buf)
				return(roff_err(tree, argv[i], 
					"unclosed quote in arg list"));
		} else { 
			argv[i] = buf++;
			while (*buf) {
				if ( ! isspace(*buf)) {
					buf++;
					continue;
				}
				if (*(buf - 1) == '\\') {
					buf++;
					continue;
				}
				break;
			}
			if (0 == *buf)
				continue;
		}
		*buf++ = 0;
		while (*buf && isspace(*buf))
			buf++;
	}

	assert(i > 0);
	if (ROFF_MAXLINEARG == i && *buf)
		return(roff_err(tree, p, "too many args"));

	argv[i] = NULL;
	return(1);
}


static int
roffscan(int tok, const int *tokv)
{

	if (NULL == tokv)
		return(1);

	for ( ; ROFF_MAX != *tokv; tokv++) 
		if (tok == *tokv)
			return(1);

	return(0);
}


static int
roffparse(struct rofftree *tree, char *buf)
{
	int		  tok, t;
	struct roffnode	 *n;
	char		 *argv[ROFF_MAXLINEARG];
	char		**argvp;

	if (0 != *buf && 0 != *(buf + 1) && 0 != *(buf + 2))
		if (0 == strncmp(buf, ".\\\"", 3))
			return(1);

	if (ROFF_MAX == (tok = rofffindtok(buf + 1))) 
		return(roff_err(tree, buf, "bogus line macro"));
	else if ( ! roffargs(tree, tok, buf, argv)) 
		return(0);

	argvp = (char **)argv;

	/* 
	 * Prelude macros break some assumptions, so branch now. 
	 */
	
	if ( ! (ROFFSec_PR_Dd & tree->asec)) {
		assert(NULL == tree->last);
		return(roffcall(tree, tok, argvp));
	} 

	/* 
	 * First check that our possible parents and parent's possible
	 * children are satisfied.  
	 */

	if (tree->last && ! roffscan
			(tree->last->tok, tokens[tok].parents))
		return(roff_err(tree, *argvp, "`%s' has invalid "
					"parent `%s'", toknames[tok], 
					toknames[tree->last->tok]));

	if (tree->last && ! roffscan
			(tok, tokens[tree->last->tok].children))
		return(roff_err(tree, *argvp, "`%s' has invalid "
					"child `%s'", toknames[tok],
					toknames[tree->last->tok]));

	/*
	 * Branch if we're not a layout token.
	 */

	if (ROFF_LAYOUT != tokens[tok].type)
		return(roffcall(tree, tok, argvp));
	if (0 == tokens[tok].ctx)
		return(roffcall(tree, tok, argvp));

	/*
	 * First consider implicit-end tags, like as follows:
	 *	.Sh SECTION 1
	 *	.Sh SECTION 2
	 * In this, we want to close the scope of the NAME section.  If
	 * there's an intermediary implicit-end tag, such as
	 *	.Sh SECTION 1
	 *	.Ss Subsection 1
	 *	.Sh SECTION 2
	 * then it must be closed as well.
	 */

	if (tok == tokens[tok].ctx) {
		/* 
		 * First search up to the point where we must close.
		 * If one doesn't exist, then we can open a new scope.
		 */

		for (n = tree->last; n; n = n->parent) {
			assert(0 == tokens[n->tok].ctx ||
					n->tok == tokens[n->tok].ctx);
			if (n->tok == tok)
				break;
			if (ROFF_SHALLOW & tokens[tok].flags) {
				n = NULL;
				break;
			}
			if (tokens[n->tok].ctx == n->tok)
				continue;
			return(roff_err(tree, *argv, "`%s' breaks "
						"scope of prior`%s'",
						toknames[tok], 
						toknames[n->tok]));
		}

		/*
		 * Create a new scope, as no previous one exists to
		 * close out.
		 */

		if (NULL == n)
			return(roffcall(tree, tok, argvp));

		/* 
		 * Close out all intermediary scoped blocks, then hang
		 * the current scope from our predecessor's parent.
		 */

		do {
			t = tree->last->tok;
			if ( ! roffexit(tree, t))
				return(0);
		} while (t != tok);

		return(roffcall(tree, tok, argvp));
	}

	/*
	 * Now consider explicit-end tags, where we want to close back
	 * to a specific tag.  Example:
	 * 	.Bl
	 * 	.It Item.
	 * 	.El
	 * In this, the `El' tag closes out the scope of `Bl'.
	 */

	assert(tok != tokens[tok].ctx && 0 != tokens[tok].ctx);

	/* LINTED */
	for (n = tree->last; n; n = n->parent)
		if (n->tok != tokens[tok].ctx) {
			if (n->tok == tokens[n->tok].ctx)
				continue;
			return(roff_err(tree, *argv, "`%s' breaks "
						"scope of prior `%s'",
						toknames[tok], 
						toknames[n->tok]));
		} else
			break;

	if (NULL == n)
		return(roff_err(tree, *argv, "`%s' has no starting "
					"tag `%s'", toknames[tok], 
					toknames[tokens[tok].ctx]));

	/* LINTED */
	do {
		t = tree->last->tok;
		if ( ! roffexit(tree, t))
			return(0);
	} while (t != tokens[tok].ctx);

	return(1);
}


static int
rofffindarg(const char *name)
{
	size_t		 i;

	/* FIXME: use a table, this is slow but ok for now. */

	/* LINTED */
	for (i = 0; i < ROFF_ARGMAX; i++)
		/* LINTED */
		if (0 == strcmp(name, tokargnames[i]))
			return((int)i);
	
	return(ROFF_ARGMAX);
}


static int
rofffindtok(const char *buf)
{
	char		 token[4];
	int		 i;

	for (i = 0; *buf && ! isspace(*buf) && i < 3; i++, buf++)
		token[i] = *buf;

	if (i == 3) 
		return(ROFF_MAX);

	token[i] = 0;

	/* FIXME: use a table, this is slow but ok for now. */

	/* LINTED */
	for (i = 0; i < ROFF_MAX; i++)
		/* LINTED */
		if (0 == strcmp(toknames[i], token))
			return((int)i);

	return(ROFF_MAX);
}


static int
roffchecksec(struct rofftree *tree, 
		const char *start, int sec, int fail)
{

	switch (sec) {
	case(ROFFSec_PR_Dd):
		return(1);
	case(ROFFSec_PR_Dt):
		if (ROFFSec_PR_Dd & tree->asec)
			return(1);
		break;
	case(ROFFSec_PR_Os):
		if (ROFFSec_PR_Dt & tree->asec)
			return(1);
		break;
	case(ROFFSec_NAME):
		if (ROFFSec_PR_Os & tree->asec)
			return(1);
		break;
	case(ROFFSec_SYNOP):
		if (ROFFSec_NAME & tree->asec)
			return(1);
		break;
	case(ROFFSec_DESC):
		if (ROFFSec_SYNOP & tree->asec)
			return(1);
		break;
	case(ROFFSec_RETVAL):
		if (ROFFSec_DESC & tree->asec)
			return(1);
		break;
	case(ROFFSec_ENV):
		if (ROFFSec_RETVAL & tree->asec)
			return(1);
		break;
	case(ROFFSec_FILES):
		if (ROFFSec_ENV & tree->asec)
			return(1);
		break;
	case(ROFFSec_EX):
		if (ROFFSec_FILES & tree->asec)
			return(1);
		break;
	case(ROFFSec_DIAG):
		if (ROFFSec_EX & tree->asec)
			return(1);
		break;
	case(ROFFSec_ERRS):
		if (ROFFSec_DIAG & tree->asec)
			return(1);
		break;
	case(ROFFSec_SEEALSO):
		if (ROFFSec_ERRS & tree->asec)
			return(1);
		break;
	case(ROFFSec_STAND):
		if (ROFFSec_SEEALSO & tree->asec)
			return(1);
		break;
	case(ROFFSec_HIST):
		if (ROFFSec_STAND & tree->asec)
			return(1);
		break;
	case(ROFFSec_AUTH):
		if (ROFFSec_HIST & tree->asec)
			return(1);
		break;
	case(ROFFSec_CAVEATS):
		if (ROFFSec_AUTH & tree->asec)
			return(1);
		break;
	case(ROFFSec_BUGS):
		if (ROFFSec_CAVEATS & tree->asec)
			return(1);
		break;
	default:
		return(1);
	}

	if (fail)
		return(0);
	return(roff_warnp(tree, start, ROFF_Sh, WRN_SECORD));
}


static int
roffispunct(const char *p)
{

	if (0 == *p)
		return(0);
	if (0 != *(p + 1))
		return(0);

	switch (*p) {
	case('{'):
		/* FALLTHROUGH */
	case('.'):
		/* FALLTHROUGH */
	case(','):
		/* FALLTHROUGH */
	case(';'):
		/* FALLTHROUGH */
	case(':'):
		/* FALLTHROUGH */
	case('?'):
		/* FALLTHROUGH */
	case('!'):
		/* FALLTHROUGH */
	case('('):
		/* FALLTHROUGH */
	case(')'):
		/* FALLTHROUGH */
	case('['):
		/* FALLTHROUGH */
	case(']'):
		/* FALLTHROUGH */
	case('}'):
		return(1);
	default:
		break;
	}

	return(0);
}


static int
rofffindcallable(const char *name)
{
	int		 c;

	if (ROFF_MAX == (c = rofffindtok(name)))
		return(ROFF_MAX);
	assert(c >= 0 && c < ROFF_MAX);
	return(ROFF_CALLABLE & tokens[c].flags ? c : ROFF_MAX);
}


static struct roffnode *
roffnode_new(int tokid, struct rofftree *tree)
{
	struct roffnode	*p;
	
	if (NULL == (p = malloc(sizeof(struct roffnode))))
		err(1, "malloc");

	p->tok = tokid;
	p->parent = tree->last;
	tree->last = p;

	return(p);
}


static int
roffargok(int tokid, int argid)
{
	const int	*c;

	if (NULL == (c = tokens[tokid].args))
		return(0);

	for ( ; ROFF_ARGMAX != *c; c++) 
		if (argid == *c)
			return(1);

	return(0);
}


static void
roffnode_free(struct rofftree *tree)
{
	struct roffnode	*p;

	assert(tree->last);

	p = tree->last;
	tree->last = tree->last->parent;
	free(p);
}


static int
roffspecial(struct rofftree *tree, int tok, const char *start, 
		const int *argc, const char **argv, 
		size_t sz, char **ordp)
{

	switch (tok) {
	case (ROFF_At):
		if (0 == sz)
			break;
		if (ROFF_ATT_MAX != roff_att(*ordp))
			break;
		return(roff_errp(tree, *ordp, tok, ERR_BADARG));
	
	case (ROFF_Xr):
		if (2 == sz) {
			assert(ordp[1]);
			if (ROFF_MSEC_MAX != roff_msec(ordp[1]))
				break;
			if ( ! roff_warn(tree, start, "invalid `%s' manual "
						"section", toknames[tok]))
				return(0);
		}
		/* FALLTHROUGH */

	case (ROFF_Sx):
		/* FALLTHROUGH*/
	case (ROFF_Fn):
		if (0 != sz) 
			break;
		return(roff_errp(tree, start, tok, ERR_ARGGE1));

	case (ROFF_Nm):
		if (0 == sz) {
			if (0 != tree->name[0]) {
				ordp[0] = tree->name;
				ordp[1] = NULL;
				break;
			}
			return(roff_err(tree, start, "`Nm' not set"));
		} else if ( ! roffsetname(tree, ordp))
			return(0);
		break;

	case (ROFF_Rv):
		/* FALLTHROUGH*/
	case (ROFF_Ex):
		if (1 == sz) 
			break;
		return(roff_errp(tree, start, tok, ERR_ARGEQ1));

	case (ROFF_Sm):
		if (1 != sz)
			return(roff_errp(tree, start, tok, ERR_ARGEQ1));
		else if (0 == strcmp(ordp[0], "on") || 
				0 == strcmp(ordp[0], "off"))
			break;
		return(roff_errp(tree, *ordp, tok, ERR_BADARG));
	
	case (ROFF_Ud):
		/* FALLTHROUGH */
	case (ROFF_Ux):
		/* FALLTHROUGH */
	case (ROFF_Bt):
		if (0 == sz) 
			break;
		return(roff_errp(tree, start, tok, ERR_ARGEQ0));
	default:
		break;
	}

	return((*tree->cb.roffspecial)(tree->arg, tok, tree->cur, 
				argc, argv, (const char **)ordp));
}


static int
roffexit(struct rofftree *tree, int tok)
{

	assert(tokens[tok].cb);
	return((*tokens[tok].cb)(tok, tree, NULL, ROFF_EXIT));
}


static int
roffcall(struct rofftree *tree, int tok, char **argv)
{
	int		 i;
	enum roffmsec	 c;

	if (NULL == tokens[tok].cb)
		return(roff_errp(tree, *argv, tok, ERR_NOTSUP));

	if (tokens[tok].sections && ROFF_MSEC_MAX != tree->section) {
		i = 0;
		while (ROFF_MSEC_MAX != 
				(c = tokens[tok].sections[i++]))
			if (c == tree->section)
				break;
		if (ROFF_MSEC_MAX == c) {
			if ( ! roff_warn(tree, *argv, "`%s' is not a valid "
					"macro in this manual section",
					toknames[tok]))
				return(0);
		}
	}

	return((*tokens[tok].cb)(tok, tree, argv, ROFF_ENTER));
}


static int
roffnextopt(const struct rofftree *tree, int tok, 
		char ***in, char **val)
{
	char		*arg, **argv;
	int		 v;

	*val = NULL;
	argv = *in;
	assert(argv);

	if (NULL == (arg = *argv))
		return(-1);
	if ('-' != *arg)
		return(-1);

	if (ROFF_ARGMAX == (v = rofffindarg(arg + 1))) {
		if ( ! roff_warn(tree, arg, "argument-like parameter `%s' to "
					"`%s'", arg, toknames[tok]))
			return(ROFF_ARGMAX);
		return(-1);
	} 
	
	if ( ! roffargok(tok, v)) {
		if ( ! roff_warn(tree, arg, "invalid argument parameter `%s' to "
				"`%s'", tokargnames[v], toknames[tok]))
			return(ROFF_ARGMAX);
		return(-1);
	} 
	
	if ( ! (ROFF_VALUE & tokenargs[v]))
		return(v);

	*in = ++argv;

	if (NULL == *argv) {
		(void)roff_err(tree, arg, "empty value of `%s' for `%s'",
				tokargnames[v], toknames[tok]);
		return(ROFF_ARGMAX);
	}

	return(v);
}


static int
roffpurgepunct(struct rofftree *tree, char **argv)
{
	int		 i;

	i = 0;
	while (argv[i])
		i++;
	assert(i > 0);
	if ( ! roffispunct(argv[--i]))
		return(1);
	while (i >= 0 && roffispunct(argv[i]))
		i--;
	i++;

	/* LINTED */
	while (argv[i])
		if ( ! roffdata(tree, 0, argv[i++]))
			return(0);
	return(1);
}


static int
roffparseopts(struct rofftree *tree, int tok, 
		char ***args, int *argc, char **argv)
{
	int		 i, c;
	char		*v;

	i = 0;

	while (-1 != (c = roffnextopt(tree, tok, args, &v))) {
		if (ROFF_ARGMAX == c) 
			return(0);

		argc[i] = c;
		argv[i] = v;
		i++;
		*args = *args + 1;
	}

	argc[i] = ROFF_ARGMAX;
	argv[i] = NULL;
	return(1);
}


static int
roffdata(struct rofftree *tree, int space, char *buf)
{

	if (0 == *buf)
		return(1);
	return((*tree->cb.roffdata)(tree->arg, 
				space != 0, tree->cur, buf));
}


/* ARGSUSED */
static	int
roff_Dd(ROFFCALL_ARGS)
{
	time_t		 t;
	char		*p, buf[32];
	size_t		 sz;

	if (ROFFSec_PR_Os & tree->asec)
		return(roff_text(tok, tree, argv, type));
	if (ROFFSec_PR_Dd & tree->asec)
		return(roff_errp(tree, *argv, tok, ERR_PR_REP));
	if ( ! roffchecksec(tree, *argv, ROFFSec_PR_Dd, 1))
		return(roff_errp(tree, *argv, tok, ERR_PR_OOO));

	assert(NULL == tree->last);
	argv++;
	tree->asec |= (tree->csec = ROFFSec_PR_Dd);

	/*
	 * This is a bit complex because there are many forms the date
	 * can be in:  it can be simply $Mdocdate$, $Mdocdate <date>$,
	 * or a raw date.  Process accordingly.
	 */

	if (0 == strcmp(*argv, "$Mdocdate$")) {
		t = time(NULL);
		if (NULL == localtime_r(&t, &tree->tm))
			err(1, "localtime_r");
		return(1);
	} 

	buf[0] = 0;
	p = *argv;
	sz = sizeof(buf);

	if (0 != strcmp(*argv, "$Mdocdate:")) {
		while (*argv) {
			if (strlcat(buf, *argv++, sz) < sz)
				continue;
			return(roff_errp(tree, p, tok, ERR_BADARG));
		}
		if (strptime(buf, "%b%d,%Y", &tree->tm))
			return(1);
		return(roff_errp(tree, p, tok, ERR_BADARG));
	}

	argv++;

	while (*argv && **argv != '$') {
		if (strlcat(buf, *argv++, sz) >= sz)
			return(roff_errp(tree, p, tok, ERR_BADARG));
		if (strlcat(buf, " ", sz) >= sz) 
			return(roff_errp(tree, p, tok, ERR_BADARG));
	}

	if (NULL == *argv) 
		return(roff_errp(tree, p, tok, ERR_BADARG));
	if (NULL == strptime(buf, "%b %d %Y", &tree->tm)) 
		return(roff_errp(tree, p, tok, ERR_BADARG));

	return(1);
}


/* ARGSUSED */
static	int
roff_Dt(ROFFCALL_ARGS)
{
	size_t		 sz;

	if (ROFFSec_PR_Os & tree->asec)
		return(roff_text(tok, tree, argv, type));
	if (ROFFSec_PR_Dt & tree->asec)
		return(roff_errp(tree, *argv, tok, ERR_PR_REP));
	if ( ! roffchecksec(tree, *argv, ROFFSec_PR_Dt, 1))
		return(roff_errp(tree, *argv, tok, ERR_PR_OOO));

	argv++;
	tree->asec |= (tree->csec = ROFFSec_PR_Dt);
	sz = sizeof(tree->title);

	if (NULL == *argv) 
		return(roff_errp(tree, *argv, tok, ERR_ARGGE2));
	if (strlcpy(tree->title, *argv, sz) >= sz)
		return(roff_errp(tree, *argv, tok, ERR_ARGLEN));

	argv++;
	if (NULL == *argv)
		return(roff_errp(tree, *argv, tok, ERR_ARGGE2));

	if (ROFF_MSEC_MAX == (tree->section = roff_msec(*argv)))
		return(roff_errp(tree, *argv, tok, ERR_BADARG));

	argv++;

	if (NULL == *argv) {
		switch (tree->section) {
		case(ROFF_MSEC_1):
			/* FALLTHROUGH */
		case(ROFF_MSEC_6):
			/* FALLTHROUGH */
		case(ROFF_MSEC_7):
			tree->volume = ROFF_VOL_URM;
			break;
		case(ROFF_MSEC_2):
			/* FALLTHROUGH */
		case(ROFF_MSEC_3):
			/* FALLTHROUGH */
		case(ROFF_MSEC_3p):
			/* FALLTHROUGH */
		case(ROFF_MSEC_4):
			/* FALLTHROUGH */
		case(ROFF_MSEC_5):
			tree->volume = ROFF_VOL_PRM;
			break;
		case(ROFF_MSEC_8):
			tree->volume = ROFF_VOL_PRM;
			break;
		case(ROFF_MSEC_9):
			tree->volume = ROFF_VOL_KM;
			break;
		case(ROFF_MSEC_UNASS):
			/* FALLTHROUGH */
		case(ROFF_MSEC_DRAFT):
			/* FALLTHROUGH */
		case(ROFF_MSEC_PAPER):
			tree->volume = ROFF_VOL_NONE;
			break;
		default:
			abort();
			/* NOTREACHED */
		}
	} else if (ROFF_VOL_MAX == (tree->volume = roff_vol(*argv)))
		return(roff_errp(tree, *argv, tok, ERR_BADARG));

	assert(NULL == tree->last);

	return(1);
}


static int
roffsetname(struct rofftree *tree, char **ordp)
{
	size_t		 sz;
	
	assert(*ordp);

	/* FIXME: not all sections can set this. */

	if (NULL != *(ordp + 1))
		return(roff_errp(tree, *ordp, ROFF_Nm, ERR_ARGMNY));
	
	sz = sizeof(tree->name);
	if (strlcpy(tree->name, *ordp, sz) >= sz)
		return(roff_errp(tree, *ordp, ROFF_Nm, ERR_ARGLEN));

	return(1);
}


/* ARGSUSED */
static	int
roff_Ns(ROFFCALL_ARGS)
{
	int		 j, c, first;
	char		*morep[1];

	first = (*argv++ == tree->cur);
	morep[0] = NULL;

	if ( ! roffspecial(tree, tok, *argv, NULL, NULL, 0, morep))
		return(0);

	while (*argv) {
		if (ROFF_MAX != (c = rofffindcallable(*argv))) {
			if ( ! roffcall(tree, c, argv))
				return(0);
			break;
		}

		if ( ! roffispunct(*argv)) {
			if ( ! roffdata(tree, 1, *argv++))
				return(0);
			continue;
		}

		for (j = 0; argv[j]; j++)
			if ( ! roffispunct(argv[j]))
				break;

		if (argv[j]) {
			if ( ! roffdata(tree, 0, *argv++))
				return(0);
			continue;
		}

		break;
	}

	if ( ! first)
		return(1);

	return(roffpurgepunct(tree, argv));
}


/* ARGSUSED */
static	int
roff_Os(ROFFCALL_ARGS)
{
	char		*p;
	size_t		 sz;

	if (ROFFSec_PR_Os & tree->asec)
		return(roff_text(tok, tree, argv, type));
	if ( ! roffchecksec(tree, *argv, ROFFSec_PR_Os, 1))
		return(roff_errp(tree, *argv, tok, ERR_PR_OOO));

	p = *++argv;
	sz = sizeof(tree->os);
	tree->asec |= (tree->csec = ROFFSec_PR_Os);

	tree->os[0] = 0;

	while (*argv)
		if (strlcat(tree->os, *argv++, sz) >= sz)
			return(roff_errp(tree, p, tok, ERR_ARGLEN));

	if (0 == tree->os[0])
		if (strlcpy(tree->os, "LOCAL", sz) >= sz)
			return(roff_errp(tree, p, tok, ERR_ARGLEN));

	assert(ROFF_MSEC_MAX != tree->section);
	assert(0 != tree->title[0]);
	assert(0 != tree->os[0]);

	assert(NULL == tree->last);

	return((*tree->cb.roffhead)(tree->arg, &tree->tm,
				tree->os, tree->title, 
				tree->section, tree->volume));
}


/* ARGSUSED */
static int
roff_layout(ROFFCALL_ARGS) 
{
	int		 i, c, argcp[ROFF_MAXLINEARG];
	char		*argvp[ROFF_MAXLINEARG], *p;

	/*
	 * The roff_layout function is for multi-line macros.  A layout
	 * has a start and end point, which is either declared
	 * explicitly or implicitly.  An explicit start and end is
	 * embodied by `.Bl' and `.El', with the former being the start
	 * and the latter being an end.  The `.Sh' and `.Ss' tags, on
	 * the other hand, are implicit.  The scope of a layout is the
	 * space between start and end.  Explicit layouts may not close
	 * out implicit ones and vice versa; implicit layouts may close
	 * out other implicit layouts.
	 */

	assert( ! (ROFF_CALLABLE & tokens[tok].flags));

	if ( ! (ROFFSec_PR_Os & tree->asec))
		return(roff_errp(tree, *argv, tok, ERR_NOT_PR));

	if (ROFF_EXIT == type) {
		roffnode_free(tree);
		if ( ! (*tree->cb.roffblkbodyout)(tree->arg, tok))
			return(0);
		return((*tree->cb.roffblkout)(tree->arg, tok));
	} 

	p = *argv++;
	assert( ! (ROFF_CALLABLE & tokens[tok].flags));

	if ( ! roffparseopts(tree, tok, &argv, argcp, argvp))
		return(0);
	if (NULL == roffnode_new(tok, tree))
		return(0);

	/*
	 * Layouts have two parts: the layout body and header.  The
	 * layout header is the trailing text of the line macro, while
	 * the layout body is everything following until termination.
	 * Example:
	 *
	 * .It Fl f ) ;
	 * Bar.
	 *
	 * ...Produces...
	 *
	 * <block>
	 * 	<head>
	 * 		<!Fl f!> ;
	 * 	</head>
	 * 	
	 *	<body>
	 *		Bar.
	 *	</body>
	 * </block>
	 */

	if ( ! (*tree->cb.roffblkin)(tree->arg, tok, argcp, 
				(const char **)argvp))
		return(0);

	/* +++ Begin run macro-specific hooks over argv. */

	switch (tok) {
	case (ROFF_Bd):
		tree->literal++;
		break;

	case (ROFF_Sh):
		if (NULL == *argv) {
			argv--;
			return(roff_errp(tree, *argv, tok, ERR_ARGGE1));
		}

		tree->csec = roff_sec((const char **)argv);

		if ( ! (ROFFSec_OTHER & tree->csec) &&
				tree->asec & tree->csec) 
			if ( ! roff_warn(tree, *argv, "section repeated"))
				return(0);

		if (0 == tree->asec && ! (ROFFSec_NAME & tree->csec))
			return(roff_err(tree, *argv, "`NAME' section "
						"must be first"));
		if ( ! roffchecksec(tree, *argv, tree->csec, 0))
			return(0);

		tree->asec |= tree->csec;

		if ( ! roffspecial(tree, tok, p, argcp, 
					(const char **)argvp, 0, argv))
			return(0);
		break;
	default:
		break;
	}

	/* --- End run macro-specific hooks over argv. */

	if (NULL == *argv)
		return((*tree->cb.roffblkbodyin)
				(tree->arg, tok, argcp, 
				 (const char **)argvp));

	if ( ! (*tree->cb.roffblkheadin)(tree->arg, tok, argcp, 
				(const char **)argvp))
		return(0);

	/*
	 * If there are no parsable parts, then write remaining tokens
	 * into the layout header and exit.
	 */

	if ( ! (ROFF_PARSED & tokens[tok].flags)) {
		i = 0;
		while (*argv)
			if ( ! roffdata(tree, i++, *argv++))
				return(0);

		if ( ! (*tree->cb.roffblkheadout)(tree->arg, tok))
			return(0);
		return((*tree->cb.roffblkbodyin)(tree->arg, tok, argcp,
				 (const char **)argvp));
	}

	/*
	 * Parsable elements may be in the header (or be the header, for
	 * that matter).  Follow the regular parsing rules for these.
	 */

	i = 0;
	while (*argv) {
		if (ROFF_MAX == (c = rofffindcallable(*argv))) {
			assert(tree->arg);
			if ( ! roffdata(tree, i++, *argv++))
				return(0);
			continue;
		}
		if ( ! roffcall(tree, c, argv))
			return(0);
		break;
	}

	/* 
	 * If there's trailing punctuation in the header, then write it
	 * out now.  Here we mimic the behaviour of a line-dominant text
	 * macro.
	 */

	if (NULL == *argv) {
		if ( ! (*tree->cb.roffblkheadout)(tree->arg, tok))
			return(0);
		return((*tree->cb.roffblkbodyin)
				(tree->arg, tok, argcp, 
				 (const char **)argvp));
	}

	/*
	 * Expensive.  Scan to the end of line then work backwards until
	 * a token isn't punctuation.
	 */

	if ( ! roffpurgepunct(tree, argv))
		return(0);
	if ( ! (*tree->cb.roffblkheadout)(tree->arg, tok))
		return(0);
	return((*tree->cb.roffblkbodyin)(tree->arg, 
				tok, argcp, (const char **)argvp));
}


/* ARGSUSED */
static int
roff_ordered(ROFFCALL_ARGS) 
{
	int		 i, first, c, argcp[ROFF_MAXLINEARG];
	char		*ordp[ROFF_MAXLINEARG], *p,
			*argvp[ROFF_MAXLINEARG];

	/*
	 * Ordered macros pass their arguments directly to handlers,
	 * instead of considering it free-form text.  Thus, the
	 * following macro looks as follows:
	 *
	 * .Xr foo 1 ) ,
	 *
	 * .Xr arg1 arg2 punctuation
	 */

	if ( ! (ROFFSec_PR_Os & tree->asec))
		return(roff_errp(tree, *argv, tok, ERR_NOT_PR));

	first = (*argv == tree->cur);
	p = *argv++;
	ordp[0] = NULL;

	if ( ! roffparseopts(tree, tok, &argv, argcp, argvp))
		return(0);

	if (NULL == *argv)
		return(roffspecial(tree, tok, p, argcp, 
					(const char **)argvp, 0, ordp));

	i = 0;
	while (*argv && i < ROFF_MAXLINEARG) {
		c = ROFF_PARSED & tokens[tok].flags ?
			rofffindcallable(*argv) : ROFF_MAX;

		if (ROFF_MAX == c && ! roffispunct(*argv)) {
			ordp[i++] = *argv++;
			continue;
		}
		ordp[i] = NULL;

		if (ROFF_MAX == c)
			break;

		if ( ! roffspecial(tree, tok, p, argcp, 
					(const char **)argvp,
					(size_t)i, ordp))
			return(0);

		return(roffcall(tree, c, argv));
	}

	assert(i != ROFF_MAXLINEARG);
	ordp[i] = NULL;

	if ( ! roffspecial(tree, tok, p, argcp, 
				(const char**)argvp,
				(size_t)i, ordp))
		return(0);

	/* FIXME: error if there's stuff after the punctuation. */

	if ( ! first || NULL == *argv)
		return(1);

	return(roffpurgepunct(tree, argv));
}


static int
macro_default(struct rofftree *tree, int tok, char *args[])
{
	char		**p;
	char		 *argv[ROFF_MAXLINEARG];
	int		  i, argc[ROFF_MAXLINEARG];

	if ( ! roffparseopts(tree, tok, &args, argc, argv))
		return(0);

	if ( ! (ROFF_PARSED & tokens[tok].flags)) 
		return((*tree->cb.macro)(tree->arg, tok, argc, argv, 0, args));

	p = args;

	while (*args) {
		c = rofffindcallable(*args);
		if (ROFF_MAX == c) {
			if (roffispunct(*args)) {


			}
		}

		if (ROFF_MAX != (c = rofffindcallable(*argv))) {
			if ( ! (ROFF_LSCOPE & tokens[tok].flags))
				if ( ! (*tree->cb.roffout)(tree->arg, tok))
					return(0);
	
			if ( ! roffcall(tree, c, argv))
				return(0);
			if (ROFF_LSCOPE & tokens[tok].flags)
				if ( ! (*tree->cb.roffout)(tree->arg, tok))
					return(0);
			break;
		}

		if ( ! roffispunct(*argv)) {
			if ( ! roffdata(tree, i++, *argv++))
				return(0);
			continue;
		}

		i = 1;
		for (j = 0; argv[j]; j++)
			if ( ! roffispunct(argv[j]))
				break;

		if (argv[j]) {
			if (ROFF_LSCOPE & tokens[tok].flags) {
				if ( ! roffdata(tree, 0, *argv++))
					return(0);
				continue;
			}
			if ( ! (*tree->cb.roffout)(tree->arg, tok))
				return(0);
			if ( ! roffdata(tree, 0, *argv++))
				return(0);
			if ( ! (*tree->cb.roffin)(tree->arg, tok, 
						argcp, 
						(const char **)argvp))
				return(0);

			i = 0;
			continue;
		}

		if ( ! (*tree->cb.roffout)(tree->arg, tok))
			return(0);
		break;
	}
}


/* ARGSUSED */
static int
roff_text(ROFFCALL_ARGS) 
{
	int		 i, j, first, c, argcp[ROFF_MAXLINEARG];
	char		*argvp[ROFF_MAXLINEARG];

	/*
	 * Text macros are similar to special tokens, except that
	 * arguments are instead flushed as pure data: we're only
	 * concerned with the macro and its arguments.  Example:
	 * 
	 * .Fl v W f ;
	 *
	 * ...Produces...
	 *
	 * <fl> v W f </fl> ;
	 */

	if ( ! (ROFFSec_PR_Os & tree->asec))
		return(roff_errp(tree, *argv, tok, ERR_NOT_PR));

	first = (*argv == tree->cur);
	argv++;

	if ( ! roffparseopts(tree, tok, &argv, argcp, argvp))
		return(0);
	if ( ! (*tree->cb.roffin)(tree->arg, tok, argcp, 
				(const char **)argvp))
		return(0);
	if (NULL == *argv)
		return((*tree->cb.roffout)(tree->arg, tok));

	if ( ! (ROFF_PARSED & tokens[tok].flags)) {
		i = 0;
		while (*argv)
			if ( ! roffdata(tree, i++, *argv++))
				return(0);
		return((*tree->cb.roffout)(tree->arg, tok));
	}

	/*
	 * Deal with punctuation.  Ugly.  Work ahead until we encounter
	 * terminating punctuation.  If we encounter it and all
	 * subsequent tokens are punctuation, then stop processing (the
	 * line-dominant macro will print these tokens after closure).
	 * If the punctuation is followed by non-punctuation, then close
	 * and re-open our scope, then continue.
	 */

	i = 0;
	while (*argv) {
		if (ROFF_MAX != (c = rofffindcallable(*argv))) {
			if ( ! (ROFF_LSCOPE & tokens[tok].flags))
				if ( ! (*tree->cb.roffout)(tree->arg, tok))
					return(0);
	
			if ( ! roffcall(tree, c, argv))
				return(0);
			if (ROFF_LSCOPE & tokens[tok].flags)
				if ( ! (*tree->cb.roffout)(tree->arg, tok))
					return(0);
			break;
		}

		if ( ! roffispunct(*argv)) {
			if ( ! roffdata(tree, i++, *argv++))
				return(0);
			continue;
		}

		i = 1;
		for (j = 0; argv[j]; j++)
			if ( ! roffispunct(argv[j]))
				break;

		if (argv[j]) {
			if (ROFF_LSCOPE & tokens[tok].flags) {
				if ( ! roffdata(tree, 0, *argv++))
					return(0);
				continue;
			}
			if ( ! (*tree->cb.roffout)(tree->arg, tok))
				return(0);
			if ( ! roffdata(tree, 0, *argv++))
				return(0);
			if ( ! (*tree->cb.roffin)(tree->arg, tok, 
						argcp, 
						(const char **)argvp))
				return(0);

			i = 0;
			continue;
		}

		if ( ! (*tree->cb.roffout)(tree->arg, tok))
			return(0);
		break;
	}

	if (NULL == *argv)
		return((*tree->cb.roffout)(tree->arg, tok));
	if ( ! first)
		return(1);

	return(roffpurgepunct(tree, argv));
}


/* ARGSUSED */
static int
roff_noop(ROFFCALL_ARGS)
{

	switch (tok) {
	case (ROFF_Ed):
		tree->literal--;
		break;
	default:
		break;
	}

	return(1);
}


/* ARGSUSED */
static int
roff_depr(ROFFCALL_ARGS)
{

	return(roff_errp(tree, *argv, tok, ERR_DEPREC));
}


/* FIXME: push this into the filter. */
static int
roff_warnp(const struct rofftree *tree, const char *pos,
		int tok, enum rofferr type)
{
	char		 *p;

	switch (type) {
	case (WRN_SECORD):
		p = "section at `%s' out of order";
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	return(roff_warn(tree, pos, p, toknames[tok]));
}


static int
roff_warn(const struct rofftree *tree, const char *pos, char *fmt, ...)
{
	va_list		 ap;
	char		 buf[128];

	va_start(ap, fmt);
	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
	va_end(ap);

	return((*tree->cb.roffmsg)(tree->arg, 
				ROFF_WARN, tree->cur, pos, buf));
}


/* FIXME: push this into the filter. */
static int
roff_errp(const struct rofftree *tree, const char *pos, 
		int tok, enum rofferr type)
{
	char		 *p;

	switch (type) {
	case (ERR_ARGEQ1):
		p = "`%s' expects exactly one argument";
		break;
	case (ERR_ARGEQ0):
		p = "`%s' expects exactly zero arguments";
		break;
	case (ERR_ARGGE1):
		p = "`%s' expects one or more arguments";
		break;
	case (ERR_ARGGE2):
		p = "`%s' expects two or more arguments";
		break;
	case (ERR_BADARG):
		p = "invalid argument for `%s'";
		break;
	case (ERR_NOTSUP):
		p = "macro `%s' is not supported";
		break;
	case(ERR_PR_OOO):
		p = "prelude macro `%s' is out of order";
		break;
	case(ERR_PR_REP):
		p = "prelude macro `%s' repeated";
		break;
	case(ERR_ARGLEN):
		p = "macro argument for `%s' is too long";
		break;
	case(ERR_DEPREC):
		p = "macro `%s' is deprecated";
		break;
	case(ERR_NOT_PR):
		p = "macro `%s' disallowed in prelude";
		break;
	case(ERR_ARGMNY):
		p = "too many arguments for macro `%s'";
		break;
	default:
		abort();
		/* NOTREACHED */
	}

	return(roff_err(tree, pos, p, toknames[tok]));
}


static int
roff_err(const struct rofftree *tree, const char *pos, char *fmt, ...)
{
	va_list		 ap;
	char		 buf[128];

	va_start(ap, fmt);
	if (-1 == vsnprintf(buf, sizeof(buf), fmt, ap))
		err(1, "vsnprintf");
	va_end(ap);

	return((*tree->cb.roffmsg)
			(tree->arg, ROFF_ERROR, tree->cur, pos, buf));
}

@


1.63
log
@Ready for looking over by people.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.62 2008/12/10 13:41:59 kristaps Exp $ */
d77 1
d222 3
d1235 4
d1413 74
d1601 8
d1622 1
d1657 1
@


1.62
log
@Sx to Sh anchors work.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.61 2008/12/10 13:15:55 kristaps Exp $ */
d1184 1
a1184 1
	if ( ! ROFFSec_NAME & tree->asec)
d1352 1
a1352 1
	if ( ! ROFFSec_NAME & tree->asec)
d1424 1
a1424 1
	if ( ! ROFFSec_NAME & tree->asec)
@


1.61
log
@Put prelude checking into asec.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.60 2008/12/10 12:09:47 kristaps Exp $ */
a40 1
/* TODO: validate Dt macro arguments. */
d1168 1
a1168 1
	char		*argvp[ROFF_MAXLINEARG];
d1194 1
a1194 1
	argv++;
d1251 4
@


1.60
log
@Linted on NetBSD side.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.59 2008/12/10 12:05:33 kristaps Exp $ */
a73 6
	int		  state;
#define	ROFF_PRELUDE	 (1 << 1)		/* In roff prelude. */ /* FIXME: put into asec. */
#define	ROFF_PRELUDE_Os	 (1 << 2)		/* `Os' is parsed. */
#define	ROFF_PRELUDE_Dt	 (1 << 3)		/* `Dt' is parsed. */
#define	ROFF_PRELUDE_Dd	 (1 << 4)		/* `Dd' is parsed. */
#define	ROFF_BODY	 (1 << 5)		/* In roff body. */
d97 1
a97 1
				const char *, int);
d137 1
a137 4
	if (ROFF_PRELUDE & tree->state) {
		(void)roff_err(tree, NULL, "prelude never finished");
		goto end;
	} else if ( ! (ROFFSec_NAME & tree->asec)) {
a186 1
	tree->state = ROFF_PRELUDE;
d219 2
a220 2
	if ( ! (ROFF_BODY & tree->state))
		return(roff_err(tree, buf, "data not in body"));
d347 1
a347 1
	if (ROFF_PRELUDE & tree->state) {
a351 2
	assert(ROFF_BODY & tree->state);

d518 2
a519 1
roffchecksec(struct rofftree *tree, const char *start, int sec)
d523 14
d597 2
a602 1
/* FIXME: move this into literals.c (or similar). */
d926 1
a926 3
	if (ROFF_BODY & tree->state) {
		assert( ! (ROFF_PRELUDE & tree->state));
		assert(ROFF_PRELUDE_Dd & tree->state);
d928 1
a928 6
	}

	assert(ROFF_PRELUDE & tree->state);
	assert( ! (ROFF_BODY & tree->state));

	if (ROFF_PRELUDE_Dd & tree->state)
d930 1
a930 1
	if (ROFF_PRELUDE_Dt & tree->state)
a933 1

d935 1
a946 1
		tree->state |= ROFF_PRELUDE_Dd;
d960 1
a960 2
		if (strptime(buf, "%b%d,%Y", &tree->tm)) {
			tree->state |= ROFF_PRELUDE_Dd;
a961 1
		}
a978 1
	tree->state |= ROFF_PRELUDE_Dd;
d989 1
a989 3
	if (ROFF_BODY & tree->state) {
		assert( ! (ROFF_PRELUDE & tree->state));
		assert(ROFF_PRELUDE_Dt & tree->state);
d991 3
a993 6
	}

	assert(ROFF_PRELUDE & tree->state);
	assert( ! (ROFF_BODY & tree->state));

	if ( ! (ROFF_PRELUDE_Dd & tree->state))
a994 2
	if (ROFF_PRELUDE_Dt & tree->state)
		return(roff_errp(tree, *argv, tok, ERR_PR_REP));
d997 1
a1054 1
	tree->state |= ROFF_PRELUDE_Dt;
d1133 1
a1133 3
	if (ROFF_BODY & tree->state) {
		assert( ! (ROFF_PRELUDE & tree->state));
		assert(ROFF_PRELUDE_Os & tree->state);
d1135 1
a1135 5
	}

	assert(ROFF_PRELUDE & tree->state);
	if ( ! (ROFF_PRELUDE_Dt & tree->state) ||
			! (ROFF_PRELUDE_Dd & tree->state)) 
a1137 2
	tree->os[0] = 0;

d1140 3
a1151 4
	tree->state |= ROFF_PRELUDE_Os;
	tree->state &= ~ROFF_PRELUDE;
	tree->state |= ROFF_BODY;

d1185 1
a1185 1
	if (ROFF_PRELUDE & tree->state)
d1248 1
a1248 1
		if ( ! roffchecksec(tree, *argv, tree->csec))
d1349 1
a1349 1
	if (ROFF_PRELUDE & tree->state)
d1421 1
a1421 1
	if (ROFF_PRELUDE & tree->state)
@


1.59
log
@Versioning up.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.58 2008/12/10 10:43:57 kristaps Exp $ */
d62 1
a62 1
	WRN_SECORD,			/* Sections out-of-order. */
a531 1
	int		 prior;
d535 1
a535 1
		if ((prior = ROFFSec_NAME) & tree->asec)
d539 1
a539 1
		if ((prior = ROFFSec_SYNOP) & tree->asec)
d543 1
a543 1
		if ((prior = ROFFSec_DESC) & tree->asec)
d547 1
a547 1
		if ((prior = ROFFSec_RETVAL) & tree->asec)
d551 1
a551 1
		if ((prior = ROFFSec_ENV) & tree->asec)
d555 1
a555 1
		if ((prior = ROFFSec_FILES) & tree->asec)
d559 1
a559 1
		if ((prior = ROFFSec_EX) & tree->asec)
d563 1
a563 1
		if ((prior = ROFFSec_DIAG) & tree->asec)
d567 1
a567 1
		if ((prior = ROFFSec_ERRS) & tree->asec)
d571 1
a571 1
		if ((prior = ROFFSec_SEEALSO) & tree->asec)
d575 1
a575 1
		if ((prior = ROFFSec_STAND) & tree->asec)
d579 1
a579 1
		if ((prior = ROFFSec_HIST) & tree->asec)
d583 1
a583 1
		if ((prior = ROFFSec_AUTH) & tree->asec)
d587 1
a587 1
		if ((prior = ROFFSec_CAVEATS) & tree->asec)
@


1.58
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.57 2008/12/10 00:52:46 kristaps Exp $ */
d167 3
a169 1
	if ( ! (*tree->cb.rofftail)(tree->arg))
@


1.57
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.56 2008/12/09 19:57:26 kristaps Exp $ */
d73 1
a73 1
	char		  volume[64];		/* `Dt' results. */
a1024 1
	sz = sizeof(tree->volume);
d1027 38
a1064 3
		tree->volume[0] = 0;
	} else if (strlcpy(tree->volume, *argv, sz) >= sz)
		return(roff_errp(tree, *argv, tok, ERR_ARGLEN));
@


1.56
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.55 2008/12/09 17:09:12 kristaps Exp $ */
d1157 1
a1157 1
	char		*argvp[ROFF_MAXLINEARG], *p;
d1183 1
a1185 2
	p = *argv++;

@


1.55
log
@Considerable clean-ups.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.54 2008/12/09 00:27:17 kristaps Exp $ */
d707 1
a707 1
		if (ROFF_ATT_MAX == roff_att(*ordp))
@


1.54
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.53 2008/12/08 20:32:49 kristaps Exp $ */
a30 1
#include "libmdocml.h"
a39 1
/* TODO: unify empty-content tags a la <br />. */
a42 1
/* FIXME: Nm has newline when used in NAME section. */
d45 18
a62 2
	int		  tok;			/* Token id. */
	struct roffnode	 *parent;		/* Parent (or NULL). */
d75 1
a75 1
#define	ROFF_PRELUDE	 (1 << 1)		/* In roff prelude. */
d88 1
a88 1
static	void		  roff_warn(const struct rofftree *, 
d90 3
a92 1
static	void		  roff_err(const struct rofftree *, 
d94 2
a100 2
static	int		  roffismsec(const char *);
static	int		  roffissec(const char **);
a101 1
static	int		  roffisatt(const char *);
d150 1
a150 1
		roff_warn(tree, NULL, "missing suggested `NAME', "
d593 1
a593 114
	roff_warn(tree, start, "section violates conventional order");
	return(1);
}


/* FIXME: move this into literals.c. */
static int
roffissec(const char **p)
{

	assert(*p);
	if (NULL != *(p + 1)) {
		if (NULL != *(p + 2))
			return(ROFFSec_OTHER);
		if (0 == strcmp(*p, "RETURN") &&
				0 == strcmp(*(p + 1), "VALUES"))
			return(ROFFSec_RETVAL);
		if (0 == strcmp(*p, "SEE") &&
				0 == strcmp(*(p + 1), "ALSO"))
			return(ROFFSec_SEEALSO);
		return(ROFFSec_OTHER);
	}

	if (0 == strcmp(*p, "NAME"))
		return(ROFFSec_NAME);
	else if (0 == strcmp(*p, "SYNOPSIS"))
		return(ROFFSec_SYNOP);
	else if (0 == strcmp(*p, "DESCRIPTION"))
		return(ROFFSec_DESC);
	else if (0 == strcmp(*p, "ENVIRONMENT"))
		return(ROFFSec_ENV);
	else if (0 == strcmp(*p, "FILES"))
		return(ROFFSec_FILES);
	else if (0 == strcmp(*p, "EXAMPLES"))
		return(ROFFSec_EX);
	else if (0 == strcmp(*p, "DIAGNOSTICS")) 
		return(ROFFSec_DIAG);
	else if (0 == strcmp(*p, "ERRORS"))
		return(ROFFSec_ERRS);
	else if (0 == strcmp(*p, "STANDARDS"))
		return(ROFFSec_STAND);
	else if (0 == strcmp(*p, "HISTORY"))
		return(ROFFSec_HIST);
	else if (0 == strcmp(*p, "AUTHORS"))
		return(ROFFSec_AUTH);
	else if (0 == strcmp(*p, "CAVEATS"))
		return(ROFFSec_CAVEATS);
	else if (0 == strcmp(*p, "BUGS"))
		return(ROFFSec_BUGS);

	return(ROFFSec_OTHER);
}


/* FIXME: move this into literals.c. */
static int
roffismsec(const char *p)
{

	if (0 == strcmp(p, "1"))
		return(ROFF_MSEC_1);
	else if (0 == strcmp(p, "2"))
		return(ROFF_MSEC_2);
	else if (0 == strcmp(p, "3"))
		return(ROFF_MSEC_3);
	else if (0 == strcmp(p, "3p"))
		return(ROFF_MSEC_3p);
	else if (0 == strcmp(p, "4"))
		return(ROFF_MSEC_4);
	else if (0 == strcmp(p, "5"))
		return(ROFF_MSEC_5);
	else if (0 == strcmp(p, "6"))
		return(ROFF_MSEC_6);
	else if (0 == strcmp(p, "7"))
		return(ROFF_MSEC_7);
	else if (0 == strcmp(p, "8"))
		return(ROFF_MSEC_8);
	else if (0 == strcmp(p, "9"))
		return(ROFF_MSEC_9);
	else if (0 == strcmp(p, "unass"))
		return(ROFF_MSEC_UNASS);
	else if (0 == strcmp(p, "draft"))
		return(ROFF_MSEC_DRAFT);
	else if (0 == strcmp(p, "paper"))
		return(ROFF_MSEC_PAPER);

	return(ROFF_MSEC_MAX);
}


/* FIXME: move this into literals.c. */
static int
roffisatt(const char *p)
{

	assert(p);
	if (0 == strcmp(p, "v1"))
		return(1);
	else if (0 == strcmp(p, "v2")) 
		return(1);
	else if (0 == strcmp(p, "v3")) 
		return(1);
	else if (0 == strcmp(p, "v6")) 
		return(1);
	else if (0 == strcmp(p, "v7")) 
		return(1);
	else if (0 == strcmp(p, "32v"))
		return(1);
	else if (0 == strcmp(p, "V.1"))
		return(1);
	else if (0 == strcmp(p, "V.4"))
		return(1);

	return(0);
d707 1
a707 1
		if (roffisatt(*ordp))
d709 1
a709 1
		return(roff_err(tree, *ordp, "invalid `At' arg"));
d714 1
a714 1
			if (ROFF_MSEC_MAX != roffismsec(ordp[1]))
d716 3
a718 2
			roff_warn(tree, start, "invalid `%s' manual "
					"section", toknames[tok]);
d727 1
a727 2
		return(roff_err(tree, start, "`%s' expects at least "
					"one arg", toknames[tok]));
d731 4
a734 3
			if (0 == tree->name[0]) {
				roff_err(tree, start, "`Nm' not set");
				return(0);
d736 1
a736 2
			ordp[0] = tree->name;
			ordp[1] = NULL;
d746 1
a746 3
		roff_err(tree, start, "`%s' expects one arg", 
				toknames[tok]);
		return(0);
d749 6
a754 11
		if (1 != sz) {
			roff_err(tree, start, "`Sm' expects one arg");
			return(0);
		} 
		
		if (0 != strcmp(ordp[0], "on") &&
				0 != strcmp(ordp[0], "off")) {
			roff_err(tree, start, "`Sm' has invalid argument");
			return(0);
		}
		break;
d761 3
a763 6
		if (0 != sz) {
			roff_err(tree, start, "`%s' expects no args",
					toknames[tok]);
			return(0);
		}
		break;
d788 3
a790 5
	if (NULL == tokens[tok].cb) {
		roff_err(tree, *argv, "`%s' is unsupported", 
				toknames[tok]);
		return(0);
	}
d798 1
a798 1
			roff_warn(tree, *argv, "`%s' is not a valid "
d800 2
a801 1
					toknames[tok]);
d826 3
a828 2
		roff_warn(tree, arg, "argument-like parameter `%s' to "
				"`%s'", arg, toknames[tok]);
d833 3
a835 2
		roff_warn(tree, arg, "invalid argument parameter `%s' to "
				"`%s'", tokargnames[v], toknames[tok]);
d845 1
a845 1
		roff_err(tree, arg, "empty value of `%s' for `%s'",
d919 1
d930 4
a933 7
	if (ROFF_PRELUDE_Dd & tree->state) {
		roff_err(tree, *argv, "repeated `Dd' in prelude");
		return(0);
	} else if (ROFF_PRELUDE_Dt & tree->state) {
		roff_err(tree, *argv, "out-of-order `Dd' in prelude");
		return(0);
	}
d939 6
a952 2
	/* Build this from Mdocdate or raw date. */
	
d955 1
d959 1
a959 2
			if (strlcat(buf, *argv++, sizeof(buf))
					< sizeof(buf)) 
d961 1
a961 2
			roff_err(tree, p, "bad `Dd' date");
			return(0);
d967 1
a967 2
		roff_err(tree, *argv, "bad `Dd' date");
		return(0);
d971 1
d973 4
a976 14
		if (strlcat(buf, *argv++, sizeof(buf))
				>= sizeof(buf)) {
			roff_err(tree, p, "bad `Dd' Mdocdate");
			return(0);
		} 
		if (strlcat(buf, " ", sizeof(buf))
				>= sizeof(buf)) {
			roff_err(tree, p, "bad `Dd' Mdocdate");
			return(0);
		}
	}
	if (NULL == *argv) {
		roff_err(tree, p, "bad `Dd' Mdocdate");
		return(0);
d979 4
a982 4
	if (NULL == strptime(buf, "%b %d %Y", &tree->tm)) {
		roff_err(tree, *argv, "bad `Dd' Mdocdate");
		return(0);
	}
d993 1
d1004 4
a1007 7
	if ( ! (ROFF_PRELUDE_Dd & tree->state)) {
		roff_err(tree, *argv, "out-of-order `Dt' in prelude");
		return(0);
	} else if (ROFF_PRELUDE_Dt & tree->state) {
		roff_err(tree, *argv, "repeated `Dt' in prelude");
		return(0);
	}
d1010 6
a1015 8
	if (NULL == *argv) {
		roff_err(tree, *argv, "`Dt' needs document title");
		return(0);
	} else if (strlcpy(tree->title, *argv, sizeof(tree->title))
			>= sizeof(tree->title)) {
		roff_err(tree, *argv, "`Dt' document title too long");
		return(0);
	}
d1018 2
a1019 4
	if (NULL == *argv) {
		roff_err(tree, *argv, "`Dt' needs section");
		return(0);
	} 
d1021 2
a1022 4
	if (ROFF_MSEC_MAX == (tree->section = roffismsec(*argv))) {
		roff_err(tree, *argv, "bad `Dt' section");
		return(0);
	}
d1025 2
d1029 2
a1030 5
	} else if (strlcpy(tree->volume, *argv, sizeof(tree->volume))
			>= sizeof(tree->volume)) {
		roff_err(tree, *argv, "`Dt' volume too long");
		return(0);
	}
d1042 1
d1048 2
a1049 4
	if (NULL != *(ordp + 1)) {
		roff_err(tree, *ordp, "too many `Nm' args");
		return(0);
	} 
d1051 3
a1053 5
	if (strlcpy(tree->name, *ordp, sizeof(tree->name)) 
			>= sizeof(tree->name)) {
		roff_err(tree, *ordp, "`Nm' arg too long");
		return(0);
	}
d1110 1
d1120 2
a1121 4
			! (ROFF_PRELUDE_Dd & tree->state)) {
		roff_err(tree, *argv, "out-of-order `Os' in prelude");
		return(0);
	}
d1126 1
d1128 3
a1130 7
	while (*argv) {
		if (strlcat(tree->os, *argv++, sizeof(tree->os))
				< sizeof(tree->os)) 
			continue;
		roff_err(tree, p, "`Os' value too long");
		return(0);
	}
d1133 2
a1134 5
		if (strlcpy(tree->os, "LOCAL", sizeof(tree->os))
				>= sizeof(tree->os)) {
			roff_err(tree, p, "`Os' value too long");
			return(0);
		}
d1147 2
a1148 2
				tree->os, tree->title, tree->section,
				tree->volume));
d1173 4
a1176 5
	if (ROFF_PRELUDE & tree->state) {
		roff_err(tree, *argv, "bad `%s' in prelude", 
				toknames[tok]);
		return(0);
	} else if (ROFF_EXIT == type) {
d1223 2
a1224 3
			roff_err(tree, *(argv - 1), 
					"`Sh' expects arguments");
			return(0);
d1226 3
a1228 1
		tree->csec = roffissec((const char **)argv);
d1231 7
a1237 6
			roff_warn(tree, *argv, "section repeated");
		if (0 == tree->asec && ! (ROFFSec_NAME & tree->csec)) {
			roff_err(tree, *argv, "`NAME' section "
					"must be first");
			return(0);
		} else if ( ! roffchecksec(tree, *argv, tree->csec))
d1338 2
a1339 5
	if (ROFF_PRELUDE & tree->state) {
		roff_err(tree, *argv, "`%s' disallowed in prelude", 
				toknames[tok]);
		return(0);
	}
d1410 2
a1411 5
	if (ROFF_PRELUDE & tree->state) {
		roff_err(tree, *argv, "`%s' disallowed in prelude", 
				toknames[tok]);
		return(0);
	}
a1428 1

a1449 1
	
a1452 1
	
d1514 20
a1533 2
	roff_err(tree, *argv, "`%s' is deprecated", toknames[tok]);
	return(0);
d1537 1
a1537 1
static void
d1547 54
a1600 2
	(*tree->cb.roffmsg)(tree->arg, 
			ROFF_WARN, tree->cur, pos, buf);
d1604 1
a1604 1
static void
d1611 2
a1612 1
	(void)vsnprintf(buf, sizeof(buf), fmt, ap);
d1615 2
a1616 2
	(*tree->cb.roffmsg)(tree->arg, 
			ROFF_ERROR, tree->cur, pos, buf);
@


1.53
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.52 2008/12/08 16:29:57 kristaps Exp $ */
d130 1
a130 1
		roff_err(tree, NULL, "prelude never finished");
d133 1
a133 1
		roff_err(tree, NULL, "missing `NAME' section");
d142 2
a143 2
		roff_err(tree, NULL, "closing explicit scope `%s'", 
				toknames[n->tok]);
d197 3
a199 4
	if (0 == *buf) {
		roff_err(tree, buf, "blank line");
		return(0);
	} else if ('.' != *buf)
d213 2
a214 4
	if ( ! (ROFF_BODY & tree->state)) {
		roff_err(tree, buf, "data not in body");
		return(0);
	}
d270 3
a272 7
			if (0 == *buf) {
				roff_err(tree, argv[i], "unclosed "
						"quote in argument "
						"list for `%s'", 
						toknames[tok]);
				return(0);
			}
d295 2
a296 5
	if (ROFF_MAXLINEARG == i && *buf) {
		roff_err(tree, p, "too many arguments for `%s'", toknames
				[tok]);
		return(0);
	}
d330 3
a332 4
	if (ROFF_MAX == (tok = rofffindtok(buf + 1))) {
		roff_err(tree, buf, "bogus line macro");
		return(0);
	} else if ( ! roffargs(tree, tok, buf, argv)) 
d354 4
a357 6
			(tree->last->tok, tokens[tok].parents)) {
		roff_err(tree, *argvp, "`%s' has invalid parent `%s'",
				toknames[tok], 
				toknames[tree->last->tok]);
		return(0);
	} 
d360 4
a363 6
			(tok, tokens[tree->last->tok].children)) {
		roff_err(tree, *argvp, "`%s' is invalid child of `%s'",
				toknames[tok],
				toknames[tree->last->tok]);
		return(0);
	}
d403 4
a406 3
			roff_err(tree, *argv, "`%s' breaks `%s' scope",
					toknames[tok], toknames[n->tok]);
			return(0);
d447 4
a450 3
			roff_err(tree, *argv, "`%s' breaks `%s' scope",
					toknames[tok], toknames[n->tok]);
			return(0);
d454 4
a457 7

	if (NULL == n) {
		roff_err(tree, *argv, "`%s' has no starting tag `%s'",
				toknames[tok], 
				toknames[tokens[tok].ctx]);
		return(0);
	}
d584 1
d633 1
d669 1
d696 1
d808 1
a808 2
		roff_err(tree, *ordp, "invalid `At' arg");
		return(0);
d825 2
a826 3
		roff_err(tree, start, "`%s' expects at least "
				"one arg", toknames[tok]);
		return(0);
@


1.52
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.51 2008/12/08 12:46:28 kristaps Exp $ */
d87 1
d684 26
d818 1
a818 15
		if (0 == strcmp(*ordp, "v1"))
			break;
		else if (0 == strcmp(*ordp, "v2")) 
			break;
		else if (0 == strcmp(*ordp, "v3")) 
			break;
		else if (0 == strcmp(*ordp, "v6")) 
			break;
		else if (0 == strcmp(*ordp, "v7")) 
			break;
		else if (0 == strcmp(*ordp, "32v"))
			break;
		else if (0 == strcmp(*ordp, "V.1"))
			break;
		else if (0 == strcmp(*ordp, "V.4"))
d1307 1
a1307 1
	char		*argvp[ROFF_MAXLINEARG];
d1336 1
a1336 1
	++argv;
@


1.51
log
@Added warnings for using macros in the wrong sections.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.50 2008/12/07 22:40:18 kristaps Exp $ */
a37 1
/* TODO: warn about "X section only" macros. */
d69 2
d85 1
d87 2
d131 6
a136 1
	} 
d340 1
a340 1
		roff_err(tree, buf + 1, "bogus line macro");
d529 119
d791 7
a797 1
		if (0 == strcmp(*ordp, "v6"))
d807 1
a807 1
		roff_err(tree, start, "invalid `At' arg");
d820 2
a842 2
	case (ROFF_Sx):
		/* FALLTHROUGH*/
d1296 14
d1334 16
d1355 29
d1406 1
a1406 2
		return((*tree->cb.roffblkbodyin)
				(tree->arg, tok, argcp, 
a1448 1

d1451 2
a1452 3
	return((*tree->cb.roffblkbodyin)
			(tree->arg, tok, argcp, 
			 (const char **)argvp));
d1464 10
d1482 1
d1487 1
a1487 2
	if (NULL == *argv) {
		ordp[0] = NULL;
a1489 1
	}
d1537 12
@


1.50
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.49 2008/12/07 16:41:04 kristaps Exp $ */
d60 1
a60 1
	char		  section[64];		/* `Dt' results. */
d83 2
d93 1
d139 1
a139 1
		if ( ! (*tokens[t].cb)(t, tree, NULL, ROFF_EXIT))
d172 1
d333 1
a333 8
	} else if (NULL == tokens[tok].cb) {
		roff_err(tree, buf + 1, "unsupported macro `%s'", 
				toknames[tok]);
		return(0);
	}

	assert(ROFF___ != tok);
	if ( ! roffargs(tree, tok, buf, argv)) 
d344 1
a344 1
		return((*tokens[tok].cb)(tok, tree, argvp, ROFF_ENTER));
d375 1
a375 1
		return((*tokens[tok].cb)(tok, tree, argvp, ROFF_ENTER));
d377 1
a377 1
		return((*tokens[tok].cb)(tok, tree, argvp, ROFF_ENTER));
d419 1
a419 1
			return((*tokens[tok].cb)(tok, tree, argvp, ROFF_ENTER));
d428 1
a428 1
			if ( ! (*tokens[t].cb)(t, tree, NULL, ROFF_EXIT))
d432 1
a432 1
		return((*tokens[tok].cb)(tok, tree, argvp, ROFF_ENTER));
d468 1
a468 1
		if ( ! (*tokens[t].cb)(t, tree, NULL, ROFF_EXIT))
d520 35
d677 7
d685 1
d750 9
d761 2
d765 1
a765 1
		roff_err(tree, *argv, "unsupported macro `%s'", 
d769 14
a782 3
	if ( ! (*tokens[tok].cb)(tok, tree, argv, ROFF_ENTER))
		return(0);
	return(1);
d1009 4
a1012 3
	} else if (strlcpy(tree->section, *argv, sizeof(tree->section))
			>= sizeof(tree->section)) {
		roff_err(tree, *argv, "`Dt' section too long");
d1143 4
@


1.49
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.48 2008/12/07 14:38:57 kristaps Exp $ */
d644 2
d704 2
a705 2
	return((*tree->cb.roffspecial)(tree->arg, tok, 
				tree->cur, argc, argv, ordp));
d1121 2
a1122 1
	if ( ! (*tree->cb.roffblkin)(tree->arg, tok, argcp, argvp))
d1126 2
a1127 1
				(tree->arg, tok, argcp, argvp));
d1129 2
a1130 1
	if ( ! (*tree->cb.roffblkheadin)(tree->arg, tok, argcp, argvp))
d1147 2
a1148 1
				(tree->arg, tok, argcp, argvp));
d1179 2
a1180 1
				(tree->arg, tok, argcp, argvp));
d1194 2
a1195 1
			(tree->arg, tok, argcp, argvp));
d1282 2
a1283 1
	if ( ! (*tree->cb.roffin)(tree->arg, tok, argcp, argvp))
d1344 3
a1346 2
			if ( ! (*tree->cb.roffin)(tree->arg, tok,
						argcp, argvp))
@


1.48
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.47 2008/12/06 21:10:31 kristaps Exp $ */
d643 7
d1211 2
a1212 1
	if (NULL == *argv)
d1215 1
d1293 2
d1326 7
d1335 5
@


1.47
log
@.St macros in place.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.46 2008/12/06 19:41:41 kristaps Exp $ */
d656 2
d661 5
a665 6
		if (1 != sz) {
			roff_err(tree, start, "`%s' expects one arg",
					toknames[tok]);
			return(0);
		}
		break;
@


1.46
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.45 2008/12/06 16:50:18 kristaps Exp $ */
d95 2
a96 1
				const char *, size_t, char **);
d622 3
a624 2
roffspecial(struct rofftree *tree, int tok, 
		const char *start, size_t sz, char **ordp)
d694 2
a695 2
	return((*tree->cb.roffspecial)
			(tree->arg, tok, tree->cur, ordp));
d992 1
a992 1
	if ( ! roffspecial(tree, tok, *argv, 0, morep))
d1204 2
a1205 1
		return(roffspecial(tree, tok, p, 0, ordp));
d1221 3
a1223 1
		if ( ! roffspecial(tree, tok, p, (size_t)i, ordp))
d1232 3
a1234 1
	if ( ! roffspecial(tree, tok, p, (size_t)i, ordp))
@


1.45
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.44 2008/12/06 13:18:44 kristaps Exp $ */
d626 16
d654 2
d657 3
a659 5
		if (0 == sz) {
			roff_err(tree, start, "`Ex' expects an arg");
			return(0);
		} else if (1 != sz) {
			roff_err(tree, start, "`Ex' expects one arg");
d665 1
a665 4
		if (0 == sz) {
			roff_err(tree, start, "`Sm' expects an arg");
			return(0);
		} else if (1 != sz) {
d679 2
a980 13
static int
roff_Sm(ROFFCALL_ARGS)
{
	char		*ordp[1], *p;

	p = *argv++;
	*ordp = *argv;

	return(roffspecial(tree, tok, p, *ordp ? 1 : 0, ordp));
}


/* ARGSUSED */
d1206 2
a1207 1
		c = rofffindcallable(*argv);
d1221 1
a1221 1
		return(roffcall(tree, c, ordp));
@


1.44
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.43 2008/12/05 22:54:44 kristaps Exp $ */
d663 10
a1182 2
	/* FIXME: the tail-switch statement is in two different places:
	 * consolidate. */
@


1.43
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.42 2008/12/05 22:34:30 kristaps Exp $ */
d94 2
a95 1
static	int		  roffspecial(struct rofftree *, int, char **);
a96 2
static	int		  roffgetname(struct rofftree *, char **,
				const char *);
d621 2
a622 1
roffspecial(struct rofftree *tree, int tok, char **ordp)
d625 44
a668 2
	return((*tree->cb.roffspecial)(tree->arg, tok, 
				tree->cur, ordp));
a932 13
roffgetname(struct rofftree *tree, char **ordp, const char *start)
{
	if (0 == tree->name[0]) {
		roff_err(tree, start, "`Nm' name not set");
		return(0);
	}
	*ordp++ = tree->name;
	*ordp = NULL;
	return(1);
}


static int
d959 1
a959 1
	char		*morep[1], *p;
d962 1
d964 1
a964 20
	if (NULL == (morep[0] = *argv++)) {
		roff_err(tree, p, "`Sm' expects an argument");
		return(0);
	} else if (0 != strcmp(morep[0], "on") && 
			0 != strcmp(morep[0], "off")) {
		roff_err(tree, p, "`Sm' has invalid argument");
		return(0);
	}

	if (*argv) 
		roff_warn(tree, *argv, "`Sm' shouldn't have arguments");

	if ( ! roffspecial(tree, tok, morep))
		return(0);

	while (*argv)
		if ( ! roffdata(tree, 1, *argv++))
			return(0);

	return(1);
d978 1
a978 1
	if ( ! roffspecial(tree, tok, morep))
d1173 5
a1177 2
	int		 i, first, c;
	char		*ordp[ROFF_MAXLINEARG];
d1186 1
a1186 1
	argv++;
d1188 2
a1189 10
	if (NULL == *argv) {
		switch (tok) {
		case (ROFF_Nm):
			if ( ! roffgetname(tree, ordp, *(argv - 1)))
				return(0);
			break;
		default:
			*ordp = NULL;
			break;
		}
d1191 2
a1192 2
		return(roffspecial(tree, tok, ordp));
	}
d1207 1
a1207 10
		switch (tok) {
		case (ROFF_Nm):
			if ( ! roffsetname(tree, ordp))
				return(0);
			break;
		default:
			break;
		}

		if ( ! roffspecial(tree, tok, ordp))
d1216 1
a1216 10
	switch (tok) {
	case (ROFF_Nm):
		if ( ! roffsetname(tree, ordp))
			return(0);
		break;
	default:
		break;
	}

	if ( ! roffspecial(tree, tok, ordp))
@


1.42
log
@Nm works properly, many other changes, etc.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.41 2008/12/05 11:28:17 kristaps Exp $ */
d33 1
d45 2
a46 33
/* FIXME: Bl -diag ignore callable children. */

enum	roffd { 
	ROFF_ENTER = 0, 
	ROFF_EXIT 
};

enum	rofftype { 
	ROFF_COMMENT, 
	ROFF_TEXT, 
	ROFF_LAYOUT,
	ROFF_SPECIAL
};

#define	ROFFCALL_ARGS \
	int tok, struct rofftree *tree, \
	char *argv[], enum roffd type

struct	rofftree;

struct	rofftok {
	int		(*cb)(ROFFCALL_ARGS);	/* Callback. */
	const int	 *args;			/* Args (or NULL). */
	const int	 *parents;		/* Limit to parents. */
	const int	 *children;		/* Limit to kids. */
	int		  ctx;			/* Blk-close node. */
	enum rofftype	  type;			/* Type of macro. */
	int	  	  flags;
#define	ROFF_PARSED	 (1 << 0)		/* "Parsed". */
#define	ROFF_CALLABLE	 (1 << 1)		/* "Callable". */
#define	ROFF_SHALLOW	 (1 << 2)		/* Nesting block. */
#define	ROFF_LSCOPE	 (1 << 3)		/* Line scope. */
};
a71 10
static	int		  roff_Dd(ROFFCALL_ARGS); /* FIXME: deprecate. */
static	int		  roff_Dt(ROFFCALL_ARGS); /* FIXME: deprecate. */
static	int		  roff_Os(ROFFCALL_ARGS); /* FIXME: deprecate. */
static	int		  roff_Ns(ROFFCALL_ARGS); /* FIXME: deprecate. */
static	int		  roff_Sm(ROFFCALL_ARGS); /* FIXME: deprecate. */
static	int		  roff_layout(ROFFCALL_ARGS);
static	int		  roff_text(ROFFCALL_ARGS);
static	int		  roff_noop(ROFFCALL_ARGS);
static	int		  roff_depr(ROFFCALL_ARGS);
static	int		  roff_ordered(ROFFCALL_ARGS);
a107 222

static	const int roffarg_An[] = { ROFF_Split, ROFF_Nosplit, ROFF_ARGMAX };
static	const int roffarg_Bd[] = { ROFF_Ragged, ROFF_Unfilled, ROFF_Literal,
	ROFF_File, ROFF_Offset, ROFF_Filled, ROFF_Compact, ROFF_ARGMAX };
static	const int roffarg_Bk[] = { ROFF_Words, ROFF_ARGMAX };
static	const int roffarg_Ex[] = { ROFF_Std, ROFF_ARGMAX };
static	const int roffarg_Rv[] = { ROFF_Std, ROFF_ARGMAX };
static 	const int roffarg_Bl[] = { ROFF_Bullet, ROFF_Dash, ROFF_Hyphen,
	ROFF_Item, ROFF_Enum, ROFF_Tag, ROFF_Diag, ROFF_Hang, ROFF_Ohang,
	ROFF_Inset, ROFF_Column, ROFF_Offset, ROFF_Width, ROFF_Compact,
	ROFF_ARGMAX };
static 	const int roffarg_St[] = { ROFF_p1003_1_88, ROFF_p1003_1_90,
	ROFF_p1003_1_96, ROFF_p1003_1_2001, ROFF_p1003_1_2004, ROFF_p1003_1,
	ROFF_p1003_1b, ROFF_p1003_1b_93, ROFF_p1003_1c_95, ROFF_p1003_1g_2000,
	ROFF_p1003_2_92, ROFF_p1387_2_95, ROFF_p1003_2, ROFF_p1387_2,
	ROFF_isoC_90, ROFF_isoC_amd1, ROFF_isoC_tcor1, ROFF_isoC_tcor2,
	ROFF_isoC_99, ROFF_ansiC, ROFF_ansiC_89, ROFF_ansiC_99, ROFF_ieee754,
	ROFF_iso8802_3, ROFF_xpg3, ROFF_xpg4, ROFF_xpg4_2, ROFF_xpg4_3,
	ROFF_xbd5, ROFF_xcu5, ROFF_xsh5, ROFF_xns5, ROFF_xns5_2d2_0,
	ROFF_xcurses4_2, ROFF_susv2, ROFF_susv3, ROFF_svid4, ROFF_ARGMAX };

static	const int roffchild_Bl[] = { ROFF_It, ROFF_El, ROFF_MAX };
static	const int roffchild_Fo[] = { ROFF_Fa, ROFF_Fc, ROFF_MAX };
static	const int roffchild_Rs[] = { ROFF_Re, ROFF__A, ROFF__B, ROFF__D,
	ROFF__I, ROFF__J, ROFF__N, ROFF__O, ROFF__P, ROFF__R, ROFF__T, ROFF__V,
	ROFF_MAX };

static	const int roffparent_El[] = { ROFF_Bl, ROFF_It, ROFF_MAX };
static	const int roffparent_Fc[] = { ROFF_Fo, ROFF_Fa, ROFF_MAX };
static	const int roffparent_Oc[] = { ROFF_Oo, ROFF_MAX };
static	const int roffparent_It[] = { ROFF_Bl, ROFF_It, ROFF_MAX };
static	const int roffparent_Re[] = { ROFF_Rs, ROFF_MAX };

static	const struct rofftok tokens[ROFF_MAX] = {
	{   roff_noop, NULL, NULL, NULL, 0, ROFF_COMMENT, 0 }, /* \" */
	{     roff_Dd, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Dd */
	{     roff_Dt, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Dt */
	{     roff_Os, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Os */
	{ roff_layout, NULL, NULL, NULL, ROFF_Sh, ROFF_LAYOUT, 0 }, /* Sh */
	{ roff_layout, NULL, NULL, NULL, ROFF_Ss, ROFF_LAYOUT, 0 }, /* Ss */ 
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Pp */ /* XXX 0 args */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_LSCOPE }, /* D1 */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_LSCOPE }, /* Dl */
	{ roff_layout, roffarg_Bd, NULL, NULL, 0, ROFF_LAYOUT, 0 }, 	/* Bd */
	{   roff_noop, NULL, NULL, NULL, ROFF_Bd, ROFF_LAYOUT, 0 }, /* Ed */
	{ roff_layout, roffarg_Bl, NULL, roffchild_Bl, 0, ROFF_LAYOUT, 0 }, /* Bl */
	{   roff_noop, NULL, roffparent_El, NULL, ROFF_Bl, ROFF_LAYOUT, 0 }, /* El */
	{ roff_layout, NULL, roffparent_It, NULL, ROFF_It, ROFF_LAYOUT, ROFF_PARSED | ROFF_SHALLOW }, /* It */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ad */ /* FIXME */
	{   roff_text, roffarg_An, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* An */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ar */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Cd */ /* XXX man.4 only */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Cm */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dv */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Er */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ev */ /* XXX needs arg */
	{   roff_text, roffarg_Ex, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Ex */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fa */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Fd */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fl */
	{roff_ordered, NULL, NULL, NULL, 0, ROFF_TEXT, /*XXX*/ -1 }, /* Fn */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ft */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ic */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* In */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Li */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Nd */
	{roff_ordered, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Nm */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Op */
	{   roff_depr, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Ot */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pa */
	{   roff_text, roffarg_Rv, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Rv */
	{   roff_text, roffarg_St, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* St */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Va */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Vt */ /* XXX needs arg */
	{roff_ordered, NULL, NULL, NULL, 0, ROFF_TEXT, /*XXX*/ -1 }, /* Xr */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* %A */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %B */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* %D */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %I */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %J */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* %N */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* %O */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* %P */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* %R */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* %T */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* %V */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ac */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ao */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Aq */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* At */ /* XXX at most 2 args */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bc */
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Bf */ /* FIXME */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bo */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Bq */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bsx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bx */
	{        NULL, NULL, NULL, NULL, 0, ROFF_SPECIAL, 0 },	/* Db */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dc */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Do */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Dq */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ec */
	{   roff_noop, NULL, NULL, NULL, ROFF_Bf, ROFF_LAYOUT, 0 }, /* Ef */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Em */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Eo */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Fx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ms */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* No */
	{     roff_Ns, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ns */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Nx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ox */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pc */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Pf */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Po */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Pq */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qc */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ql */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qo */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Qq */
	{   roff_noop, NULL, roffparent_Re, NULL, ROFF_Rs, ROFF_LAYOUT, 0 }, /* Re */
	{ roff_layout, NULL, NULL, roffchild_Rs, 0, ROFF_LAYOUT, 0 },	/* Rs */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sc */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* So */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_LSCOPE }, /* Sq */
	{     roff_Sm, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Sm */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sy */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Tn */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ux */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xc */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xo */
	{ roff_layout, NULL, NULL, roffchild_Fo, 0, ROFF_LAYOUT, 0 }, /* Fo */
	{   roff_noop, NULL, roffparent_Fc, NULL, ROFF_Fo, ROFF_LAYOUT, 0 }, /* Fc */
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Oo */
	{   roff_noop, NULL, roffparent_Oc, NULL, ROFF_Oo, ROFF_LAYOUT, 0 }, /* Oc */
	{ roff_layout, roffarg_Bk, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Bk */
	{   roff_noop, NULL, NULL, NULL, ROFF_Bk, ROFF_LAYOUT, 0 }, /* Ek */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Bt */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Hf */
	{   roff_depr, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Fr */
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Ud */
	};

#define	ROFF_VALUE	(1 << 0)

static	const int tokenargs[ROFF_ARGMAX] = {
	0,		0,		0,		0,
	0,		ROFF_VALUE,	ROFF_VALUE,	0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		ROFF_VALUE,	0,
	0,		ROFF_VALUE,	0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	0,		0,		0,		0,
	};

const	char *const toknamesp[ROFF_MAX] = {		 
	"\\\"",		"Dd",		"Dt",		"Os",
	"Sh",		"Ss",		"Pp",		"D1",
	"Dl",		"Bd",		"Ed",		"Bl",
	"El",		"It",		"Ad",		"An",
	"Ar",		"Cd",		"Cm",		"Dv",
	"Er",		"Ev",		"Ex",		"Fa",
	"Fd",		"Fl",		"Fn",		"Ft",
	"Ic",		"In",		"Li",		"Nd",
	"Nm",		"Op",		"Ot",		"Pa",
	"Rv",		"St",		"Va",		"Vt",
	/* LINTED */
	"Xr",		"\%A",		"\%B",		"\%D",
	/* LINTED */
	"\%I",		"\%J",		"\%N",		"\%O",
	/* LINTED */
	"\%P",		"\%R",		"\%T",		"\%V",
	"Ac",		"Ao",		"Aq",		"At",
	"Bc",		"Bf",		"Bo",		"Bq",
	"Bsx",		"Bx",		"Db",		"Dc",
	"Do",		"Dq",		"Ec",		"Ef",
	"Em",		"Eo",		"Fx",		"Ms",
	"No",		"Ns",		"Nx",		"Ox",
	"Pc",		"Pf",		"Po",		"Pq",
	"Qc",		"Ql",		"Qo",		"Qq",
	"Re",		"Rs",		"Sc",		"So",
	"Sq",		"Sm",		"Sx",		"Sy",
	"Tn",		"Ux",		"Xc",		"Xo",
	"Fo",		"Fc",		"Oo",		"Oc",
	"Bk",		"Ek",		"Bt",		"Hf",
	"Fr",		"Ud",
	};

const	char *const tokargnamesp[ROFF_ARGMAX] = {		 
	"split",		"nosplit",		"ragged",
	"unfilled",		"literal",		"file",		 
	"offset",		"bullet",		"dash",		 
	"hyphen",		"item",			"enum",		 
	"tag",			"diag",			"hang",		 
	"ohang",		"inset",		"column",	 
	"width",		"compact",		"std",	 
	"p1003.1-88",		"p1003.1-90",		"p1003.1-96",
	"p1003.1-2001",		"p1003.1-2004",		"p1003.1",
	"p1003.1b",		"p1003.1b-93",		"p1003.1c-95",
	"p1003.1g-2000",	"p1003.2-92",		"p1387.2-95",
	"p1003.2",		"p1387.2",		"isoC-90",
	"isoC-amd1",		"isoC-tcor1",		"isoC-tcor2",
	"isoC-99",		"ansiC",		"ansiC-89",
	"ansiC-99",		"ieee754",		"iso8802-3",
	"xpg3",			"xpg4",			"xpg4.2",
	"xpg4.3",		"xbd5",			"xcu5",
	"xsh5",			"xns5",			"xns5.2d2.0",
	"xcurses4.2",		"susv2",		"susv3",
	"svid4",		"filled",		"words",
	};

const	char *const *toknames = toknamesp;
const	char *const *tokargnames = tokargnamesp;


@


1.41
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.40 2008/12/04 23:10:51 kristaps Exp $ */
d87 1
d102 5
a106 5
static	int		  roff_Dd(ROFFCALL_ARGS);
static	int		  roff_Dt(ROFFCALL_ARGS);
static	int		  roff_Os(ROFFCALL_ARGS);
static	int		  roff_Ns(ROFFCALL_ARGS);
static	int		  roff_Sm(ROFFCALL_ARGS);
d135 3
d214 1
a214 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Nm */ /* FIXME */
d298 1
a298 1
	0,		0,		0,		0,
d1152 36
d1189 1
a1189 1
static	int
d1437 9
a1446 3
		/* FIXME: satisfies number of args? */

		ordp[0] = NULL;
d1452 17
a1468 3
		if (ROFF_MAX != (c = rofffindcallable(*argv)))
			return(roffcall(tree, c, argv));
		if (roffispunct(*argv)) 
d1470 4
d1475 1
a1475 1
		ordp[i++] = *argv++;
d1478 1
d1481 8
a1488 1
	/* FIXME: too many or too few args? */
d1490 1
a1490 2
	if (i == ROFF_MAXLINEARG && *argv) {
		roff_err(tree, *argv, "too many args", toknames[tok]);
a1491 1
	}
a1494 3
	if ( ! roffspecial(tree, tok, ordp))
		return(0);

@


1.40
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.39 2008/12/04 19:31:57 kristaps Exp $ */
d44 1
@


1.39
log
@Moved charset recognition into the filter.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.38 2008/12/04 16:34:59 kristaps Exp $ */
d70 1
a70 1
	int		  flags;
a76 5
struct	roffarg {
	int		  flags;
#define	ROFF_VALUE	 (1 << 0)		/* Has a value. */
};

d109 1
d132 1
d203 1
a203 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fn */ /* XXX needs arg */ /* FIXME */
d217 1
a217 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xr */ /* XXX needs arg */
d249 1
a249 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* No */
d271 2
a272 2
	{  NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xc */
	{  NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xo */
d285 2
d503 7
d525 11
a535 2
			while (*buf && ! isspace(*buf))
				buf++;
d543 1
a543 1
	
d879 9
d1151 1
a1151 2
	int		 argcp[1];
	char		*argvp[1], *morep[1], *p;
a1154 2
	argcp[0] = ROFF_ARGMAX;
	argvp[0] = NULL;
d1167 1
a1167 2
	if ( ! (*tree->cb.roffspecial)(tree->arg, 
				tok, argcp, argvp, morep))
d1183 1
a1183 2
	int		 argcp[1];
	char		*argvp[1], *morep[1];
d1186 1
d1188 1
a1188 5
	argcp[0] = ROFF_ARGMAX;
	argvp[0] = morep[0] = NULL;

	if ( ! (*tree->cb.roffspecial)(tree->arg, 
				tok, argcp, argvp, morep))
d1381 55
@


1.38
log
@Character-set validation fixes.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.37 2008/12/04 16:19:52 kristaps Exp $ */
a971 1
	int		 tok;
a974 13

	if (-1 == (tok = rofftok_scan(buf))) {
		roff_err(tree, buf, "invalid character sequence");
		return(0);
	} else if (ROFFTok_MAX != tok) {
		if (ROFFTok_Null == tok) { /* FIXME */
			buf += 2;
			return(roffdata(tree, space, buf));
		}
		return((*tree->cb.rofftoken)
				(tree->arg, space != 0, tok));
	}

@


1.37
log
@Character-encoding tests.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.36 2008/12/04 11:25:29 kristaps Exp $ */
d974 3
d980 5
a984 1
	} else if (ROFFTok_MAX != tok) 
d987 1
@


1.36
log
@More html-css.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.35 2008/12/03 19:21:58 kristaps Exp $ */
a44 2
#define	ROFF_MAXARG	  32

d134 2
a135 1
static	int		  textparse(const struct rofftree *, char *);
d274 2
a275 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xc */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xo */
d452 1
a452 1
textparse(const struct rofftree *tree, char *buf)
d454 3
d462 27
a488 1
	return((*tree->cb.roffdata)(tree->arg, 1, buf));
d505 1
a505 1
	for (i = 0; *buf && i < ROFF_MAXARG; i++) {
d530 1
a530 1
	if (ROFF_MAXARG == i && *buf) {
d561 1
a561 1
	char		 *argv[ROFF_MAXARG];
d938 1
a938 1
		if ( ! (*tree->cb.roffdata)(tree->arg, 0, argv[i++]))
d969 17
d1156 3
a1158 5
	while (*argv) {
		if ((*tree->cb.roffdata)(tree->arg, 1, *argv++))
			continue;
		return(0);
	}
d1189 3
a1191 3
			if ((*tree->cb.roffdata)(tree->arg, 1, *argv++))
				continue;
			return(0);
d1193 1
d1199 3
a1201 3
			if ((*tree->cb.roffdata)(tree->arg, 0, *argv++))
				continue;
			return(0);
d1268 2
a1269 2
	int		 i, c, argcp[ROFF_MAXARG];
	char		*argvp[ROFF_MAXARG];
d1313 2
a1314 2
		while (*argv) {
			if ( ! (*tree->cb.roffdata)(tree->arg, i, *argv++))
d1316 1
a1316 2
			i = 1;
		}
d1332 1
a1332 2
			if ( ! (*tree->cb.roffdata)
					(tree->arg, i, *argv++))
a1333 1
			i = 1;
d1373 2
a1374 2
	int		 i, j, first, c, argcp[ROFF_MAXARG];
	char		*argvp[ROFF_MAXARG];
d1394 2
a1395 2
		while (*argv) {
			if ( ! (*tree->cb.roffdata)(tree->arg, i, *argv++))
d1397 1
a1397 2
			i = 1;
		}
d1426 1
a1426 1
			if ( ! (*tree->cb.roffdata)(tree->arg, i, *argv++))
a1427 1
			i = 1;
d1437 1
a1437 1
			if ( ! (*tree->cb.roffdata)(tree->arg, 0, *argv++))
@


1.35
log
@Major update.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.34 2008/12/02 18:26:57 kristaps Exp $ */
d43 1
d1214 3
a1216 1
	return((*tree->cb.roffhead)(tree->arg));
@


1.34
log
@Transition to splitting xml/ml.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.33 2008/12/02 13:20:24 kristaps Exp $ */
d137 3
a139 3
#ifdef __linux__ /* FIXME: remove */
static	size_t		  strlcat(char *, const char *, size_t);
static	size_t		  strlcpy(char *, const char *, size_t);
d1230 2
d1253 4
a1256 2
		return(1);
	if ( ! (*tree->cb.roffin)(tree->arg, tok, argcp, argvp))
d1271 4
a1274 1
		return((*tree->cb.roffout)(tree->arg, tok));
d1303 6
a1308 2
	if (NULL == *argv)
		return((*tree->cb.roffout)(tree->arg, tok));
d1318 4
a1321 1
	return((*tree->cb.roffout)(tree->arg, tok));
a1461 77

#ifdef __linux /* FIXME: remove. */
/*	$OpenBSD: strlcat.c,v 1.13 2005/08/08 08:05:37 espie Exp $	*/

/*
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */
static size_t
strlcat(char *dst, const char *src, size_t siz)
{
	char *d = dst;
	const char *s = src;
	size_t n = siz;
	size_t dlen;

	/* Find the end of dst and adjust bytes left but don't go past
	 * end */
	while (n-- != 0 && *d != '\0')
		d++;
	dlen = d - dst;
	n = siz - dlen;

	if (n == 0)
		return(dlen + strlen(s));
	while (*s != '\0') {
		if (n != 1) {
			*d++ = *s;
			n--;
		}
		s++;
	}
	*d = '\0';

	return(dlen + (s - src));	/* count does not include NUL */
}


static size_t
strlcpy(char *dst, const char *src, size_t siz)
{
	char *d = dst;
	const char *s = src;
	size_t n = siz;

	/* Copy as many bytes as will fit */
	if (n != 0) {
		while (--n != 0) {
			if ((*d++ = *s++) == '\0')
				break;
		}
	}

	/* Not enough room in dst, add NUL and traverse rest of src */
	if (n == 0) {
		if (siz != 0)
			*d = '\0';		/* NUL-terminate dst */
		while (*s++)
			;
	}

	return(s - src - 1);	/* count does not include NUL */
}
#endif /*__linux__*/
@


1.33
log
@Added `Sm' functionality.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.32 2008/12/02 00:15:41 kristaps Exp $ */
d137 1
a137 1
#ifdef __linux__
d1449 1
a1449 1
#ifdef __linux
@


1.32
log
@Lint fixes and prettiness.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.31 2008/12/02 00:10:37 kristaps Exp $ */
d20 1
d34 2
d110 1
d133 1
d137 9
d269 1
a269 1
	{        NULL, NULL, NULL, NULL, 0, ROFF_SPECIAL, 0 }, /* Sm */
d835 15
d867 1
a867 1
				"`%s'", &arg[1], toknames[tok]);
d1085 1
a1085 1
roff_Ns(ROFFCALL_ARGS)
d1087 2
a1088 1
	int		 j, c, first;
d1090 1
a1090 1
	first = (*argv == tree->cur);
d1092 10
a1101 1
	argv++;
d1103 2
a1104 14
	if (ROFF_MAX != (c = rofffindcallable(*argv))) {
		if (NULL == tokens[c].cb) {
			roff_err(tree, *argv, "unsupported macro `%s'",
					toknames[c]);
			return(0);
		}
		if ( ! (*tree->cb.roffspecial)(tree->arg, tok))
			return(0);
		if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
			return(0);
		if ( ! first)
			return(1);
		return(roffpurgepunct(tree, argv));
	} 
d1106 2
a1107 1
	if ( ! (*tree->cb.roffdata)(tree->arg, 0, *argv++))
d1111 21
a1131 23
		if (ROFF_MAX == (c = rofffindcallable(*argv))) {
			if ( ! roffispunct(*argv)) {
				if ( ! (*tree->cb.roffdata)
						(tree->arg, 1, *argv++))
					return(0);
				continue;
			}
			
			/* FIXME: this is identical to that of
			 * roff_text. */

			/* See if only punctuation remains. */

			for (j = 0; argv[j]; j++)
				if ( ! roffispunct(argv[j]))
					break;

			if (argv[j]) {
				if ( ! (*tree->cb.roffdata)
						(tree->arg, 0, *argv++))
					return(0);
				continue;
			}
d1133 3
a1135 1
			/*  Only punctuation remains. */
d1137 4
d1143 4
a1146 3
		if (NULL == tokens[c].cb) {
			roff_err(tree, *argv, "unsupported macro `%s'",
					toknames[c]);
d1149 7
a1155 1
		if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
d1157 2
d1164 1
d1285 1
a1285 8

		if (NULL == tokens[c].cb) {
			roff_err(tree, *argv, "unsupported macro `%s'",
					toknames[c]);
			return(0);
		}

		if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
a1286 1

d1353 10
a1362 4
		if (ROFF_MAX == (c = rofffindcallable(*argv))) {
			if ( ! roffispunct(*argv)) {
				if ( ! (*tree->cb.roffdata)
						(tree->arg, i, *argv++))
d1364 3
a1366 5
				i = 1;
				continue;
			}

			/* See if only punctuation remains. */
d1368 3
d1372 2
a1373 10
			for (j = 0; argv[j]; j++)
				if ( ! roffispunct(argv[j]))
					break;

			if (argv[j]) {
				if ( ! (*tree->cb.roffdata)
						(tree->arg, 0, *argv++))
					return(0);
				continue;
			}
d1375 4
a1378 1
			/*  Only punctuation remains. */
d1380 2
a1381 1
			if ( ! (*tree->cb.roffout)(tree->arg, tok))
d1383 1
a1383 1
			break;
d1386 1
a1386 18
		/*
		 * A sub-command has been found.  Execute it and
		 * discontinue parsing for arguments.  If we're
		 * line-scoped, then close out after it returns; if we
		 * aren't, then close out before.
		 */

		if (NULL == tokens[c].cb) {
			roff_err(tree, *argv, "unsupported macro `%s'",
					toknames[c]);
			return(0);
		} 
		
		if ( ! (ROFF_LSCOPE & tokens[tok].flags))
			if ( ! (*tree->cb.roffout)(tree->arg, tok))
				return(0);
		
		if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
a1387 5

		if (ROFF_LSCOPE & tokens[tok].flags)
			if ( ! (*tree->cb.roffout)(tree->arg, tok))
				return(0);

d1447 78
@


1.31
log
@Improvements to the xml part.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.30 2008/12/01 21:25:48 kristaps Exp $ */
a33 1

a34 1

a35 1

a36 1

a37 1

a38 1

d64 3
a66 3
	const int	 *parents;
	const int	 *children;
	int		  ctx;
d72 1
a72 1
#define	ROFF_LSCOPE	 (1 << 3)
d87 1
a87 2
	char		 *cur;

a92 1

d99 2
a100 3

	struct roffcb	  cb;
	void		 *arg;
a106 1

a110 1

a112 1

a116 1

d133 3
a135 5
static	const int roffarg_An[] = { ROFF_Split, ROFF_Nosplit, 
	ROFF_ARGMAX };
static	const int roffarg_Bd[] = { ROFF_Ragged, ROFF_Unfilled, 
	ROFF_Literal, ROFF_File, ROFF_Offset, ROFF_Filled,
	ROFF_Compact, ROFF_ARGMAX };
d139 3
a141 15
static 	const int roffarg_Bl[] = { ROFF_Bullet, ROFF_Dash, 
	ROFF_Hyphen, ROFF_Item, ROFF_Enum, ROFF_Tag, ROFF_Diag, 
	ROFF_Hang, ROFF_Ohang, ROFF_Inset, ROFF_Column, ROFF_Offset, 
	ROFF_Width, ROFF_Compact, ROFF_ARGMAX };
static 	const int roffarg_St[] = {
	ROFF_p1003_1_88, ROFF_p1003_1_90, ROFF_p1003_1_96,
	ROFF_p1003_1_2001, ROFF_p1003_1_2004, ROFF_p1003_1,
	ROFF_p1003_1b, ROFF_p1003_1b_93, ROFF_p1003_1c_95,
	ROFF_p1003_1g_2000, ROFF_p1003_2_92, ROFF_p1387_2_95,
	ROFF_p1003_2, ROFF_p1387_2, ROFF_isoC_90, ROFF_isoC_amd1,
	ROFF_isoC_tcor1, ROFF_isoC_tcor2, ROFF_isoC_99, ROFF_ansiC,
	ROFF_ansiC_89, ROFF_ansiC_99, ROFF_ieee754, ROFF_iso8802_3,
	ROFF_xpg3, ROFF_xpg4, ROFF_xpg4_2, ROFF_xpg4_3, ROFF_xbd5,
	ROFF_xcu5, ROFF_xsh5, ROFF_xns5, ROFF_xns5_2d2_0,
	ROFF_xcurses4_2, ROFF_susv2, ROFF_susv3, ROFF_svid4,
d143 9
d155 3
a157 3
static	const int roffchild_Rs[] = { ROFF_Re, ROFF__A, ROFF__B,
	ROFF__D, ROFF__I, ROFF__J, ROFF__N, ROFF__O, ROFF__P,
	ROFF__R, ROFF__T, ROFF__V, ROFF_MAX };
a164 1
/* Table of all known tokens. */
a273 1
/* Table of all known token arguments. */
d648 1
@


1.30
log
@No more segfaults when run over openbsd sources.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.29 2008/12/01 16:14:34 kristaps Exp $ */
d115 1
d130 1
d258 1
a258 1
	{        NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ns */
d883 23
d1075 73
d1289 2
a1290 17
	i = 0;
	while (argv[i])
		i++;

	assert(i > 0);
	if ( ! roffispunct(argv[--i]))
		return((*tree->cb.roffout)(tree->arg, tok));

	while (i >= 0 && roffispunct(argv[i]))
		i--;

	i++;

	/* LINTED */
	while (argv[i])
		if ( ! (*tree->cb.roffdata)(tree->arg, 0, argv[i++]))
			return(0);
d1400 1
a1400 23
	/*
	 * We're the line-dominant macro.  Check if there's remaining
	 * punctuation.  If there is, then flush it out before exiting.
	 */

	i = 0;
	while (argv[i])
		i++;

	assert(i > 0);
	if ( ! roffispunct(argv[--i]))
		return(1);

	while (i >= 0 && roffispunct(argv[i]))
		i--;
	i++;

	/* LINTED */
	while (argv[i])
		if ( ! (*tree->cb.roffdata)(tree->arg, 0, argv[i++]))
			return(0);

	return(1);
@


1.29
log
@Better Oo/Oc support.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.28 2008/12/01 16:01:28 kristaps Exp $ */
d19 2
d95 1
a95 1
	time_t		  date;			/* `Dd' results. */
d402 3
d459 4
d909 2
d929 55
a983 1
	/* TODO: parse date. */
a984 1
	assert(NULL == tree->last);
a985 1

d1012 28
a1039 1
	/* TODO: parse date. */
d1052 1
d1054 1
a1054 3
	if (ROFF_EXIT == type) {
		return((*tree->cb.rofftail)(tree->arg));
	} else if (ROFF_BODY & tree->state) {
d1067 18
a1084 1
	/* TODO: extract OS. */
a1201 1
	assert(0 != i);
a1331 2

	assert(0 != i);
@


1.28
log
@Considerable scoping fixes.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.27 2008/12/01 15:32:36 kristaps Exp $ */
a168 1
static	const int roffchild_Oo[] = { ROFF_Op, ROFF_Oc, ROFF_MAX };
d175 1
a175 1
static	const int roffparent_Oc[] = { ROFF_Oo, ROFF_Oc, ROFF_MAX };
d279 1
a279 1
	{ roff_layout, NULL, NULL, roffchild_Oo, 0, ROFF_LAYOUT, 0 }, /* Oo */
d441 1
a441 1
		roff_warn(tree, buf, "blank line");
@


1.27
log
@Considerably improved roff_text parser.
Consolidated noop roff macros.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.26 2008/12/01 09:25:18 kristaps Exp $ */
d239 1
a239 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Bf */ /* FIXME */
d249 1
a249 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Ef */ /* FIXME */
d260 1
a260 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_LAYOUT, ROFF_PARSED | ROFF_CALLABLE }, /* Po */
d383 1
a383 1
		roff_warn(tree, NULL, "prelude never finished");
d387 1
a387 1
	for (n = tree->last; n->parent; n = n->parent) {
d390 1
a390 1
		roff_warn(tree, NULL, "closing explicit scope `%s'", 
d557 1
a557 2
	} else 
		assert(tree->last);
d566 2
a567 1
	if ( ! roffscan(tree->last->tok, tokens[tok].parents)) {
d574 2
a575 1
	if ( ! roffscan(tok, tokens[tree->last->tok].children)) {
d618 5
a655 1
	assert(tree->last);
d658 18
a682 1
	assert(tree->last);
a964 1
		roffnode_free(tree);
a986 3
	if (NULL == roffnode_new(tok, tree))
		return(0);

@


1.26
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.25 2008/11/30 23:05:57 kristaps Exp $ */
d31 1
a31 1
/* FIXME: warn if Pp occurs before/after Sh etc. (see mdoc.samples). */
d33 1
a33 1
/* FIXME: warn about "X section only" macros. */
d35 1
a35 1
/* FIXME: warn about empty lists. */
d37 1
a37 1
/* FIXME: roff_layout and roff_text have identical-ish lower bodies. */
d39 5
a43 1
/* FIXME: NAME section needs specific elements. */
d76 1
a112 3
#ifdef notyet
static	int		  roff_Ns(ROFFCALL_ARGS);
#endif
d116 2
a117 2
static	int		  roff_comment(ROFFCALL_ARGS);
static	int		  roff_close(ROFFCALL_ARGS);
d136 2
d182 1
a182 1
	{roff_comment, NULL, NULL, NULL, 0, ROFF_COMMENT, 0 }, /* \" */
d188 3
a190 3
	{   roff_text, NULL, NULL, NULL, ROFF_Pp, ROFF_TEXT, 0 }, /* Pp */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* D1 */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Dl */
d192 1
a192 1
	{  roff_close, NULL, NULL, NULL, ROFF_Bd, ROFF_LAYOUT, 0 }, /* Ed */
d194 1
a194 1
	{  roff_close, NULL, roffparent_El, NULL, ROFF_Bl, ROFF_LAYOUT, 0 }, /* El */
d215 2
a216 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Op */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, /* Ot */ /* XXX deprecated */
d236 1
a236 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Aq */
d241 1
a241 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bq */
d247 1
a247 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dq */
d261 1
a261 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pq */
d264 3
a266 3
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qo */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qq */
	{  roff_close, NULL, roffparent_Re, NULL, ROFF_Rs, ROFF_LAYOUT, 0 }, /* Re */
d270 1
a270 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sq */
d279 1
a279 1
	{  roff_close, NULL, roffparent_Fc, NULL, ROFF_Fo, ROFF_LAYOUT, 0 }, /* Fc */
d281 1
a281 1
	{  roff_close, NULL, roffparent_Oc, NULL, ROFF_Oo, ROFF_LAYOUT, 0 }, /* Oc */
d283 5
a287 1
	{  roff_close, NULL, NULL, NULL, ROFF_Bk, ROFF_LAYOUT, 0 }, /* Ek */
d338 2
a339 1
	"Bk",		"Ek",
a586 5

	/* 
	 * Check our scope rules. 
	 */

d850 25
d978 1
a978 1
	char		*v, *argvp[ROFF_MAXARG];
d981 1
a981 1
		roff_err(tree, *argv, "`%s' disallowed in prelude", 
d984 1
a984 3
	}

	if (ROFF_EXIT == type) {
d989 1
a989 2
	i = 0;
	argv++;
d991 1
a991 12
	while (-1 != (c = roffnextopt(tree, tok, &argv, &v))) {
		if (ROFF_ARGMAX == c)
			return(0);

		argcp[i] = c;
		argvp[i] = v;
		i++;
		argv++;
	}

	argcp[i] = ROFF_ARGMAX;
	argvp[i] = NULL;
d993 2
d998 6
a1005 1

a1007 1

d1011 5
d1026 5
d1055 3
a1057 3
	 * If we're the first parser (*argv == tree->cur) then purge out
	 * any additional punctuation, should there be any remaining at
	 * the end of line. 
d1060 1
a1060 1
	if ( ! (ROFF_PARSED & tokens[tok].flags && *argv))
d1063 5
d1096 1
a1096 1
	char		*v, *argvp[ROFF_MAXARG];
d1104 1
a1104 4
	/* FIXME: breaks if passed from roff_layout. */
	first = *argv == tree->cur;

	i = 0;
d1107 2
a1108 13
	while (-1 != (c = roffnextopt(tree, tok, &argv, &v))) {
		if (ROFF_ARGMAX == c) 
			return(0);

		argcp[i] = c;
		argvp[i] = v;
		i++;
		argv++;
	}

	argcp[i] = ROFF_ARGMAX;
	argvp[i] = NULL;

d1111 2
d1124 7
d1134 4
a1137 10
			/* 
			 * If all that remains is roff punctuation, then
			 * close out our scope and return.
			 */
			if (roffispunct(*argv)) {
				for (j = 0; argv[j]; j++)
					if ( ! roffispunct(argv[j]))
						break;
				if (NULL == argv[j])
					break;
d1139 1
d1141 2
a1142 4
			
			if ( ! (*tree->cb.roffdata)
					(tree->arg, i, *argv++))
				return(0);
d1145 16
a1160 1
			continue;
d1165 3
a1167 1
		 * discontinue parsing for arguments.
d1176 4
d1183 4
d1190 4
a1193 2
	if ( ! (*tree->cb.roffout)(tree->arg, tok))
		return(0);
d1195 3
a1197 4
	/* 
	 * If we're the first parser (*argv == tree->cur) then purge out
	 * any additional punctuation, should there be any remaining at
	 * the end of line. 
a1199 3
	if ( ! (first && *argv))
		return(1);

d1225 1
a1225 1
roff_comment(ROFFCALL_ARGS)
d1234 1
a1234 1
roff_close(ROFFCALL_ARGS)
d1237 2
a1238 48
	return(1);
}


#if notyet
/* ARGSUSED */
static int
roff_Ns(ROFFCALL_ARGS)
{
	int		 c;

	argv++;

	if (ROFF_MAX != (c = rofffindcallable(*argv))) {
		if (NULL == tokens[c].cb) {
			roff_err(tree, *argv, "unsupported macro `%s'",
					toknames[c]);
			return(0);
		}
		if ( ! (*tree->cb.roffspecial)(tree->arg, tok))
			return(0);
		if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
			return(0);

		return(1);
	} else if ( ! (*tree->cb.roffdata)(tree->arg, 0, *argv++))
		return(0);
	
	while (*argv) {
		if (ROFF_MAX == (c = rofffindcallable(*argv))) {
			assert(tree->arg);
			if ( ! (*tree->cb.roffdata)
					(tree->arg, 1, *argv++))
				return(0);
			continue;
		}
		if (NULL == tokens[c].cb) {
			roff_err(tree, *argv, "unsupported macro `%s'",
					toknames[c]);
			return(0);
		}
		if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
			return(0);

		break;
	}

	return(1);
a1239 1
#endif
@


1.25
log
@Small fixes to output.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.24 2008/11/30 21:41:35 kristaps Exp $ */
d108 3
a115 1
static	int		  roff_special(ROFFCALL_ARGS);
d240 1
a240 1
	{roff_special, NULL, NULL, NULL, 0, ROFF_SPECIAL, 0 },	/* Db */
d251 1
a251 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ns */
d255 1
a255 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Pf */
d267 1
a267 1
	{roff_special, NULL, NULL, NULL, 0, ROFF_SPECIAL, 0 }, /* Sm */
a498 1
/* XXX */
d1002 4
a1005 5
		if (ROFF_MAX != (c = rofffindcallable(*argv))) {
			if (NULL == tokens[c].cb) {
				roff_err(tree, *argv, "unsupported "
						"macro `%s'",
						toknames[c]);
d1007 8
a1014 4
			}
			if ( ! (*tokens[c].cb)(c, tree, argv, ROFF_ENTER))
				return(0);
			break;
d1017 1
a1017 2
		assert(tree->arg);
		if ( ! (*tree->cb.roffdata)(tree->arg, i, *argv++))
d1019 2
a1020 1
		i = 1;
d1029 2
a1030 4
	if (ROFF_PARSED & tokens[tok].flags && *argv) {
		i = 0;
		while (argv[i])
			i++;
d1032 3
a1034 3
		assert(i > 0);
		if ( ! roffispunct(argv[--i]))
			return((*tree->cb.roffout)(tree->arg, tok));
d1036 6
a1041 2
		while (i >= 0 && roffispunct(argv[i]))
			i--;
d1043 2
a1044 2
		assert(0 != i);
		i++;
d1046 4
a1049 5
		/* LINTED */
		while (argv[i])
			if ( ! (*tree->cb.roffdata)(tree->arg, 0, argv[i++]))
				return(0);
	}
d1116 2
a1117 1
			if ( ! (*tree->cb.roffdata)(tree->arg, i, *argv++))
d1150 6
a1155 4
	if (first && *argv) {
		i = 0;
		while (argv[i])
			i++;
d1157 3
a1159 3
		assert(i > 0);
		if ( ! roffispunct(argv[--i]))
			return(1);
d1161 2
a1162 2
		while (i >= 0 && roffispunct(argv[i]))
			i--;
d1164 2
a1165 2
		assert(0 != i);
		i++;
d1167 4
a1170 5
		/* LINTED */
		while (argv[i])
			if ( ! (*tree->cb.roffdata)(tree->arg, 0, argv[i++]))
				return(0);
	}
d1194 1
d1197 1
a1197 1
roff_special(ROFFCALL_ARGS)
d1199 3
d1203 35
a1237 1
	return((*tree->cb.roffspecial)(tree->arg, tok));
d1239 1
@


1.24
log
@Preliminary xml output filter (validate-renamed) done.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.23 2008/11/30 20:53:34 kristaps Exp $ */
d521 4
d532 3
a534 3
	} else if (ROFF_COMMENT == tokens[tok].type)
		return(1);
	
@


1.23
log
@Cleaned up presentation with mbuf_putstring & al.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.22 2008/11/30 18:53:11 kristaps Exp $ */
d982 1
a982 1
	if ( ! (*tree->cb.roffin)(tree->arg, tok, 0, argcp, argvp))
d1078 1
a1078 1
	if ( ! (*tree->cb.roffin)(tree->arg, tok, 1, argcp, argvp))
@


1.22
log
@Small error fixed.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.21 2008/11/30 18:50:44 kristaps Exp $ */
d310 1
d312 1
d314 1
d677 1
a677 1
	size_t		 i;
d982 1
a982 1
	if ( ! (*tree->cb.roffin)(tree->arg, tok, argcp, argvp))
d1036 1
d1078 1
a1078 1
	if ( ! (*tree->cb.roffin)(tree->arg, tok, argcp, argvp))
d1155 1
@


1.21
log
@Fixed spacing (almost there).
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.20 2008/11/30 12:41:45 kristaps Exp $ */
d1025 1
a1025 1
			return(1);
@


1.20
log
@Backed out PUNCT changes (again).
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.19 2008/11/29 16:23:22 kristaps Exp $ */
d37 1
a37 1
/* FIXME: ; : } ) (etc.) after text macros? */
a40 2
/* FIXME: don't print Os, just do roffbegin. */

d71 1
a71 2
#define	ROFF_QUOTES	 (1 << 2)		/* Quoted args. */
#define	ROFF_SHALLOW	 (1 << 3)		/* Nesting block. */
d179 3
a181 3
	{     roff_Os, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_QUOTES }, /* Os */
	{ roff_layout, NULL, NULL, NULL, ROFF_Sh, ROFF_LAYOUT, ROFF_PARSED }, /* Sh */
	{ roff_layout, NULL, NULL, NULL, ROFF_Ss, ROFF_LAYOUT, ROFF_PARSED }, /* Ss */ 
d189 1
a189 1
	{ roff_layout, NULL, roffparent_It, NULL, ROFF_It, ROFF_LAYOUT, ROFF_SHALLOW }, /* It */
d193 1
a193 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_QUOTES }, /* Cd */ /* XXX man.4 only */
d207 1
a207 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_QUOTES }, /* Nd */
d441 1
a441 1
	return((*tree->cb.roffdata)(tree->arg, buf));
a695 1
#if notyet
a735 1
#endif
d983 1
d985 1
a985 1
			if ( ! (*tree->cb.roffdata)(tree->arg, *argv++))
d987 1
d992 1
d1007 1
a1007 1
		if ( ! (*tree->cb.roffdata)(tree->arg, *argv++))
d1009 27
d1046 1
a1046 1
	int		 i, c, argcp[ROFF_MAXARG];
d1055 3
d1078 1
d1080 1
a1080 1
			if ( ! (*tree->cb.roffdata)(tree->arg, *argv++))
d1082 1
d1087 1
d1090 14
a1103 1
			if ( ! (*tree->cb.roffdata)(tree->arg, *argv++))
d1105 2
d1127 30
a1156 1
	return((*tree->cb.roffout)(tree->arg, tok));
@


1.19
log
@Annotated omit-punctuation macros.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.18 2008/11/29 16:11:42 kristaps Exp $ */
a74 1
#define	ROFF_PUNCT	 (1 << 4)
d193 3
a195 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Ad */
	{   roff_text, roffarg_An, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* An */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Ar */
d198 3
a200 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Dv */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Er */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Ev */ /* XXX needs arg */
d202 1
a202 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Fa */ /* XXX needs arg */
d204 4
a207 4
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Fl */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Fn */ /* XXX needs arg */ /* FIXME */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Ft */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Ic */ /* XXX needs arg */
d209 1
a209 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Li */
d211 2
a212 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Nm */ /* FIXME */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Op */
d214 1
a214 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Pa */
d217 3
a219 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Va */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Vt */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Xr */ /* XXX needs arg */
d239 2
a240 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Bsx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Bx */
d247 1
a247 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Em */ /* XXX needs arg */
d249 2
a250 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Fx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Ms */
d253 2
a254 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Nx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Ox */
d270 3
a272 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Sy */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_PUNCT }, /* Tn */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_PUNCT }, /* Ux */
d699 44
d1058 2
a1059 5
		if (ROFF_MAX != (c = rofffindcallable(*argv))) {
			if (NULL == tokens[c].cb) {
				roff_err(tree, *argv, "unsupported "
						"macro `%s'",
						toknames[c]);
d1061 1
a1061 5
			}
			if ( ! (*tokens[c].cb)(c, tree, 
						argv, ROFF_ENTER))
				return(0);
			break;
d1063 13
a1075 1
		if ( ! (*tree->cb.roffdata)(tree->arg, *argv++))
d1077 2
@


1.18
log
@Validation presentation (html-like).
Fixed newlining for data.
Moved roffhead/rofftail to roff_Os.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.17 2008/11/29 14:14:21 kristaps Exp $ */
d75 1
d194 3
a196 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ad */
	{   roff_text, roffarg_An, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* An */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ar */
d199 3
a201 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dv */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Er */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ev */ /* XXX needs arg */
d203 1
a203 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fa */ /* XXX needs arg */
d205 4
a208 4
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fl */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fn */ /* XXX needs arg */ /* FIXME */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ft */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ic */ /* XXX needs arg */
d210 1
a210 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Li */
d212 2
a213 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Nm */ /* FIXME */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Op */
d215 1
a215 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pa */
d218 3
a220 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Va */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Vt */ /* XXX needs arg */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xr */ /* XXX needs arg */
d240 2
a241 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bsx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bx */
d248 1
a248 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Em */ /* XXX needs arg */
d250 2
a251 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Fx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ms */
d254 2
a255 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Nx */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ox */
d271 3
a273 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sy */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Tn */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ux */
@


1.17
log
@Inclusion of "real" validation code.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.16 2008/11/28 18:15:29 kristaps Exp $ */
d41 2
d59 1
a59 1
	const char *argv[], enum roffd type
d134 1
a134 1
				int, const char ***, char **);
d238 1
a238 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bq */
d289 1
a289 1
	0,		0,		0,		0,
a389 3
	if ( ! (*tree->cb.rofftail)(tree->arg))
		goto end;

a418 5
	if ( ! (*tree->cb.roffhead)(args)) {
		free(tree);
		return(NULL);
	}

d519 1
a519 1
	const char	**argvp;
d534 1
a534 1
	argvp = (const char **)argv;
d561 3
a563 3
		roff_err(tree, *argvp, "`%s' is invalid child `%s'",
				toknames[tree->last->tok],
				toknames[tok]);
d758 1
a758 1
		const char ***in, char **val)
d760 1
a760 1
	const char	*arg, **argv;
d867 2
a868 2
		assert(ROFF_PRELUDE_Os & tree->state);
		return(roff_layout(tok, tree, argv, type));
d890 4
a893 1
	return(roff_layout(tok, tree, argv, type));
d934 6
d945 1
a945 2
			if ( ! (*tree->cb.roffdata)
					(tree->arg, *argv++))
d948 1
a948 4

		if ( ! ((*tree->cb.roffout)(tree->arg, tok)))
			return(0);
		return((*tree->cb.roffblkin)(tree->arg, tok));
d969 1
a969 3
	if ( ! ((*tree->cb.roffout)(tree->arg, tok)))
		return(0);
	return((*tree->cb.roffblkin)(tree->arg, tok));
@


1.16
log
@Cleaned up exit routine.
Added roffhead and rofftail call.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.15 2008/11/28 15:25:49 kristaps Exp $ */
d133 2
a134 3
static	int 		  roffparse(struct rofftree *, char *, size_t);
static	int		  textparse(const struct rofftree *,
				const char *, size_t);
d362 2
d376 1
a376 1
			break;
d388 1
a388 1
	if ( ! (*tree->cb.roffhead)(tree->arg))
d399 1
d409 3
d430 1
a430 1
roff_engine(struct rofftree *tree, char *buf, size_t sz)
d433 2
a434 1
	tree->cur = NULL;
d436 1
a436 1
	if (0 == sz) {
d440 1
a440 1
		return(textparse(tree, buf, sz));
d442 1
a442 1
	return(roffparse(tree, buf, sz));
d447 1
a447 1
textparse(const struct rofftree *tree, const char *buf, size_t sz)
d449 2
a450 3
	
	/* Print text. */
	return(1);
d520 1
a520 1
roffparse(struct rofftree *tree, char *buf, size_t sz)
a526 2
	assert(sz > 0);

d965 1
@


1.15
log
@Removed superfluous structures from rofftree.
Added roffdata for generalised text processing.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.14 2008/11/28 11:21:12 kristaps Exp $ */
d360 1
a360 1
	int		 error;
d363 2
a364 1
	error = 0;
d366 1
a366 6
	for (n = tree->last; n->parent; n = n->parent)
		if (tokens[n->tok].ctx == 0) {
			roff_warn(tree, NULL, "closing explicit scope "
					"of `%s'", toknames[n->tok]);
			error = 1;
		}
d368 1
a368 1
	if (0 == error && (ROFF_PRELUDE & tree->state)) {
d370 15
a384 1
		error = 1;
d387 7
d415 5
@


1.14
log
@Initial pushing to mbuf.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.13 2008/11/27 17:27:50 kristaps Exp $ */
a82 1
	size_t		  line;			/* Parsed at line. */
d102 2
a103 4
	struct md_mbuf		*mbuf;		/* Output (or NULL). */
	const struct md_args	*args;		/* Global args. */
	const struct md_rbuf	*rbuf;		/* Input. */
	const struct roffcb	*cb;
d117 1
a117 1
static	void		  roffnode_free(int, struct rofftree *);
d360 2
a361 1
	int		 error, tok;
d363 1
a363 3
	assert(tree->mbuf);
	if ( ! flush)
		tree->mbuf = NULL;
d365 5
a369 12
	/* LINTED */
	while (tree->last) {
		if (tree->last->parent) {
			tok = tree->last->tok;
			if (tokens[tok].ctx == 0) {
				warnx("%s: closing out explicit scope "
						"of `%s' from line %zu",
						tree->rbuf->name,
						toknames[tok],
						tree->last->line);
				tree->mbuf = NULL;
			}
a370 5
		if ( ! (*tokens[tree->last->tok].cb)
				(tree->last->tok, tree, NULL, ROFF_EXIT))
			/* Disallow flushing. */
			tree->mbuf = NULL;
	}
d372 2
a373 5
	error = tree->mbuf ? 0 : 1;

	if (tree->mbuf && (ROFF_PRELUDE & tree->state)) {
		warnx("%s: prelude never finished",
				tree->rbuf->name);
d377 3
d386 1
a386 2
roff_alloc(const struct md_args *args, struct md_mbuf *out, 
		const struct md_rbuf *in, const struct roffcb *cb)
d394 3
a396 4
	tree->args = args;
	tree->mbuf = out;
	tree->rbuf = in;
	tree->cb = cb;
d535 3
a537 4
		roff_err(tree, *argvp, "`%s' has invalid parent `%s' "
				"from line %zu", toknames[tok], 
				toknames[tree->rbuf->line],
				tree->rbuf->line);
d542 3
a544 4
		roff_err(tree, *argvp, "`%s' is invalid child for "
				"`%s' from line %zu", toknames[tok], 
				toknames[tree->rbuf->line],
				tree->rbuf->line);
a699 1
	p->line = tree->rbuf->line;
d725 1
a725 1
roffnode_free(int tokid, struct rofftree *tree)
a729 1
	assert(tree->last->tok == tokid);
d889 2
a890 2
		roffnode_free(tok, tree);
		return((*tree->cb->roffblkout)(tree->args, tok));
a892 2
	assert(tree->mbuf);

d912 1
a912 1
	if ( ! (*tree->cb->roffin)(tree->args, tok, argcp, argvp))
d917 2
a918 3
			if ( ! md_buf_putstring(tree->mbuf, *argv++))
				return(0);
			if ( ! md_buf_putchar(tree->mbuf, ' '))
d922 1
a922 4
		if ( ! md_buf_putchar(tree->mbuf, '\n'))
			return(0);

		if ( ! ((*tree->cb->roffout)(tree->args, tok)))
d924 1
a924 1
		return((*tree->cb->roffblkin)(tree->args, tok));
d940 1
a940 3
		if ( ! md_buf_putstring(tree->mbuf, *argv++))
			return(0);
		if ( ! md_buf_putchar(tree->mbuf, ' '))
d944 1
a944 4
	if (NULL == *argv && ! md_buf_putchar(tree->mbuf, '\n'))
		return(0);

	if ( ! ((*tree->cb->roffout)(tree->args, tok)))
d946 1
a946 1
	return((*tree->cb->roffblkin)(tree->args, tok));
a956 2
	assert(tree->mbuf);

d979 1
a979 1
	if ( ! (*tree->cb->roffin)(tree->args, tok, argcp, argvp))
d984 1
a984 3
			if ( ! md_buf_putstring(tree->mbuf, *argv++))
				return(0);
			if ( ! md_buf_putchar(tree->mbuf, ' '))
d987 1
a987 3
		if ( ! md_buf_putchar(tree->mbuf, '\n'))
			return(0);
		return((*tree->cb->roffout)(tree->args, tok));
d1003 1
a1003 4

		if ( ! md_buf_putstring(tree->mbuf, *argv++))
			return(0);
		if ( ! md_buf_putchar(tree->mbuf, ' '))
d1007 1
a1007 4
	if (NULL == *argv && ! md_buf_putchar(tree->mbuf, '\n'))
		return(0);

	return((*tree->cb->roffout)(tree->args, tok));
d1034 1
a1034 1
	return((*tree->cb->roffspecial)(tree->args, tok));
d1048 2
a1049 2
	(*tree->cb->roffmsg)(tree->args, ROFF_WARN, tree->cur, pos,
			tree->rbuf->name, tree->rbuf->line, buf);
d1063 2
a1064 2
	(*tree->cb->roffmsg)(tree->args, ROFF_ERROR, tree->cur, pos,
			tree->rbuf->name, tree->rbuf->line, buf);
@


1.13
log
@*** empty log message ***
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.12 2008/11/27 16:54:58 kristaps Exp $ */
d88 2
a90 1
	char		 *cur;
d95 1
a97 1
	/* FIXME: if we had prev ptrs, this wouldn't be necessary. */
d102 1
d180 1
a180 2
static	const struct rofftok tokens[ROFF_MAX] = 
	{
d277 1
a277 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Fo */
d279 1
a279 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Oo */
d286 1
a286 2
static	const int tokenargs[ROFF_ARGMAX] = 
	{
d304 1
a304 2
const	char *const toknamesp[ROFF_MAX] = 
	{		 
d333 1
a333 2
const	char *const tokargnamesp[ROFF_ARGMAX] = 
	{		 
a355 1

d363 1
a363 1
	int		 error;
d370 12
a381 1
	while (tree->last)
d386 1
d391 2
a392 1
		/*roff_warn(tree, "prelude never finished");*/
d424 1
a424 1
	tree->cur = buf;
d553 4
a556 4
		warnx("%s: invalid parent `%s' for `%s' (line %zu)",
				tree->rbuf->name, 
				toknames[tree->last->tok],
				toknames[tok], tree->rbuf->line);
d561 3
a563 3
		warnx("%s: invalid child `%s' for `%s' (line %zu)",
				tree->rbuf->name, toknames[tok], 
				toknames[tree->last->tok],
d645 1
d915 2
d940 6
d947 2
a948 1
		/* TODO: print all tokens. */
d963 1
a963 2
			if ( ! (*tokens[c].cb)(c, tree, 
						argv, ROFF_ENTER))
d965 1
d968 5
a972 1
		/* TODO: print token. */
d974 2
a975 2
		argv++;
	}
a978 1

d990 2
d1018 8
a1025 3

		/* TODO: print all tokens. */

d1040 1
d1043 5
a1047 1
		/* TODO: print token. */
d1049 2
a1050 2
		argv++;
	}
d1079 1
a1079 1
	return((*tree->cb->roffspecial)(tok));
@


1.12
log
@Considerable fixes.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.11 2008/11/27 14:02:41 kristaps Exp $ */
d454 1
a454 1
				roff_err(tree, p, argv[i], "unclosed "
d474 1
a474 1
		roff_err(tree, p, p, "too many arguments for `%s'", toknames
d901 1
a901 1
		return((*tree->cb->roffblkout)(tok));
d923 1
a923 1
	if ( ! (*tree->cb->roffin)(tok, argcp, argvp))
d930 1
a930 1
		if ( ! ((*tree->cb->roffout)(tok)))
d932 1
a932 1
		return((*tree->cb->roffblkin)(tok));
d953 1
a953 1
	if ( ! ((*tree->cb->roffout)(tok)))
d956 1
a956 1
	return((*tree->cb->roffblkin)(tok));
d989 1
a989 1
	if ( ! (*tree->cb->roffin)(tok, argcp, argvp))
d996 1
a996 1
		return((*tree->cb->roffout)(tok));
d1017 1
a1017 1
	return((*tree->cb->roffout)(tok));
@


1.11
log
@Added "special" macros.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.10 2008/11/27 13:29:44 kristaps Exp $ */
d22 1
d89 1
d120 5
d132 2
a133 1
static	int		  roffnextopt(int, const char ***, char **);
d142 3
a144 1
	ROFF_Literal, ROFF_File, ROFF_Offset, ROFF_ARGMAX };
d150 1
a150 1
	ROFF_ARGMAX };
d178 2
a179 1
static	const struct rofftok tokens[ROFF_MAX] = {
d189 1
a189 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, 	/* Bd */
d280 1
a280 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Bk */
d282 1
a282 1
};
d285 18
a302 60
static	const struct roffarg tokenargs[ROFF_ARGMAX] = {
	{ 0 },					/* split */
	{ 0 },					/* nosplit */
	{ 0 },					/* ragged */
	{ 0 },					/* unfilled */
	{ 0 },					/* literal */
	{ ROFF_VALUE },				/* file */
	{ ROFF_VALUE },				/* offset */
	{ 0 },					/* bullet */
	{ 0 },					/* dash */
	{ 0 },					/* hyphen */
	{ 0 },					/* item */
	{ 0 },					/* enum */
	{ 0 },					/* tag */
	{ 0 },					/* diag */
	{ 0 },					/* hang */
	{ 0 },					/* ohang */
	{ 0 },					/* inset */
	{ 0 },					/* column */
	{ 0 },					/* width */
	{ 0 },					/* compact */
	{ 0 },					/* std */
	{ 0 },					/* p1003_1_88 */
	{ 0 },					/* p1003_1_90 */
	{ 0 },					/* p1003_1_96 */
	{ 0 },					/* p1003_1_2001 */
	{ 0 },					/* p1003_1_2004 */
	{ 0 },					/* p1003_1 */
	{ 0 },					/* p1003_1b */
	{ 0 },					/* p1003_1b_93 */
	{ 0 },					/* p1003_1c_95 */
	{ 0 },					/* p1003_1g_2000 */
	{ 0 },					/* p1003_2_92 */
	{ 0 },					/* p1387_2_95 */
	{ 0 },					/* p1003_2 */
	{ 0 },					/* p1387_2 */
	{ 0 },					/* isoC_90 */
	{ 0 },					/* isoC_amd1 */
	{ 0 },					/* isoC_tcor1 */
	{ 0 },					/* isoC_tcor2 */
	{ 0 },					/* isoC_99 */
	{ 0 },					/* ansiC */
	{ 0 },					/* ansiC_89 */
	{ 0 },					/* ansiC_99 */
	{ 0 },					/* ieee754 */
	{ 0 },					/* iso8802_3 */
	{ 0 },					/* xpg3 */
	{ 0 },					/* xpg4 */
	{ 0 },					/* xpg4_2 */
	{ 0 },					/* xpg4_3 */
	{ 0 },					/* xbd5 */
	{ 0 },					/* xcu5 */
	{ 0 },					/* xsh5 */
	{ 0 },					/* xns5 */
	{ 0 },					/* xns5_2d2_0 */
	{ 0 },					/* xcurses4_2 */
	{ 0 },					/* susv2 */
	{ 0 },					/* susv3 */
	{ 0 },					/* svid4 */
};
d355 1
a355 1
	"svid4"
d358 1
d382 1
a382 2
		warnx("%s: prelude never finished", 
				tree->rbuf->name);
d397 2
a398 4
	if (NULL == (tree = calloc(1, sizeof(struct rofftree)))) {
		warn("malloc");
		return(NULL);
	}
d414 2
d417 1
a417 3
		warnx("%s: blank line (line %zu)", 
				tree->rbuf->name, 
				tree->rbuf->line);
a429 12
	if (NULL == tree->last) {
		warnx("%s: unexpected text (line %zu)",
				tree->rbuf->name, 
				tree->rbuf->line);
		return(0);
	} else if (NULL == tree->last->parent) {
		warnx("%s: disallowed text (line %zu)",
				tree->rbuf->name, 
				tree->rbuf->line);
		return(0);
	}

a430 1

d440 1
d445 2
d454 4
a457 5
				warnx("%s: unclosed quoted arg for "
						"`%s' (line %zu)",
						tree->rbuf->name,
						toknames[tok],
						tree->rbuf->line);
d474 2
a475 3
		warnx("%s: too many args for `%s' (line %zu)",
				tree->rbuf->name, toknames[tok],
				tree->rbuf->line);
a478 5
#ifdef DEBUG
	(void)printf("argparse: %d arguments for `%s'\n",
			i, toknames[tok]);
#endif

d511 1
a511 2
		warnx("%s: unknown line macro (line %zu)",
				tree->rbuf->name, tree->rbuf->line);
d514 2
a515 3
		warnx("%s: macro `%s' not supported (line %zu)",
				tree->rbuf->name, toknames[tok],
				tree->rbuf->line);
d522 2
a523 2
	else
		argvp = (const char **)argv + 1;
d526 1
a526 1
	 * Prelude macros break some assumptions: branch now. 
d572 12
d585 5
d605 2
a606 5
		if (NULL == n) {
#ifdef DEBUG
			(void)printf("scope: new `%s'\n",
					toknames[tok]);
#endif
a607 1
		}
d610 2
a611 1
		 * Close out all intermediary scoped blocks.
a615 4
#ifdef DEBUG
		(void)printf("scope: closing `%s'\n", 
				toknames[t]);
#endif
a619 6
#ifdef DEBUG
		(void)printf("scope: new parent of `%s' is `%s'\n", 
				toknames[tok], 
				toknames[tree->last->tok]);
#endif

d623 9
a636 3
#ifdef DEBUG
		(void)printf("scope: closing `%s'\n", toknames[t]);
#endif
d682 1
a682 5
		if (0 == strcmp(toknames[i], token)) {
#ifdef DEBUG
			(void)printf("lookup (good): `%s' (%d)\n", 
					token, (int)i);
#endif
a683 1
		}
a684 4
#ifdef DEBUG
	(void)printf("lookup (bad): `%s'\n", token);
#endif
	
d706 2
a707 4
	if (NULL == (p = malloc(sizeof(struct roffnode)))) {
		warn("malloc");
		return(NULL);
	}
a713 8
#ifdef DEBUG
	(void)printf("scope: new `%s' child of `%s'\n",
			toknames[tree->last->tok], 
			tree->last->parent ?
				toknames[tree->last->parent->tok] :
				"<root>");
#endif

a741 8
#ifdef DEBUG
	(void)printf("scope: closing `%s' back to `%s'\n",
			toknames[tree->last->tok],
			tree->last->parent ?
				toknames[tree->last->parent->tok] :
				"<root>");
#endif

d749 2
a750 1
roffnextopt(int tok, const char ***in, char **val)
d764 3
a766 3
	/* FIXME: should we let this slide... ? */

	if (ROFF_ARGMAX == (v = rofffindarg(&arg[1])))
d768 5
a772 4

	/* FIXME: should we let this slide... ? */

	if ( ! roffargok(tok, v))
d774 3
a776 1
	if ( ! (ROFF_VALUE & tokenargs[v].flags))
d781 5
a785 1
	/* FIXME: what if this looks like a roff token or argument? */
d787 1
a787 1
	return(*argv ? v : ROFF_ARGMAX);
d806 1
a806 2
		warnx("%s: prelude `Dd' repeated (line %zu)",
				tree->rbuf->name, tree->rbuf->line);
d809 1
a809 2
		warnx("%s: prelude `Dd' out-of-order (line %zu)",
				tree->rbuf->name, tree->rbuf->line);
d837 1
a837 2
		warnx("%s: prelude `Dt' out-of-order (line %zu)",
				tree->rbuf->name, tree->rbuf->line);
d840 1
a840 2
		warnx("%s: prelude `Dt' repeated (line %zu)",
				tree->rbuf->name, tree->rbuf->line);
d870 1
a870 2
		warnx("%s: prelude `Os' out-of-order (line %zu)",
				tree->rbuf->name, tree->rbuf->line);
d894 2
a895 4
		warnx("%s: macro `%s' called in prelude (line %zu)",
				tree->rbuf->name, 
				toknames[tok], 
				tree->rbuf->line);
d905 1
d907 2
a908 6
	while (-1 != (c = roffnextopt(tok, &argv, &v))) {
		if (ROFF_ARGMAX == c) {
			warnx("%s: error parsing `%s' args (line %zu)",
					tree->rbuf->name, 
					toknames[tok],
					tree->rbuf->line);
d910 1
a910 8
		} else if ( ! roffargok(tok, c)) {
			warnx("%s: arg `%s' not for `%s' (line %zu)",
					tree->rbuf->name, 
					tokargnames[c],
					toknames[tok],
					tree->rbuf->line);
			return(0);
		}
d927 1
d938 3
a940 5
				warnx("%s: macro `%s' not supported "
						"(line %zu)",
						tree->rbuf->name, 
						toknames[c],
						tree->rbuf->line);
d944 1
a944 1
						argv + 1, ROFF_ENTER))
d947 1
d949 1
d968 2
a969 4
		warnx("%s: macro `%s' called in prelude (line %zu)",
				tree->rbuf->name, 
				toknames[tok],
				tree->rbuf->line);
d974 1
d976 2
a977 6
	while (-1 != (c = roffnextopt(tok, &argv, &v))) {
		if (ROFF_ARGMAX == c) {
			warnx("%s: error parsing `%s' args (line %zu)",
					tree->rbuf->name, 
					toknames[tok],
					tree->rbuf->line);
d979 1
a979 1
		} 
d993 1
d995 1
d1002 3
a1004 5
				warnx("%s: macro `%s' not supported "
						"(line %zu)",
						tree->rbuf->name, 
						toknames[c],
						tree->rbuf->line);
d1008 1
a1008 1
						argv + 1, ROFF_ENTER))
d1011 1
d1013 1
d1046 30
@


1.10
log
@More fixes and work-ness.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.9 2008/11/27 11:23:51 kristaps Exp $ */
d38 3
a40 1
#define	ROFF_MAXARG	  10
d50 2
a51 1
	ROFF_LAYOUT 
d113 1
d231 1
a231 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Db */ /* XXX */
d258 1
a258 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Sm */
d1117 9
@


1.9
log
@Mainly quotes.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.8 2008/11/26 22:27:08 kristaps Exp $ */
d68 1
a68 1
#define	ROFF_NOBLKCHILD	 (1 << 3)		/* No blk children. */
d118 2
a119 1
static	int		  roffargs(int, char *, char **);
d165 4
a168 4
	{roff_comment, NULL, NULL, NULL, 0, ROFF_COMMENT, 0 },	/* \" */
	{     roff_Dd, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Dd */
	{     roff_Dt, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Dt */
	{     roff_Os, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Os */
d178 1
a178 1
	{ roff_layout, NULL, roffparent_It, NULL, ROFF_It, ROFF_LAYOUT, 0 }, /* It */
d189 1
a189 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Fd */
d194 1
a194 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* In */
d196 1
a196 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Nd */ /* FIXME */
d201 1
a201 1
	{   roff_text, roffarg_Rv, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Rv */
d208 1
a208 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %D */
d211 4
a214 4
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %N */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %O */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %P */
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %R */
d216 3
a218 3
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %V */
	{  roff_close, NULL, NULL, NULL, ROFF_Ao, ROFF_LAYOUT, 0 }, /* Ac */
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Ao */
d220 2
a221 2
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* At */ /* XXX at most 2 args */
	{  roff_close, NULL, NULL, NULL, ROFF_Bo, ROFF_LAYOUT, 0 }, /* Bc */
d223 1
a223 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Bo */
d228 2
a229 2
	{  roff_close, NULL, NULL, NULL, ROFF_Do, ROFF_LAYOUT, 0 }, /* Dc */
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Do */
d231 1
a231 1
	{  roff_close, NULL, NULL, NULL, ROFF_Eo, ROFF_LAYOUT, 0 }, /* Ec */
d234 1
a234 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Eo */
d241 1
a241 1
	{  roff_close, NULL, NULL, NULL, ROFF_Po, ROFF_LAYOUT, 0 }, /* Pc */
d243 1
a243 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Po */
d245 1
a245 1
	{  roff_close, NULL, NULL, NULL, ROFF_Qo, ROFF_LAYOUT, 0 }, /* Qc */
d247 1
a247 1
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* Qo */
d251 2
a252 2
	{  roff_close, NULL, NULL, NULL, ROFF_So, ROFF_LAYOUT, 0 }, /* Sc */
	{ roff_layout, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, /* So */
d256 1
a256 1
	{   roff_text, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE | ROFF_QUOTES }, /* Sy */
d478 2
a479 1
roffargs(int tok, char *buf, char **argv)
a482 2
	(void)tok;/* FIXME: quotable strings? */

d488 18
a505 5
		argv[i] = buf++;
		while (*buf && ! isspace(*buf))
			buf++;
		if (0 == *buf) {
			continue;
d513 11
a523 2
	if (i < ROFF_MAXARG)
		argv[i] = NULL;
d525 2
a526 1
	return(ROFF_MAXARG > i);
d568 1
a568 4
	if ( ! roffargs(tok, buf, argv)) {
		warnx("%s: too many args to `%s' (line %zu)",
				tree->rbuf->name, toknames[tok], 
				tree->rbuf->line);
d570 1
a570 1
	} else
d626 4
d631 5
d643 5
@


1.8
log
@Various fixes.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.7 2008/11/26 21:42:59 kristaps Exp $ */
d68 1
d109 1
a148 1
static	const int roffchild_Bd[] = { ROFF_Ed, ROFF_MAX };
d152 3
a155 1
static	const int roffparent_Ed[] = { ROFF_Bd, ROFF_MAX };
d160 1
d173 2
a174 2
	{ roff_layout, NULL, NULL, roffchild_Bd, 0, ROFF_LAYOUT, 0 }, 	/* Bd */
	{ roff_layout, NULL, roffparent_Ed, NULL, ROFF_Bd, ROFF_LAYOUT, 0 }, 	/* Ed */
d176 1
a176 1
	{ roff_layout, NULL, roffparent_El, NULL, ROFF_Bl, ROFF_LAYOUT, 0 }, /* El */
d205 14
a218 14
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* %A */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %B */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %D */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %I */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %J */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %N */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %O */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %P */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %R */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* %T */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* %V */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ac */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ao */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Aq */
d220 1
a220 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bc */
d222 1
a222 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bo */
d227 2
a228 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dc */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Do */
d230 1
a230 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ec */
d233 1
a233 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Eo */
d235 1
a235 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ms */
d240 1
a240 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pc */
d242 1
a242 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Po */
d244 1
a244 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qc */
d246 1
a246 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qo */
d248 4
a251 4
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Re */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Rs */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sc */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* So */
d261 1
a261 1
	{ roff_layout, NULL, roffparent_Fc, NULL, ROFF_Fo, ROFF_LAYOUT, 0 }, /* Fc */
d263 3
a265 1
	{ roff_layout, NULL, roffparent_Oc, NULL, ROFF_Oo, ROFF_LAYOUT, 0 }, /* Oc */
d270 58
a327 20
	{ 0 },						/* split */
	{ 0 },						/* nosplit */
	{ 0 },						/* ragged */
	{ 0 },						/* unfilled */
	{ 0 },						/* literal */
	{ ROFF_VALUE },					/* file */
	{ ROFF_VALUE },					/* offset */
	{ 0 },						/* bullet */
	{ 0 },						/* dash */
	{ 0 },						/* hyphen */
	{ 0 },						/* item */
	{ 0 },						/* enum */
	{ 0 },						/* tag */
	{ 0 },						/* diag */
	{ 0 },						/* hang */
	{ 0 },						/* ohang */
	{ 0 },						/* inset */
	{ 0 },						/* column */
	{ 0 },						/* width */
	{ 0 },						/* compact */
d356 2
a357 1
	"Fo",		"Fc",		"Oo",		"Oc"
d362 20
a381 20
	"split",	"nosplit",	"ragged",	 
	"unfilled",	"literal",	"file",		 
	"offset",	"bullet",	"dash",		 
	"hyphen",	"item",		"enum",		 
	"tag",		"diag",		"hang",		 
	"ohang",	"inset",	"column",	 
	"width",	"compact",	"std",	 
	"-p1003.1-88",	"-p1003.1-90",	"-p1003.1-96",
	"-p1003.1-2001", "-p1003.1-2004", "-p1003.1",
	"-p1003.1b",	"-p1003.1b-93",	"-p1003.1c-95",
	"-p1003.1g-2000", "-p1003.2-92", "-p1387.2-95",
	"-p1003.2",	"-p1387.2",	"-isoC-90",
	"-isoC-amd1",	"-isoC-tcor1",	"-isoC-tcor2",
	"-isoC-99",	"-ansiC",	"-ansiC-89",
	"-ansiC-99",	"-ieee754",	"-iso8802-3",
	"-xpg3",	"-xpg4",	"-xpg4.2",
	"-xpg4.3",	"-xbd5",	"-xcu5",
	"-xsh5",	"-xns5",	"-xns5.2d2.0",
	"-xcurses4.2",	"-susv2",	"-susv3",
	"-svid4"
d624 6
d633 1
d645 2
a646 1
	return((*tokens[tok].cb)(tok, tree, argvp, ROFF_ENTER));
d676 1
a676 4
	if (i == 3) {
#ifdef DEBUG
		(void)printf("lookup: macro too long: `%s'\n", buf);
#endif
a677 1
	}
d728 9
d765 8
d1063 1
a1063 1
/* ARGUSED */
d1070 9
@


1.7
log
@Considerable fixes.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.6 2008/11/26 16:50:34 kristaps Exp $ */
d147 1
a147 1
static	const int roffchild_Oo[] = { ROFF_Op, ROFF_Oc, ROFF_MAX };
d150 1
d152 1
d156 1
a156 1
static	const int roffparent_It[] = { ROFF_Bl, ROFF_MAX };
d167 4
a170 4
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	 	/* D1 */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 }, 		/* Dl */
	{   NULL, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, 	/* Bd */
	{   NULL, NULL, NULL, NULL, 0, ROFF_LAYOUT, 0 }, 	/* Ed */
d191 2
a192 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Nd */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Nm */ /* FIXME */
d194 1
a194 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ot */
d222 1
a222 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Db */
d225 1
a225 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dq */
d237 1
a237 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Pf */
d239 1
a239 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pq */
d241 1
a241 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ql */
d243 1
a243 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qq */
d248 1
a248 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sq */
d250 3
a252 3
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sx */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sy */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Tn */
d288 25
a312 100
	"\\\"",		 
	"Dd",	/* Title macros. */
	"Dt",		 
	"Os",		 
	"Sh",	/* Layout macros */
	"Ss",		 
	"Pp",		 
	"D1",		 
	"Dl",		 
	"Bd",		 
	"Ed",		 
	"Bl",		 
	"El",		 
	"It",		 
	"Ad",	/* Text macros. */
	"An",		 
	"Ar",		 
	"Cd",		 
	"Cm",		 
	"Dv",		 
	"Er",		 
	"Ev",		 
	"Ex",		 
	"Fa",		 
	"Fd",		 
	"Fl",		 
	"Fn",		 
	"Ft",		 
	"Ic",		 
	"In",		 
	"Li",		 
	"Nd",		 
	"Nm",		 
	"Op",		 
	"Ot",		 
	"Pa",		 
	"Rv",		 
	"St",		 
	"Va",		 
	"Vt",		 
	"Xr",		 
	"\%A",	/* General text macros. */
	"\%B",
	"\%D",
	"\%I",
	"\%J",
	"\%N",
	"\%O",
	"\%P",
	"\%R",
	"\%T",
	"\%V",
	"Ac",
	"Ao",
	"Aq",
	"At",
	"Bc",
	"Bf",
	"Bo",
	"Bq",
	"Bsx",
	"Bx",
	"Db",
	"Dc",
	"Do",
	"Dq",
	"Ec",
	"Ef",
	"Em",
	"Eo",
	"Fx",
	"Ms",
	"No",
	"Ns",
	"Nx",
	"Ox",
	"Pc",
	"Pf",
	"Po",
	"Pq",
	"Qc",
	"Ql",
	"Qo",
	"Qq",
	"Re",
	"Rs",
	"Sc",
	"So",
	"Sq",
	"Sm",
	"Sx",
	"Sy",
	"Tn",
	"Ux",
	"Xc",	/* FIXME: do not support! */
	"Xo",	/* FIXME: do not support! */
	"Fo",
	"Fc",
	"Oo",
	"Oc",
d317 20
a336 58
	"split",	 
	"nosplit",	 
	"ragged",	 
	"unfilled",	 
	"literal",	 
	"file",		 
	"offset",	 
	"bullet",	 
	"dash",		 
	"hyphen",	 
	"item",		 
	"enum",		 
	"tag",		 
	"diag",		 
	"hang",		 
	"ohang",	 
	"inset",	 
	"column",	 
	"width",	 
	"compact",	 
	"std",	 
	"-p1003.1-88",
	"-p1003.1-90",
	"-p1003.1-96",
	"-p1003.1-2001",
	"-p1003.1-2004",
	"-p1003.1",
	"-p1003.1b",
	"-p1003.1b-93",
	"-p1003.1c-95",
	"-p1003.1g-2000",
	"-p1003.2-92",
	"-p1387.2-95",
	"-p1003.2",
	"-p1387.2",
	"-isoC-90",
	"-isoC-amd1",
	"-isoC-tcor1",
	"-isoC-tcor2",
	"-isoC-99",
	"-ansiC",
	"-ansiC-89",
	"-ansiC-99",
	"-ieee754",
	"-iso8802-3",
	"-xpg3",
	"-xpg4",
	"-xpg4.2",
	"-xpg4.3",
	"-xbd5",
	"-xcu5",
	"-xsh5",
	"-xns5",
	"-xns5.2d2.0",
	"-xcurses4.2",
	"-susv2",
	"-susv3",
	"-svid4",
a532 6

#if 0
	(void)printf("parse: macro `%s' (%d), parent `%s' (%d)\n",
			toknames[tok], tok, 
			toknames[tree->last->tok], tree->last->tok);

a539 1
#endif
d660 1
d909 9
a917 2
		if (2 >= strlen(*argv) && ROFF_MAX != 
				(c = rofffindcallable(*argv)))
d921 1
a921 1

d976 9
a984 2
		if (2 >= strlen(*argv) && ROFF_MAX != 
				(c = rofffindcallable(*argv)))
d988 1
a988 1

@


1.6
log
@Added regression tests.
Considerable fixes... blah blah blah...
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.5 2008/11/25 16:49:57 kristaps Exp $ */
d32 2
d36 2
d65 3
a67 4
#define	ROFF_NESTED	 (1 << 0) 		/* Nested-layout. */
#define	ROFF_PARSED	 (1 << 1)		/* "Parsed". */
#define	ROFF_CALLABLE	 (1 << 2)		/* "Callable". */
#define	ROFF_QUOTES	 (1 << 3)		/* Quoted args. */
d112 1
d124 22
a145 11
static	const int roffarg_An[] = { 
	ROFF_Split, ROFF_Nosplit, ROFF_ARGMAX };

static	const int roffarg_Bd[] = {
	ROFF_Ragged, ROFF_Unfilled, ROFF_Literal, ROFF_File, 
	ROFF_Offset, ROFF_ARGMAX };

static 	const int roffarg_Bl[] = {
	ROFF_Bullet, ROFF_Dash, ROFF_Hyphen, ROFF_Item, ROFF_Enum,
	ROFF_Tag, ROFF_Diag, ROFF_Hang, ROFF_Ohang, ROFF_Inset,
	ROFF_Column, ROFF_Offset, ROFF_ARGMAX };
d147 1
d149 1
d152 2
a153 1

d169 20
a188 20
	{ roff_layout, roffarg_Bl, NULL, roffchild_Bl, 0, ROFF_LAYOUT, 0 }, 	/* Bl */
	{ roff_layout, NULL, roffparent_El, NULL, ROFF_Bl, ROFF_LAYOUT, 0 }, 	/* El */
	{ roff_layout, NULL, roffparent_It, NULL, ROFF_It, ROFF_LAYOUT, 0 }, 	/* It */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ad */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* An */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ar */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Cd */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Cm */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dv */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Er */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ev */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ex */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fa */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Fd */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fl */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fn */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ft */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ic */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* In */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Li */
d190 2
a191 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Nm */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Op */
d193 6
a198 6
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pa */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Rv */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* St */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Va */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Vt */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xr */
d213 1
a213 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* At */
d215 1
a215 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Bf */
d218 2
a219 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bsx */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bx */
d225 2
a226 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, 0 },	/* Ef */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Em */
d228 1
a228 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Fx */
d232 2
a233 2
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Nx */
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ox */
d251 1
a251 1
	{   NULL, NULL, NULL, NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ux */
d254 4
d305 1
a305 1
	"Dr",		 
a313 1
	"Ex",		 
d382 4
d410 38
d577 1
d581 1
a581 1
	for ( ; ROFF_MAX != *tokv; tokv++)
d644 6
d657 1
a749 4
#ifdef DEBUG
	(void)printf("lookup: `%s'\n", token);
#endif

d755 5
a759 1
		if (0 == strcmp(toknames[i], token))
d761 5
@


1.5
log
@Imported all macros from mdoc(7).
Put all names into roff.c with extern access from private.h.
Annotated list of changes that must occur for end-game (scope, nests, etc.).
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.4 2008/11/25 12:14:02 kristaps Exp $ */
d30 4
a35 1
/* Whether we're entering or leaving a roff scope. */
a40 1
/* The type of a macro (see mdoc(7) for more). */
a46 1
/* Arguments passed to a macro callback. */
a52 1
/* Describes a roff token (like D1 or Sh). */
d56 3
a59 1
	int		  symm;			/* FIXME */
a66 1
/* An argument to a roff token (like -split or -enum). */
a71 3
/* mdocml remembers only the current parse node and the chain leading to
 * the document root (scopes).
 */
a77 1
/* State of file parse. */
a91 4
	roffin		 roffin;		/* Text-macro cb. */
	roffblkin	 roffblkin;		/* Block-macro cb. */
	roffout		 roffout;		/* Text-macro cb. */
	roffblkout	 roffblkout;		/* Block-macro cb. */
d95 1
d101 1
d104 1
d119 1
a119 1
/* Arguments for `An' macro. */
d122 1
a122 1
/* Arguments for `Bd' macro. */
d126 1
a126 1
/* Arguments for `Bl' macro. */
d132 5
a136 23
/* FIXME: a big list of fixes that must occur.
 *
 * (1) Distinction not between ROFF_TEXT and ROFF_LAYOUT, but instead
 *     ROFF_ATOM and ROFF_NODE, which designate line spacing.  If
 *     ROFF_ATOM, we need not remember any state.
 *
 * (2) Have a maybe-NULL list of possible subsequent children for each
 *     node.  Bl, e.g., can only have It children (roffparse).
 *
 * (3) Have a maybe-NULL list of possible parents for each node.  It,
 *     e.g., can only have Bl as a parent (roffparse).
 *
 *     (N.B. If (2) were complete, (3) wouldn't be necessary.)
 *
 * (4) Scope rules.  If Pp exists, it closes the scope out from the
 *     previous Pp (if it exists).  Same with Sh and Ss.  If El exists,
 *     it closes out Bl and interim It.
 *
 * (5) Nesting.  Sh cannot be any descendant of Sh.  Bl, however, can be
 *     nested within an It.
 *
 * Once that's done, we're golden.
 */
d140 96
a235 96
	{        NULL,       NULL, 0, ROFF_COMMENT, 0 },	/* \" */
	{     roff_Dd,       NULL, 0, ROFF_TEXT, 0 },	/* Dd */
	{     roff_Dt,       NULL, 0, ROFF_TEXT, 0 },	/* Dt */
	{     roff_Os,       NULL, 0, ROFF_TEXT, 0 },	/* Os */
	{ roff_layout,       NULL, ROFF_Sh, ROFF_LAYOUT, ROFF_PARSED }, /* Sh */
	{ roff_layout,       NULL, ROFF_Ss, ROFF_LAYOUT, ROFF_PARSED }, /* Ss */ 
	{ roff_layout,       NULL, ROFF_Pp, ROFF_LAYOUT, 0 }, 	/* Pp */
	{ roff_layout,       NULL, 0, ROFF_TEXT, 0 },	 	/* D1 */
	{ roff_layout,       NULL, 0, ROFF_TEXT, 0 }, 		/* Dl */
	{ roff_layout, roffarg_Bd, 0, ROFF_LAYOUT, 0 }, 	/* Bd */
	{ roff_layout,       NULL, ROFF_Bd, ROFF_LAYOUT, 0 }, 	/* Ed */
	{ roff_layout, roffarg_Bl, 0, ROFF_LAYOUT, 0 }, 	/* Bl */
	{ roff_layout,       NULL, ROFF_Bl, ROFF_LAYOUT, 0 }, 	/* El */
	{ roff_layout,       NULL, ROFF_It, ROFF_LAYOUT, 0 }, 	/* It */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ad */
	{   roff_text, roffarg_An, 0, ROFF_TEXT, ROFF_PARSED }, /* An */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ar */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Cd */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Cm */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dv */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Er */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ev */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ex */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fa */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Fd */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fl */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Fn */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ft */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ic */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* In */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Li */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Nd */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Nm */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Op */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ot */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pa */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Rv */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* St */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Va */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Vt */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xr */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* %A */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %B */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* %D */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %I */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE}, /* %J */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* %N */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* %O */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* %P */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* %R */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* %T */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* %V */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ac */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ao */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Aq */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* At */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bc */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Bf */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bo */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Bq */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bsx */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Bx */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Db */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dc */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Do */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Dq */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ec */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Ef */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Em */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Eo */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Fx */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ms */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* No */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ns */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Nx */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ox */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pc */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Pf */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Po */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Pq */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qc */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Ql */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qo */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Qq */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Re */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Rs */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sc */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* So */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sq */
	{   roff_text,       NULL, 0, ROFF_TEXT, 0 },	/* Sm */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sx */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Sy */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Tn */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED }, /* Ux */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xc */
	{   roff_text,       NULL, 0, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Xo */
d422 1
a422 2
		const struct md_rbuf *in, roffin textin, 
		roffout textout, roffblkin blkin, roffblkout blkout)
d435 1
a435 4
	tree->roffin = textin;
	tree->roffout = textout;
	tree->roffblkin = blkin;
	tree->roffblkout = blkout;
d510 15
d529 1
a529 1
	struct roffnode	 *node;
d535 7
a541 10
	/*
	 * Extract the token identifier from the buffer.  If there's no
	 * callback for the token (comment, etc.) then exit immediately.
	 * We don't do any error handling (yet), so if the token doesn't
	 * exist, die.
	 */

	if (3 > sz) {
		warnx("%s: malformed line (line %zu)", 
				tree->rbuf->name, 
d544 2
d547 3
a549 5
	/* FIXME: .Bsx is three letters! */
	} else if (ROFF_MAX == (tok = rofffindtok(buf + 1))) {
		warnx("%s: unknown line token `%c%c' (line %zu)",
				tree->rbuf->name, 
				*(buf + 1), *(buf + 2), 
d552 6
a557 3
	} else if (ROFF_COMMENT == tokens[tok].type) 
		/* Ignore comment tokens. */
		return(1);
d559 23
a581 2
	if ( ! roffargs(tok, buf, argv)) {
		warnx("%s: too many arguments to `%s' (line %zu)",
d583 1
d589 1
a589 7
	 * If this is a non-nestable layout token and we're below a
	 * token of the same type, then recurse upward to the token,
	 * closing out the interim scopes.
	 *
	 * If there's a nested token on the chain, then raise an error
	 * as nested tokens have corresponding "ending" tokens and we're
	 * breaking their scope.
d592 2
a593 1
	node = NULL;
d595 3
a597 5
	if (ROFF_LAYOUT == tokens[tok].type && 
			! (ROFF_NESTED & tokens[tok].flags)) {
		for (node = tree->last; node; node = node->parent) {
			if (node->tok == tok)
				break;
d599 2
a600 1
			/* Don't break nested scope. */
d602 13
a614 9
			if ( ! (ROFF_NESTED & tokens[node->tok].flags))
				continue;
			warnx("%s: scope of %s (line %zu) broken by "
					"%s (line %zu)", 
					tree->rbuf->name, 
					toknames[tok], node->line, 
					toknames[node->tok],
					tree->rbuf->line);
			return(0);
a615 10
	}

	if (node) {
		assert(ROFF_LAYOUT == tokens[tok].type);
		assert( ! (ROFF_NESTED & tokens[tok].flags));
		assert(node->tok == tok);

		/* Clear up to last scoped token. */

		/* LINTED */
d618 5
a622 2
			if ( ! (*tokens[tree->last->tok].cb)
					(tree->last->tok, tree, NULL, ROFF_EXIT))
d625 2
d629 10
a638 1
	/* Proceed with actual token processing. */
a639 1
	argvp = (const char **)&argv[1];
d662 1
a662 1
rofffindtok(const char *name)
d664 1
d667 16
d688 1
a688 1
		if (0 == strncmp(name, toknames[i], 2))
d754 35
d803 5
a807 2
	if (ROFF_PRELUDE_Dd & tree->state ||
			ROFF_PRELUDE_Dt & tree->state) {
d836 1
a836 2
	if ( ! (ROFF_PRELUDE_Dd & tree->state) ||
			(ROFF_PRELUDE_Dt & tree->state)) {
d840 4
a888 36
/* ARGUSED */
static int
roffnextopt(int tok, const char ***in, char **val)
{
	const char	*arg, **argv;
	int		 v;

	*val = NULL;
	argv = *in;
	assert(argv);

	if (NULL == (arg = *argv))
		return(-1);
	if ('-' != *arg)
		return(-1);

	/* FIXME: should we let this slide... ? */

	if (ROFF_ARGMAX == (v = rofffindarg(&arg[1])))
		return(-1);

	/* FIXME: should we let this slide... ? */

	if ( ! roffargok(tok, v))
		return(-1);
	if ( ! (ROFF_VALUE & tokenargs[v].flags))
		return(v);

	*in = ++argv;

	/* FIXME: what if this looks like a roff token or argument? */

	return(*argv ? v : ROFF_ARGMAX);
}


d906 1
a906 1
		return((*tree->roffblkout)(tok));
d938 1
a938 1
	if ( ! (*tree->roffin)(tok, argcp, argvp))
d944 1
a944 1
		if ( ! ((*tree->roffout)(tok)))
d946 1
a946 1
		return((*tree->roffblkin)(tok));
d960 1
a960 1
	if ( ! ((*tree->roffout)(tok)))
d963 1
a963 1
	return((*tree->roffblkin)(tok));
d1001 1
a1001 1
	if ( ! (*tree->roffin)(tok, argcp, argvp))
d1006 1
a1006 1
		return((*tree->roffout)(tok));
d1020 10
a1029 1
	return((*tree->roffout)(tok));
@


1.4
log
@Single call-back for filters.
Removed verbose flag.
Added more macros and arguments.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.3 2008/11/24 18:34:50 kristaps Exp $ */
d32 1
d38 1
a38 2
/* FIXME: prolog roffs can be text roffs, too. */

d45 1
d52 1
d54 4
a57 2
	int		(*cb)(ROFFCALL_ARGS);
	enum rofftype	  type;
d59 4
a62 4
#define	ROFF_NESTED	 (1 << 0) 
#define	ROFF_PARSED	 (1 << 1)
#define	ROFF_CALLABLE	 (1 << 2)
#define	ROFF_QUOTES	 (1 << 3)
d65 1
a66 1
	int 		  tok;
d68 1
a68 1
#define	ROFF_VALUE	 (1 << 0)
d71 3
d75 3
a77 3
	int		  tok;	
	struct roffnode	 *parent;
	size_t		  line;
d80 1
d82 6
a87 6
	struct roffnode	 *last;
	time_t		  date;
	char		  os[64];
	char		  title[64];
	char		  section[64];
	char		  volume[64];
d89 13
a101 14
#define	ROFF_PRELUDE	 (1 << 1)
#define	ROFF_PRELUDE_Os	 (1 << 2)
#define	ROFF_PRELUDE_Dt	 (1 << 3)
#define	ROFF_PRELUDE_Dd	 (1 << 4)
#define	ROFF_BODY	 (1 << 5)

	roffin		 roffin;
	roffblkin	 roffblkin;
	roffout		 roffout;
	roffblkout	 roffblkout;

	struct md_mbuf		*mbuf; /* NULL if !flush. */
	const struct md_args	*args;
	const struct md_rbuf	*rbuf;
a106 1

d117 2
d123 36
d160 1
d162 96
a257 16
	{        NULL, ROFF_COMMENT, 0 },
	{     roff_Dd, ROFF_TEXT, 0 },			/* Dd */
	{     roff_Dt, ROFF_TEXT, 0 },			/* Dt */
	{     roff_Os, ROFF_TEXT, 0 },			/* Os */
	{ roff_layout, ROFF_LAYOUT, ROFF_PARSED },	/* Sh */
	{ roff_layout, ROFF_LAYOUT, ROFF_PARSED }, 	/* Ss XXX */ 
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* Pp */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* D1 */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* Dl */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* Bd */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* Ed */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* Bl */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* El */
	{ roff_layout, ROFF_LAYOUT, 0 }, 		/* It */
	{   roff_text, ROFF_TEXT, ROFF_PARSED },	/* An */
	{   roff_text, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE }, /* Li */
d260 1
a260 2
/* FIXME: multiple owners? */

d262 20
a281 18
	{ ROFF_An, 0 },				/* split */
	{ ROFF_An, 0 },				/* nosplit */
	{ ROFF_Bd, 0 },				/* ragged */
	{ ROFF_Bd, 0 },				/* unfilled */
	{ ROFF_Bd, 0 },				/* literal */
	{ ROFF_Bd, ROFF_VALUE },		/* file */
	{ ROFF_Bd, ROFF_VALUE },		/* offset */
	{ ROFF_Bl, 0 },				/* bullet */
	{ ROFF_Bl, 0 },				/* dash */
	{ ROFF_Bl, 0 },				/* hyphen */
	{ ROFF_Bl, 0 },				/* item */
	{ ROFF_Bl, 0 },				/* enum */
	{ ROFF_Bl, 0 },				/* tag */
	{ ROFF_Bl, 0 },				/* diag */
	{ ROFF_Bl, 0 },				/* hang */
	{ ROFF_Bl, 0 },				/* ohang */
	{ ROFF_Bl, 0 },				/* inset */
	{ ROFF_Bl, 0 },				/* column */
d284 127
a410 2
static	const char *const toknames[ROFF_MAX] = ROFF_NAMES;
static 	const char *const tokargnames[ROFF_ARGMAX] = ROFF_ARGNAMES;
d558 2
d695 16
d821 1
a821 1
roffnextopt(const char ***in, char **val)
d834 3
d839 5
d864 2
a865 1
				tree->rbuf->name, toknames[tok],
d876 2
a877 1
	while (-1 != (c = roffnextopt(&argv, &v))) {
d879 7
a885 1
			warnx("%s: error parsing `%s' args (line %zu)", 
d887 1
d894 1
d898 3
d942 2
a943 1
				tree->rbuf->name, toknames[tok],
d949 2
a950 1
	while (-1 != (c = roffnextopt(&argv, &v))) {
d952 1
a952 1
			warnx("%s: error parsing `%s' args (line %zu)", 
d957 1
a957 1
		}
d960 1
d964 3
@


1.3
log
@Annotated todo for prologue/text tokens.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.2 2008/11/24 18:32:39 kristaps Exp $ */
a39 1
	ROFF_TITLE, 
a51 1
	char		 *name;
d62 1
a62 1
	char		 *name;
d76 4
a79 3
	char		  title[256];
	char		  section[256];
	char		  volume[256];
a85 1
	struct md_mbuf	*mbuf; /* NULL if ROFF_EXIT and error. */
d87 6
a94 4
	const roffin		*roffin;
	const roffblkin		*roffblkin;
	const roffout		*roffout;
	const roffblkout	*roffblkout;
d104 1
a104 2
static	struct roffnode	 *roffnode_new(int, size_t, 
				struct rofftree *);
d116 17
a132 8
static const struct rofftok tokens[ROFF_MAX] = {
	{ "\\\"",    NULL, ROFF_COMMENT, 0 },
	{   "Dd", roff_Dd, ROFF_TITLE, 0 },
	{   "Dt", roff_Dt, ROFF_TITLE, 0 },
	{   "Os", roff_Os, ROFF_TITLE, 0 },
	{   "Sh", roff_layout, ROFF_LAYOUT, ROFF_PARSED },
	{   "An", roff_text, ROFF_TEXT, ROFF_PARSED },
	{   "Li", roff_text, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE },
d135 21
a155 3
static const struct roffarg tokenargs[ROFF_ARGMAX] = {
	{  "split", 	0 },
	{  "nosplit",	0 },
d158 3
d193 2
a194 4
		const struct md_rbuf *in,
		const roffin *roffin, const roffout *roffout,
		const roffblkin *roffblkin, 
		const roffblkout *roffblkout)
d207 4
a210 4
	tree->roffin = roffin;
	tree->roffout = roffout;
	tree->roffblkin = roffblkin;
	tree->roffblkout = roffblkout;
d319 1
a319 1
				tree->rbuf->name, tokens[tok].name, 
a323 31
	/* Domain cross-contamination (and sanity) checks. */

	switch (tokens[tok].type) {
	case (ROFF_TITLE):
		if (ROFF_PRELUDE & tree->state) {
			assert( ! (ROFF_BODY & tree->state));
			break;
		}
		assert(ROFF_BODY & tree->state);
		warnx("%s: prelude token `%s' in body (line %zu)",
				tree->rbuf->name, tokens[tok].name, 
				tree->rbuf->line);
		return(0);
	case (ROFF_LAYOUT):
		/* FALLTHROUGH */
	case (ROFF_TEXT):
		if (ROFF_BODY & tree->state) {
			assert( ! (ROFF_PRELUDE & tree->state));
			break;
		}
		assert(ROFF_PRELUDE & tree->state);
		warnx("%s: body token `%s' in prelude (line %zu)",
				tree->rbuf->name, tokens[tok].name, 
				tree->rbuf->line);
		return(0);
	case (ROFF_COMMENT):
		return(1);
	default:
		abort();
	}

d349 2
a350 3
					tokens[tok].name,
					node->line, 
					tokens[node->tok].name,
d389 1
a389 1
		if (0 == strcmp(name, tokenargs[i].name))
d406 1
a406 1
		if (0 == strncmp(name, tokens[i].name, 2))
a423 1
/* FIXME: accept only struct rofftree *. */
d425 1
a425 1
roffnode_new(int tokid, size_t line, struct rofftree *tree)
d434 1
a434 1
	p->line = line;
a455 1
/* FIXME: accept only struct rofftree *. */
d461 6
d468 4
a471 2
	if (ROFF_PRELUDE_Dt & tree->state ||
			ROFF_PRELUDE_Dd & tree->state) {
d477 2
d491 6
d498 2
d507 2
d522 7
a528 3
		roffnode_free(ROFF_Os, tree);
		return(1);
	} 
d538 1
a538 3
	assert(NULL == tree->last);
	if (NULL == roffnode_new(ROFF_Os, tree->rbuf->line, tree))
		return(0);
d544 3
a546 1
	return(1);
d585 7
d594 1
a594 1
		return((*tree->roffblkout[tok])(tok));
d602 1
a602 1
					tokens[tok].name,
d611 1
a611 1
	if (NULL == roffnode_new(tok, tree->rbuf->line, tree))
d614 1
a614 1
	if ( ! (*tree->roffin[tok])(tok, argcp, argvp))
d620 1
a620 1
		if ( ! ((*tree->roffout[tok])(tok)))
d622 1
a622 1
		return((*tree->roffblkin[tok])(tok));
d636 1
a636 1
	if ( ! ((*tree->roffout[tok])(tok)))
d639 1
a639 1
	return((*tree->roffblkin[tok])(tok));
d650 7
d662 1
a662 1
					tokens[tok].name,
d671 1
a671 1
	if ( ! (*tree->roffin[tok])(tok, argcp, argvp))
d676 1
a676 1
		return((*tree->roffout[tok])(tok));
d690 1
a690 1
	return((*tree->roffout[tok])(tok));
@


1.2
log
@Generic roff_layout for layout tokens.
@
text
@d1 1
a1 1
/* $Id: roff.c,v 1.1 2008/11/24 14:24:55 kristaps Exp $ */
d37 2
@


1.1
log
@Split roff engine into roff.c.
Re-worked calling convention for md_*.
@
text
@d1 1
a1 1
/* $Id: html4_strict.c,v 1.6 2008/11/24 08:50:33 kristaps Exp $ */
d45 2
a46 1
	struct rofftree *tree, const char *argv[], enum roffd type
d89 4
a94 9
#define	ROFF___	 	  0
#define	ROFF_Dd		  1
#define	ROFF_Dt		  2
#define	ROFF_Os		  3
#define	ROFF_Sh		  4
#define	ROFF_An		  5
#define	ROFF_Li		  6
#define	ROFF_MAX	  7

d98 3
a100 3
static	int		  roff_Sh(ROFFCALL_ARGS);
static	int		  roff_An(ROFFCALL_ARGS);
static	int		  roff_Li(ROFFCALL_ARGS);
d108 1
a113 3
static	void		  dbg_enter(const struct md_args *, int);
static	void		  dbg_leave(const struct md_args *, int);

d120 3
a122 3
	{   "Sh", roff_Sh, ROFF_LAYOUT, 0 },
	{   "An", roff_An, ROFF_TEXT, ROFF_PARSED },
	{   "Li", roff_Li, ROFF_TEXT, ROFF_PARSED | ROFF_CALLABLE },
a124 4
#define	ROFF_Split	  0
#define	ROFF_Nosplit	  1
#define	ROFF_ARGMAX	  2

d143 1
a143 1
				(tree, NULL, ROFF_EXIT))
d162 4
a165 1
		const struct md_rbuf *in)
d178 4
d370 1
a370 1
					(tree, NULL, ROFF_EXIT))
d378 1
a378 1
	return((*tokens[tok].cb)(tree, argvp, ROFF_ENTER));
d416 11
a459 56
static int dbg_lvl = 0;


static void
dbg_enter(const struct md_args *args, int tokid)
{
	int		 i;
	static char	 buf[72];

	assert(args);
	if ( ! (args->dbg & MD_DBG_TREE))
		return;
	assert(tokid >= 0 && tokid <= ROFF_MAX);

	buf[0] = buf[71] = 0;

	switch (tokens[tokid].type) {
	case (ROFF_LAYOUT):
		(void)strncat(buf, "[body-layout] ", sizeof(buf) - 1);
		break;
	case (ROFF_TEXT):
		(void)strncat(buf, "[  body-text] ", sizeof(buf) - 1);
		break;
	case (ROFF_TITLE):
		(void)strncat(buf, "[    prelude] ", sizeof(buf) - 1);
		break;
	default:
		abort();
	}

	/* LINTED */
	for (i = 0; i < dbg_lvl; i++)
		(void)strncat(buf, "  ", sizeof(buf) - 1);

	(void)strncat(buf, tokens[tokid].name, sizeof(buf) - 1);

	(void)printf("%s\n", buf);

	dbg_lvl++;
}


/* FIXME: accept only struct rofftree *. */
static void
dbg_leave(const struct md_args *args, int tokid)
{
	assert(args);
	if ( ! (args->dbg & MD_DBG_TREE))
		return;

	assert(tokid >= 0 && tokid <= ROFF_MAX);
	assert(dbg_lvl > 0);
	dbg_lvl--;
}


a465 2
	dbg_enter(tree->args, ROFF_Dd);

a476 2
	dbg_leave(tree->args, ROFF_Dd);

a485 2
	dbg_enter(tree->args, ROFF_Dt);

a496 2
	dbg_leave(tree->args, ROFF_Dt);

a507 1
		dbg_leave(tree->args, ROFF_Os);
a510 2
	dbg_enter(tree->args, ROFF_Os);

d531 1
a531 32
/* ARGSUSED */
static int
roff_Sh(ROFFCALL_ARGS)
{

	if (ROFF_EXIT == type) {
		roffnode_free(ROFF_Sh, tree);
		dbg_leave(tree->args, ROFF_Sh);
		return(1);
	} 

	dbg_enter(tree->args, ROFF_Sh);

	if (NULL == roffnode_new(ROFF_Sh, tree->rbuf->line, tree))
		return(0);

	return(1);
}


/* ARGSUSED */
static int
roff_Li(ROFFCALL_ARGS) 
{

	dbg_enter(tree->args, ROFF_Li);
	dbg_leave(tree->args, ROFF_Li);

	return(1);
}


d561 1
a561 1
roff_An(ROFFCALL_ARGS) 
d563 2
a564 2
	int		 c;
	char		*val;
d566 4
a569 1
	dbg_enter(tree->args, ROFF_An);
d571 4
a574 10
	while (-1 != (c = roffnextopt(&argv, &val))) {
		switch (c) {
		case (ROFF_Split):
			/* Process argument. */
			break;
		case (ROFF_Nosplit):
			/* Process argument. */
			break;
		default:
			warnx("%s: error parsing `An' args (line %zu)", 
d576 1
d580 2
d585 14
a598 2
	/* Print header. */
  
d600 32
a631 13
		if (/* is_parsable && */ 2 >= strlen(*argv)) {
			if (ROFF_MAX != (c = rofffindtok(*argv))) {
				if (ROFF_CALLABLE & tokens[c].flags) {
					/* Call to token. */
					if ( ! (*tokens[c].cb)(tree, (const char **)argv + 1, ROFF_ENTER))
						return(0);
				} 
				/* Print token. */
			} else {
				/* Print token. */
			}
		} else {
			/* Print token. */
d633 2
d638 2
a639 1
	/* Print footer. */
d641 4
a644 1
	dbg_leave(tree->args, ROFF_An);
d646 12
a657 1
	return(1);
a658 1

@
