head	1.15;
access;
symbols
	VERSION_1_13_3:1.14
	VERSION_1_13_2:1.12
	VERSION_1_12_4:1.7
	VERSION_1_13_1:1.6
	VERSION_1_12_3:1.6
	VERSION_1_12_2:1.6
	VERSION_1_12:1.7.0.2
	VERSION_1_12_1:1.5
	VERSION_1_12_0:1.5
	VERSION_1_11_7:1.5
	VERSION_1_11_6:1.5
	VERSION_1_11_5:1.5
	VERSION_1_11_4:1.4
	VERSION_1_11_3:1.4;
locks; strict;
comment	@ * @;


1.15
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2015.03.06.09.24.59;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2014.12.19.04.58.35;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2014.11.14.04.24.04;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2014.11.01.04.08.43;	author schwarze;	state Exp;
branches;
next	1.10;

1.10
date	2014.10.26.18.22.51;	author schwarze;	state Exp;
branches;
next	1.9;

1.9
date	2014.10.25.01.03.52;	author schwarze;	state Exp;
branches;
next	1.8;

1.8
date	2014.08.16.19.00.01;	author schwarze;	state Exp;
branches;
next	1.7;

1.7
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.6;

1.6
date	2013.06.02.03.52.21;	author schwarze;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.24.18.15.14;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.26.21.13.07;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.26.14.43.07;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.26.12.01.14;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.26.00.30.11;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.15
log
@modernize style: "return" is not a function
@
text
@/*	$Id: preconv.c,v 1.14 2015/03/06 09:24:59 kristaps Exp $ */
/*
 * Copyright (c) 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2014 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <stdio.h>
#include <string.h>
#include "mandoc.h"
#include "libmandoc.h"

int
preconv_encode(struct buf *ib, size_t *ii, struct buf *ob, size_t *oi,
    int *filenc)
{
	unsigned char	*cu;
	int		 nby;
	unsigned int	 accum;

	cu = (unsigned char *)ib->buf + *ii;
	assert(*cu & 0x80);

	if ( ! (*filenc & MPARSE_UTF8))
		goto latin;

	nby = 1;
	while (nby < 5 && *cu & (1 << (7 - nby)))
		nby++;

	switch (nby) {
	case 2:
		accum = *cu & 0x1f;
		if (accum < 0x02)  /* Obfuscated ASCII. */
			goto latin;
		break;
	case 3:
		accum = *cu & 0x0f;
		break;
	case 4:
		accum = *cu & 0x07;
		if (accum > 0x04) /* Beyond Unicode. */
			goto latin;
		break;
	default:  /* Bad sequence header. */
		goto latin;
	}

	cu++;
	switch (nby) {
	case 3:
		if ((accum == 0x00 && ! (*cu & 0x20)) ||  /* Use 2-byte. */
		    (accum == 0x0d && *cu & 0x20))  /* Surrogates. */
			goto latin;
		break;
	case 4:
		if ((accum == 0x00 && ! (*cu & 0x30)) ||  /* Use 3-byte. */
		    (accum == 0x04 && *cu & 0x30))  /* Beyond Unicode. */
			goto latin;
		break;
	default:
		break;
	}

	while (--nby) {
		if ((*cu & 0xc0) != 0x80)  /* Invalid continuation. */
			goto latin;
		accum <<= 6;
		accum += *cu & 0x3f;
		cu++;
	}

	assert(accum > 0x7f);
	assert(accum < 0x110000);
	assert(accum < 0xd800 || accum > 0xdfff);

	*oi += snprintf(ob->buf + *oi, 11, "\\[u%.4X]", accum);
	*ii = (char *)cu - ib->buf;
	*filenc &= ~MPARSE_LATIN1;
	return 1;

latin:
	if ( ! (*filenc & MPARSE_LATIN1))
		return 0;

	*oi += snprintf(ob->buf + *oi, 11,
	    "\\[u%.4X]", (unsigned char)ib->buf[(*ii)++]);

	*filenc &= ~MPARSE_UTF8;
	return 1;
}

int
preconv_cue(const struct buf *b, size_t offset)
{
	const char	*ln, *eoln, *eoph;
	size_t		 sz, phsz;

	ln = b->buf + offset;
	sz = b->sz - offset;

	/* Look for the end-of-line. */

	if (NULL == (eoln = memchr(ln, '\n', sz)))
		eoln = ln + sz;

	/* Check if we have the correct header/trailer. */

	if ((sz = (size_t)(eoln - ln)) < 10 ||
	    memcmp(ln, ".\\\" -*-", 7) || memcmp(eoln - 3, "-*-", 3))
		return MPARSE_UTF8 | MPARSE_LATIN1;

	/* Move after the header and adjust for the trailer. */

	ln += 7;
	sz -= 10;

	while (sz > 0) {
		while (sz > 0 && ' ' == *ln) {
			ln++;
			sz--;
		}
		if (0 == sz)
			break;

		/* Find the end-of-phrase marker (or eoln). */

		if (NULL == (eoph = memchr(ln, ';', sz)))
			eoph = eoln - 3;
		else
			eoph++;

		/* Only account for the "coding" phrase. */

		if ((phsz = eoph - ln) < 7 ||
		    strncasecmp(ln, "coding:", 7)) {
			sz -= phsz;
			ln += phsz;
			continue;
		}

		sz -= 7;
		ln += 7;

		while (sz > 0 && ' ' == *ln) {
			ln++;
			sz--;
		}
		if (0 == sz)
			return 0;

		/* Check us against known encodings. */

		if (phsz > 4 && !strncasecmp(ln, "utf-8", 5))
			return MPARSE_UTF8;
		if (phsz > 10 && !strncasecmp(ln, "iso-latin-1", 11))
			return MPARSE_LATIN1;
		return 0;
	}
	return MPARSE_UTF8 | MPARSE_LATIN1;
}
@


1.14
log
@Allow compilation on Mac OS X, which doesn't have MACHINE defined.
While there, specify some casts to satisfy the compiler warnings.

OK schwarze@@
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.13 2014/12/19 04:58:35 schwarze Exp $ */
d95 1
a95 1
	return(1);
d99 1
a99 1
		return(0);
d105 1
a105 1
	return(1);
d126 1
a126 1
		return(MPARSE_UTF8 | MPARSE_LATIN1);
d165 1
a165 1
			return(0);
d170 1
a170 1
			return(MPARSE_UTF8);
d172 2
a173 2
			return(MPARSE_LATIN1);
		return(0);
d175 1
a175 1
	return(MPARSE_UTF8 | MPARSE_LATIN1);
@


1.13
log
@Rewrite the low-level UTF-8 parser from scratch.
It accepted invalid byte sequences like 0xc080-c1bf, 0xe08080-e09fbf,
0xeda080-edbfbf, and 0xf0808080-f08fbfbf, produced valid roff Unicode
escape sequences from them, and the algorithm contained strong
defenses against any attempt to fix it.

This cures an assertion failure in the terminal formatter caused
by sneaking in ASCII 0x08 (backspace) by "encoding" it as an (invalid)
multibyte UTF-8 sequence, found by jsg@@ with afl.

As a bonus, the new algorithm also reduces the code in the function
by about 20%.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.12 2014/11/14 04:24:04 schwarze Exp $ */
d36 1
a36 1
	cu = ib->buf + *ii;
@


1.12
log
@Remove needless and harmful byte swapping on big endian architectures.
Problem found and patch provided by Martin Natano at bitrig, thanks!
Tested on macppc by natano@@ and on i386, amd64, and sparc64 myself.

While here, sync with OpenBSD by removing some trailing whitespace.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.11 2014/11/01 04:08:43 schwarze Exp $ */
d22 1
d32 2
a33 2
	size_t		 i;
	int		 state;
d35 3
a37 1
	unsigned char	 cu;
d42 37
a78 2
	state = 0;
	accum = 0U;
d80 6
a85 68
	for (i = *ii; i < ib->sz; i++) {
		cu = ib->buf[i];
		if (state) {
			if ( ! (cu & 128) || (cu & 64)) {
				/* Bad sequence header. */
				break;
			}

			/* Accept only legitimate bit patterns. */

			if (cu > 191 || cu < 128) {
				/* Bad in-sequence bits. */
				break;
			}

			accum |= (cu & 63) << --state * 6;

			if (state)
				continue;

			if (accum < 0x80)
				ob->buf[(*oi)++] = accum;
			else
				*oi += snprintf(ob->buf + *oi,
				    11, "\\[u%.4X]", accum);
			*ii = i + 1;
			*filenc &= ~MPARSE_LATIN1;
			return(1);
		} else {
			/*
			 * Entering a UTF-8 state:  if we encounter a
			 * UTF-8 bitmask, calculate the expected UTF-8
			 * state from it.
			 */
			for (state = 0; state < 7; state++)
				if ( ! (cu & (1 << (7 - state))))
					break;

			/* Accept only legitimate bit patterns. */

			switch (state--) {
			case (4):
				if (cu <= 244 && cu >= 240) {
					accum = (cu & 7) << 18;
					continue;
				}
				/* Bad 4-sequence start bits. */
				break;
			case (3):
				if (cu <= 239 && cu >= 224) {
					accum = (cu & 15) << 12;
					continue;
				}
				/* Bad 3-sequence start bits. */
				break;
			case (2):
				if (cu <= 223 && cu >= 194) {
					accum = (cu & 31) << 6;
					continue;
				}
				/* Bad 2-sequence start bits. */
				break;
			default:
				/* Bad sequence bit mask. */
				break;
			}
			break;
		}
d88 8
a95 1
	/* FALLTHROUGH: Invalid or incomplete UTF-8 sequence. */
@


1.11
log
@Refactor, no functional change: Remove the parse point from struct buf.
Some functions need multiple parse points, some none at all,
and it varies whether any of them need to be passed around.
So better pass them as a separate argument, and only when needed.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.10 2014/10/26 18:22:51 schwarze Exp $ */
d32 1
a32 2
	const long	 one = 1L;
	int		 state, be;
a40 6
	be = 0;

	/* Quick test for big-endian value. */

	if ( ! (*((const char *)(&one))))
		be = 1;
a61 13
			/*
			 * Accum is held in little-endian order as
			 * stipulated by the UTF-8 sequence coding.  We
			 * need to convert to a native big-endian if our
			 * architecture requires it.
			 */

			if (be)
				accum = (accum >> 24) | 
					((accum << 8) & 0x00FF0000) |
					((accum >> 8) & 0x0000FF00) |
					(accum << 24);

d76 1
a76 1
			for (state = 0; state < 7; state++) 
d141 1
a141 1
	if ((sz = (size_t)(eoln - ln)) < 10 || 
d172 1
a172 1
		} 
@


1.10
log
@KNF: indentation and sort variables by size; no functional change
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.9 2014/10/25 01:03:52 schwarze Exp $ */
d28 2
a29 1
preconv_encode(struct buf *ib, struct buf *ob, int *filenc)
d49 1
a49 1
	for (i = ib->offs; i < ib->sz; i++) {
d83 1
a83 1
				ob->buf[ob->offs++] = accum;
d85 1
a85 1
				ob->offs += snprintf(ob->buf + ob->offs,
d87 1
a87 1
			ib->offs = i + 1;
d138 2
a139 2
	ob->offs += snprintf(ob->buf + ob->offs, 11,
	    "\\[u%.4X]", (unsigned char)ib->buf[ib->offs++]);
d146 1
a146 1
preconv_cue(const struct buf *b)
d151 2
a152 2
	ln = b->buf + b->offs;
	sz = b->sz - b->offs;
@


1.9
log
@integrate preconv(1) into mandoc(1);
enhances functionality and reduces code and docs by more than 300 lines
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.8 2014/08/16 19:00:01 schwarze Exp $ */
d30 2
a33 1
	size_t		 i;
a34 1
	const long	 one = 1L;
d161 1
a161 2
			memcmp(ln, ".\\\" -*-", 7) ||
			memcmp(eoln - 3, "-*-", 3))
@


1.8
log
@Improve build system and autodetection.
* Make ./configure standalone, that's what people expect.
* Let people write a ./configure.local from scratch, not edit existing files.
* Autodetect wchar, sqlite3, and manpath and act accordingly.
* Autodetect the need for -L/usr/local/lib and -lutil.
* Get rid of config.h.p{re,ost}, let ./configure only write what's needed.
* Let ./configure write a Makefile.local snippet, that's quite flexible.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.7 2014/08/10 23:54:41 schwarze Exp $ */
d4 1
a20 4
#if HAVE_MMAP
#include <sys/stat.h>
#include <sys/mman.h>
#endif
a21 2
#include <assert.h>
#include <fcntl.h>
a22 1
#include <stdlib.h>
d24 2
a25 1
#include <unistd.h>
d27 2
a28 90
/* 
 * The read_whole_file() and resize_buf() functions are copied from
 * read.c, including all dependency code.
 */

enum	enc {
	ENC_UTF_8, /* UTF-8 */
	ENC_US_ASCII, /* US-ASCII */
	ENC_LATIN_1, /* Latin-1 */
	ENC__MAX
};

struct	buf {
	char		 *buf; /* binary input buffer */
	size_t	 	  sz; /* size of binary buffer */
	size_t		  offs; /* starting buffer offset */
};

struct	encode {
	const char	 *name;
	int		(*conv)(const struct buf *);
};

static	int	 cue_enc(const struct buf *, size_t *, enum enc *);
static	int	 conv_latin_1(const struct buf *);
static	int	 conv_us_ascii(const struct buf *);
static	int	 conv_utf_8(const struct buf *);
static	int	 read_whole_file(const char *, int, 
			struct buf *, int *);
static	void	 resize_buf(struct buf *, size_t);
static	void	 usage(void);

static	const struct encode encs[ENC__MAX] = {
	{ "utf-8", conv_utf_8 }, /* ENC_UTF_8 */
	{ "us-ascii", conv_us_ascii }, /* ENC_US_ASCII */
	{ "latin-1", conv_latin_1 }, /* ENC_LATIN_1 */
};

static	const char	 *progname;

static void
usage(void)
{

	fprintf(stderr, "usage: %s "
			"[-D enc] "
			"[-e ENC] "
			"[file]\n", progname);
}

static int
conv_latin_1(const struct buf *b)
{
	size_t		 i;
	unsigned char	 cu;
	const char	*cp;

	cp = b->buf + (int)b->offs;

	/*
	 * Latin-1 falls into the first 256 code-points of Unicode, so
	 * there's no need for any sort of translation.  Just make the
	 * 8-bit characters use the Unicode escape.
	 * Note that binary values 128 < v < 160 are passed through
	 * unmodified to mandoc.
	 */

	for (i = b->offs; i < b->sz; i++) {
		cu = (unsigned char)*cp++;
		cu < 160U ? putchar(cu) : printf("\\[u%.4X]", cu);
	}

	return(1);
}

static int
conv_us_ascii(const struct buf *b)
{

	/*
	 * US-ASCII has no conversion since it falls into the first 128
	 * bytes of Unicode.
	 */

	fwrite(b->buf, 1, b->sz, stdout);
	return(1);
}

static int
conv_utf_8(const struct buf *b)
a33 1
	const char	*cp;
d36 3
a38 1
	cp = b->buf + (int)b->offs;
d48 2
a49 2
	for (i = b->offs; i < b->sz; i++) {
		cu = (unsigned char)*cp++;
d53 1
a53 1
				return(0);
d60 1
a60 1
				return(0);
d65 3
d75 1
a75 1
			if (0 == state && be) 
d81 9
a89 6
			if (0 == state) {
				accum < 128U ? putchar(accum) : 
					printf("\\[u%.4X]", accum);
				accum = 0U;
			}
		} else if (cu & (1 << 7)) {
d101 1
a101 1
			switch (state) {
d105 1
a105 1
					break;
d108 1
a108 1
				return(0);
d112 1
a112 1
					break;
d115 1
a115 1
				return(0);
d119 1
a119 1
					break;
d122 1
a122 1
				return(0);
d125 1
a125 1
				return(0);
d127 2
a128 39
			state--;
		} else
			putchar(cu);
	}

	if (0 != state) {
		/* Bad trailing bits. */
		return(0);
	}

	return(1);
}

static void
resize_buf(struct buf *buf, size_t initial)
{

	buf->sz = buf->sz > initial / 2 ? 
		2 * buf->sz : initial;

	buf->buf = realloc(buf->buf, buf->sz);
	if (NULL == buf->buf) {
		perror(NULL);
		exit(EXIT_FAILURE);
	}
}

static int
read_whole_file(const char *f, int fd, 
		struct buf *fb, int *with_mmap)
{
	size_t		 off;
	ssize_t		 ssz;

#if HAVE_MMAP
	struct stat	 st;
	if (-1 == fstat(fd, &st)) {
		perror(f);
		return(0);
d131 1
a131 6
	/*
	 * If we're a regular file, try just reading in the whole entry
	 * via mmap().  This is faster than reading it into blocks, and
	 * since each file is only a few bytes to begin with, I'm not
	 * concerned that this is going to tank any machines.
	 */
d133 2
a134 2
	if (S_ISREG(st.st_mode) && st.st_size >= (1U << 31)) {
		fprintf(stderr, "%s: input too large\n", f);
a135 10
	} 
	
	if (S_ISREG(st.st_mode)) {
		*with_mmap = 1;
		fb->sz = (size_t)st.st_size;
		fb->buf = mmap(NULL, fb->sz, PROT_READ, MAP_SHARED, fd, 0);
		if (fb->buf != MAP_FAILED)
			return(1);
	}
#endif
d137 2
a138 29
	/*
	 * If this isn't a regular file (like, say, stdin), then we must
	 * go the old way and just read things in bit by bit.
	 */

	*with_mmap = 0;
	off = 0;
	fb->sz = 0;
	fb->buf = NULL;
	for (;;) {
		if (off == fb->sz && fb->sz == (1U << 31)) {
			fprintf(stderr, "%s: input too large\n", f);
			break;
		} 
		
		if (off == fb->sz)
			resize_buf(fb, 65536);

		ssz = read(fd, fb->buf + (int)off, fb->sz - off);
		if (ssz == 0) {
			fb->sz = off;
			return(1);
		}
		if (ssz == -1) {
			perror(f);
			break;
		}
		off += (size_t)ssz;
	}
d140 2
a141 3
	free(fb->buf);
	fb->buf = NULL;
	return(0);
d144 2
a145 2
static int
cue_enc(const struct buf *b, size_t *offs, enum enc *enc)
d148 1
a148 2
	size_t		 sz, phsz, nsz;
	int		 i;
d150 2
a151 2
	ln = b->buf + (int)*offs;
	sz = b->sz - *offs;
d156 1
a156 5
		return(-1);

	/* Set next-line marker. */

	*offs = (size_t)((eoln + 1) - b->buf);
d163 1
a163 1
		return(0);
d187 2
a188 2
		if ((phsz = (size_t)(eoph - ln)) < 7 ||
				strncasecmp(ln, "coding:", 7)) {
d202 1
a202 1
			break;
d206 5
a210 15
		for (i = 0; i < (int)ENC__MAX; i++) {
			nsz = strlen(encs[i].name);
			if (phsz < nsz)
				continue;
			if (strncasecmp(ln, encs[i].name, nsz))
				continue;

			*enc = (enum enc)i;
			return(1);
		}

		/* Unknown encoding. */

		*enc = ENC__MAX;
		return(1);
d212 1
a212 129

	return(0);
}

int
main(int argc, char *argv[])
{
	int	 	 i, ch, map, fd, rc;
	struct buf	 b;
	const char	*fn;
	enum enc	 enc, def;
	unsigned char 	 bom[3] = { 0xEF, 0xBB, 0xBF };
	size_t		 offs;
	extern int	 optind;
	extern char	*optarg;

	progname = strrchr(argv[0], '/');
	if (progname == NULL)
		progname = argv[0];
	else
		++progname;

	fn = "<stdin>";
	fd = STDIN_FILENO;
	rc = EXIT_FAILURE;
	enc = def = ENC__MAX;
	map = 0;

	memset(&b, 0, sizeof(struct buf));

	while (-1 != (ch = getopt(argc, argv, "D:e:rdvh")))
		switch (ch) {
		case ('D'):
			/* FALLTHROUGH */
		case ('e'):
			for (i = 0; i < (int)ENC__MAX; i++) {
				if (strcasecmp(optarg, encs[i].name))
					continue;
				break;
			}
			if (i < (int)ENC__MAX) {
				if ('D' == ch)
					def = (enum enc)i;
				else
					enc = (enum enc)i;
				break;
			}

			fprintf(stderr, "%s: Bad encoding\n", optarg);
			return(EXIT_FAILURE);
		case ('r'):
			/* FALLTHROUGH */
		case ('d'):
			/* FALLTHROUGH */
		case ('v'):
			/* Compatibility with GNU preconv. */
			break;
		case ('h'):
			/* Compatibility with GNU preconv. */
			/* FALLTHROUGH */
		default:
			usage();
			return(EXIT_FAILURE);
		}

	argc -= optind;
	argv += optind;
	
	/* 
	 * Open and read the first argument on the command-line.
	 * If we don't have one, we default to stdin.
	 */

	if (argc > 0) {
		fn = *argv;
		fd = open(fn, O_RDONLY, 0);
		if (-1 == fd) {
			perror(fn);
			return(EXIT_FAILURE);
		}
	}

	if ( ! read_whole_file(fn, fd, &b, &map))
		goto out;

	/* Try to read the UTF-8 BOM. */

	if (ENC__MAX == enc)
		if (b.sz > 3 && 0 == memcmp(b.buf, bom, 3)) {
			b.offs = 3;
			enc = ENC_UTF_8;
		}

	/* Try reading from the "-*-" cue. */

	if (ENC__MAX == enc) {
		offs = b.offs;
		ch = cue_enc(&b, &offs, &enc);
		if (0 == ch)
			ch = cue_enc(&b, &offs, &enc);
	}

	/*
	 * No encoding has been detected.
	 * Thus, we either fall into our default encoder, if specified,
	 * or use Latin-1 if all else fails.
	 */

	if (ENC__MAX == enc) 
		enc = ENC__MAX == def ? ENC_LATIN_1 : def;

	if ( ! (*encs[(int)enc].conv)(&b)) {
		fprintf(stderr, "%s: Bad encoding\n", fn);
		goto out;
	}

	rc = EXIT_SUCCESS;
out:
#if HAVE_MMAP
	if (map)
		munmap(b.buf, b.sz);
	else 
#endif
		free(b.buf);

	if (fd > STDIN_FILENO)
		close(fd);

	return(rc);
@


1.7
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.6 2013/06/02 03:52:21 schwarze Exp $ */
d20 1
a20 1
#ifdef HAVE_MMAP
d247 1
a247 1
#ifdef	HAVE_MMAP
d511 1
a511 1
#ifdef	HAVE_MMAP
@


1.6
log
@Sync to OpenBSD, no functional change:
* Add the missing mparse_parse_buffer prototype.
* Drop the useless MAP_FILE constant: It's not specified in POSIX,
  so it's not required, it's the default anyway, and it's 0 anyway.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.5 2011/07/24 18:15:14 kristaps Exp $ */
a16 1
#ifdef HAVE_CONFIG_H
a17 1
#endif
d19 1
@


1.5
log
@Scary-looking but otherwise harmless changes allow me to build for Windows.
That is to say, with mingw32.  This amounts to the following:

 (1) break compat.c into compat_strlcpy.c and compat_strlcat.c
 (2) add compat_getsubopt.c (from OpenBSD) and test-getsubopt.c
 (3) add test-strptime.c for HAVE_STRPTIME
 (4) add ifdef bits here and there, where necessary
 (5) remove some harmless unportable stuff (u_char, localtime_r)

I've added the appropriate mdocml.zip target to the Makefile, too.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.4 2011/05/26 21:13:07 kristaps Exp $ */
d35 1
a35 1
 * read.c, including all dependency code (MAP_FILE, etc.).
a37 4
#ifndef MAP_FILE
#define	MAP_FILE	0
#endif

d270 1
a270 2
		fb->buf = mmap(NULL, fb->sz, PROT_READ, 
				MAP_FILE|MAP_SHARED, fd, 0);
@


1.4
log
@Some small lint checks in preconv.  Also add it to the default lint rule.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.3 2011/05/26 14:43:07 kristaps Exp $ */
d21 1
d24 1
a248 1
	struct stat	 st;
d252 2
d279 1
d517 1
d521 1
@


1.3
log
@preconv is now on encoding-recognition parity with groff.  This last
commit adds parsing of "File Variables" in the first two lines in order
to grok the encoding.  This completes groff's recognition sequence (-e,
BOM, File variables, -D, default).  I've also cleaned up the manual to
indicate this and for some general readability.

preconv is now compiled by default in the Makefile.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.2 2011/05/26 12:01:14 kristaps Exp $ */
d140 1
a140 1
	if ( ! (*((char *)(&one))))
d379 1
a379 1
		for (i = 0; i < ENC__MAX; i++) {
d406 1
a406 1
	const char	 bom[3] = { 0xEF, 0xBB, 0xBF };
d430 1
a430 1
			for (i = 0; i < ENC__MAX; i++) {
d435 1
a435 1
			if (i < ENC__MAX) {
@


1.2
log
@Significantly improve preconv.  Allow it to recode UTF-8 characters into
the \[uNNNN] strings (taking into account big-endian archs).  Also allow
it to determine from the BOM whether it's a UTF-8 file.  Also add the
initial manual.  This has been tested over a random selection of UTF-8
documents, as

 % preconv -e utf-8 foo.1 | ./mandoc -Tlocale

where -Tlocale is allowed (-DUSE_WCHAR).

Note that we're still missing the "type" indicator that preconv accepts.
@
text
@d1 1
a1 1
/*	$Id: preconv.c,v 1.1 2011/05/26 00:30:11 kristaps Exp $ */
d58 1
d98 2
d104 1
a104 1
		cu < 128U ? putchar(cu) : printf("\\[u%.4X]", cu);
d312 87
d407 1
d488 9
d506 2
a507 1
	if ( ! (*encs[(int)enc].conv)(&b)) 
d509 1
@


1.1
log
@It's annoying that we don't have preconv, so throw together a quick
version and let it grow in-tree.  Right now, this only supports the
Latin-1 and US-ASCII encoding.  I'll do UTF-8 next.  It's
call-compatible with GNU's preconv although I don't do fancy stuff like
BOM or header check.  This will come.  I used read.c's file-grokking
code.
@
text
@d1 1
a1 1
/*	$Id: read.c,v 1.14 2011/04/30 10:18:24 kristaps Exp $ */
d88 1
a88 1
	unsigned char	 c;
d100 2
a101 2
		c = (unsigned char)*cp++;
		c < 128 ? putchar(c) : printf("\\[u%.4X]", c);
d123 99
d313 1
a313 1
	struct buf	 buf;
d316 1
d332 1
a332 1
	memset(&buf, 0, sizeof(struct buf));
d386 1
a386 1
	if ( ! read_whole_file(fn, fd, &buf, &map))
d389 7
a395 3
	if (ENC__MAX == enc) {
		/* TODO: search for BOM. */
	}
d406 1
a406 1
	if ( ! (*encs[(int)enc].conv)(&buf))
d412 1
a412 1
		munmap(buf.buf, buf.sz);
d414 1
a414 1
		free(buf.buf);
@
