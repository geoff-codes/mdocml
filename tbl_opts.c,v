head	1.21;
access;
symbols
	VERSION_1_13_3:1.20
	VERSION_1_13_2:1.15
	VERSION_1_12_4:1.14
	VERSION_1_13_1:1.13
	VERSION_1_12_3:1.12
	VERSION_1_12_2:1.12
	VERSION_1_12:1.14.0.2
	VERSION_1_12_1:1.12
	VERSION_1_12_0:1.12
	VERSION_1_11_7:1.11
	VERSION_1_11_6:1.11
	VERSION_1_11_5:1.11
	VERSION_1_11_4:1.11
	VERSION_1_11_3:1.11
	VERSION_1_11_2:1.11
	VERSION_1_11_1:1.10
	VERSION_1_10_10:1.9
	VERSION_1_10_9:1.7;
locks; strict;
comment	@ * @;


1.21
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.20;

1.20
date	2015.01.28.17.32.07;	author schwarze;	state Exp;
branches;
next	1.19;

1.19
date	2015.01.28.15.03.45;	author schwarze;	state Exp;
branches;
next	1.18;

1.18
date	2015.01.26.13.03.48;	author schwarze;	state Exp;
branches;
next	1.17;

1.17
date	2015.01.26.00.57.22;	author schwarze;	state Exp;
branches;
next	1.16;

1.16
date	2015.01.14.22.44.55;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2014.11.26.17.51.55;	author schwarze;	state Exp;
branches;
next	1.14;

1.14
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.13;

1.13
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2011.09.18.14.14.15;	author schwarze;	state Exp;
branches;
next	1.11;

1.11
date	2011.04.04.23.04.38;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2011.03.20.16.02.05;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.09.05.38.23;	author joerg;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.07.13.20.58;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2011.01.06.13.45.47;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2011.01.02.10.10.57;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2010.12.29.14.38.14;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2010.12.29.01.16.57;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.28.13.47.38;	author kristaps;	state Exp;
branches;
next	1.1;

1.1
date	2010.12.28.13.46.07;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.21
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@/*	$Id: tbl_opts.c,v 1.20 2015/01/28 17:32:07 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mandoc.h"
#include "libmandoc.h"
#include "libroff.h"

#define	KEY_DPOINT	0
#define	KEY_DELIM	1
#define	KEY_LINESIZE	2
#define	KEY_TAB		3

struct	tbl_phrase {
	const char	*name;
	int		 key;
};

static	const struct tbl_phrase keys[] = {
	{"decimalpoint", 0},
	{"delim",	 0},
	{"linesize",	 0},
	{"tab",		 0},
	{"allbox",	 TBL_OPT_ALLBOX | TBL_OPT_BOX},
	{"box",		 TBL_OPT_BOX},
	{"frame",	 TBL_OPT_BOX},
	{"center",	 TBL_OPT_CENTRE},
	{"centre",	 TBL_OPT_CENTRE},
	{"doublebox",	 TBL_OPT_DBOX},
	{"doubleframe",  TBL_OPT_DBOX},
	{"expand",	 TBL_OPT_EXPAND},
	{"nokeep",	 TBL_OPT_NOKEEP},
	{"nospaces",	 TBL_OPT_NOSPACE},
	{"nowarn",	 TBL_OPT_NOWARN},
};

#define KEY_MAXKEYS ((int)(sizeof(keys)/sizeof(keys[0])))

static	void	 arg(struct tbl_node *, int, const char *, int *, int);


static void
arg(struct tbl_node *tbl, int ln, const char *p, int *pos, int key)
{
	int		 len, want;

	while (p[*pos] == ' ' || p[*pos] == '\t')
		(*pos)++;

	/* Arguments are enclosed in parentheses. */

	len = 0;
	if (p[*pos] == '(') {
		(*pos)++;
		while (p[*pos + len] != ')')
			len++;
	}

	switch (key) {
	case KEY_DELIM:
		mandoc_vmsg(MANDOCERR_TBLOPT_EQN, tbl->parse,
		    ln, *pos, "%.*s", len, p + *pos);
		want = 2;
		break;
	case KEY_TAB:
		want = 1;
		if (len == want)
			tbl->opts.tab = p[*pos];
		break;
	case KEY_LINESIZE:
		want = 0;
		break;
	case KEY_DPOINT:
		want = 1;
		if (len == want)
			tbl->opts.decimal = p[*pos];
		break;
	default:
		abort();
	}

	if (len == 0)
		mandoc_msg(MANDOCERR_TBLOPT_NOARG,
		    tbl->parse, ln, *pos, keys[key].name);
	else if (want && len != want)
		mandoc_vmsg(MANDOCERR_TBLOPT_ARGSZ,
		    tbl->parse, ln, *pos, "%s want %d have %d",
		    keys[key].name, want, len);

	*pos += len;
	if (p[*pos] == ')')
		(*pos)++;
}

/*
 * Parse one line of options up to the semicolon.
 * Each option can be preceded by blanks and/or commas,
 * and some options are followed by arguments.
 */
void
tbl_option(struct tbl_node *tbl, int ln, const char *p, int *offs)
{
	int		 i, pos, len;

	pos = *offs;
	for (;;) {
		while (p[pos] == ' ' || p[pos] == '\t' || p[pos] == ',')
			pos++;

		if (p[pos] == ';') {
			*offs = pos + 1;
			return;
		}

		/* Parse one option name. */

		len = 0;
		while (isalpha((unsigned char)p[pos + len]))
			len++;

		if (len == 0) {
			mandoc_vmsg(MANDOCERR_TBLOPT_ALPHA,
			    tbl->parse, ln, pos, "%c", p[pos]);
			pos++;
			continue;
		}

		/* Look up the option name. */

		i = 0;
		while (i < KEY_MAXKEYS &&
		    (strncasecmp(p + pos, keys[i].name, len) ||
		     keys[i].name[len] != '\0'))
			i++;

		if (i == KEY_MAXKEYS) {
			mandoc_vmsg(MANDOCERR_TBLOPT_BAD, tbl->parse,
			    ln, pos, "%.*s", len, p + pos);
			pos += len;
			continue;
		}

		/* Handle the option. */

		pos += len;
		if (keys[i].key)
			tbl->opts.opts |= keys[i].key;
		else
			arg(tbl, ln, p, &pos, i);
	}
}
@


1.20
log
@* Polish tbl(7) error reporting.
* Do not print out macro names in tbl(7) data blocks.
* Like with GNU tbl, let empty tables cause a blank line.
* Avoid producing empty tables in -Tman.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.19 2015/01/28 15:03:45 schwarze Exp $ */
a101 1
		/* NOTREACHED */
@


1.19
log
@For now, it can't be helped that mandoc tbl(7) ignores high-level macros,
but stop throwing away their arguments.  This fixes information loss in a
handful of Xenocara manuals, at the price of a small amount of formatting
noise creeping through.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.18 2015/01/26 13:03:48 schwarze Exp $ */
d83 2
a84 1
		mandoc_msg(MANDOCERR_TBLEQN, tbl->parse, ln, *pos, NULL);
@


1.18
log
@More improvements regarding tbl(7) options.
* Treat "allbox" as an alias for "box" for now.
* Parse and ignore the GNU tbl "nowarn" option.
* For separation, allow spaces, tabs, and commas only.
* Mark eqn(7) within tbl(7) as unsupported.
* Simplify the option table.
* Improve and sort documentation.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.17 2015/01/26 00:57:22 schwarze Exp $ */
d123 1
a123 1
tbl_option(struct tbl_node *tbl, int ln, const char *p)
d127 1
a127 1
	pos = 0;
d132 2
a133 1
		if (p[pos] == ';')
d135 1
@


1.17
log
@Improve (or rather, rewrite) tbl(7) option parsing.
* Allow the layout to start after the semicolon on the options line.
* Ignore leading commas.
* Option arguments cannot contain closing parentheses.
* Avoid needless UNSUPP messages.
* Better ERROR reporting.
* Delete unused "linesize" field in struct tbl_opts.
* No need for static buffers.
* Garbage collect one almost empty wrapper function.
Improved functionality, but minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.16 2015/01/14 22:44:55 schwarze Exp $ */
d31 4
a34 16
enum	tbl_ident {
	KEY_CENTRE = 0,
	KEY_DELIM,
	KEY_EXPAND,
	KEY_BOX,
	KEY_DBOX,
	KEY_ALLBOX,
	KEY_TAB,
	KEY_LINESIZE,
	KEY_NOKEEP,
	KEY_DPOINT,
	KEY_NOSPACE,
	KEY_FRAME,
	KEY_DFRAME,
	KEY_MAX
};
a38 1
	enum tbl_ident	 ident;
d41 17
a57 2
/* Handle Commonwealth/American spellings. */
#define	KEY_MAXKEYS	 14
d59 1
a59 16
static	const struct tbl_phrase keys[KEY_MAXKEYS] = {
	{ "center",	 TBL_OPT_CENTRE,	KEY_CENTRE},
	{ "centre",	 TBL_OPT_CENTRE,	KEY_CENTRE},
	{ "delim",	 0,			KEY_DELIM},
	{ "expand",	 TBL_OPT_EXPAND,	KEY_EXPAND},
	{ "box",	 TBL_OPT_BOX,		KEY_BOX},
	{ "doublebox",	 TBL_OPT_DBOX,		KEY_DBOX},
	{ "allbox",	 TBL_OPT_ALLBOX,	KEY_ALLBOX},
	{ "frame",	 TBL_OPT_BOX,		KEY_FRAME},
	{ "doubleframe", TBL_OPT_DBOX,		KEY_DFRAME},
	{ "tab",	 0,			KEY_TAB},
	{ "linesize",	 0,			KEY_LINESIZE},
	{ "nokeep",	 TBL_OPT_NOKEEP,	KEY_NOKEEP},
	{ "decimalpoint", 0,			KEY_DPOINT},
	{ "nospaces",	 TBL_OPT_NOSPACE,	KEY_NOSPACE},
};
d61 1
a61 2
static	void		 arg(struct tbl_node *, int,
				const char *, int *, enum tbl_ident);
d65 1
a65 1
arg(struct tbl_node *tbl, int ln, const char *p, int *pos, enum tbl_ident key)
a66 1
	const char	*optname;
d69 1
a69 1
	while (isspace((unsigned char)p[*pos]))
d83 1
a83 1
		optname = "delim";
a86 1
		optname = "tab";
a91 1
		optname = "linesize";
a94 1
		optname = "decimalpoint";
d106 1
a106 1
		    tbl->parse, ln, *pos, optname);
d109 2
a110 2
		    tbl->parse, ln, *pos,
		    "%s want %d have %d", optname, want, len);
d129 1
a129 1
		while (isspace((unsigned char)p[pos]) || p[pos] == ',')
d169 1
a169 1
			arg(tbl, ln, p, &pos, keys[i].ident);
@


1.16
log
@simplify by getting rid of ROFF_ERR in tbl(7) parsing; no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.15 2014/11/26 17:51:55 schwarze Exp $ */
d4 1
a56 6
/* Maximum length of key name string. */
#define	KEY_MAXNAME	 13

/* Maximum length of key number size. */
#define	KEY_MAXNUMSZ	 10

d74 1
a74 1
static	int		 arg(struct tbl_node *, int,
a75 2
static	void		 opt(struct tbl_node *, int,
				const char *, int *);
d78 1
a78 1
static int
d81 2
a82 2
	int		 i;
	char		 buf[KEY_MAXNUMSZ];
d87 1
a87 1
	/* Arguments always begin with a parenthesis. */
d89 5
a93 4
	if ('(' != p[*pos]) {
		mandoc_msg(MANDOCERR_TBL, tbl->parse,
		    ln, *pos, NULL);
		return(0);
a95 8
	(*pos)++;

	/*
	 * The arguments can be ANY value, so we can't just stop at the
	 * next close parenthesis (the argument can be a closed
	 * parenthesis itself).
	 */

d98 2
a99 11
		if ('\0' == p[(*pos)++]) {
			mandoc_msg(MANDOCERR_TBL, tbl->parse,
			    ln, *pos - 1, NULL);
			return(0);
		}

		if ('\0' == p[(*pos)++]) {
			mandoc_msg(MANDOCERR_TBL, tbl->parse,
			    ln, *pos - 1, NULL);
			return(0);
		}
d102 5
a106 6
		if ('\0' != (tbl->opts.tab = p[(*pos)++]))
			break;

		mandoc_msg(MANDOCERR_TBL, tbl->parse,
		    ln, *pos - 1, NULL);
		return(0);
d108 3
a110 14
		for (i = 0; i < KEY_MAXNUMSZ && p[*pos]; i++, (*pos)++) {
			buf[i] = p[*pos];
			if ( ! isdigit((unsigned char)buf[i]))
				break;
		}

		if (i < KEY_MAXNUMSZ) {
			buf[i] = '\0';
			tbl->opts.linesize = atoi(buf);
			break;
		}

		mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, *pos, NULL);
		return(0);
d112 5
a116 6
		if ('\0' != (tbl->opts.decimal = p[(*pos)++]))
			break;

		mandoc_msg(MANDOCERR_TBL, tbl->parse,
		    ln, *pos - 1, NULL);
		return(0);
d122 7
a128 1
	/* End with a close parenthesis. */
d130 3
a132 5
	if (')' == p[(*pos)++])
		return(1);

	mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, *pos - 1, NULL);
	return(0);
d135 7
a141 2
static void
opt(struct tbl_node *tbl, int ln, const char *p, int *pos)
d143 1
a143 2
	int		 i, sv;
	char		 buf[KEY_MAXNAME];
d145 4
a148 17
	/*
	 * Parse individual options from the stream as surrounded by
	 * this goto.  Each pass through the routine parses out a single
	 * option and registers it.  Option arguments are processed in
	 * the arg() function.
	 */

again:	/*
	 * EBNF describing this section:
	 *
	 * options	::= option_list [:space:]* [;][\n]
	 * option_list	::= option option_tail
	 * option_tail	::= [,:space:]+ option_list |
	 *		::= epsilon
	 * option	::= [:alpha:]+ args
	 * args		::= [:space:]* [(] [:alpha:]+ [)]
	 */
d150 2
a151 2
	while (isspace((unsigned char)p[*pos]))
		(*pos)++;
d153 1
a153 1
	/* Safe exit point. */
d155 10
a164 12
	if (';' == p[*pos])
		return;

	/* Copy up to first non-alpha character. */

	for (sv = *pos, i = 0; i < KEY_MAXNAME; i++, (*pos)++) {
		buf[i] = (char)tolower((unsigned char)p[*pos]);
		if ( ! isalpha((unsigned char)buf[i]))
			break;
	}

	/* Exit if buffer is empty (or overrun). */
d166 1
a166 9
	if (KEY_MAXNAME == i || 0 == i) {
		mandoc_msg(MANDOCERR_TBL, tbl->parse, ln, *pos, NULL);
		return;
	}

	buf[i] = '\0';

	while (isspace((unsigned char)p[*pos]) || p[*pos] == ',')
		(*pos)++;
d168 10
a177 7
	/*
	 * Look through all of the available keys to find one that
	 * matches the input.  FIXME: hashtable this.
	 */

	for (i = 0; i < KEY_MAXKEYS; i++) {
		if (strcmp(buf, keys[i].name))
d179 1
d181 1
a181 6
		/*
		 * Note: this is more difficult to recover from, as we
		 * can be anywhere in the option sequence and it's
		 * harder to jump to the next.  Meanwhile, just bail out
		 * of the sequence altogether.
		 */
d183 1
d186 2
a187 4
		else if ( ! arg(tbl, ln, p, pos, keys[i].ident))
			return;

		break;
a188 26

	/*
	 * Allow us to recover from bad options by continuing to another
	 * parse sequence.
	 */

	if (KEY_MAXKEYS == i)
		mandoc_msg(MANDOCERR_TBLOPT, tbl->parse, ln, sv, NULL);

	goto again;
	/* NOTREACHED */
}

void
tbl_option(struct tbl_node *tbl, int ln, const char *p)
{
	int		 pos;

	/*
	 * Table options are always on just one line, so automatically
	 * switch into the next input mode here.
	 */
	tbl->part = TBL_PART_LAYOUT;

	pos = 0;
	opt(tbl, ln, p, &pos);
@


1.15
log
@Allow comma-separated options in tbl(7) tables.
Provides better groff compatibility.
From bentley@@.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.14 2014/08/10 23:54:41 schwarze Exp $ */
d255 1
a255 1
int
a267 3

	/* Always succeed. */
	return(1);
@


1.14
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.13 2014/04/20 16:46:05 schwarze Exp $ */
d185 1
a185 1
	 * option_tail	::= [:space:]+ option_list |
d216 1
a216 1
	while (isspace((unsigned char)p[*pos]))
@


1.13
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.12 2011/09/18 14:14:15 schwarze Exp $ */
a16 1
#ifdef HAVE_CONFIG_H
d18 2
a19 1
#endif
@


1.12
log
@forgotten Copyright bumps; no code change
found while syncing to OpenBSD
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.11 2011/04/04 23:04:38 kristaps Exp $ */
d65 1
a65 1
	{ "delim",	 0,	       		KEY_DELIM},
d67 2
a68 2
	{ "box",	 TBL_OPT_BOX,   	KEY_BOX},
	{ "doublebox",	 TBL_OPT_DBOX,  	KEY_DBOX},
d79 1
a79 1
static	int		 arg(struct tbl_node *, int, 
d81 1
a81 1
static	void		 opt(struct tbl_node *, int, 
d84 1
d97 2
a98 2
		mandoc_msg(MANDOCERR_TBL, tbl->parse, 
				ln, *pos, NULL);
d111 1
a111 1
	case (KEY_DELIM):
d114 1
a114 1
					ln, *pos - 1, NULL);
d116 1
a116 1
		} 
d120 1
a120 1
					ln, *pos - 1, NULL);
d122 1
a122 1
		} 
d124 1
a124 1
	case (KEY_TAB):
d129 1
a129 1
				ln, *pos - 1, NULL);
d131 1
a131 1
	case (KEY_LINESIZE):
d146 1
a146 1
	case (KEY_DPOINT):
d150 2
a151 2
		mandoc_msg(MANDOCERR_TBL, tbl->parse, 
				ln, *pos - 1, NULL);
d186 1
a186 1
	 * 		::= epsilon
d219 1
a219 1
	/* 
d235 1
a235 1
		if (keys[i].key) 
d243 1
a243 1
	/* 
@


1.11
log
@Add config.h Glue for OpenIndiana (and older OpenSolaris) to build.
From a patch by Yuri Pankov, thanks!
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.10 2011/03/20 16:02:05 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
@


1.10
log
@Consolidate messages.  Have all parse-time messages (in libmdoc,
libroff, etc., etc.) route into mandoc_msg() and mandoc_vmsg(), for the
time being in libmandoc.h.  This requires struct mparse to be passed
into the allocation routines instead of mandocmsg and a void pointer.
Then, move some of the functionality of the old mmsg() into read.c's
mparse_mmsg() (check against wlevel and setting of file_status) and use
main.c's mmsg() as simply a printing tool.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.9 2011/03/15 16:23:51 kristaps Exp $ */
d17 4
@


1.9
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.8 2011/01/09 05:38:23 joerg Exp $ */
d23 1
d92 2
a93 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos);
d108 2
a109 1
			TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d114 2
a115 1
			TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d123 2
a124 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d139 1
a139 1
		(*tbl->msg)(MANDOCERR_TBL, tbl->data, ln, *pos, NULL);
d145 2
a146 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d158 1
a158 1
	TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos - 1);
d205 1
a205 1
		TBL_MSG(tbl, MANDOCERR_TBL, ln, *pos);
d244 1
a244 1
		TBL_MSG(tbl, MANDOCERR_TBLOPT, ln, sv);
@


1.8
log
@Add some unsigned char casts for tolower() usage
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.7 2011/01/07 13:20:58 kristaps Exp $ */
d191 1
a191 1
		buf[i] = tolower((unsigned char)p[*pos]);
@


1.7
log
@Quiesce lint with some type handling.  Does not change anything.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.6 2011/01/06 13:45:47 kristaps Exp $ */
d191 1
a191 1
		buf[i] = tolower(p[*pos]);
@


1.6
log
@Remove delims from struct tbl (not used anywhere and never will be).
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.5 2011/01/02 10:10:57 kristaps Exp $ */
d75 1
a75 1
				const char *, int *, int);
d80 1
a80 1
arg(struct tbl_node *tbl, int ln, const char *p, int *pos, int key)
@


1.5
log
@Churn to get parts of 'struct tbl' visible from mandoc.h: rename the
existing 'struct tbl' as 'struct tbl_node', then move all option stuff
into a 'struct tbl' in mandoc.h.

This conflicted with a structure in chars.c, which was renamed.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.4 2010/12/29 14:38:14 kristaps Exp $ */
d105 1
a105 1
		if ('\0' == (tbl->opts.delims[0] = p[(*pos)++])) {
d110 1
a110 1
		if ('\0' == (tbl->opts.delims[1] = p[(*pos)++])) {
@


1.4
log
@Merge, with considerable changes, tbl.bsd.lv's layout-handling code.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.3 2010/12/29 01:16:57 kristaps Exp $ */
d74 4
a77 2
static	int		 arg(struct tbl *, int, const char *, int *, int);
static	void		 opt(struct tbl *, int, const char *, int *);
d80 1
a80 1
arg(struct tbl *tbl, int ln, const char *p, int *pos, int key)
d105 1
a105 1
		if ('\0' == (tbl->delims[0] = p[(*pos)++])) {
d110 1
a110 1
		if ('\0' == (tbl->delims[1] = p[(*pos)++])) {
d116 1
a116 1
		if ('\0' != (tbl->tab = p[(*pos)++]))
d130 1
a130 1
			tbl->linesize = atoi(buf);
d137 1
a137 1
		if ('\0' != (tbl->decimal = p[(*pos)++]))
d157 1
a157 1
opt(struct tbl *tbl, int ln, const char *p, int *pos)
d225 1
a225 1
			tbl->opts |= keys[i].key;
d245 1
a245 1
tbl_option(struct tbl *tbl, int ln, const char *p)
@


1.3
log
@Significant update to options handling, which now departs almost
completely with the BSD.lv code due to performance issues and flat-out
errors.

Performance issues: functions called per character.  Ugly.

Flat-out errors: disallowing "reserved" tokens as arguments to those
options accepting arguments.

Also added are two mandoc.h error codes for general tbl syntax errors
and for bad options.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.2 2010/12/28 13:47:38 kristaps Exp $ */
a237 2
	/* Try again... */

d239 1
@


1.2
log
@Fix copyright email.
@
text
@d1 1
a1 1
/*	$Id: tbl_opts.c,v 1.1 2010/12/28 13:46:07 kristaps Exp $ */
d17 1
d22 1
d51 6
d75 1
a75 1
static	int		 opt(struct tbl *, int, const char *, int *);
d80 2
a81 1
	int		 sv;
d83 2
a84 2
again:
	sv = *pos;
d86 4
a89 8
	switch (tbl_next(tbl, p, pos)) {
	case (TBL_TOK_OPENPAREN):
		break;
	case (TBL_TOK_SPACE):
		/* FALLTHROUGH */
	case (TBL_TOK_TAB):
		goto again;
	default:
d93 1
a93 1
	sv = *pos;
d95 5
a99 6
	switch (tbl_next(tbl, p, pos)) {
	case (TBL_TOK__MAX):
		break;
	default:
		return(0);
	}
d103 7
a109 2
		/* FIXME: cache this value. */
		if (2 != strlen(tbl->buf))
d111 1
a111 2
		tbl->delims[0] = tbl->buf[0];
		tbl->delims[1] = tbl->buf[1];
d114 5
a118 5
		/* FIXME: cache this value. */
		if (1 != strlen(tbl->buf))
			return(0);
		tbl->tab = tbl->buf[0];
		break;
d120 14
a133 3
		if ((tbl->linesize = atoi(tbl->buf)) <= 0)
			return(0);
		break;
d135 5
a139 5
		/* FIXME: cache this value. */
		if (1 != strlen(tbl->buf))
			return(0);
		tbl->decimal = tbl->buf[0];
		break;
d142 1
d145 1
a145 1
	sv = *pos;
d147 2
a148 6
	switch (tbl_next(tbl, p, pos)) {
	case (TBL_TOK_CLOSEPAREN):
		break;
	default:
		return(0);
	}
d150 2
a151 1
	return(1);
d154 1
a154 2

static int
d158 1
d160 6
a165 2
again:
	sv = *pos;
d167 1
a167 1
	/*
d178 21
a198 12
	switch (tbl_next(tbl, p, pos)) {
	case (TBL_TOK__MAX):
		break;
	case (TBL_TOK_SPACE):
		/* FALLTHROUGH */
	case (TBL_TOK_TAB):
		goto again;
	case (TBL_TOK_SEMICOLON):
		tbl->part = TBL_PART_LAYOUT;
		return(1);
	default:
		return(0);
d201 10
d212 1
a212 2
		/* FIXME: hashtable this? */
		if (strcasecmp(tbl->buf, keys[i].name))
d214 8
d225 1
a225 1
			return(0);
d230 5
d236 3
a238 1
		return(0);
d240 1
a240 1
	return(opt(tbl, ln, p, pos));
d248 6
d255 4
a258 1
	return(opt(tbl, ln, p, &pos));
@


1.1
log
@Adding initial options processing (not hooked into parse yet).  This is
more or less copied from tbl.bsd.lv and still needs integration with the
general mandoc framework, e.g., with error messages.
@
text
@d1 1
a1 1
/*	$Id: option.c,v 1.5 2009/09/09 12:51:34 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
@
