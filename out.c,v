head	1.62;
access;
symbols
	VERSION_1_13_3:1.59
	VERSION_1_13_2:1.54
	VERSION_1_12_4:1.51
	VERSION_1_13_1:1.49
	VERSION_1_12_3:1.46
	VERSION_1_12_2:1.45
	VERSION_1_12:1.51.0.2
	VERSION_1_12_1:1.43
	VERSION_1_12_0:1.43
	VERSION_1_11_7:1.42
	VERSION_1_11_6:1.42
	VERSION_1_11_5:1.42
	VERSION_1_11_4:1.40
	VERSION_1_11_3:1.40
	VERSION_1_11_2:1.40
	VERSION_1_11_1:1.39
	VERSION_1_10_10:1.39
	VERSION_1_10_9:1.30
	VERSION_1_10_8:1.29
	VERSION_1_10_7:1.29
	VERSION_1_10_6:1.29
	VERSION_1_10_5:1.23
	VERSION_1_10_5_PREPDF:1.23
	VERSION_1_10_4:1.17
	VERSION_1_10_3:1.17
	VERSION_1_10_2:1.16
	VERSION_1_10_1:1.15
	VERSION_1_9_24:1.15
	VERSION_1_9_25:1.15
	VERSION_1_9_23:1.15
	VERSION_1_9_22:1.12
	VERSION_1_9_21:1.12
	VERSION_1_9_20:1.12
	VERSION_1_9_19:1.12
	VERSION_1_9_18:1.12
	VERSION_1_9_17:1.12
	VERSION_1_9_16:1.12
	VERSION_1_9_15:1.12
	VERSION_1_9_15-pre2:1.12
	VERSION_1_9_15-pre1:1.11
	VERSION_1_9_14:1.11
	VERSION_1_9_13:1.7
	VERSION_1_9_12:1.7
	VERSION_1_9_11:1.7
	VERSION_1_9_10:1.7
	VERSION_1_9_9:1.5
	VERSION_1_9_8:1.4
	VERSION_1_9_7:1.4
	VERSION_1_9_5:1.2;
locks; strict;
comment	@ * @;


1.62
date	2015.10.12.00.08.16;	author schwarze;	state Exp;
branches;
next	1.61;

1.61
date	2015.10.06.18.32.19;	author schwarze;	state Exp;
branches;
next	1.60;

1.60
date	2015.09.26.00.54.04;	author schwarze;	state Exp;
branches;
next	1.59;

1.59
date	2015.01.30.04.11.50;	author schwarze;	state Exp;
branches;
next	1.58;

1.58
date	2015.01.28.02.23.49;	author schwarze;	state Exp;
branches;
next	1.57;

1.57
date	2014.12.23.13.48.57;	author schwarze;	state Exp;
branches;
next	1.56;

1.56
date	2014.12.23.09.31.46;	author schwarze;	state Exp;
branches;
next	1.55;

1.55
date	2014.12.23.03.28.01;	author schwarze;	state Exp;
branches;
next	1.54;

1.54
date	2014.12.04.02.05.42;	author schwarze;	state Exp;
branches;
next	1.53;

1.53
date	2014.10.14.18.18.05;	author schwarze;	state Exp;
branches;
next	1.52;

1.52
date	2014.10.14.02.16.06;	author schwarze;	state Exp;
branches;
next	1.51;

1.51
date	2014.08.12.19.28.16;	author schwarze;	state Exp;
branches;
next	1.50;

1.50
date	2014.08.10.23.54.41;	author schwarze;	state Exp;
branches;
next	1.49;

1.49
date	2014.08.01.19.25.52;	author schwarze;	state Exp;
branches;
next	1.48;

1.48
date	2014.04.20.16.46.05;	author schwarze;	state Exp;
branches;
next	1.47;

1.47
date	2014.03.23.11.25.26;	author schwarze;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.05.20.30.05;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.31.21.37.17;	author schwarze;	state Exp;
branches;
next	1.44;

1.44
date	2012.05.27.17.54.54;	author schwarze;	state Exp;
branches;
next	1.43;

1.43
date	2011.09.20.23.05.49;	author schwarze;	state Exp;
branches;
next	1.42;

1.42
date	2011.07.24.18.15.14;	author kristaps;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.17.15.24.25;	author kristaps;	state Exp;
branches;
next	1.40;

1.40
date	2011.04.09.15.29.40;	author kristaps;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.17.08.49.34;	author kristaps;	state Exp;
branches;
next	1.38;

1.38
date	2011.03.15.16.23.51;	author kristaps;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.30.16.05.37;	author schwarze;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.25.12.07.30;	author schwarze;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.11.14.12.01;	author kristaps;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.10.15.31.00;	author kristaps;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.10.14.40.30;	author kristaps;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.08.17.16.48;	author kristaps;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.08.17.00.27;	author kristaps;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.05.15.37.23;	author kristaps;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.29.11.28.09;	author kristaps;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.24.13.56.51;	author kristaps;	state Exp;
branches;
next	1.27;

1.27
date	2010.08.24.13.39.37;	author kristaps;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.24.13.07.01;	author kristaps;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.24.12.18.49;	author kristaps;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.16.09.37.58;	author kristaps;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.22.23.03.15;	author kristaps;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.22.14.03.50;	author kristaps;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.21.20.35.03;	author kristaps;	state Exp;
branches;
next	1.20;

1.20
date	2010.07.19.07.53.40;	author kristaps;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.18.23.06.18;	author kristaps;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.18.22.55.06;	author kristaps;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.25.19.50.23;	author kristaps;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.19.20.46.28;	author kristaps;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.07.11.29.55;	author kristaps;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.07.11.25.38;	author kristaps;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.07.07.49.38;	author kristaps;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.01.17.14.30;	author kristaps;	state Exp;
branches;
next	1.11;

1.11
date	2009.11.12.08.21.05;	author kristaps;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.08.09.23.35;	author kristaps;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.07.14.14.15;	author kristaps;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.07.08.26.45;	author kristaps;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.22.18.59.00;	author kristaps;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.22.18.55.32;	author kristaps;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.18.19.02.10;	author kristaps;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.09.06.54.11;	author kristaps;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.07.12.35.24;	author kristaps;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.21.13.06.13;	author kristaps;	state dead;
branches;
next	1.1;

1.1
date	2009.09.21.00.39.02;	author kristaps;	state Exp;
branches;
next	;


desc
@@


1.62
log
@To make the code more readable, delete 283 /* FALLTHROUGH */ comments
that were right between two adjacent case statement.  Keep only
those 24 where the first case actually executes some code before
falling through to the next case.
@
text
@/*	$Id: out.c,v 1.61 2015/10/06 18:32:19 schwarze Exp $ */
/*
 * Copyright (c) 2009, 2010, 2011 Kristaps Dzonsons <kristaps@@bsd.lv>
 * Copyright (c) 2011, 2014, 2015 Ingo Schwarze <schwarze@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include "config.h"

#include <sys/types.h>

#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include "mandoc_aux.h"
#include "mandoc.h"
#include "out.h"

static	void	tblcalc_data(struct rofftbl *, struct roffcol *,
			const struct tbl_opts *, const struct tbl_dat *);
static	void	tblcalc_literal(struct rofftbl *, struct roffcol *,
			const struct tbl_dat *);
static	void	tblcalc_number(struct rofftbl *, struct roffcol *,
			const struct tbl_opts *, const struct tbl_dat *);


/*
 * Parse the *src string and store a scaling unit into *dst.
 * If the string doesn't specify the unit, use the default.
 * If no default is specified, fail.
 * Return 2 on complete success, 1 when a conversion was done,
 * but there was trailing garbage, and 0 on total failure.
 */
int
a2roffsu(const char *src, struct roffsu *dst, enum roffscale def)
{
	char		*endptr;

	dst->unit = def == SCALE_MAX ? SCALE_BU : def;
	dst->scale = strtod(src, &endptr);
	if (endptr == src)
		return 0;

	switch (*endptr++) {
	case 'c':
		dst->unit = SCALE_CM;
		break;
	case 'i':
		dst->unit = SCALE_IN;
		break;
	case 'f':
		dst->unit = SCALE_FS;
		break;
	case 'M':
		dst->unit = SCALE_MM;
		break;
	case 'm':
		dst->unit = SCALE_EM;
		break;
	case 'n':
		dst->unit = SCALE_EN;
		break;
	case 'P':
		dst->unit = SCALE_PC;
		break;
	case 'p':
		dst->unit = SCALE_PT;
		break;
	case 'u':
		dst->unit = SCALE_BU;
		break;
	case 'v':
		dst->unit = SCALE_VS;
		break;
	case '\0':
		endptr--;
		/* FALLTHROUGH */
	default:
		if (SCALE_MAX == def)
			return 0;
		dst->unit = def;
		break;
	}

	return *endptr == '\0' ? 2 : 1;
}

/*
 * Calculate the abstract widths and decimal positions of columns in a
 * table.  This routine allocates the columns structures then runs over
 * all rows and cells in the table.  The function pointers in "tbl" are
 * used for the actual width calculations.
 */
void
tblcalc(struct rofftbl *tbl, const struct tbl_span *sp,
	size_t totalwidth)
{
	const struct tbl_opts	*opts;
	const struct tbl_dat	*dp;
	struct roffcol		*col;
	size_t			 ewidth, xwidth;
	int			 spans;
	int			 icol, maxcol, necol, nxcol, quirkcol;

	/*
	 * Allocate the master column specifiers.  These will hold the
	 * widths and decimal positions for all cells in the column.  It
	 * must be freed and nullified by the caller.
	 */

	assert(NULL == tbl->cols);
	tbl->cols = mandoc_calloc((size_t)sp->opts->cols,
	    sizeof(struct roffcol));
	opts = sp->opts;

	for (maxcol = -1; sp; sp = sp->next) {
		if (TBL_SPAN_DATA != sp->pos)
			continue;
		spans = 1;
		/*
		 * Account for the data cells in the layout, matching it
		 * to data cells in the data section.
		 */
		for (dp = sp->first; dp; dp = dp->next) {
			/* Do not used spanned cells in the calculation. */
			if (0 < --spans)
				continue;
			spans = dp->spans;
			if (1 < spans)
				continue;
			icol = dp->layout->col;
			if (maxcol < icol)
				maxcol = icol;
			col = tbl->cols + icol;
			col->flags |= dp->layout->flags;
			if (dp->layout->flags & TBL_CELL_WIGN)
				continue;
			tblcalc_data(tbl, col, opts, dp);
		}
	}

	/*
	 * Count columns to equalize and columns to maximize.
	 * Find maximum width of the columns to equalize.
	 * Find total width of the columns *not* to maximize.
	 */

	necol = nxcol = 0;
	ewidth = xwidth = 0;
	for (icol = 0; icol <= maxcol; icol++) {
		col = tbl->cols + icol;
		if (col->flags & TBL_CELL_EQUAL) {
			necol++;
			if (ewidth < col->width)
				ewidth = col->width;
		}
		if (col->flags & TBL_CELL_WMAX)
			nxcol++;
		else
			xwidth += col->width;
	}

	/*
	 * Equalize columns, if requested for any of them.
	 * Update total width of the columns not to maximize.
	 */

	if (necol) {
		for (icol = 0; icol <= maxcol; icol++) {
			col = tbl->cols + icol;
			if ( ! (col->flags & TBL_CELL_EQUAL))
				continue;
			if (col->width == ewidth)
				continue;
			if (nxcol && totalwidth)
				xwidth += ewidth - col->width;
			col->width = ewidth;
		}
	}

	/*
	 * If there are any columns to maximize, find the total
	 * available width, deducting 3n margins between columns.
	 * Distribute the available width evenly.
	 */

	if (nxcol && totalwidth) {
		xwidth = totalwidth - xwidth - 3*maxcol -
		    (opts->opts & (TBL_OPT_BOX | TBL_OPT_DBOX) ?
		     2 : !!opts->lvert + !!opts->rvert);

		/*
		 * Emulate a bug in GNU tbl width calculation that
		 * manifests itself for large numbers of x-columns.
		 * Emulating it for 5 x-columns gives identical
		 * behaviour for up to 6 x-columns.
		 */

		if (nxcol == 5) {
			quirkcol = xwidth % nxcol + 2;
			if (quirkcol != 3 && quirkcol != 4)
				quirkcol = -1;
		} else
			quirkcol = -1;

		necol = 0;
		ewidth = 0;
		for (icol = 0; icol <= maxcol; icol++) {
			col = tbl->cols + icol;
			if ( ! (col->flags & TBL_CELL_WMAX))
				continue;
			col->width = (double)xwidth * ++necol / nxcol
			    - ewidth + 0.4995;
			if (necol == quirkcol)
				col->width--;
			ewidth += col->width;
		}
	}
}

static void
tblcalc_data(struct rofftbl *tbl, struct roffcol *col,
		const struct tbl_opts *opts, const struct tbl_dat *dp)
{
	size_t		 sz;

	/* Branch down into data sub-types. */

	switch (dp->layout->pos) {
	case TBL_CELL_HORIZ:
	case TBL_CELL_DHORIZ:
		sz = (*tbl->len)(1, tbl->arg);
		if (col->width < sz)
			col->width = sz;
		break;
	case TBL_CELL_LONG:
	case TBL_CELL_CENTRE:
	case TBL_CELL_LEFT:
	case TBL_CELL_RIGHT:
		tblcalc_literal(tbl, col, dp);
		break;
	case TBL_CELL_NUMBER:
		tblcalc_number(tbl, col, opts, dp);
		break;
	case TBL_CELL_DOWN:
		break;
	default:
		abort();
	}
}

static void
tblcalc_literal(struct rofftbl *tbl, struct roffcol *col,
		const struct tbl_dat *dp)
{
	size_t		 sz;
	const char	*str;

	str = dp->string ? dp->string : "";
	sz = (*tbl->slen)(str, tbl->arg);

	if (col->width < sz)
		col->width = sz;
}

static void
tblcalc_number(struct rofftbl *tbl, struct roffcol *col,
		const struct tbl_opts *opts, const struct tbl_dat *dp)
{
	int		 i;
	size_t		 sz, psz, ssz, d;
	const char	*str;
	char		*cp;
	char		 buf[2];

	/*
	 * First calculate number width and decimal place (last + 1 for
	 * non-decimal numbers).  If the stored decimal is subsequent to
	 * ours, make our size longer by that difference
	 * (right-"shifting"); similarly, if ours is subsequent the
	 * stored, then extend the stored size by the difference.
	 * Finally, re-assign the stored values.
	 */

	str = dp->string ? dp->string : "";
	sz = (*tbl->slen)(str, tbl->arg);

	/* FIXME: TBL_DATA_HORIZ et al.? */

	buf[0] = opts->decimal;
	buf[1] = '\0';

	psz = (*tbl->slen)(buf, tbl->arg);

	if (NULL != (cp = strrchr(str, opts->decimal))) {
		buf[1] = '\0';
		for (ssz = 0, i = 0; cp != &str[i]; i++) {
			buf[0] = str[i];
			ssz += (*tbl->slen)(buf, tbl->arg);
		}
		d = ssz + psz;
	} else
		d = sz + psz;

	/* Adjust the settings for this column. */

	if (col->decimal > d) {
		sz += col->decimal - d;
		d = col->decimal;
	} else
		col->width += d - col->decimal;

	if (sz > col->width)
		col->width = sz;
	if (d > col->decimal)
		col->decimal = d;
}
@


1.61
log
@modernize style: "return" is not a function
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.60 2015/09/26 00:54:04 schwarze Exp $ */
a242 1
		/* FALLTHROUGH */
a248 1
		/* FALLTHROUGH */
a249 1
		/* FALLTHROUGH */
a250 1
		/* FALLTHROUGH */
@


1.60
log
@/* NOTREACHED */ after abort() is silly, delete it
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.59 2015/01/30 04:11:50 schwarze Exp $ */
d54 1
a54 1
		return(0);
d92 1
a92 1
			return(0);
d97 1
a97 1
	return(*endptr == '\0' ? 2 : 1);
@


1.59
log
@Abolish struct tbl_head and replace it by an "int col" member in
struct tbl_cell.  No functional change, minus 40 lines of code.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.58 2015/01/28 02:23:49 schwarze Exp $ */
a264 1
		/* NOTREACHED */
@


1.58
log
@adjust formatting for the tbl(7) layout 'x' modifier (maximize column)
to match groff for up to six maximized columns
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.57 2014/12/23 13:48:57 schwarze Exp $ */
d143 1
a143 1
			icol = dp->layout->head->ident;
@


1.57
log
@support negative horizontal widths in man(7);
minus twenty lines of code in spite of enhanced functionality
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.56 2014/12/23 09:31:46 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011, 2014 Ingo Schwarze <schwarze@@openbsd.org>
d110 1
d115 1
a115 1
	int			 icol, maxcol, necol, nxcol;
d126 1
d150 1
a150 1
			tblcalc_data(tbl, col, sp->opts, dp);
d200 20
a219 1
		xwidth = totalwidth - 3*maxcol - xwidth;
d224 5
a228 2
			col->width = xwidth / nxcol--;
			xwidth -= col->width;
@


1.56
log
@some scaling unit fixes:
- .sp with an invalid argument is .sp 1v, not .sp 0v
- in man(1), trailing garbage doesn't make scaling units invalid
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.55 2014/12/23 03:28:01 schwarze Exp $ */
a96 3
	/* FIXME: do this in the caller. */
	if (dst->scale < 0.0)
		dst->scale = 0.0;
@


1.55
log
@In a2roffsu(), do not parse the number twice.
Gets rid of 25 lines of code and one static buffer.
No functional change for numbers shorter than BUFSIZ characters.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.54 2014/12/04 02:05:42 schwarze Exp $ */
d43 2
a44 1
 * Return 1 on success and 0 on failure.
a49 2
	double		 scale;
	enum roffscale	 unit;
d51 3
a53 2
	scale = strtod(src, &endptr);
	if (endptr == src || (endptr[0] != '\0' && endptr[1] != '\0'))
d56 1
a56 1
	switch (*endptr) {
d58 1
a58 1
		unit = SCALE_CM;
d61 13
a73 1
		unit = SCALE_IN;
d76 1
a76 1
		unit = SCALE_PC;
d79 1
a79 1
		unit = SCALE_PT;
d81 2
a82 2
	case 'f':
		unit = SCALE_FS;
d85 1
a85 4
		unit = SCALE_VS;
		break;
	case 'm':
		unit = SCALE_EM;
d88 3
d93 1
a93 1
		unit = def;
a94 11
	case 'u':
		unit = SCALE_BU;
		break;
	case 'M':
		unit = SCALE_MM;
		break;
	case 'n':
		unit = SCALE_EN;
		break;
	default:
		return(0);
d98 3
a100 5
	if (scale < 0.0)
		scale = 0.0;
	dst->scale = scale;
	dst->unit = unit;
	return(1);
@


1.54
log
@fix handling of roff requests having a default scale other than "n",
in particular .sp which uses "v", when the scale is not specified;
cures groff-mandoc differences in about a dozen Xenocara manuals
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.53 2014/10/14 18:18:05 schwarze Exp $ */
a22 2
#include <ctype.h>
#include <stdio.h>
d40 4
a43 2
 * Convert a `scaling unit' to a consistent form, or fail.  Scaling
 * units are documented in groff.7, mdoc.7, man.7.
d48 2
a49 2
	char		 buf[BUFSIZ], hasd;
	int		 i;
d52 2
a53 32
	if ('\0' == *src)
		return(0);

	i = hasd = 0;

	switch (*src) {
	case '+':
		src++;
		break;
	case '-':
		buf[i++] = *src++;
		break;
	default:
		break;
	}

	if ('\0' == *src)
		return(0);

	while (i < BUFSIZ) {
		if ( ! isdigit((unsigned char)*src)) {
			if ('.' != *src)
				break;
			else if (hasd)
				break;
			else
				hasd = 1;
		}
		buf[i++] = *src++;
	}

	if (BUFSIZ == i || (*src && *(src + 1)))
d56 1
a56 3
	buf[i] = '\0';

	switch (*src) {
d97 3
a99 2
	if ((dst->scale = atof(buf)) < 0.0)
		dst->scale = 0.0;
@


1.53
log
@even if a table has zero columns, do not segfault in the formatter;
bug reported by bentley@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.52 2014/10/14 02:16:06 schwarze Exp $ */
d113 1
a113 1
		unit = SCALE_EN;
@


1.52
log
@Rudimentary implementation of the e, x, and z table layout modifiers
to equalize, maximize, and ignore the width of columns.
Does not yet take vertical rulers into account,
and does not do line breaks within table cells.
Considerably improves the lftp(1) manual; issue noticed by sthen@@.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.51 2014/08/12 19:28:16 schwarze Exp $ */
d161 1
a161 1
	for (maxcol = 0; sp; sp = sp->next) {
@


1.51
log
@In mdoc(7) and man(7), if a width is given as a bare number without
specifying a unit, the implied unit is 'n' (on the terminal, one
character position; in PostScript, half of the current font size
in points), not 'u' (roff output device basic unit).  No functional
change right now, but important for the upcoming scaling unit fixes.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.50 2014/08/10 23:54:41 schwarze Exp $ */
d4 1
a4 1
 * Copyright (c) 2011 Ingo Schwarze <schwarze@@openbsd.org>
d142 2
a143 1
tblcalc(struct rofftbl *tbl, const struct tbl_span *sp)
d147 1
d149 1
d161 1
a161 1
	for ( ; sp; sp = sp->next) {
d176 7
a182 2
			assert(dp->layout);
			col = &tbl->cols[dp->layout->head->ident];
d186 56
@


1.50
log
@Get rid of HAVE_CONFIG_H, it is always defined; idea from libnbcompat.
Include <sys/types.h> where needed, it does not belong in config.h.
Remove <stdio.h> from config.h; if it is missing somewhere, it should
be added, but i cannot find a *.c file where it is missing.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.49 2014/08/01 19:25:52 schwarze Exp $ */
d113 1
a113 1
		unit = SCALE_BU;
@


1.49
log
@Clarity with respect to floating point handling:
Write double constants as double rather than integer literals.
Remove useless explicit (double) cast done at one place and nowhere else.
No functional change.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.48 2014/04/20 16:46:05 schwarze Exp $ */
a17 1
#ifdef HAVE_CONFIG_H
a18 1
#endif
@


1.48
log
@KNF: case (FOO):  ->  case FOO:, remove /* LINTED */ and /* ARGSUSED */,
remove trailing whitespace and blanks before tabs, improve some indenting;
no functional change
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.47 2014/03/23 11:25:26 schwarze Exp $ */
d131 2
a132 2
	if ((dst->scale = atof(buf)) < 0)
		dst->scale = 0;
@


1.47
log
@The files mandoc.c and mandoc.h contained both specialised low-level
functions used for multiple languages (mdoc, man, roff), for example
mandoc_escape(), mandoc_getarg(), mandoc_eos(), and generic auxiliary
functions.  Split the auxiliaries out into their own file and header.
While here, do some #include cleanup.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.46 2013/10/05 20:30:05 schwarze Exp $ */
d42 2
a43 1
/* 
d60 1
a60 1
	case ('+'):
d63 1
a63 1
	case ('-'):
d91 1
a91 1
	case ('c'):
d94 1
a94 1
	case ('i'):
d97 1
a97 1
	case ('P'):
d100 1
a100 1
	case ('p'):
d103 1
a103 1
	case ('f'):
d106 1
a106 1
	case ('v'):
d109 1
a109 1
	case ('m'):
d112 1
a112 1
	case ('\0'):
d117 1
a117 1
	case ('u'):
d120 1
a120 1
	case ('M'):
d123 1
a123 1
	case ('n'):
d157 2
a158 2
	tbl->cols = mandoc_calloc
		((size_t)sp->opts->cols, sizeof(struct roffcol));
d191 1
a191 1
	case (TBL_CELL_HORIZ):
d193 1
a193 1
	case (TBL_CELL_DHORIZ):
d198 1
a198 1
	case (TBL_CELL_LONG):
d200 1
a200 1
	case (TBL_CELL_CENTRE):
d202 1
a202 1
	case (TBL_CELL_LEFT):
d204 1
a204 1
	case (TBL_CELL_RIGHT):
d207 1
a207 1
	case (TBL_CELL_NUMBER):
d210 1
a210 1
	case (TBL_CELL_DOWN):
d236 1
a236 1
	int 		 i;
@


1.46
log
@Cleanup suggested by gcc-4.8.1, following hints by Christos Zoulas:
- avoid bad qualifier casting in roff.c, roff_parsetext()
  by changing the mandoc_escape arguments to "const char const **"
- avoid bad qualifier casting in mandocdb.c, index_merge()
- do not complain about unused variables in test-*.c
- garbage collect a few unused variables elsewhere
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.45 2013/05/31 21:37:17 schwarze Exp $ */
d31 1
@


1.45
log
@The name "struct tbl" was badly misleading for two reasons:
1) This struct almost exclusively contains the table options.
2) Information about the table as a whole is actually in "struct tbl_node".
Besides, "struct tbl" was almost impossible to search for.
So rename it to "struct tbl_opts".  No functional change.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.44 2012/05/27 17:54:54 schwarze Exp $ */
a144 1
	const struct tbl_head	*hp;
a157 2
	hp = sp->head;

@


1.44
log
@Do not handle vertical lines as additional tbl(7) columns,
instead save their properties with the following column.
This simplifies layout parsing and saves a lot of code
related to column handling.

At output time, print all white space and vertical lines
separating columns before printing the following column,
and none after printing the preceding column, considerably
simplifying white space handling and width calculations.

No functional change, but it saves 150 lines of code,
and it allows the next patch to tbl_term.c, tbl_literal().

"Please check them in and I'll look into them later!" kristaps@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.43 2011/09/20 23:05:49 schwarze Exp $ */
d35 1
a35 1
			const struct tbl *, const struct tbl_dat *);
d39 1
a39 1
			const struct tbl *, const struct tbl_dat *);
d157 1
a157 1
		((size_t)sp->tbl->cols, sizeof(struct roffcol));
d178 1
a178 1
			tblcalc_data(tbl, col, sp->tbl, dp);
d185 1
a185 1
		const struct tbl *tp, const struct tbl_dat *dp)
d209 1
a209 1
		tblcalc_number(tbl, col, tp, dp);
d235 1
a235 1
		const struct tbl *tp, const struct tbl_dat *dp)
d257 1
a257 1
	buf[0] = tp->decimal;
d262 1
a262 1
	if (NULL != (cp = strrchr(str, tp->decimal))) {
@


1.43
log
@Major rewrite of the horizontal spacing of tables
to work both with and without frames and rulers.
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.42 2011/07/24 18:15:14 kristaps Exp $ */
a180 19

	/* 
	 * Calculate width of the spanners.  These get one space for a
	 * vertical line, two for a double-vertical line. 
	 */

	for ( ; hp; hp = hp->next) {
		col = &tbl->cols[hp->ident];
		switch (hp->pos) {
		case (TBL_HEAD_VERT):
			col->width = (*tbl->len)(1, tbl->arg);
			break;
		case (TBL_HEAD_DVERT):
			col->width = (*tbl->len)(2, tbl->arg);
			break;
		default:
			break;
		}
	}
@


1.42
log
@Scary-looking but otherwise harmless changes allow me to build for Windows.
That is to say, with mingw32.  This amounts to the following:

 (1) break compat.c into compat_strlcpy.c and compat_strlcat.c
 (2) add compat_getsubopt.c (from OpenBSD) and test-getsubopt.c
 (3) add test-strptime.c for HAVE_STRPTIME
 (4) add ifdef bits here and there, where necessary
 (5) remove some harmless unportable stuff (u_char, localtime_r)

I've added the appropriate mdocml.zip target to the Makefile, too.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.41 2011/07/17 15:24:25 kristaps Exp $ */
d147 1
d164 1
d170 6
d242 1
a242 1
	size_t		 sz, bufsz, spsz;
a244 7
	/* 
	 * Calculate our width and use the spacing, with a minimum
	 * spacing dictated by position (centre, e.g,. gets a space on
	 * either side, while right/left get a single adjacent space).
	 */

	bufsz = spsz = 0;
a247 20
	/* FIXME: TBL_DATA_HORIZ et al.? */

	assert(dp->layout);
	switch (dp->layout->pos) {
	case (TBL_CELL_LONG):
		/* FALLTHROUGH */
	case (TBL_CELL_CENTRE):
		bufsz = (*tbl->len)(1, tbl->arg);
		break;
	default:
		bufsz = (*tbl->len)(1, tbl->arg);
		break;
	}

	if (dp->layout->spacing) {
		spsz = (*tbl->len)(dp->layout->spacing, tbl->arg);
		bufsz = bufsz > spsz ? bufsz : spsz;
	}

	sz += bufsz;
d264 1
a264 1
	 * no-decimal numbers).  If the stored decimal is subsequent
a290 5
	/* Padding. */

	sz += (*tbl->len)(2, tbl->arg);
	d += (*tbl->len)(1, tbl->arg);

a302 5

	/* Adjust for stipulated width. */

	if (col->width < dp->layout->spacing)
		col->width = dp->layout->spacing;
a303 2


@


1.41
log
@Remove unused function.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.40 2011/04/09 15:29:40 kristaps Exp $ */
d72 1
a72 1
		if ( ! isdigit((u_char)*src)) {
@


1.40
log
@Remove a2roffdeco() and mandoc_special() functions and replace them with
a public (mandoc.h) function mandoc_escape(), which merges the
functionality of both prior functions.

Reason: code duplication.  The a2roffdeco() and mandoc_special()
functions were pretty much the same thing and both quite complex.  This
allows one function to receive improvements in (e.g.) subexpression
handling and performance, instead of having to replicate functionality.

As such, the mandoc_escape() function already handles a superset of the
escapes handled in previous versions and has improvements in performance
(using strcspn(), for example) and reliable handling of subexpressions.

This code Works For Me, but may need work to catch any regressions.
Since the benefits are great (leaner code, simpler API), I'd rather have
it in-tree than floating as a patch.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.39 2011/03/17 08:49:34 kristaps Exp $ */
a134 42

/*
 * Correctly writes the time in nroff form, which differs from standard
 * form in that a space isn't printed in lieu of the extra %e field for
 * single-digit dates.
 */
void
time2a(time_t t, char *dst, size_t sz)
{
	struct tm	 tm;
	char		 buf[5];
	char		*p;
	size_t		 nsz;

	assert(sz > 1);
	localtime_r(&t, &tm);

	p = dst;
	nsz = 0;

	dst[0] = '\0';

	if (0 == (nsz = strftime(p, sz, "%B ", &tm)))
		return;

	p += (int)nsz;
	sz -= nsz;

	if (0 == strftime(buf, sizeof(buf), "%e, ", &tm))
		return;

	nsz = strlcat(p, buf + (' ' == buf[0] ? 1 : 0), sz);

	if (nsz >= sz)
		return;

	p += (int)nsz;
	sz -= nsz;

	(void)strftime(p, sz, "%Y", &tm);
}

@


1.39
log
@Move mandoc_{realloc,malloc,calloc} out of libmandoc.h and into mandoc.h
so that everybody can use them.  This follows the convention of
libXXXX.h being internal to a library and XXXX.h being the external
interface.  Not only does this allow the removal of lots of redundant
NULL-checking code, it also sets the tone for adding new mandoc-global
routines.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.38 2011/03/15 16:23:51 kristaps Exp $ */
a176 237

int
a2roffdeco(enum roffdeco *d, const char **word, size_t *sz)
{
	int		 i, j, lim;
	char		 term, c;
	const char	*wp;
	enum roffdeco	 dd;

	*d = DECO_NONE;
	lim = i = 0;
	term = '\0';
	wp = *word;

	switch ((c = wp[i++])) {
	case ('('):
		*d = DECO_SPECIAL;
		lim = 2;
		break;
	case ('F'):
		/* FALLTHROUGH */
	case ('f'):
		*d = 'F' == c ? DECO_FFONT : DECO_FONT;

		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		case ('3'):
			/* FALLTHROUGH */
		case ('B'):
			*d = DECO_BOLD;
			return(i);
		case ('2'):
			/* FALLTHROUGH */
		case ('I'):
			*d = DECO_ITALIC;
			return(i);
		case ('P'):
			*d = DECO_PREVIOUS;
			return(i);
		case ('1'):
			/* FALLTHROUGH */
		case ('R'):
			*d = DECO_ROMAN;
			return(i);
		default:
			i--;
			lim = 1;
			break;
		}
		break;
	case ('k'):
		/* FALLTHROUGH */
	case ('M'):
		/* FALLTHROUGH */
	case ('m'):
		/* FALLTHROUGH */
	case ('*'):
		if ('*' == c)
			*d = DECO_RESERVED;

		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		default:
			i--;
			lim = 1;
			break;
		}
		break;

	case ('N'):

		/*
		 * Sequence of characters:  backslash,  'N' (i = 0),
		 * starting delimiter (i = 1), character number (i = 2).
		 */

		*word = wp + 2;
		*sz = 0;

		/*
		 * Cannot use a digit as a starting delimiter;
		 * but skip the digit anyway.
		 */

		if (isdigit((int)wp[1]))
			return(2);

		/*
		 * Any non-digit terminates the character number.
		 * That is, the terminating delimiter need not
		 * match the starting delimiter.
		 */

		for (i = 2; isdigit((int)wp[i]); i++)
			(*sz)++;

		/*
		 * This is only a numbered character
		 * if the character number has at least one digit.
		 */

		if (*sz)
			*d = DECO_NUMBERED;

		/*
		 * Skip the terminating delimiter, even if it does not
		 * match, and even if there is no character number.
		 */

		return(++i);

	case ('h'):
		/* FALLTHROUGH */
	case ('v'):
		/* FALLTHROUGH */
	case ('s'):
		j = 0;
		if ('+' == wp[i] || '-' == wp[i]) {
			i++;
			j = 1;
		}

		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		case ('\''):
			term = '\'';
			break;
		case ('0'):
			j = 1;
			/* FALLTHROUGH */
		default:
			i--;
			lim = 1;
			break;
		}

		if ('+' == wp[i] || '-' == wp[i]) {
			if (j)
				return(i);
			i++;
		} 

		/* Handle embedded numerical subexp or escape. */

		if ('(' == wp[i]) {
			while (wp[i] && ')' != wp[i])
				if ('\\' == wp[i++]) {
					/* Handle embedded escape. */
					*word = &wp[i];
					i += a2roffdeco(&dd, word, sz);
				}

			if (')' == wp[i++])
				break;

			*d = DECO_NONE;
			return(i - 1);
		} else if ('\\' == wp[i]) {
			*word = &wp[++i];
			i += a2roffdeco(&dd, word, sz);
		}

		break;
	case ('['):
		*d = DECO_SPECIAL;
		term = ']';
		break;
	case ('c'):
		*d = DECO_NOSPACE;
		return(i);
	case ('z'):
		*d = DECO_NONE;
		if ('\\' == wp[i]) {
			*word = &wp[++i];
			return(i + a2roffdeco(&dd, word, sz));
		} else
			lim = 1;
		break;
	case ('o'):
		/* FALLTHROUGH */
	case ('w'):
		if ('\'' == wp[i++]) {
			term = '\'';
			break;
		} 
		/* FALLTHROUGH */
	default:
		*d = DECO_SSPECIAL;
		i--;
		lim = 1;
		break;
	}

	assert(term || lim);
	*word = &wp[i];

	if (term) {
		j = i;
		while (wp[i] && wp[i] != term)
			i++;
		if ('\0' == wp[i]) {
			*d = DECO_NONE;
			return(i);
		}

		assert(i >= j);
		*sz = (size_t)(i - j);

		return(i + 1);
	}

	assert(lim > 0);
	*sz = (size_t)lim;

	for (j = 0; wp[i] && j < lim; j++)
		i++;
	if (j < lim)
		*d = DECO_NONE;

	return(i);
}

@


1.38
log
@Make lint shut up a little bit.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.37 2011/01/30 16:05:37 schwarze Exp $ */
d434 1
a434 1
	tbl->cols = calloc
@


1.37
log
@Implement the \N'number' (numbered character) roff escape sequence.
Don't use it in new manuals, it is inherently non-portable, but we
need it for backward-compatibility with existing manuals, for example
in Xenocara driver pages.
ok kristaps@@ jmc@@ and tested by Matthieu Herrb (matthieu at openbsd dot org)
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.36 2011/01/25 12:07:30 schwarze Exp $ */
d434 2
a435 1
	tbl->cols = calloc(sp->tbl->cols, sizeof(struct roffcol));
@


1.36
log
@correct horizontal spacing of data cells
correct alignment of centered cells
adjust horizontal rule width to the new spacing
ok kristaps@@
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.35 2011/01/11 14:12:01 kristaps Exp $ */
d4 1
d255 43
@


1.35
log
@Add support for "^" vertical spanners.  Unlike GNU tbl, raise
error-class messages when data is being ignored by specifying it in "^"
cells (either as-is or in blocks).

Also note again that horizontal spanners aren't really supported...
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.34 2011/01/10 15:31:00 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009, 2010 Kristaps Dzonsons <kristaps@@bsd.lv>
d488 1
a488 1
		bufsz = (*tbl->len)(2, tbl->arg);
@


1.34
log
@Clarify what members may be NULL or not in calculating widths.  Make
sure signedness is correct.  Verify that layouts MUST exit for data
cells.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.33 2011/01/10 14:40:30 kristaps Exp $ */
d456 2
@


1.33
log
@First, make extra data cells be thrown away.  This makes "dp->layout"
always hold, which cleans up the table stuff a bit.

Second, set a "spans" value per data cell consisting of the number of
skipped TBL_CELL_SPAN layout cells.

Third, make tbl_term.c understand how to skip over spanned sections when
iterating over the header queue.

What remains is to calculate the widths of spanned cells.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.32 2011/01/08 17:16:48 kristaps Exp $ */
d467 1
d475 5
a479 3
	sz = bufsz = spsz = 0;
	if (dp->string)
		sz = (*tbl->slen)(dp->string, tbl->arg);
d508 2
a509 1
	size_t		 sz, psz, ssz, d, max;
a510 1
	const char	*str;
d522 2
a523 2
	str = dp && dp->string ? dp->string : "";
	max = dp && dp->layout ? dp->layout->spacing : 0;
d525 1
a525 1
	sz = (*tbl->slen)(str, tbl->arg);
d562 2
a563 2
	if (col->width < max)
		col->width = max;
@


1.32
log
@The numerical column type centres on the *last* decimal point.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.31 2011/01/08 17:00:27 kristaps Exp $ */
d402 1
a402 2
			if (NULL == dp->layout)
				continue;
@


1.31
log
@Give the "n" cell type knowledge of its spacing.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.30 2011/01/05 15:37:23 kristaps Exp $ */
d530 1
a530 1
	if (NULL != (cp = strchr(str, tp->decimal))) {
@


1.30
log
@Stuff tbl_calc() into out.c so that it can be shared by all output modes
(isn't now, but will need to be, used by -T[x]html also).  Necessitated
a lot of churn in getting tbl_calc* code out of tbl_term.c and into
out.c, including renaming some structures and so on.  The abstraction is
in having a pointer to a wrapper function for calculating string widths.
The char devices use term_strlen and term_len; the others will probably
just use strlen().

While at it, remove some superfluous assertions in the tbl code.  This
allows all tbl manuals to clear.

Lastly, set the right-margin to be the maximum margin for each table
span.  This allows big, complicated tbl-pages like terminfo to be
displayed.  They're ugly, but they work.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.29 2010/08/29 11:28:09 kristaps Exp $ */
d506 1
a506 1
	size_t		 sz, psz, ssz, d;
a510 2
	/* TODO: use spacing modifier. */

d520 2
a521 3
	str = "";
	if (dp->string)
		str = dp->string;
d557 5
@


1.29
log
@Remove overstrike `\o'.  This isn't the best solution because we really
should be printing the contents, but for the time being, this is good
enough.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.28 2010/08/24 13:56:51 kristaps Exp $ */
d30 1
d33 7
d369 194
@


1.28
log
@Handle nested, recursive mathematical subexpressions.  This is
definitely not general, but it's good enough for pod2man definitions
(after I clean up the roff, which will be addressed in later fixes).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.27 2010/08/24 13:39:37 kristaps Exp $ */
d318 2
@


1.27
log
@Strip out `\k' escape.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.26 2010/08/24 13:07:01 kristaps Exp $ */
d282 20
@


1.26
log
@Stripping out of `\w' groff escape.  Yet another for pod2man...
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.25 2010/08/24 12:18:49 kristaps Exp $ */
d223 2
@


1.25
log
@Strip out the `\z' escape.  This is the first recursive sequence,
getting mandoc ready to handle pod2man's complex escapes.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.24 2010/08/16 09:37:58 kristaps Exp $ */
d296 6
@


1.24
log
@Add \v and \h to ignored escapes.  These are in the category of \s.
Also made sign-less \s-style escapes be ok (this is technically against
what's in the groff.7 manual, but seems pretty widespread).  Noted by
Thomas Jeunet as uglifying the gcc.1 manual.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.23 2010/07/22 23:03:15 kristaps Exp $ */
d175 1
d279 1
a279 1
		
d288 8
@


1.23
log
@Added `in' macro support for -man -Tascii.  This is not yet supported in
-Thtml (I'm surprised to note that neither is LITERAL mode).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.22 2010/07/22 14:03:50 kristaps Exp $ */
d243 4
d248 2
a249 1
		if ('+' == wp[i] || '-' == wp[i])
d251 2
a252 2

		j = ('s' != wp[i - 1]);
d265 1
a265 1
			j++;
d274 1
a274 1
			if (j++)
a278 2
		if (0 == j)
			return(i);
@


1.22
log
@Accept "\s0" (i.e., properly ignore it).  Found in the wild (e.g., gfdl.7).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.21 2010/07/21 20:35:03 kristaps Exp $ */
d119 1
@


1.21
log
@Accomodate for groff's crappy behaviour wherein an unrecognised
single-character escape (and ONLY this type of escape) will map back
into itself:

       "If a backslash is followed by a character that does not
	constitute a defined escape sequence the backslash is silently
        ignored and the  character maps to itself."

(From groff.7.)

Found by Jason McIntyre.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.20 2010/07/19 07:53:40 kristaps Exp $ */
d258 3
@


1.20
log
@Double-up DECO_RESERVED switch branch for colours.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.19 2010/07/18 23:06:18 kristaps Exp $ */
d281 1
a281 1
		*d = DECO_SPECIAL;
@


1.19
log
@Properly discard \m colour escapes.  Noted by J.C. Roberts.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.18 2010/07/18 22:55:06 kristaps Exp $ */
a220 15
	case ('*'):
		*d = DECO_RESERVED;
		switch (wp[i++]) {
		case ('('):
			lim = 2;
			break;
		case ('['):
			term = ']';
			break;
		default:
			i--;
			lim = 1;
			break;
		}
		break;
d224 5
@


1.18
log
@Throw out a2roffdeco() in out.c for a readable version.  The prior one
was completely unmaintainable.  The new one is both readable and quite
similar to mandoc_special(), which in future versions will easily allow
throwing-away of unsupported escapes (such as \m).  It's also a fair bit
smaller.

DECO_SIZE has been removed: this crap, like colours, will not be
supported.

mandoc_special() also has #if 0'd switch branches for ALL groff.7
escapes and some lint fixes.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.17 2010/06/25 19:50:23 kristaps Exp $ */
d236 16
@


1.17
log
@Remove "pt" from struct roffsu, as CSS (the only reason it was there) is
unclear about which units accept floats/integers, which leads me to
assume that it handles either and rounds as appropriate.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.16 2010/06/19 20:46:28 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@bsd.lv>
a31 20
/* See a2roffdeco(). */
#define	C2LIM(c, l) do { \
	(l) = 1; \
	if ('[' == (c) || '\'' == (c)) \
		(l) = 0; \
	else if ('(' == (c)) \
		(l) = 2; } \
	while (/* CONSTCOND */ 0)

/* See a2roffdeco(). */
#define	C2TERM(c, t) do { \
	(t) = 0; \
	if ('\'' == (c)) \
		(t) = 1; \
	else if ('[' == (c)) \
		(t) = 2; \
	else if ('(' == (c)) \
		(t) = 3; } \
	while (/* CONSTCOND */ 0)

a167 6
/* 
 * Returns length of parsed string (the leading "\" should NOT be
 * included).  This can be zero if the current character is the nil
 * terminator.  "d" is set to the type of parsed decorator, which may
 * have an adjoining "word" of size "sz" (e.g., "(ab" -> "ab", 2).
 */
d169 1
a169 2
a2roffdeco(enum roffdeco *d,
		const char **word, size_t *sz)
d171 3
a173 3
	int		 j, term, lim;
	char		 set;
	const char	*wp, *sp;
d176 2
d180 1
a180 4
	switch ((set = *wp)) {
	case ('\0'):
		return(0);

a181 5
		if ('\0' == *(++wp))
			return(1);
		if ('\0' == *(wp + 1))
			return(2);

d183 2
a184 4
		*sz = 2;
		*word = wp;
		return(3);

d188 9
a196 10
		/*
		 * FIXME: this needs work and consolidation (it should
		 * follow the sequence that special characters do, for
		 * one), but isn't a priority at the moment.  Note, for
		 * one, that in reality \fB != \FB, although here we let
		 * these slip by.
		 */
		switch (*(++wp)) {
		case ('\0'):
			return(1);
d201 1
a201 1
			return(2);
d206 1
a206 1
			return(2);
d209 1
a209 1
			return(2);
d214 1
a214 22
			return(2);
		case ('('):
			if ('\0' == *(++wp))
				return(2);
			if ('\0' == *(wp + 1))
				return(3);

			*d = 'F' == set ? DECO_FFONT : DECO_FONT;
			*sz = 2;
			*word = wp;
			return(4);
		case ('['):
			*word = ++wp;
			for (j = 0; *wp && ']' != *wp; wp++, j++)
				/* Loop... */ ;

			if ('\0' == *wp)
				return(j + 2);

			*d = 'F' == set ? DECO_FFONT : DECO_FONT;
			*sz = (size_t)j;
			return(j + 3);
d216 2
d220 1
a220 6

		*d = 'F' == set ? DECO_FFONT : DECO_FONT;
		*sz = 1;
		*word = wp;
		return(2);

d222 2
a223 4
		switch (*(++wp)) {
		case ('\0'):
			return(1);

d225 2
a226 10
			if ('\0' == *(++wp))
				return(2);
			if ('\0' == *(wp + 1))
				return(3);

			*d = DECO_RESERVED;
			*sz = 2;
			*word = wp;
			return(4);

d228 2
a229 11
			*word = ++wp;
			for (j = 0; *wp && ']' != *wp; wp++, j++)
				/* Loop... */ ;

			if ('\0' == *wp)
				return(j + 2);

			*d = DECO_RESERVED;
			*sz = (size_t)j;
			return(j + 3);

d231 2
d235 1
a235 6

		*d = DECO_RESERVED;
		*sz = 1;
		*word = wp;
		return(2);

d237 2
a238 3
		sp = wp;
		if ('\0' == *(++wp))
			return(1);
d240 1
a240 2
		C2LIM(*wp, lim);
		C2TERM(*wp, term);
d242 7
a248 9
		if (term) 
			wp++;

		*word = wp;

		if (*wp == '+' || *wp == '-')
			++wp;

		switch (*wp) {
d250 1
a250 10
			/* FALLTHROUGH */
		case ('['):
			/* FALLTHROUGH */
		case ('('):
			if (term) 
				return((int)(wp - sp));

			C2LIM(*wp, lim);
			C2TERM(*wp, term);
			wp++;
d253 2
d258 22
a279 2
		if ( ! isdigit((u_char)*wp))
			return((int)(wp - sp));
d281 2
a282 5
		for (j = 0; isdigit((u_char)*wp); j++) {
			if (lim && j >= lim)
				break;
			++wp;
		}
d284 7
a290 6
		if (term && term < 3) {
			if (1 == term && *wp != '\'')
				return((int)(wp - sp));
			if (2 == term && *wp != ']')
				return((int)(wp - sp));
			++wp;
d293 2
a294 2
		*d = DECO_SIZE;
		return((int)(wp - sp));
d296 2
a297 8
	case ('['):
		*word = ++wp;

		for (j = 0; *wp && ']' != *wp; wp++, j++)
			/* Loop... */ ;

		if ('\0' == *wp)
			return(j + 1);
d299 2
a300 8
		*d = DECO_SPECIAL;
		*sz = (size_t)j;
		return(j + 2);

	case ('c'):
		*d = DECO_NOSPACE;
		*sz = 1;
		return(1);
d302 4
a305 3
	default:
		break;
	}
d307 1
a307 4
	*d = DECO_SPECIAL;
	*word = wp;
	*sz = 1;
	return(1);
@


1.16
log
@Churn as I finish email address migration kth.se -> bsd.lv.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.15 2010/04/07 11:29:55 kristaps Exp $ */
a141 2
	dst->pt = hasd;

@


1.15
log
@Lint fix.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.14 2010/04/07 11:25:38 kristaps Exp $ */
d3 1
a3 1
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
@


1.14
log
@Add support/ignoring of \f(xy, \f[X...], \F(xy, \FX, \F[X...] roff-style font escapes (noted by Frantisek Holop).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.13 2010/04/07 07:49:38 kristaps Exp $ */
d200 1
a200 1
	int		 j, offs, term, lim;
a205 1
	offs = 0;
@


1.13
log
@Bug in printing of reserved words with form \*[xxx] fixed (found by Joerg Sonnenberger).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.12 2010/01/01 17:14:30 kristaps Exp $ */
d201 1
d208 1
a208 1
	switch (*wp) {
d223 61
d301 10
a310 2
			offs = 1;
			break;
d313 1
a313 4
			*d = DECO_RESERVED;
			*sz = 1;
			*word = wp;
			return(2);
d315 5
a319 1
		break;
d374 5
a378 25
	case ('f'):
		switch (*(++wp)) {
		case ('\0'):
			return(1);
		case ('3'):
			/* FALLTHROUGH */
		case ('B'):
			*d = DECO_BOLD;
			break;
		case ('2'):
			/* FALLTHROUGH */
		case ('I'):
			*d = DECO_ITALIC;
			break;
		case ('P'):
			*d = DECO_PREVIOUS;
			break;
		case ('1'):
			/* FALLTHROUGH */
		case ('R'):
			*d = DECO_ROMAN;
			break;
		default:
			break;
		}
d380 2
a381 1
		return(2);
d383 3
a385 2
	case ('['):
		break;
d393 1
a393 4
		*d = DECO_SPECIAL;
		*word = wp;
		*sz = 1;
		return(1);
d396 4
a399 12
	*word = ++wp;

	for (j = 0; *wp && ']' != *wp; wp++, j++)
		/* Loop... */ ;

	if ('\0' == *wp)
		return(j + 1 + offs);

	*d = offs ? DECO_RESERVED : DECO_SPECIAL;
	*sz = (size_t)j;

	return (j + 2 + offs);
@


1.12
log
@Big check-in of compatibility layer.  This should work on most major architectures. Thanks to Joerg Sonnenberger.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.11 2009/11/12 08:21:05 kristaps Exp $ */
d200 1
a200 1
	int		 j, type, term, lim;
d205 1
a205 1
	type = 1;
d239 1
a239 1
			type = 0;
d347 1
d352 1
a352 1
		return(j + 1);
d354 1
a354 1
	*d = type ? DECO_SPECIAL : DECO_RESERVED;
d356 2
a357 1
	return (j + 2);
@


1.11
log
@Fixed \c support for all input and output modes (documented in mandoc_char.7).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.10 2009/11/08 09:23:35 kristaps Exp $ */
d17 4
a51 4
#ifdef __linux__
extern	size_t	  strlcat(char *, const char *, size_t);
#endif

@


1.10
log
@a2roffdeco() now supports \s escapes.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.9 2009/11/07 14:14:15 kristaps Exp $ */
d334 5
@


1.9
log
@Hooked up -Tascii to a2roffdeco backend.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.8 2009/11/07 08:26:45 kristaps Exp $ */
d28 20
d190 6
a195 1
/* Returns length of parsed string. */
d200 2
a201 2
	int		 j, type, sv, t, lim;
	const char	*wp;
d212 1
a212 2
		wp++;
		if ('\0' == *wp)
d223 1
a223 3
		wp++;

		switch (*wp) {
d228 1
a228 2
			wp++;
			if ('\0' == *wp)
a249 1
#if 0
d251 3
a253 1
		wp++;
d255 2
a256 3
		/* This closely follows mandoc_special(). */
		if ('\0' == *wp) 
			return(1);
d258 2
a259 2
		t = 0;
		lim = 1;
d261 1
a261 13
		if (*wp == '\'') {
			lim = 0;
			t = 1;
			++wp;
		} else if (*wp == '[') {
			lim = 0;
			t = 2;
			++wp;
		} else if (*wp == '(') {
			lim = 2;
			t = 3;
			++wp;
		}
d266 15
a280 24
		if (*wp == '\'') {
			if (t) {
				*word = wp;
				return;
			}
			lim = 0;
			t = 1;
			++wp;
		} else if (*wp == '[') {
			if (t) {
				*word = wp;
				return;
			}
			lim = 0;
			t = 2;
			++wp;
		} else if (*wp == '(') {
			if (t) {
				*word = wp;
				return;
			}
			lim = 2;
			t = 3;
			++wp;
d283 2
a284 4
		if ( ! isdigit((u_char)*wp)) {
			*word = --wp;
			return;
		}
d292 5
a296 9
		if (t && t < 3) {
			if (1 == t && *wp != '\'') {
				*word = --wp;
				return;
			}
			if (2 == t && *wp != ']') {
				*word = --wp;
				return;
			}
d299 3
a301 3
		*word = --wp;
		return;
#endif
d304 1
a304 3
		wp++;

		switch (*wp) {
d349 1
a349 1
	*sz = j;
@


1.8
log
@Initial abstraction of front-end decoration events (special characters, text decorations, etc.).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.7 2009/10/22 18:59:00 kristaps Exp $ */
a178 1

d225 1
a225 1
			return(3);
@


1.7
log
@Linuxisms.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.6 2009/10/22 18:55:32 kristaps Exp $ */
d169 192
@


1.6
log
@Fixed maddening mismatch between groff and strftime mismatch of day ("%e").  Noted by Ulrich Sporlein.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.5 2009/10/18 19:02:10 kristaps Exp $ */
d24 1
d28 3
@


1.5
log
@Had out.h roff-scale converters accept default unit scale (because -mdoc and -man differ).
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.4 2009/10/09 06:54:11 kristaps Exp $ */
d19 1
d23 1
d122 43
@


1.4
log
@Scaling factor made floating point (as per groff.7) and, e.g., gnu/usr.bin/cvs/man/cvs.1.
@
text
@d1 1
a1 1
/*	$Id: out.c,v 1.3 2009/10/07 12:35:24 kristaps Exp $ */
d28 1
a28 17
 * units are documented in groff.7, which stipulates the following:
 *
 *  (1) A scaling unit is a signed/unsigned integer/float with or
 *      without a unit.
 *
 *  (2) The following units exist:
 *	c	Centimeter
 *	i	Inch
 *	P	Pica = 1/6 inch
 *	p	Point = 1/72 inch
 *	m	Em = the font size in points (width of letter m)
 *	M	100th of an Em 
 *	n	En = Em/2 
 *	u	Basic unit for actual output device
 *	v	Vertical line space in basic units scaled point =
 *		1/sizescale of a point (defined in font DESC file)
 *	f	Scale by 65536.
d31 1
a31 1
a2roffsu(const char *src, struct roffsu *dst)
d37 3
d53 3
d96 4
a99 1
		/* FALLTHROUGH */
@


1.3
log
@Additions to -Tman -Thtml: all structural components tested & in place.
Fitted both -Thtml with handling of arbitrary vertical and horizontal scaling units (see groff(7)).  Undocumented until fitted into -Tascii (next release).
@
text
@d1 1
a1 1
/*	$Id: html.c,v 1.57 2009/10/04 09:02:40 kristaps Exp $ */
d49 1
a49 1
	char		 buf[BUFSIZ], *p;
d53 24
a76 2
	for (p = buf, i = 0; i < BUFSIZ && isdigit((u_char)*src); i++)
		*p++ = *src++;
d81 1
a81 1
	*p = '\0';
d120 1
a120 1
	if ((dst->scale = atoi(buf)) < 0)
d123 2
@


1.2
log
@Removed new-born out.{h,c} (not a good idea).
Removed if 0 for HTML-mode output (why not).
Added option -oxxxx for passing options to output devices.
@
text
@d1 102
@


1.1
log
@Tentative addition of front-end utility functions (out.h) (not sure if it's necessary).
More -Thtml installments.
@
text
@a0 113
/*	$Id: html.c,v 1.40 2009/09/20 19:44:16 kristaps Exp $ */
/*
 * Copyright (c) 2009 Kristaps Dzonsons <kristaps@@kth.se>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
#include <sys/types.h>

#include <assert.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#include "mdoc.h"
#include "man.h"
#include "out.h"

int
out_a2list(const struct mdoc_node *n)
{
	int		 i;

	assert(MDOC_BLOCK == n->type && MDOC_Bl == n->tok);
	assert(n->args);

	for (i = 0; i < (int)n->args->argc; i++) 
		switch (n->args->argv[i].arg) {
		case (MDOC_Enum):
			/* FALLTHROUGH */
		case (MDOC_Dash):
			/* FALLTHROUGH */
		case (MDOC_Hyphen):
			/* FALLTHROUGH */
		case (MDOC_Bullet):
			/* FALLTHROUGH */
		case (MDOC_Tag):
			/* FALLTHROUGH */
		case (MDOC_Hang):
			/* FALLTHROUGH */
		case (MDOC_Inset):
			/* FALLTHROUGH */
		case (MDOC_Diag):
			/* FALLTHROUGH */
		case (MDOC_Item):
			/* FALLTHROUGH */
		case (MDOC_Column):
			/* FALLTHROUGH */
		case (MDOC_Ohang):
			return(n->args->argv[i].arg);
		default:
			break;
		}

	abort();
	/* NOTREACHED */
}


int
out_a2width(const char *p)
{
	int		 i, len;

	if (0 == (len = (int)strlen(p)))
		return(0);
	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p) + 2);

	return(len + 2);
}


int
out_a2offs(const char *p, int indent)
{
	int		 len, i;

	if (0 == strcmp(p, "left"))
		return(0);
	if (0 == strcmp(p, "indent"))
		return(indent + 1);
	if (0 == strcmp(p, "indent-two"))
		return((indent + 1) * 2);

	if (0 == (len = (int)strlen(p)))
		return(0);

	for (i = 0; i < len - 1; i++) 
		if ( ! isdigit((u_char)p[i]))
			break;

	if (i == len - 1) 
		if ('n' == p[len - 1] || 'm' == p[len - 1])
			return(atoi(p));

	return(len);
}

@
